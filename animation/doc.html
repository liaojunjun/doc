<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>create for ggdoc , @author sunyi</title>
    <style>
        .octicon{display:inline-block;fill:currentColor;vertical-align:text-bottom}
        .anchor{float:left;line-height:1;margin-left:-20px;padding-right:4px}
        .anchor:focus{outline:0}
        h1 .octicon-link,h2 .octicon-link,h3 .octicon-link,h4 .octicon-link,h5 .octicon-link,h6 .octicon-link{color:#1b1f23;vertical-align:middle;visibility:hidden}
        h1:hover .anchor,h2:hover .anchor,h3:hover .anchor,h4:hover .anchor,h5:hover .anchor,h6:hover .anchor{text-decoration:none}
        h1:hover .anchor .octicon-link,h2:hover .anchor .octicon-link,h3:hover .anchor .octicon-link,h4:hover .anchor .octicon-link,h5:hover .anchor .octicon-link,h6:hover .anchor .octicon-link{visibility:visible}
        h1:hover .anchor .octicon-link:before,h2:hover .anchor .octicon-link:before,h3:hover .anchor .octicon-link:before,h4:hover .anchor .octicon-link:before,h5:hover .anchor .octicon-link:before,h6:hover .anchor .octicon-link:before{width:16px;height:16px;content:" ";display:inline-block;background-image:url("data:image/svg+xml,%3Csvgxmlns='http://www.w3.org/2000/svg'viewBox='001616'version='1.1'width='16'height='16'aria-hidden='true'%3E%3Cpathfill-rule='evenodd'd='M49h1v1H4c-1.50-3-1.69-3-3.5S2.55343h4c1.45031.6933.501.41-.912.72-23.25V8.59c.58-.451-1.271-2.09C105.228.98484H4c-.980-21.22-22.5S3949zm9-3h-1v1h1c1021.2222.5S13.98121312H9c-.980-2-1.22-2-2.50-.83.42-1.641-2.09V6.25c-1.09.53-21.84-23.25C611.317.5513913h4c1.4503-1.693-3.5S14.56136z'%3E%3C/path%3E%3C/svg%3E")}
        body{-webkit-text-size-adjust:100%;line-height:1.5;color:#24292e;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji;font-size:16px;line-height:1.5;word-wrap:break-word;background-color:#e3e3ef;height:100%;width:100%;margin:0;padding:20px}
        details{display:block}
        summary{display:list-item}
        a{background-color:initial}
        a:active,a:hover{outline-width:0}
        strong{font-weight:inherit;font-weight:bolder}
        h1{font-size:2em;margin:.67em 0}
        img{border-style:none}
        code,kbd,pre{font-family:monospace,monospace;font-size:1em}
        hr{box-sizing:initial;height:0;overflow:visible}
        input{font:inherit;margin:0}
        input{overflow:visible}
        [type="checkbox"]{box-sizing:border-box;padding:0}
        *{box-sizing:border-box}
        input{font-family:inherit;font-size:inherit;line-height:inherit}
        a{color:#0366d6;text-decoration:none}
        a:hover{text-decoration:underline}
        strong{font-weight:600}
        hr{height:0;margin:15px 0;overflow:hidden;background:transparent;border:0;border-bottom:1px solid #dfe2e5}
        hr:after,hr:before{display:table;content:""}
        hr:after{clear:both}
        table{border-spacing:0;border-collapse:collapse}
        td,th{padding:0}
        details summary{cursor:pointer}
        kbd{display:inline-block;padding:3px 5px;font:11px SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;line-height:10px;color:#444d56;vertical-align:middle;background-color:#fafbfc;border:1px solid #d1d5da;border-radius:3px;box-shadow:inset 0 -1px 0 #d1d5da}
        h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:0}
        h1{font-size:32px}
        h1,h2{font-weight:600}
        h2{font-size:24px}
        h3{font-size:20px}
        h3,h4{font-weight:600}
        h4{font-size:16px}
        h5{font-size:14px}
        h5,h6{font-weight:600}
        h6{font-size:12px}
        p{margin-top:0;margin-bottom:10px}
        blockquote{margin:0}
        ol,ul{padding-left:0;margin-top:0;margin-bottom:0}
        ol ol,ul ol{list-style-type:lower-roman}
        ol ol ol,ol ul ol,ul ol ol,ul ul ol{list-style-type:lower-alpha}
        dd{margin-left:0}
        code,pre{font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:12px}
        pre{margin-top:0;margin-bottom:0}
        input::-webkit-inner-spin-button,input::-webkit-outer-spin-button{margin:0;-webkit-appearance:none;appearance:none}
        :checked+.radio-label{position:relative;z-index:1;border-color:#0366d6}
        .border{border:1px solid #e1e4e8!important}
        .border-0{border:0!important}
        .border-bottom{border-bottom:1px solid #e1e4e8!important}
        .rounded-1{border-radius:3px!important}
        .bg-white{background-color:#fff!important}
        .bg-gray-light{background-color:#fafbfc!important}
        .text-gray-light{color:#6a737d!important}
        .mb-0{margin-bottom:0!important}
        .my-2{margin-top:8px!important;margin-bottom:8px!important}
        .pl-0{padding-left:0!important}
        .py-0{padding-top:0!important;padding-bottom:0!important}
        .pl-1{padding-left:4px!important}
        .pl-2{padding-left:8px!important}
        .py-2{padding-top:8px!important;padding-bottom:8px!important}
        .pl-3,.px-3{padding-left:16px!important}
        .px-3{padding-right:16px!important}
        .pl-4{padding-left:24px!important}
        .pl-5{padding-left:32px!important}
        .pl-6{padding-left:40px!important}
        .f6{font-size:12px!important}
        .lh-condensed{line-height:1.25!important}
        .text-bold{font-weight:600!important}
        .pl-c{color:#6a737d}
        .pl-c1,.pl-s .pl-v{color:#005cc5}
        .pl-e,.pl-en{color:#6f42c1}
        .pl-s .pl-s1,.pl-smi{color:#24292e}
        .pl-ent{color:#22863a}
        .pl-k{color:#d73a49}
        .pl-pds,.pl-s,.pl-s .pl-pse .pl-s1,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre{color:#032f62}
        .pl-smw,.pl-v{color:#e36209}
        .pl-bu{color:#b31d28}
        .pl-ii{color:#fafbfc;background-color:#b31d28}
        .pl-c2{color:#fafbfc;background-color:#d73a49}
        .pl-c2:before{content:"^M"}
        .pl-sr .pl-cce{font-weight:700;color:#22863a}
        .pl-ml{color:#735c0f}
        .pl-mh,.pl-mh .pl-en,.pl-ms{font-weight:700;color:#005cc5}
        .pl-mi{font-style:italic;color:#24292e}
        .pl-mb{font-weight:700;color:#24292e}
        .pl-md{color:#b31d28;background-color:#ffeef0}
        .pl-mi1{color:#22863a;background-color:#f0fff4}
        .pl-mc{color:#e36209;background-color:#ffebda}
        .pl-mi2{color:#f6f8fa;background-color:#005cc5}
        .pl-mdr{font-weight:700;color:#6f42c1}
        .pl-ba{color:#586069}
        .pl-sg{color:#959da5}
        .pl-corl{text-decoration:underline;color:#032f62}
        .mb-0{margin-bottom:0!important}
        .my-2{margin-bottom:8px!important}
        .my-2{margin-top:8px!important}
        .pl-0{padding-left:0!important}
        .py-0{padding-top:0!important;padding-bottom:0!important}
        .pl-1{padding-left:4px!important}
        .pl-2{padding-left:8px!important}
        .py-2{padding-top:8px!important;padding-bottom:8px!important}
        .pl-3{padding-left:16px!important}
        .pl-4{padding-left:24px!important}
        .pl-5{padding-left:32px!important}
        .pl-6{padding-left:40px!important}
        .pl-7{padding-left:48px!important}
        .pl-8{padding-left:64px!important}
        .pl-9{padding-left:80px!important}
        .pl-10{padding-left:96px!important}
        .pl-11{padding-left:112px!important}
        .pl-12{padding-left:128px!important}
        hr{border-bottom-color:#eee}
        kbd{display:inline-block;padding:3px 5px;font:11px SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;line-height:10px;color:#444d56;vertical-align:middle;background-color:#fafbfc;border:1px solid #d1d5da;border-radius:3px;box-shadow:inset 0 -1px 0 #d1d5da}
        .markdown-body:after,.markdown-body:before{display:table;content:""}
        .markdown-body:after{clear:both}
        .markdown-body>:first-child{margin-top:0!important}
        .markdown-body>:last-child{margin-bottom:0!important}
        a:not([href]){color:inherit;text-decoration:none}
        blockquote,details,dl,ol,p,pre,table,ul{margin-top:0;margin-bottom:16px}
        hr{height:.25em;padding:0;margin:24px 0;background-color:#e1e4e8;border:0}
        blockquote{padding:0 1em;color:#6a737d;border-left:.25em solid #dfe2e5}
        blockquote>:first-child{margin-top:0}
        blockquote>:last-child{margin-bottom:0}
        h1,h2,h3,h4,h5,h6{margin-top:24px;margin-bottom:16px;font-weight:600;line-height:1.25}
        h1{font-size:2em}
        h1,h2{padding-bottom:.3em;border-bottom:1px solid #eaecef}
        h2{font-size:1.5em}
        h3{font-size:1.25em}
        h4{font-size:1em}
        h5{font-size:.875em}
        h6{font-size:.85em;color:#6a737d}
        ol,ul{padding-left:2em}
        ol ol,ol ul,ul ol,ul ul{margin-top:0;margin-bottom:0}
        li{word-wrap:break-all}
        li>p{margin-top:16px}
        li+li{margin-top:.25em}
        dl{padding:0}
        dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:600}
        dl dd{padding:0 16px;margin-bottom:16px}
        table{display:block;width:100%;overflow:auto}
        table th{font-weight:600}
        table td,table th{padding:6px 13px;border:1px solid #dfe2e5}
        table tr{background-color:#fff;border-top:1px solid #c6cbd1}
        table tr:nth-child(2n){background-color:#f6f8fa}
        img{max-width:100%;box-sizing:initial;background-color:#fff}
        img[align="right"]{padding-left:20px}
        img[align="left"]{padding-right:20px}
        code{padding:.2em .4em;margin:0;font-size:85%;background-color:rgba(27,31,35,0.05);border-radius:3px}
        pre{word-wrap:normal}
        pre>code{padding:0;margin:0;font-size:100%;word-break:normal;white-space:pre;background:transparent;border:0}
        .highlight{margin-bottom:16px}
        .highlight pre{margin-bottom:0;word-break:normal}
        .highlight pre,pre{padding:16px;overflow:auto;font-size:85%;line-height:1.45;background-color:#f6f8fa;border-radius:3px}
        pre code{display:inline;max-width:auto;padding:0;margin:0;overflow:visible;line-height:inherit;word-wrap:normal;background-color:initial;border:0}
        .commit-tease-sha{display:inline-block;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:90%;color:#444d56}
        .full-commit .btn-outline:not(:disabled):hover{color:#005cc5;border-color:#005cc5}
        .blob-wrapper{overflow-x:auto;overflow-y:hidden}
        .blob-wrapper-embedded{max-height:240px;overflow-y:auto}
        .blob-num{width:1%;min-width:50px;padding-right:10px;padding-left:10px;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:12px;line-height:20px;color:rgba(27,31,35,0.3);text-align:right;white-space:nowrap;vertical-align:top;cursor:pointer;user-select:none}
        .blob-num:hover{color:rgba(27,31,35,0.6)}
        .blob-num:before{content:attr(data-line-number)}
        .blob-code{position:relative;padding-right:10px;padding-left:10px;line-height:20px;vertical-align:top}
        .blob-code-inner{overflow:visible;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:12px;color:#24292e;word-wrap:normal;white-space:pre}
        .pl-token.active,.pl-token:hover{cursor:pointer;background:#ffea7f}
        .tab-size[data-tab-size="1"]{-moz-tab-size:1;tab-size:1}
        .tab-size[data-tab-size="2"]{-moz-tab-size:2;tab-size:2}
        .tab-size[data-tab-size="3"]{-moz-tab-size:3;tab-size:3}
        .tab-size[data-tab-size="4"]{-moz-tab-size:4;tab-size:4}
        .tab-size[data-tab-size="5"]{-moz-tab-size:5;tab-size:5}
        .tab-size[data-tab-size="6"]{-moz-tab-size:6;tab-size:6}
        .tab-size[data-tab-size="7"]{-moz-tab-size:7;tab-size:7}
        .tab-size[data-tab-size="8"]{-moz-tab-size:8;tab-size:8}
        .tab-size[data-tab-size="9"]{-moz-tab-size:9;tab-size:9}
        .tab-size[data-tab-size="10"]{-moz-tab-size:10;tab-size:10}
        .tab-size[data-tab-size="11"]{-moz-tab-size:11;tab-size:11}
        .tab-size[data-tab-size="12"]{-moz-tab-size:12;tab-size:12}
        .task-list-item{list-style-type:none}
        .task-list-item+.task-list-item{margin-top:3px}
        .task-list-item input{margin:0 .2em .25em -1.6em;vertical-align:middle}
        #page{width:calc(100% - 500px);margin-left:500px;overflow: hidden;}
        fieldset{display:none;background-color:#fff;border:0;overflow:hidden;box-shadow:2px 2px 10px rgba(128,128,128,0.2);margin-bottom:20px;padding:20px}
        fieldset legend{font-weight:bold;color:green;height:3.5em;margin-left:-20px;padding:0}
        #nav{background:rgb(255 255 255 / .7);padding:20px 10px 100px 20px;position:fixed;top:0;left:0;bottom:0;width:500px;overflow-y:auto;overflow-x: hidden;white-space:nowrap}
        ::-webkit-scrollbar{width:5px}
        ::-webkit-scrollbar-thumb{background-color:#79a5e8}
        @media print,(max-width:900px){
          #nav{display:none!important}
          #page{width:100%!important;margin-left:0!important}
          fieldset{padding-top: 0 !important;padding-bottom: 0 !important;display:block!important;box-shadow:none!important}
          .toggle-hash-btn {display: none !important;}
        }
        .hljs{display:block;overflow-x:auto;padding:.5em;color:#333;background:#f8f8f8}
        .hljs-comment,.hljs-quote{color:#998;font-style:italic}
        .hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:bold}
        .hljs-number,.hljs-literal,.hljs-variable,.hljs-template-variable,.hljs-tag .hljs-attr{color:#008080}
        .hljs-string,.hljs-doctag{color:#d14}
        .hljs-title,.hljs-section,.hljs-selector-id{color:#900;font-weight:bold}
        .hljs-subst{font-weight:normal}
        .hljs-type,.hljs-class .hljs-title{color:#458;font-weight:bold}
        .hljs-tag,.hljs-name,.hljs-attribute{color:#000080;font-weight:normal}
        .hljs-regexp,.hljs-link{color:#009926}
        .hljs-symbol,.hljs-bullet{color:#990073}
        .hljs-built_in,.hljs-builtin-name{color:#0086b3}
        .hljs-meta{color:#999;font-weight:bold}
        .hljs-deletion{background:#fdd}
        .hljs-addition{background:#dfd}
        .hljs-emphasis{font-style:italic}
        .hljs-strong{font-weight:bold}
        .toggle-hash-btn {position: fixed;bottom: 10px;left:10px;z-index: 1000; display: flex; justify-content: space-between;  width: 270px;}
        iframe {border: 5px solid #999;margin:10px;width: 90%;min-height: 50px;}
    </style>
    <script>
          const $ = selector => document.querySelector(selector);
          const $$ = selector => document.querySelectorAll(selector);
          const decode = s => decodeURIComponent(s);
          const domInfo = dom => ({
            offsetParent: dom.offsetParent.className,
            offsetLeft: dom.offsetLeft,
            offsetTop: dom.offsetTop,
            clientWidth: dom.clientWidth,
            offsetWidth: dom.offsetWidth,
            BoundingClientRect: dom.getBoundingClientRect(),
          });
          let openHash = false;
          function viewFieldset() {
            const hash = decode(location.hash);
            if(openHash && hash &&$(`fieldset${hash}`)) {
              Array.from($$('fieldset')).forEach(dom  =>dom.style.display = 'none');
              $(`fieldset${hash}`).style.display = 'block';
            }else {
              Array.from($$('fieldset')).forEach(dom  =>dom.style.display = 'block');
            }
          }
          window.onhashchange = viewFieldset;
          window.onload  = ()=>{
            viewFieldset();
            setATarget();
            loadIframe();
          };
          
          function toggleHash() {
            openHash = !openHash;
            viewFieldset();
            $('.toggle-hash-btn button').innerText = openHash ? '关闭专注模式' : '开启专注模式';
          }
          function setATarget() {
            $$('#page a').forEach(a=>a.target = '_blank');
          }
          function elementInViewport(el) {
            if (el instanceof Element) {
              const { top, left, width, height } = el.getBoundingClientRect();
              const { innerHeight, innerWidth } = window;
              return (
                top + height >= 0 &&
                left + width >= 0 &&
                top <= innerHeight &&
                left <= innerWidth
              );
            }
            return false;
          }
          function loadIframe() {
            const query = "data-src";
            const frames = Array.from($$(`iframe[${query}]`));

            const load = (item) => {
              frames.splice(
                frames.findIndex((v) => v === item),
                1
              );
              item.src = item.getAttribute(query);
              item.removeAttribute(query);
            };
            const processScroll = () => {
              frames.forEach((item) => {
                if (elementInViewport(item)) {
                  load(item);
                }
              });
            };
            processScroll();
            window.addEventListener("scroll", processScroll, false);
            window.removeEventListener("beforeunload", processScroll, false);
          }
    </script>
</head>

<body>
  <div class="toggle-hash-btn">
    <button  onclick="toggleHash()">开启专注模式</button>
  </div><div id="page">
      <fieldset id='_m33dVK'>
      <legend>css-animations</legend>
      <h1 id="css-动画">CSS 动画</h1>
<p>CSS 动画可以在不借助 Javascript 的情况下做出一些简单的动画效果。</p>
<p>你也可以通过 Javascript 控制 CSS 动画，使用少量的代码，就能让动画表现更加出色。</p>
<h2 id="css-过渡（transition">CSS 过渡（transition)</h2>
<p>CSS 过渡的理念非常简单，我们只需要定义某一个属性以及如何动态地表现其变化。当属性变化时，浏览器将会绘制出相应的过渡动画。</p>
<p>也就是说：我们只需要改变某个属性，然后所有流畅的动画都由浏览器生成。</p>
<p>举个例子，以下 CSS 会为 <code>backgroud-color</code> 的变化生成一个 3 秒的过渡动画：</p>
<pre><code class="language-css"><span class="hljs-selector-class">.animated</span> {
  <span class="hljs-attribute">transition-property</span>: background-color;
  <span class="hljs-attribute">transition-duration</span>: <span class="hljs-number">3s</span>;
}</code></pre>
<p>现在，只要一个元素拥有名为 <code>.animated</code> 的类，那么任何背景颜色的变化都会被渲染为 3 秒钟的动画。</p>
<p>单击以下按钮以演示动画：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;color&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
  <span class="hljs-selector-id">#color</span> {
    <span class="hljs-attribute">transition-property</span>: background-color;
    <span class="hljs-attribute">transition-duration</span>: <span class="hljs-number">3s</span>;
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  color.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">this</span>.style.backgroundColor = <span class="hljs-string">&quot;red&quot;</span>;
  };
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>CSS 提供了四个属性来描述一个过渡：</p>
<ul>
<li><code>transition-property</code></li>
<li><code>transition-duration</code></li>
<li><code>transition-timing-function</code></li>
<li><code>transition-delay</code></li>
</ul>
<p>之后我们会详细介绍它们，目前我们需要知道，我们可以在 <code>transition</code> 中以 <code>property duration timing-function delay</code> 的顺序一次性定义它们，并且可以同时为多个属性设置过渡动画。</p>
<p>请看以下例子，点击按钮生成 <code>color</code> 和 <code>font-size</code> 的过渡动画：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;growing&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
  <span class="hljs-selector-id">#growing</span> {
    <span class="hljs-attribute">transition</span>: font-size <span class="hljs-number">3s</span>, color <span class="hljs-number">2s</span>;
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  growing.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">this</span>.style.fontSize = <span class="hljs-string">&quot;36px&quot;</span>;
    <span class="hljs-built_in">this</span>.style.color = <span class="hljs-string">&quot;red&quot;</span>;
  };
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>现在让我们一个一个展开看这些属性。</p>
<h2 id="transition-property">transition-property</h2>
<p>在 <code>transition-property</code> 中我们可以列举要设置动画的所有属性，如：<code>left、margin-left、height 和 color</code>。</p>
<p>不是所有的 CSS 属性都可以使用过渡动画，但是它们中的<a href="http://www.w3.org/TR/css3-transitions/#animatable-properties-">大多数</a>都是可以的。<code>all</code> 表示应用在所有属性上。</p>
<h2 id="transition-duration">transition-duration</h2>
<p><code>transition-duration</code> 允许我们指定动画持续的时间。时间的格式参照 <a href="http://www.w3.org/TR/css3-values/#time">CSS 时间格式</a>：单位为秒 <code>s</code> 或者毫秒 <code>ms</code>。</p>
<h2 id="transition-delay">transition-delay</h2>
<p><code>transition-delay</code> 允许我们设定动画<strong>开始前</strong>的延迟时间。例如，对于 <code>transition-delay: 1s</code>，动画将会在属性变化发生 1 秒后开始渲染。</p>
<p>你也可以提供一个负值。那么动画将会从整个过渡的中间时刻开始渲染。例如，对于 <code>transition-duration: 2s</code>，同时把 <code>delay</code> 设置为 <code>-1s</code>，那么这个动画将会持续 1 秒钟，并且从正中间开始渲染。</p>
<p>这里演示了数字从 <code>0</code> 到 <code>9</code> 的动画，使用了 CSS <code>translate</code> 方法：</p>
<p>如下在 <code>tranform</code> 属性上应用动画：</p>
<pre><code class="language-css"><span class="hljs-selector-id">#stripe</span><span class="hljs-selector-class">.animate</span> {
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">90%</span>);
  <span class="hljs-attribute">transition-property</span>: transform;
  <span class="hljs-attribute">transition-duration</span>: <span class="hljs-number">9s</span>;
}</code></pre>
<p>在以上的例子中，JavaScript 把 <code>.animate</code> 类添加到了元素上，由此触发了动画：</p>
<pre><code class="language-js">stripe.classList.add(<span class="hljs-string">&quot;animate&quot;</span>);</code></pre>
<p>我们也可以『从中间』开始，也就是说从某个特定数字开始，比方说，从当前的时间的秒数开始。这就要用到负的 <code>transition-delay</code>。</p>
<p>此处，如果你单击这个数字，那么它会从当前的秒数开始渲染：</p>
<p>只需添加一行 JavaScript 代码：</p>
<pre><code class="language-js">stripe.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> sec = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getSeconds() % <span class="hljs-number">10</span>;

  <span class="hljs-comment">// for instance, -3s here starts the animation from the 3rd second</span>
  stripe.style.transitionDelay = <span class="hljs-string">&quot;-&quot;</span> + sec + <span class="hljs-string">&quot;s&quot;</span>;

  stripe.classList.add(<span class="hljs-string">&quot;animate&quot;</span>);
};</code></pre>
<h2 id="transition-timing-function">transition-timing-function</h2>
<p>时间函数描述了动画进程在时间上的分布。它是先慢后快还是先快后慢？</p>
<p>乍一看，这可能是最复杂的属性了，但是稍微花点时间，你就会发现其实也很简单。</p>
<p>这个属性接受两种值：一个贝塞尔曲线（Bezier curve）或者阶跃函数（steps）。我们先从贝塞尔曲线开始，这也是较为常用的。</p>
<h3 id="贝塞尔曲线（bezier-curve）">贝塞尔曲线（Bezier curve）</h3>
<p>时间函数可以用<a href="/bezier-curve">贝塞尔曲线</a>描述，通过设置四个满足以下条件的控制点：</p>
<ol>
<li>第一个应为：<code>(0,0)</code>。</li>
<li>最后一个应为：<code>(1,1)</code>。</li>
<li>对于中间值，<code>x</code> 必须位于 <code>0..1</code> 之间，<code>y</code> 可以为任意值。</li>
</ol>
<p>CSS 中设置一贝塞尔曲线的语法为：<code>cubic-bezier(x2, y2, x3, y3)</code>。这里我们只需要设置第二个和第三个值，因为第一个点固定为 <code>(0,0)</code>，第四个点固定为 <code>(1,1)</code>。</p>
<p>时间函数描述了动画进行的快慢。</p>
<ul>
<li><code>x</code> 轴表示时间：<code>0</code> —— 开始时刻，<code>1</code> —— <code>transition-duration</code>的结束时刻。</li>
<li><code>y</code> 轴表示过程的完成度：<code>0</code> —— 属性的起始值，<code>1</code> —— 属性的最终值。</li>
</ul>
<p>最简单的一种情况就是动画匀速进行，可以通过设置曲线为 <code>cubic-bezier(0, 0, 1, 1)</code> 来实现。</p>
<p>看上去就像这样：</p>
<p>...正如我们所见，这就是条直线。随着时间 <code>x</code> 推移，完成度 <code>y</code> 稳步从 <code>0</code> 增长到 <code>1</code>。</p>
<p>例子中的列车匀速地从左侧移动到右侧：</p>
<p>这个里面的 CSS 就是基于刚才那条曲线的：</p>
<pre><code class="language-css"><span class="hljs-selector-class">.train</span> {
  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">transition</span>: left <span class="hljs-number">5s</span> <span class="hljs-built_in">cubic-bezier</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
  <span class="hljs-comment">/* JavaScript sets left to 450px */</span>
}</code></pre>
<p>...那么，我们如果表现出减速行驶的列车呢？</p>
<p>我们可以使用另一条贝塞尔曲线：<code>cubic-bezier(0.0, 0.5, 0.5 ,1.0)</code>。</p>
<p>图像如下：</p>
<p>正如我们所见，这个过程起初很快：曲线开始迅速升高，然后越来越慢。</p>
<p>这是实际的效果演示：</p>
<p>CSS：</p>
<pre><code class="language-css"><span class="hljs-selector-class">.train</span> {
  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">transition</span>: left <span class="hljs-number">5s</span> <span class="hljs-built_in">cubic-bezier</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>);
  <span class="hljs-comment">/* JavaScript sets left to 450px */</span>
}</code></pre>
<p>CSS 提供几条内置的曲线：<code>linear</code>、<code>ease</code>、<code>ease-in</code>、<code>ease-out</code> 和 <code>ease-in-out</code>。</p>
<p><code>linear</code> 其实就是 <code>cubic-bezier(0, 0, 1, 1)</code> 的简写 —— 一条直线，刚刚我们已经看过了。</p>
<p>其它的名称是以下贝塞尔曲线的简写：</p>
<table>
<thead>
<tr>
<th><code>ease</code><sup>*</sup></th>
<th><code>ease-in</code></th>
<th><code>ease-out</code></th>
<th><code>ease-in-out</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>(0.25, 0.1, 0.25, 1.0)</code></td>
<td><code>(0.42, 0, 1.0, 1.0)</code></td>
<td><code>(0, 0, 0.58, 1.0)</code></td>
<td><code>(0.42, 0, 0.58, 1.0)</code></td>
</tr>
<tr>
<td><img src="ease.svg" alt="ease, figure"></td>
<td><img src="ease-in.svg" alt="ease-in, figure"></td>
<td><img src="ease-out.svg" alt="ease-out, figure"></td>
<td><img src="ease-in-out.svg" alt="ease-in-out, figure"></td>
</tr>
</tbody></table>
<p><code>*</code> —— 默认值，如果没有指定时间函数，那么将使用 <code>ease</code> 作为默认值。</p>
<p>所以，我们可以使用 <code>ease-out</code> 来表现减速行驶的列车：</p>
<pre><code class="language-css"><span class="hljs-selector-class">.train</span> {
  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">transition</span>: left <span class="hljs-number">5s</span> ease-out;
  <span class="hljs-comment">/* transition: left 5s cubic-bezier(0, .5, .5, 1); */</span>
}</code></pre>
<p>但是这看起来有点怪怪的。</p>
<p><strong>贝塞尔曲线可以使动画『超出』其原本的范围。</strong></p>
<p>曲线上的控制点的 <code>y</code> 值可以使任意的：不管是负值还是一个很大的值。如此，贝塞尔曲线就会变得很低或者很高，让动画超出其正常的范围。</p>
<p>在一下的例子中使用的代码：</p>
<pre><code class="language-css"><span class="hljs-selector-class">.train</span> {
  <span class="hljs-attribute">left</span>: <span class="hljs-number">100px</span>;
  <span class="hljs-attribute">transition</span>: left <span class="hljs-number">5s</span> <span class="hljs-built_in">cubic-bezier</span>(<span class="hljs-number">0.5</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">2</span>);
  <span class="hljs-comment">/* JavaScript sets left to 400px */</span>
}</code></pre>
<p><code>left</code> 本该在 <code>100px</code> 到 <code>400px</code> 之间变化。</p>
<p>但是如果你点击列车，你会发现：</p>
<ul>
<li>起初，列车会<strong>反向</strong>运动：<code>left</code> 会变得小于 <code>100px</code>。</li>
<li>然后，它会变回往前运动，并且超过 <code>400px</code>。</li>
<li>最后再返回 —— 回到 <code>400px</code>。</li>
</ul>
<p>我们把第二个点的 <code>y</code> 坐标移动到了小于 <code>0</code> 的位置，同时把第三个点的 <code>y</code> 坐标移动到了大于 <code>1</code> 的位置，因此曲线已经不再像一个四分之一圆了。<code>y</code> 坐标超出了常规的 <code>0..1</code> 的范围。</p>
<p>正如我们所知，<code>y</code> 表示『动画进程的完成度』。<code>y = 0</code> 表示属性的初始值，<code>y = 1</code> 则表示属性的最终值。因此，<code>y &lt; 0</code> 意味着属性值要比初始值小，而 <code>y &gt; 1</code> 则表明属性值要比最终值大。</p>
<p>当然了，<code>-1</code> 和 <code>2</code> 还是比较缓和的值。如果我们把 <code>y</code> 设为 <code>-99</code> 和 <code>99</code>，那么列车将会偏离地更远。</p>
<p>但是，如何针对特定的任务寻找到合适的贝塞尔曲线呢？事实上，有很多工具可以帮到你。比方说，我们可以利用这个网站：<a href="http://cubic-bezier.com/">http://cubic-bezier.com/</a>。</p>
<h3 id="阶跃函数（steps）">阶跃函数（Steps）</h3>
<p>时间函数 <code>steps(number of steps[, start/end])</code> 允许你让动画分段进行，<code>number of steps</code> 表示需要拆分为多少段。</p>
<p>让我们通过一个数字的例子来演示一下。我们将会让数字以离散的方式变化，而不是以连续的方式。</p>
<p>为了达到效果，我们把动画拆分为 9 段：</p>
<pre><code class="language-css"><span class="hljs-selector-id">#stripe</span><span class="hljs-selector-class">.animate</span> {
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">90%</span>);
  <span class="hljs-attribute">transition</span>: transform <span class="hljs-number">9s</span> <span class="hljs-built_in">steps</span>(<span class="hljs-number">9</span>, start);
}</code></pre>
<p><code>step(9, start)</code> 生效时：</p>
<p><code>steps</code> 的第一个参数表示段数。这个过渡动画将会被拆分为 9 个部分（每个占 10%）。时间间隔也会以同样的方式被拆分：9 秒会被分割为多个时长 1 秒的间隔。</p>
<p>第二个参数可以取 <code>start</code> 或 <code>end</code> 两者其一。</p>
<p><code>start</code> 表示在动画开始时，我们需要立即开始第一段的动画。</p>
<p>可以观察到，在动画过程中：当我们单击数字之后，它会立马变为 <code>1</code>（即第一段），然后在下一秒开始的时候继续变化。</p>
<p>具体的流程如下：</p>
<ul>
<li><code>0s</code> —— <code>-10%</code>（在第一秒开始的时候立即变化）</li>
<li><code>1s</code> —— <code>-20%</code></li>
<li>...</li>
<li><code>8s</code> -- <code>-80%</code></li>
<li>（最后一秒，显示最终值）</li>
</ul>
<p>另一个值 <code>end</code> 表示：改变不应该在最开始的时候发生，而是发生在每一段的最后时刻。</p>
<p>其流程如下：</p>
<ul>
<li><code>0s</code> —— <code>0</code></li>
<li><code>1s</code> —— <code>-10%</code>（在第一秒结束时第一次变化）</li>
<li><code>2s</code> —— <code>-20%</code></li>
<li>...</li>
<li><code>9s</code> —— <code>-90%</code></li>
</ul>
<p><code>step(9, end)</code> 生效时：</p>
<p>另外还有一些简写值：</p>
<ul>
<li><code>step-start</code> —— 等同于 <code>steps(1, start)</code>。即：动画立刻开始，并且只有一段。也就是说，会立刻开始，紧接着就结束了，宛如没有动画一样。</li>
<li><code>step-end</code> —— 等同于 <code>steps(1, end)</code>。即：在 <code>transition-duration</code> 结束时生成一段动画。</li>
</ul>
<p>这些值很少会被用到，因为它们并不算是真正的动画，而是单步的变化。</p>
<h2 id="transitionend-事件">transitionend 事件</h2>
<p>CSS 动画完成后，会触发 <code>transitionend</code> 事件。</p>
<p>这被广泛用于在动画结束后执行某种操作。我们也可以用它来串联动画。</p>
<p>举例来说，下面的小船会在点击后向右浮动，然后再回来。而且，每一次都会向右移动地更远一点：</p>
<p>[iframe data-src=&quot;boat&quot; height=300 edit link]</p>
<p>这个动画通过 <code>go</code> 函数初始化，并且在每次动画完成后都会重复执行，并转变方向：</p>
<pre><code class="language-js">boat.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">//...</span>
  <span class="hljs-keyword">let</span> times = <span class="hljs-number">1</span>;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">go</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (times % <span class="hljs-number">2</span>) {
      <span class="hljs-comment">// 向右移动</span>
      boat.classList.remove(<span class="hljs-string">&quot;back&quot;</span>);
      boat.style.marginLeft = <span class="hljs-number">100</span> * times + <span class="hljs-number">200</span> + <span class="hljs-string">&quot;px&quot;</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 向左移动</span>
      boat.classList.add(<span class="hljs-string">&quot;back&quot;</span>);
      boat.style.marginLeft = <span class="hljs-number">100</span> * times - <span class="hljs-number">200</span> + <span class="hljs-string">&quot;px&quot;</span>;
    }
  }

  go();

  boat.addEventListener(<span class="hljs-string">&quot;transitionend&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    times++;
    go();
  });
};</code></pre>
<p><code>transitionend</code> 的事件对象有几个特定的属性：</p>
<p><code>event.propertyName</code>
：当前完成动画的属性，这在我们同时为多个属性加上动画时会很有用。</p>
<p><code>event.elapsedTime</code>
：动画完成的时间（按秒计算），不包括 <code>transition-delay</code>。</p>
<h2 id="关键帧动画（keyframes）">关键帧动画（Keyframes）</h2>
<p>我们可以通过 CSS 提供的 <code>@keyframes</code> 规则整合多个简单的动画。</p>
<p>它会指定某个动画的名称以及相应的规则：哪个属性，何时以及何地渲染动画。然后使用 <code>animation</code> 属性把动画绑定到相应的元素上，并为其添加额外的参数。</p>
<p>这里有个详细的例子：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;progress&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
  <span class="hljs-keyword">@keyframes</span> go-left-right {
    <span class="hljs-comment">/* 指定一个名字：&quot;go-left-right&quot; */</span>
    <span class="hljs-selector-tag">from</span> {
      <span class="hljs-attribute">left</span>: <span class="hljs-number">0px</span>;
    } <span class="hljs-comment">/* 从 left: 0px 开始 */</span>
    <span class="hljs-selector-tag">to</span> {
      <span class="hljs-attribute">left</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">100%</span> - <span class="hljs-number">50px</span>);
    } <span class="hljs-comment">/* 移动至 left: 100%-50px */</span>
  }

  <span class="hljs-selector-class">.progress</span> {
    <span class="hljs-attribute">animation</span>: go-left-right <span class="hljs-number">3s</span> infinite alternate;
    <span class="hljs-comment">/* 把动画 &quot;go-left-right&quot; 应用到元素上
       持续 3 秒
       持续次数：infinite
       每次都改变方向
    */</span>

    <span class="hljs-attribute">position</span>: relative;
    <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid green;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">20px</span>;
    <span class="hljs-attribute">background</span>: lime;
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre>
<p>有许多关于 <code>@keyframes</code> 的文章以及一个<a href="https://drafts.csswg.org/css-animations/">详细的规范说明</a>。</p>
<p>很可能你并不需要经常用到 <code>@keyframes</code>，除非你的网站上有一直在运动的元素。</p>
<h2 id="总结">总结</h2>
<p>CSS 动画允许你为一个或者多个属性的变化创建丝滑流畅（也可能不是）的过渡动画。</p>
<p>它们适用于大多数的动画需求。我们也可以使用 JavaScript 创建动画，下一章将会详细讲解相关内容。</p>
<p>相对于 JavaScript 动画，CSS 动画存在的特点如下：</p>
<ul>
<li>简单的事，简单地做。</li>
<li>快速，而且对 CPU 造成的压力很小。</li>
<li>JavaScript 动画更加灵活。它们可以实现任何动画逻辑，比如某个元素的爆炸效果。</li>
<li>不仅仅只是属性的变化。我们还可以在 JavaScript 中生成新元素用于动画。</li>
</ul>
<p>本节已经介绍了可以使用 CSS 实现的主要动画类型，而且 <code>transitionend</code> 还允许在动画结束后执行 JavaScript 代码，因此它可以方便得与代码结合起来。</p>

      </fieldset>
      
      <fieldset id='_MHx32v'>
      <legend>js-animation</legend>
      <p>JavaScript 动画可以处理 CSS 无法处理的事情。</p>
<p>例如，沿着具有与 Bezier 曲线不同的时序函数的复杂路径移动，或者实现画布上的动画。</p>
<h2 id="使用-setinterval">使用 setInterval</h2>
<p>从 HTML/CSS 的角度来看，动画是 style 属性的逐渐变化。例如，将 <code>style.left</code> 从 <code>0px</code> 变化到 <code>100px</code> 可以移动元素。</p>
<p>如果我们用 <code>setInterval</code> 每秒做 50 次小变化，看起来会更流畅。电影也是这样的原理：每秒 24 帧或更多帧足以使其看起来流畅。</p>
<p>伪代码如下：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> delay = <span class="hljs-number">1000</span> / <span class="hljs-number">50</span>; <span class="hljs-comment">// 每秒 50 帧</span>
<span class="hljs-keyword">let</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (animation complete) <span class="hljs-built_in">clearInterval</span>(timer);
  <span class="hljs-keyword">else</span> increase style.left
}, delay)</code></pre>
<p>更完整的动画示例：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> start = <span class="hljs-built_in">Date</span>.now(); <span class="hljs-comment">// 保存开始时间</span>

<span class="hljs-keyword">let</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// 距开始过了多长时间</span>
  <span class="hljs-keyword">let</span> timePassed = <span class="hljs-built_in">Date</span>.now() - start;

  <span class="hljs-keyword">if</span> (timePassed &gt;= <span class="hljs-number">2000</span>) {
    <span class="hljs-built_in">clearInterval</span>(timer); <span class="hljs-comment">// 2 秒后结束动画</span>
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-comment">// 在 timePassed 时刻绘制动画</span>
  draw(timePassed);
}, <span class="hljs-number">20</span>);

<span class="hljs-comment">// 随着 timePassed 从 0 增加到 2000</span>
<span class="hljs-comment">// 将 left 的值从 0px 增加到 400px</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">draw</span>(<span class="hljs-params">timePassed</span>) </span>{
  train.style.left = timePassed / <span class="hljs-number">5</span> + <span class="hljs-string">&quot;px&quot;</span>;
}</code></pre>
<h2 id="使用-requestanimationframe">使用 requestAnimationFrame</h2>
<p>假设我们有几个同时运行的动画。</p>
<p>如果我们单独运行它们，每个都有自己的 <code>setInterval(..., 20)</code>，那么浏览器必须以比 <code>20ms</code> 更频繁的速度重绘。</p>
<p>每个 <code>setInterval</code> 每 <code>20ms</code> 触发一次，但它们相互独立，因此 <code>20ms</code> 内将有多个独立运行的重绘。</p>
<p>这几个独立的重绘应该组合在一起，以使浏览器更加容易处理。</p>
<p>换句话说，像下面这样：</p>
<pre><code class="language-js"><span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  animate1();
  animate2();
  animate3();
}, <span class="hljs-number">20</span>);</code></pre>
<p>……比这样更好：</p>
<pre><code class="language-js"><span class="hljs-built_in">setInterval</span>(animate1, <span class="hljs-number">20</span>);
<span class="hljs-built_in">setInterval</span>(animate2, <span class="hljs-number">20</span>);
<span class="hljs-built_in">setInterval</span>(animate3, <span class="hljs-number">20</span>);</code></pre>
<p>还有一件事需要记住。有时当 CPU 过载时，或者有其他原因需要降低重绘频率。例如，如果浏览器选项卡被隐藏，那么绘图完全没有意义。</p>
<p>有一个标准<a href="http://www.w3.org/TR/animation-timing/">动画时序</a>提供了 <code>requestAnimationFrame</code> 函数。</p>
<p>它解决了所有这些问题，甚至更多其它的问题。</p>
<p>语法：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> requestId = requestAnimationFrame(callback);</code></pre>
<p>这会让 <code>callback</code> 函数在浏览器每次重绘的最近时间运行。</p>
<p>如果我们对 <code>callback</code> 中的元素进行变化，这些变化将与其他 <code>requestAnimationFrame</code> 回调和 CSS 动画组合在一起。因此，只会有一次几何重新计算和重绘，而不是多次。</p>
<p>返回值 <code>requestId</code> 可用来取消回调：</p>
<pre><code class="language-js"><span class="hljs-comment">// 取消回调的周期执行</span>
cancelAnimationFrame(requestId);</code></pre>
<p><code>callback</code> 得到一个参数 —— 从页面加载开始经过的毫秒数。这个时间也可通过调用 <a href="mdn:api/Performance/now">performance.now()</a> 得到。</p>
<p>通常 <code>callback</code> 很快就会运行，除非 CPU 过载或笔记本电量消耗殆尽，或者其他原因。</p>
<p>下面的代码显示了 <code>requestAnimationFrame</code> 的前 10 次运行之间的时间间隔。通常是 10-20ms：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">let</span> prev = performance.now();
  <span class="hljs-keyword">let</span> times = <span class="hljs-number">0</span>;

  requestAnimationFrame(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">measure</span>(<span class="hljs-params">time</span>) </span>{
    <span class="hljs-built_in">document</span>.body.insertAdjacentHTML(
      <span class="hljs-string">&quot;beforeEnd&quot;</span>,
      <span class="hljs-built_in">Math</span>.floor(time - prev) + <span class="hljs-string">&quot; &quot;</span>
    );
    prev = time;

    <span class="hljs-keyword">if</span> (times++ &lt; <span class="hljs-number">10</span>) requestAnimationFrame(measure);
  });
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h2 id="结构化动画">结构化动画</h2>
<p>现在我们可以在 <code>requestAnimationFrame</code> 基础上创建一个更通用的动画函数：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">animate</span>(<span class="hljs-params">{ timing, draw, duration }</span>) </span>{
  <span class="hljs-keyword">let</span> start = performance.now();

  requestAnimationFrame(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">animate</span>(<span class="hljs-params">time</span>) </span>{
    <span class="hljs-comment">// timeFraction 从 0 增加到 1</span>
    <span class="hljs-keyword">let</span> timeFraction = (time - start) / duration;
    <span class="hljs-keyword">if</span> (timeFraction &gt; <span class="hljs-number">1</span>) timeFraction = <span class="hljs-number">1</span>;

    <span class="hljs-comment">// 计算当前动画状态</span>
    <span class="hljs-keyword">let</span> progress = timing(timeFraction);

    draw(progress); <span class="hljs-comment">// 绘制</span>

    <span class="hljs-keyword">if</span> (timeFraction &lt; <span class="hljs-number">1</span>) {
      requestAnimationFrame(animate);
    }
  });
}</code></pre>
<p><code>animate</code> 函数接受 3 个描述动画的基本参数：</p>
<p><code>duration</code>
: 动画总时间，比如 <code>1000</code>。</p>
<p><code>timing(timeFraction)</code>
: 时序函数，类似 CSS 属性 <code>transition-timing-function</code>，传入一个已过去的时间与总时间之比的小数（<code>0</code> 代表开始，<code>1</code> 代表结束），返回动画完成度（类似 Bezier 曲线中的 <code>y</code>）。</p>
<pre><code>例如，线性函数意味着动画以相同的速度均匀地进行：

```js
function linear(timeFraction) {
  return timeFraction;
}
```

图像如下：


它类似于 `transition-timing-function: linear`。后文有更多有趣的变体。</code></pre>
<p><code>draw(progress)</code>
: 获取动画完成状态并绘制的函数。值 <code>progress = 0</code> 表示开始动画状态，<code>progress = 1</code> 表示结束状态。</p>
<pre><code>这是实际绘制动画的函数。

它可以移动元素：

```js
function draw(progress) {
  train.style.left = progress + &#x27;px&#x27;;
}
```

……或者做任何其他事情，我们可以以任何方式为任何事物制作动画。</code></pre>
<p>让我们使用我们的函数将元素的 <code>width</code> 从 <code>0</code> 变化为 <code>100%</code>。</p>
<p>它的代码如下：</p>
<pre><code class="language-js">animate({
  <span class="hljs-attr">duration</span>: <span class="hljs-number">1000</span>,
  <span class="hljs-function"><span class="hljs-title">timing</span>(<span class="hljs-params">timeFraction</span>)</span> {
    <span class="hljs-keyword">return</span> timeFraction;
  },
  <span class="hljs-function"><span class="hljs-title">draw</span>(<span class="hljs-params">progress</span>)</span> {
    elem.style.width = progress * <span class="hljs-number">100</span> + <span class="hljs-string">&quot;%&quot;</span>;
  },
});</code></pre>
<p>与 CSS 动画不同，我们可以在这里设计任何时序函数和任何绘图函数。时序函数不受 Bezier 曲线的限制。并且 <code>draw</code> 不局限于操作 CSS 属性，还可以为类似烟花动画或其他动画创建新元素。</p>
<h2 id="时序函数">时序函数</h2>
<p>上文我们看到了最简单的线性时序函数。</p>
<p>让我们看看更多。我们将尝试使用不同时序函数的移动动画来查看它们的工作原理。</p>
<h3 id="n-次幂">n 次幂</h3>
<p>如果我们想加速动画，我们可以让 <code>progress</code> 为 <code>n</code> 次幂。</p>
<p>例如，抛物线：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quad</span>(<span class="hljs-params">timeFraction</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.pow(timeFraction, <span class="hljs-number">2</span>);
}</code></pre>
<p>……或者三次曲线甚至使用更大的 <code>n</code>。增大幂会让动画加速得更快。</p>
<h3 id="圆弧">圆弧</h3>
<p>函数：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">circ</span>(<span class="hljs-params">timeFraction</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> - <span class="hljs-built_in">Math</span>.sin(<span class="hljs-built_in">Math</span>.acos(timeFraction));
}</code></pre>
<h3 id="反弹：弓箭射击">反弹：弓箭射击</h3>
<p>此函数执行“弓箭射击”。首先，我们“拉弓弦”，然后“射击”。</p>
<p>与以前的函数不同，它取决于附加参数 <code>x</code>，即“弹性系数”。“拉弓弦”的距离由它定义。</p>
<p>代码如下：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">back</span>(<span class="hljs-params">x, timeFraction</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.pow(timeFraction, <span class="hljs-number">2</span>) * ((x + <span class="hljs-number">1</span>) * timeFraction - x);
}</code></pre>
<h3 id="弹跳">弹跳</h3>
<p>想象一下，我们正在抛球。球落下之后，弹跳几次然后停下来。</p>
<p><code>bounce</code> 函数也是如此，但顺序相反：“bouncing”立即启动。它使用了几个特殊的系数：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bounce</span>(<span class="hljs-params">timeFraction</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>, result; <span class="hljs-number">1</span>; a += b, b /= <span class="hljs-number">2</span>) {
    <span class="hljs-keyword">if</span> (timeFraction &gt;= (<span class="hljs-number">7</span> - <span class="hljs-number">4</span> * a) / <span class="hljs-number">11</span>) {
      <span class="hljs-keyword">return</span> (
        -<span class="hljs-built_in">Math</span>.pow((<span class="hljs-number">11</span> - <span class="hljs-number">6</span> * a - <span class="hljs-number">11</span> * timeFraction) / <span class="hljs-number">4</span>, <span class="hljs-number">2</span>) + <span class="hljs-built_in">Math</span>.pow(b, <span class="hljs-number">2</span>)
      );
    }
  }
}</code></pre>
<h3 id="伸缩动画">伸缩动画</h3>
<p>另一个“伸缩”函数接受附加参数 <code>x</code> 作为“初始范围”</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">elastic</span>(<span class="hljs-params">x, timeFraction</span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">10</span> * (timeFraction - <span class="hljs-number">1</span>)) *
    <span class="hljs-built_in">Math</span>.cos(((<span class="hljs-number">20</span> * <span class="hljs-built_in">Math</span>.PI * x) / <span class="hljs-number">3</span>) * timeFraction)
  );
}</code></pre>
<h2 id="逆转：ease">逆转：ease*</h2>
<p>我们有一组时序函数。它们的直接应用称为“easeIn”。</p>
<p>有时我们需要以相反的顺序显示动画。这是通过“easeOut”变换完成的。</p>
<h3 id="easeout">easeOut</h3>
<p>在“easeOut”模式中，我们将 <code>timing</code> 函数封装到 <code>timingEaseOut</code>中：</p>
<pre><code class="language-js">timingEaseOut(timeFraction) = <span class="hljs-number">1</span> - timing(<span class="hljs-number">1</span> - timeFraction);</code></pre>
<p>换句话说，我们有一个“变换”函数 <code>makeEaseOut</code>，它接受一个“常规”时序函数 <code>timing</code> 并返回一个封装器，里面封装了 <code>timing</code> 函数：</p>
<pre><code class="language-js"><span class="hljs-comment">// 接受时序函数，返回变换后的变体</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeEaseOut</span>(<span class="hljs-params">timing</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">timeFraction</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> - timing(<span class="hljs-number">1</span> - timeFraction);
  };
}</code></pre>
<p>例如，我们可以使用上面描述的 <code>bounce</code> 函数：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> bounceEaseOut = makeEaseOut(bounce);</code></pre>
<h3 id="easeinout">easeInOut</h3>
<p>我们还可以在动画的开头和结尾都显示效果。该变换称为“easeInOut”。</p>
<p>给定时序函数，我们按下面的方式计算动画状态：</p>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (timeFraction &lt;= <span class="hljs-number">0.5</span>) {
  <span class="hljs-comment">// 动画前半部分</span>
  <span class="hljs-keyword">return</span> timing(<span class="hljs-number">2</span> * timeFraction) / <span class="hljs-number">2</span>;
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// 动画后半部分</span>
  <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> - timing(<span class="hljs-number">2</span> * (<span class="hljs-number">1</span> - timeFraction))) / <span class="hljs-number">2</span>;
}</code></pre>
<p>封装器代码：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeEaseInOut</span>(<span class="hljs-params">timing</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">timeFraction</span>) </span>{
    <span class="hljs-keyword">if</span> (timeFraction &lt; <span class="hljs-number">0.5</span>) <span class="hljs-keyword">return</span> timing(<span class="hljs-number">2</span> * timeFraction) / <span class="hljs-number">2</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> - timing(<span class="hljs-number">2</span> * (<span class="hljs-number">1</span> - timeFraction))) / <span class="hljs-number">2</span>;
  };
}

bounceEaseInOut = makeEaseInOut(bounce);</code></pre>
<h2 id="总结">总结</h2>
<p>JavaScript 动画应该通过 <code>requestAnimationFrame</code> 实现。该内置方法允许设置回调函数，以便在浏览器准备重绘时运行。那通常很快，但确切的时间取决于浏览器。</p>
<p>当页面在后台时，根本没有重绘，因此回调将不会运行：动画将被暂停并且不会消耗资源。那很棒。</p>
<p>这是设置大多数动画的 helper 函数 <code>animate</code>：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">animate</span>(<span class="hljs-params">{ timing, draw, duration }</span>) </span>{
  <span class="hljs-keyword">let</span> start = performance.now();

  requestAnimationFrame(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">animate</span>(<span class="hljs-params">time</span>) </span>{
    <span class="hljs-comment">// timeFraction 从 0 增加到 1</span>
    <span class="hljs-keyword">let</span> timeFraction = (time - start) / duration;
    <span class="hljs-keyword">if</span> (timeFraction &gt; <span class="hljs-number">1</span>) timeFraction = <span class="hljs-number">1</span>;

    <span class="hljs-comment">// 计算当前动画状态</span>
    <span class="hljs-keyword">let</span> progress = timing(timeFraction);

    draw(progress); <span class="hljs-comment">// 绘制</span>

    <span class="hljs-keyword">if</span> (timeFraction &lt; <span class="hljs-number">1</span>) {
      requestAnimationFrame(animate);
    }
  });
}</code></pre>

      </fieldset>
      </div><div id="nav"><div style="margin-left:0em"><a href="#_m33dVK">css-animations</a><br/></div><div style="margin-left:0em"><a href="#_MHx32v">js-animation</a><br/></div></div>
</body></html>