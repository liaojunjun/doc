<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>create for ggdoc , @author sunyi</title>
    <style>
        .octicon{display:inline-block;fill:currentColor;vertical-align:text-bottom}
        .anchor{float:left;line-height:1;margin-left:-20px;padding-right:4px}
        .anchor:focus{outline:0}
        h1 .octicon-link,h2 .octicon-link,h3 .octicon-link,h4 .octicon-link,h5 .octicon-link,h6 .octicon-link{color:#1b1f23;vertical-align:middle;visibility:hidden}
        h1:hover .anchor,h2:hover .anchor,h3:hover .anchor,h4:hover .anchor,h5:hover .anchor,h6:hover .anchor{text-decoration:none}
        h1:hover .anchor .octicon-link,h2:hover .anchor .octicon-link,h3:hover .anchor .octicon-link,h4:hover .anchor .octicon-link,h5:hover .anchor .octicon-link,h6:hover .anchor .octicon-link{visibility:visible}
        h1:hover .anchor .octicon-link:before,h2:hover .anchor .octicon-link:before,h3:hover .anchor .octicon-link:before,h4:hover .anchor .octicon-link:before,h5:hover .anchor .octicon-link:before,h6:hover .anchor .octicon-link:before{width:16px;height:16px;content:" ";display:inline-block;background-image:url("data:image/svg+xml,%3Csvgxmlns='http://www.w3.org/2000/svg'viewBox='001616'version='1.1'width='16'height='16'aria-hidden='true'%3E%3Cpathfill-rule='evenodd'd='M49h1v1H4c-1.50-3-1.69-3-3.5S2.55343h4c1.45031.6933.501.41-.912.72-23.25V8.59c.58-.451-1.271-2.09C105.228.98484H4c-.980-21.22-22.5S3949zm9-3h-1v1h1c1021.2222.5S13.98121312H9c-.980-2-1.22-2-2.50-.83.42-1.641-2.09V6.25c-1.09.53-21.84-23.25C611.317.5513913h4c1.4503-1.693-3.5S14.56136z'%3E%3C/path%3E%3C/svg%3E")}
        body{-webkit-text-size-adjust:100%;line-height:1.5;color:#24292e;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji;font-size:16px;line-height:1.5;word-wrap:break-word;background-color:#e3e3ef;height:100%;width:100%;margin:0;padding:20px}
        details{display:block}
        summary{display:list-item}
        a{background-color:initial}
        a:active,a:hover{outline-width:0}
        strong{font-weight:inherit;font-weight:bolder}
        h1{font-size:2em;margin:.67em 0}
        img{border-style:none}
        code,kbd,pre{font-family:monospace,monospace;font-size:1em}
        hr{box-sizing:initial;height:0;overflow:visible}
        input{font:inherit;margin:0}
        input{overflow:visible}
        [type="checkbox"]{box-sizing:border-box;padding:0}
        *{box-sizing:border-box}
        input{font-family:inherit;font-size:inherit;line-height:inherit}
        a{color:#0366d6;text-decoration:none}
        a:hover{text-decoration:underline}
        strong{font-weight:600}
        hr{height:0;margin:15px 0;overflow:hidden;background:transparent;border:0;border-bottom:1px solid #dfe2e5}
        hr:after,hr:before{display:table;content:""}
        hr:after{clear:both}
        table{border-spacing:0;border-collapse:collapse}
        td,th{padding:0}
        details summary{cursor:pointer}
        kbd{display:inline-block;padding:3px 5px;font:11px SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;line-height:10px;color:#444d56;vertical-align:middle;background-color:#fafbfc;border:1px solid #d1d5da;border-radius:3px;box-shadow:inset 0 -1px 0 #d1d5da}
        h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:0}
        h1{font-size:32px}
        h1,h2{font-weight:600}
        h2{font-size:24px}
        h3{font-size:20px}
        h3,h4{font-weight:600}
        h4{font-size:16px}
        h5{font-size:14px}
        h5,h6{font-weight:600}
        h6{font-size:12px}
        p{margin-top:0;margin-bottom:10px}
        blockquote{margin:0}
        ol,ul{padding-left:0;margin-top:0;margin-bottom:0}
        ol ol,ul ol{list-style-type:lower-roman}
        ol ol ol,ol ul ol,ul ol ol,ul ul ol{list-style-type:lower-alpha}
        dd{margin-left:0}
        code,pre{font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:12px}
        pre{margin-top:0;margin-bottom:0}
        input::-webkit-inner-spin-button,input::-webkit-outer-spin-button{margin:0;-webkit-appearance:none;appearance:none}
        :checked+.radio-label{position:relative;z-index:1;border-color:#0366d6}
        .border{border:1px solid #e1e4e8!important}
        .border-0{border:0!important}
        .border-bottom{border-bottom:1px solid #e1e4e8!important}
        .rounded-1{border-radius:3px!important}
        .bg-white{background-color:#fff!important}
        .bg-gray-light{background-color:#fafbfc!important}
        .text-gray-light{color:#6a737d!important}
        .mb-0{margin-bottom:0!important}
        .my-2{margin-top:8px!important;margin-bottom:8px!important}
        .pl-0{padding-left:0!important}
        .py-0{padding-top:0!important;padding-bottom:0!important}
        .pl-1{padding-left:4px!important}
        .pl-2{padding-left:8px!important}
        .py-2{padding-top:8px!important;padding-bottom:8px!important}
        .pl-3,.px-3{padding-left:16px!important}
        .px-3{padding-right:16px!important}
        .pl-4{padding-left:24px!important}
        .pl-5{padding-left:32px!important}
        .pl-6{padding-left:40px!important}
        .f6{font-size:12px!important}
        .lh-condensed{line-height:1.25!important}
        .text-bold{font-weight:600!important}
        .pl-c{color:#6a737d}
        .pl-c1,.pl-s .pl-v{color:#005cc5}
        .pl-e,.pl-en{color:#6f42c1}
        .pl-s .pl-s1,.pl-smi{color:#24292e}
        .pl-ent{color:#22863a}
        .pl-k{color:#d73a49}
        .pl-pds,.pl-s,.pl-s .pl-pse .pl-s1,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre{color:#032f62}
        .pl-smw,.pl-v{color:#e36209}
        .pl-bu{color:#b31d28}
        .pl-ii{color:#fafbfc;background-color:#b31d28}
        .pl-c2{color:#fafbfc;background-color:#d73a49}
        .pl-c2:before{content:"^M"}
        .pl-sr .pl-cce{font-weight:700;color:#22863a}
        .pl-ml{color:#735c0f}
        .pl-mh,.pl-mh .pl-en,.pl-ms{font-weight:700;color:#005cc5}
        .pl-mi{font-style:italic;color:#24292e}
        .pl-mb{font-weight:700;color:#24292e}
        .pl-md{color:#b31d28;background-color:#ffeef0}
        .pl-mi1{color:#22863a;background-color:#f0fff4}
        .pl-mc{color:#e36209;background-color:#ffebda}
        .pl-mi2{color:#f6f8fa;background-color:#005cc5}
        .pl-mdr{font-weight:700;color:#6f42c1}
        .pl-ba{color:#586069}
        .pl-sg{color:#959da5}
        .pl-corl{text-decoration:underline;color:#032f62}
        .mb-0{margin-bottom:0!important}
        .my-2{margin-bottom:8px!important}
        .my-2{margin-top:8px!important}
        .pl-0{padding-left:0!important}
        .py-0{padding-top:0!important;padding-bottom:0!important}
        .pl-1{padding-left:4px!important}
        .pl-2{padding-left:8px!important}
        .py-2{padding-top:8px!important;padding-bottom:8px!important}
        .pl-3{padding-left:16px!important}
        .pl-4{padding-left:24px!important}
        .pl-5{padding-left:32px!important}
        .pl-6{padding-left:40px!important}
        .pl-7{padding-left:48px!important}
        .pl-8{padding-left:64px!important}
        .pl-9{padding-left:80px!important}
        .pl-10{padding-left:96px!important}
        .pl-11{padding-left:112px!important}
        .pl-12{padding-left:128px!important}
        hr{border-bottom-color:#eee}
        kbd{display:inline-block;padding:3px 5px;font:11px SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;line-height:10px;color:#444d56;vertical-align:middle;background-color:#fafbfc;border:1px solid #d1d5da;border-radius:3px;box-shadow:inset 0 -1px 0 #d1d5da}
        .markdown-body:after,.markdown-body:before{display:table;content:""}
        .markdown-body:after{clear:both}
        .markdown-body>:first-child{margin-top:0!important}
        .markdown-body>:last-child{margin-bottom:0!important}
        a:not([href]){color:inherit;text-decoration:none}
        blockquote,details,dl,ol,p,pre,table,ul{margin-top:0;margin-bottom:16px}
        hr{height:.25em;padding:0;margin:24px 0;background-color:#e1e4e8;border:0}
        blockquote{padding:0 1em;color:#6a737d;border-left:.25em solid #dfe2e5}
        blockquote>:first-child{margin-top:0}
        blockquote>:last-child{margin-bottom:0}
        h1,h2,h3,h4,h5,h6{margin-top:24px;margin-bottom:16px;font-weight:600;line-height:1.25}
        h1{font-size:2em}
        h1,h2{padding-bottom:.3em;border-bottom:1px solid #eaecef}
        h2{font-size:1.5em}
        h3{font-size:1.25em}
        h4{font-size:1em}
        h5{font-size:.875em}
        h6{font-size:.85em;color:#6a737d}
        ol,ul{padding-left:2em}
        ol ol,ol ul,ul ol,ul ul{margin-top:0;margin-bottom:0}
        li{word-wrap:break-all}
        li>p{margin-top:16px}
        li+li{margin-top:.25em}
        dl{padding:0}
        dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:600}
        dl dd{padding:0 16px;margin-bottom:16px}
        table{display:block;width:100%;overflow:auto}
        table th{font-weight:600}
        table td,table th{padding:6px 13px;border:1px solid #dfe2e5}
        table tr{background-color:#fff;border-top:1px solid #c6cbd1}
        table tr:nth-child(2n){background-color:#f6f8fa}
        img{max-width:100%;box-sizing:initial;background-color:#fff}
        img[align="right"]{padding-left:20px}
        img[align="left"]{padding-right:20px}
        code{padding:.2em .4em;margin:0;font-size:85%;background-color:rgba(27,31,35,0.05);border-radius:3px}
        pre{word-wrap:normal}
        pre>code{padding:0;margin:0;font-size:100%;word-break:normal;white-space:pre;background:transparent;border:0}
        .highlight{margin-bottom:16px}
        .highlight pre{margin-bottom:0;word-break:normal}
        .highlight pre,pre{padding:16px;overflow:auto;font-size:85%;line-height:1.45;background-color:#f6f8fa;border-radius:3px}
        pre code{display:inline;max-width:auto;padding:0;margin:0;overflow:visible;line-height:inherit;word-wrap:normal;background-color:initial;border:0}
        .commit-tease-sha{display:inline-block;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:90%;color:#444d56}
        .full-commit .btn-outline:not(:disabled):hover{color:#005cc5;border-color:#005cc5}
        .blob-wrapper{overflow-x:auto;overflow-y:hidden}
        .blob-wrapper-embedded{max-height:240px;overflow-y:auto}
        .blob-num{width:1%;min-width:50px;padding-right:10px;padding-left:10px;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:12px;line-height:20px;color:rgba(27,31,35,0.3);text-align:right;white-space:nowrap;vertical-align:top;cursor:pointer;user-select:none}
        .blob-num:hover{color:rgba(27,31,35,0.6)}
        .blob-num:before{content:attr(data-line-number)}
        .blob-code{position:relative;padding-right:10px;padding-left:10px;line-height:20px;vertical-align:top}
        .blob-code-inner{overflow:visible;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:12px;color:#24292e;word-wrap:normal;white-space:pre}
        .pl-token.active,.pl-token:hover{cursor:pointer;background:#ffea7f}
        .tab-size[data-tab-size="1"]{-moz-tab-size:1;tab-size:1}
        .tab-size[data-tab-size="2"]{-moz-tab-size:2;tab-size:2}
        .tab-size[data-tab-size="3"]{-moz-tab-size:3;tab-size:3}
        .tab-size[data-tab-size="4"]{-moz-tab-size:4;tab-size:4}
        .tab-size[data-tab-size="5"]{-moz-tab-size:5;tab-size:5}
        .tab-size[data-tab-size="6"]{-moz-tab-size:6;tab-size:6}
        .tab-size[data-tab-size="7"]{-moz-tab-size:7;tab-size:7}
        .tab-size[data-tab-size="8"]{-moz-tab-size:8;tab-size:8}
        .tab-size[data-tab-size="9"]{-moz-tab-size:9;tab-size:9}
        .tab-size[data-tab-size="10"]{-moz-tab-size:10;tab-size:10}
        .tab-size[data-tab-size="11"]{-moz-tab-size:11;tab-size:11}
        .tab-size[data-tab-size="12"]{-moz-tab-size:12;tab-size:12}
        .task-list-item{list-style-type:none}
        .task-list-item+.task-list-item{margin-top:3px}
        .task-list-item input{margin:0 .2em .25em -1.6em;vertical-align:middle}
        #page{width:calc(100% - 500px);margin-left:500px;overflow: hidden;}
        fieldset{display:none;background-color:#fff;border:0;overflow:hidden;box-shadow:2px 2px 10px rgba(128,128,128,0.2);margin-bottom:20px;padding:20px}
        fieldset legend{font-weight:bold;color:green;height:3.5em;margin-left:-20px;padding:0}
        #nav{background:rgb(255 255 255 / .7);padding:20px 10px 100px 20px;position:fixed;top:0;left:0;bottom:0;width:500px;overflow-y:auto;overflow-x: hidden;white-space:nowrap}
        ::-webkit-scrollbar{width:5px}
        ::-webkit-scrollbar-thumb{background-color:#79a5e8}
        @media print,(max-width:900px){
          #nav{display:none!important}
          #page{width:100%!important;margin-left:0!important}
          fieldset{padding-top: 0 !important;padding-bottom: 0 !important;display:block!important;box-shadow:none!important}
          .toggle-hash-btn {display: none !important;}
        }
        .hljs{display:block;overflow-x:auto;padding:.5em;color:#333;background:#f8f8f8}
        .hljs-comment,.hljs-quote{color:#998;font-style:italic}
        .hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:bold}
        .hljs-number,.hljs-literal,.hljs-variable,.hljs-template-variable,.hljs-tag .hljs-attr{color:#008080}
        .hljs-string,.hljs-doctag{color:#d14}
        .hljs-title,.hljs-section,.hljs-selector-id{color:#900;font-weight:bold}
        .hljs-subst{font-weight:normal}
        .hljs-type,.hljs-class .hljs-title{color:#458;font-weight:bold}
        .hljs-tag,.hljs-name,.hljs-attribute{color:#000080;font-weight:normal}
        .hljs-regexp,.hljs-link{color:#009926}
        .hljs-symbol,.hljs-bullet{color:#990073}
        .hljs-built_in,.hljs-builtin-name{color:#0086b3}
        .hljs-meta{color:#999;font-weight:bold}
        .hljs-deletion{background:#fdd}
        .hljs-addition{background:#dfd}
        .hljs-emphasis{font-style:italic}
        .hljs-strong{font-weight:bold}
        .toggle-hash-btn {position: fixed;bottom: 10px;left:10px;z-index: 1000; display: flex; justify-content: space-between;  width: 270px;}
        iframe {border: 5px solid #999;margin:10px;width: 90%;min-height: 50px;}
    </style>
    <script>
          const $ = selector => document.querySelector(selector);
          const $$ = selector => document.querySelectorAll(selector);
          const decode = s => decodeURIComponent(s);
          const domInfo = dom => ({
            offsetParent: dom.offsetParent.className,
            offsetLeft: dom.offsetLeft,
            offsetTop: dom.offsetTop,
            clientWidth: dom.clientWidth,
            offsetWidth: dom.offsetWidth,
            BoundingClientRect: dom.getBoundingClientRect(),
          });
          let openHash = false;
          function viewFieldset() {
            const hash = decode(location.hash);
            if(openHash && hash &&$(`fieldset${hash}`)) {
              Array.from($$('fieldset')).forEach(dom  =>dom.style.display = 'none');
              $(`fieldset${hash}`).style.display = 'block';
            }else {
              Array.from($$('fieldset')).forEach(dom  =>dom.style.display = 'block');
            }
          }
          window.onhashchange = viewFieldset;
          window.onload  = ()=>{
            viewFieldset();
            setATarget();
          };
          
          function toggleHash() {
            openHash = !openHash;
            viewFieldset();
            $('.toggle-hash-btn button').innerText = openHash ? '关闭专注模式' : '开启专注模式';
          }
          function setATarget() {
            $$('#page a').forEach(a=>a.target = '_blank');
          }
    </script>
</head>

<body>
  <div class="toggle-hash-btn">
    <button  onclick="toggleHash()">开启专注模式</button>
  </div><div id="page">
      <fieldset id='_oiRHn1'>
      <legend>article</legend>
      <h1 id="javascript-简介">JavaScript 简介</h1>
<p>让我们来看看 JavaScript 有什么特别之处，我们可以用它实现什么，以及哪些其他技术可以与其搭配产生奇妙的效果。</p>
<h2 id="什么是-javascript？">什么是 JavaScript？</h2>
<p><em>JavaScript</em> 最初被创建的目的是“使网页更生动”。</p>
<p>这种编程语言写出来的程序被称为 <strong>脚本</strong>。它们可以被直接写在网页的 HTML 中，在页面加载的时候自动执行。</p>
<p>脚本被以纯文本的形式提供和执行。它们不需要特殊的准备或编译即可运行。</p>
<p>这方面，JavaScript 和 <a href="https://en.wikipedia.org/wiki/Java_(programming_language)">Java</a> 有很大的区别。</p>
<pre><code class="language-smart">JavaScript 在刚诞生的时候，它的名字叫 &quot;LiveScript&quot;。但是因为当时 Java 很流行，所以决定将一种新语言定位为 Java 的“弟弟”会有助于它的流行。

随着 JavaScript 的发展，它已经成为了一门完全独立的语言，并且也拥有了自己的语言规范 [ECMAScript](http://en.wikipedia.org/wiki/ECMAScript)。现在，它和 Java 之间没有任何关系。</code></pre>
<p>如今，JavaScript 不仅可以在浏览器中执行，也可以在服务端执行，甚至可以在任意搭载了 <a href="https://en.wikipedia.org/wiki/JavaScript_engine">JavaScript 引擎</a> 的设备中执行。</p>
<p>浏览器中嵌入了 JavaScript 引擎，有时也称作“JavaScript 虚拟机”。</p>
<p>不同的引擎有不同的“代号”，例如：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/V8_(JavaScript_engine)">V8</a> —— Chrome 和 Opera 中的 JavaScript 引擎。</li>
<li><a href="https://en.wikipedia.org/wiki/SpiderMonkey">SpiderMonkey</a> —— Firefox 中的 JavaScript 引擎。</li>
<li>……还有其他一些代号，像 &quot;Chakra&quot; 用于 IE，&quot;ChakraCore&quot; 用于 Microsoft Edge，&quot;Nitro&quot; 和 &quot;SquirrelFish&quot; 用于 Safari，等等。</li>
</ul>
<p>上面这些术语很容易记住，因为它们经常出现在开发者的文章中。我们也会用到这些术语。例如，如果“V8 支持某个功能”，那么我们可以认为这个功能大概能在 Chrome 和 Opera 中正常运行。</p>
<pre><code class="language-smart">
引擎很复杂，但是基本原理很简单。

1. 引擎（如果是浏览器，则引擎被嵌入在其中）读取（“解析”）脚本。
2. 然后，引擎将脚本转化（“编译”）为机器语言。
3. 然后，机器代码快速地执行。

引擎会对流程中的每个阶段都进行优化。它甚至可以在编译的脚本运行时监视它，分析流经该脚本的数据，并根据获得的信息进一步优化机器代码。</code></pre>
<h2 id="浏览器中的-javascript-能做什么？">浏览器中的 JavaScript 能做什么？</h2>
<p>现代的 JavaScript 是一种“安全的”编程语言。它不提供对内存或 CPU 的底层访问，因为它最初是为浏览器创建的，不需要这些功能。</p>
<p>JavaScript 的能力很大程度上取决于它运行的环境。例如，<a href="https://wikipedia.org/wiki/Node.js">Node.js</a> 支持允许 JavaScript 读取/写入任意文件，执行网络请求等的函数。</p>
<p>浏览器中的 JavaScript 可以做与网页操作、用户交互和 Web 服务器相关的所有事情。</p>
<p>例如，浏览器中的 JavaScript 可以做下面这些事：</p>
<ul>
<li>在网页中添加新的 HTML，修改网页已有内容和网页的样式。</li>
<li>响应用户的行为，响应鼠标的点击，指针的移动，按键的按动。</li>
<li>向远程服务器发送网络请求，下载和上传文件（所谓的 <a href="https://en.wikipedia.org/wiki/Ajax_(programming)">AJAX</a> 和 <a href="https://en.wikipedia.org/wiki/Comet_(programming)">COMET</a> 技术）。</li>
<li>获取或设置 cookie，向访问者提出问题或发送消息。</li>
<li>记住客户端的数据（“本地存储”）。</li>
</ul>
<h2 id="浏览器中的-javascript-不能做什么？">浏览器中的 JavaScript 不能做什么？</h2>
<p>为了用户的（信息）安全，在浏览器中的 JavaScript 的能力是受限的。目的是防止恶意网页获取用户私人信息或损害用户数据。</p>
<p>此类限制的例子包括：</p>
<ul>
<li><p>网页中的 JavaScript 不能读、写、复制和执行硬盘上的任意文件。它没有直接访问操作系统的功能。</p>
<p>现代浏览器允许 JavaScript 做一些文件相关的操作，但是这个操作是受到限制的。仅当用户做出特定的行为，JavaScript 才能操作这个文件。例如，用户把文件“拖放”到浏览器中，或者通过 <code>&lt;input&gt;</code> 标签选择了文件。</p>
<p>有很多与相机/麦克风和其它设备进行交互的方式，但是这些都需要获得用户的明确许可。因此，启用了 JavaScript 的网页应该不会偷偷地启动网络摄像头观察你，并把你的信息发送到 <a href="https://en.wikipedia.org/wiki/National_Security_Agency">美国国家安全局</a>。</p>
</li>
<li><p>不同的标签页/窗口之间通常互不了解。有时候，也会有一些联系。例如，一个标签页通过 JavaScript 打开另外一个标签页。但即使在这种情况下，如果两个标签页打开的不是同一个网站（域名、协议或者端口任一不相同的网站），它们都不能相互通信。</p>
<p>这就是所谓的“同源策略”。为了解决“同源策略”问题，两个标签页必须 <strong>都</strong> 包含一些处理这个问题的特定的 JavaScript 代码，并均允许数据交换。本教程会讲到这部分相关的知识。</p>
<p>这个限制也是为了用户的信息安全。例如，用户打开的 <code>http://anysite.com</code> 网页必须不能访问 <code>http://gmail.com</code>（另外一个标签页打开的网页）也不能从那里窃取信息。</p>
</li>
<li><p>JavaScript 可以轻松地通过互联网与当前页面所在的服务器进行通信。但是从其他网站/域的服务器中接收数据的能力被削弱了。尽管可以，但是需要来自远程服务器的明确协议（在 HTTP header 中）。这也是为了用户的信息安全。</p>
</li>
</ul>
<p><img src="limitations.svg" alt=""></p>
<p>如果在浏览器环境外（例如在服务器上）使用 JavaScript，则不存在此类限制。现代浏览器还允许安装可能会要求扩展权限的插件/扩展。</p>
<h2 id="是什么使得-javascript-与众不同？">是什么使得 JavaScript 与众不同？</h2>
<p>至少有 <strong>3</strong> 件事值得一提：</p>
<pre><code class="language-compare">+ 与 HTML/CSS 完全集成。
+ 简单的事，简单地完成。
+ 被所有的主流浏览器支持，并且默认开启。</code></pre>
<p>JavaScript 是将这三件事结合在一起的唯一的浏览器技术。</p>
<p>这就是为什么 JavaScript 与众不同。这也是为什么它是用于创建浏览器界面的使用最广泛的工具。</p>
<p>此外，JavaScript 还可用于创建服务器和移动端应用程序等。</p>
<h2 id="javascript-上层语言">JavaScript “上层”语言</h2>
<p>不同的人想要不同的功能。JavaScript 的语法也不能满足所有人的需求。</p>
<p>这是正常的，因为每个人的项目和需求都不一样。</p>
<p>因此，最近出现了许多新语言，这些语言在浏览器中执行之前，都会被 <strong>编译</strong>（转化）成 JavaScript。</p>
<p>现代化的工具使得编译速度非常快且透明，实际上允许开发者使用另一种语言编写代码并会将其“自动转换”为 JavaScript。</p>
<p>此类语言的示例有：</p>
<ul>
<li><a href="http://coffeescript.org/">CoffeeScript</a> 是 JavaScript 的一种语法糖。它引入了更加简短的语法，使我们可以编写更清晰简洁的代码。通常，Ruby 开发者喜欢它。</li>
<li><a href="http://www.typescriptlang.org/">TypeScript</a> 专注于添加“严格的数据类型”以简化开发，以更好地支持复杂系统的开发。由微软开发。</li>
<li><a href="http://flow.org/">Flow</a> 也添加了数据类型，但是以一种不同的方式。由 Facebook 开发。</li>
<li><a href="https://www.dartlang.org/">Dart</a> 是一门独立的语言。它拥有自己的引擎，该引擎可以在非浏览器环境中运行（例如手机应用），它也可以被编译成 JavaScript。由 Google 开发。</li>
<li><a href="https://brython.info/">Brython</a> 是一个 Python 的 JavaScript 编译器，可以在不使用 JavaScript 的情况下，以纯 Python 编写应用程序。</li>
</ul>
<p>这样的语言还有很多。当然，即使我们在使用此类编译语言，我们也需要了解 JavaScript。因为了解 JavaScript 才能让我们真正明白我们在做什么。</p>
<h2 id="总结">总结</h2>
<ul>
<li>JavaScript 最开始是专门为浏览器设计的一门语言，但是现在也被用于很多其他的环境。</li>
<li>如今，JavaScript 已经成为了与 HTML/CSS 完全集成的，使用最广泛的浏览器语言。</li>
<li>有很多其他的语言可以被“编译”成 JavaScript，这些语言还提供了更多的功能。建议最好了解一下这些语言，至少在掌握了 JavaScript 之后大致的了解一下。</li>
</ul>

      </fieldset>
      
      <fieldset id='_Yn0r2M'>
      <legend>article</legend>
      <h1 id="手册与规范">手册与规范</h1>
<p>这本书是一个 <strong>教程</strong>。它旨在帮助你由浅入深掌握 JavaScript 这门语言。但是，当你已经熟悉了这门语言的基础知识，你就会需要其他资料。</p>
<h2 id="规范">规范</h2>
<p><strong>ECMA-262 规范</strong> 包含了大部分深入的、详细的、规范化的关于 JavaScript 的信息。这份规范明确地定义了这门语言。</p>
<p>但正因其规范化，对于新手来说难以理解。所以，如果你需要关于这门语言细节最权威的信息来源，这份规范就很适合你（去阅读）。但它并不适合日常使用。</p>
<p>每年都会发布一个新版本的规范。最新的规范草案请见 <a href="https://tc39.es/ecma262/">https://tc39.es/ecma262/</a>。</p>
<p>想了解最新最前沿的功能，包括“即将纳入规范的”（所谓的 &quot;stage 3&quot;），请看这里的提案 <a href="https://github.com/tc39/proposals">https://github.com/tc39/proposals</a>。</p>
<p>当然，如果你正在做浏览器相关的开发工作，那么本教程的 <a href="info:browser-environment">第二部分</a> 涵盖了其他规范。</p>
<h2 id="手册">手册</h2>
<ul>
<li><p><strong>MDN（Mozilla）JavaScript 索引</strong> 是一个带有用例和其他信息的手册。它是一个获取关于个别语言函数、方法等深入信息的很好的来源。</p>
<p>  你可以在 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference</a> 阅读它。</p>
<p>  虽然，利用互联网搜索通常是最好的选择。只需在查询时输入“MDN [关键字]”，例如 <a href="https://google.com/search?q=MDN+parseInt">https://google.com/search?q=MDN+parseInt</a> 搜索 <code>parseInt</code> 函数。</p>
</li>
</ul>
<ul>
<li><p><strong>MSDN</strong> —— 一本微软的手册，它包含大量的信息，包括 JavaScript（在里面经常被写成 JScript）。如果有人需要关于 Internet Explorer 的规范细节，最好去看：<a href="http://msdn.microsoft.com/">http://msdn.microsoft.com/</a>。</p>
<p>  当然，我们还可以在使用互联网搜索中使用如 &quot;RegExp MSDN&quot; 或 &quot;RegExp MSDN jscript&quot; 这样的词条。</p>
</li>
</ul>
<h2 id="兼容性表">兼容性表</h2>
<p>JavaScript 是一门还在发展中的语言，定期会添加一些新的功能。</p>
<p>要查看它们在基于浏览器的引擎及其他引擎中的支持情况，请看：</p>
<ul>
<li><a href="http://caniuse.com">http://caniuse.com</a> —— 每个功能的支持表，例如，查看哪个引擎支持现代加密（cryptography）函数：<a href="http://caniuse.com/#feat=cryptography">http://caniuse.com/#feat=cryptography</a>。</li>
<li><a href="https://kangax.github.io/compat-table">https://kangax.github.io/compat-table</a> —— 一份列有语言功能以及引擎是否支持这些功能的表格。</li>
</ul>
<p>所有这些资源在实际开发中都有用武之地，因为它们包含了有关语言细节，以及它们被支持的程度等非常有价值的信息。</p>
<p>为了让你在真正需要深入了解特定功能的时候不会捉襟见肘，请记住它们（或者这一页）。</p>

      </fieldset>
      
      <fieldset id='_yBIy7W'>
      <legend>article</legend>
      <h1 id="代码编辑器">代码编辑器</h1>
<p>程序员接触时间最长的就是代码编辑器。</p>
<p>代码编辑器主要分两种：IDE（集成开发环境）和轻量编辑器。很多人喜欢这两种各选一个。</p>
<h2 id="ide">IDE</h2>
<p><a href="https://en.wikipedia.org/wiki/Integrated_development_environment">IDE</a>（集成开发环境）是指用于管理整个项目的，具有强大功能的编辑器。顾名思义，它不仅仅是一个编辑器，而且还是个完整的“开发环境”。</p>
<p>IDE 加载项目（通常包含很多文件），并且允许在不同文件之间导航（navigation）。IDE 还提供基于整个项目（不仅仅是打开的文件）的自动补全功能，集成版本控制（如 <a href="https://git-scm.com/">git</a>）、集成测试环境等一些其他“项目层面”的东西。</p>
<p>如果你还没考虑好选哪一款 IDE，可以考虑下面两个：</p>
<ul>
<li><a href="https://code.visualstudio.com/">Visual Studio Code</a>（跨平台，免费）。</li>
<li><a href="http://www.jetbrains.com/webstorm/">WebStorm</a>（跨平台，收费）。</li>
</ul>
<p>对于 Windows 系统来说，也有个叫 &quot;Visual Studio&quot; 的 IDE，请不要跟 &quot;Visual Studio Code&quot; 混淆。&quot;Visual Studio&quot; 是一个收费的、强大的 Windows 专用编辑器，它十分适合于 .NET 开发。用它进行 JavaScript 开发也不错。&quot;Visual Studio&quot; 有个免费的版本 <a href="https://www.visualstudio.com/vs/community/">Visual Studio Community</a>。</p>
<p>很多 IDE 是收费的，但是它们都可以试用。购买 IDE 的费用对于一名合格的程序员的薪水来说，肯定算不了什么，所以去选一个对你来说最好的吧。</p>
<h2 id="轻量编辑器">轻量编辑器</h2>
<p>“轻量编辑器”没有 IDE 功能那么强大，但是它们一般很快、优雅而且简单。</p>
<p>“轻量编辑器”主要用于快速打开和编辑文件。</p>
<p>“轻量编辑器”和 &quot;IDE&quot; 最大的区别是，IDE 一般在项目中使用，这也就意味着在开启的时候要加载很多数据，如果需要的话还会分析项目的结构等。如果我们只需要编辑一个文件，那么“轻量编辑器”会更快。</p>
<p>实际上，“轻量编辑器”一般都有各种各样的插件，这些插件可以做目录级（directory-level）的语法分析和代码补全。所以“轻量编辑器”和 IDE 也没有严格的界限。</p>
<p>下面是一些值得你关注的“轻量编辑器”：</p>
<ul>
<li><a href="https://atom.io/">Atom</a>（跨平台，免费）。</li>
<li><a href="https://code.visualstudio.com/">Visual Studio Code</a>（跨平台，免费）。</li>
<li><a href="http://www.sublimetext.com">Sublime Text</a>（跨平台，共享软件）。</li>
<li><a href="https://notepad-plus-plus.org/">Notepad++</a>（Windows，免费）。</li>
<li><a href="http://www.vim.org/">Vim</a> 和 <a href="https://www.gnu.org/software/emacs/">Emacs</a> 也很棒，如果你知道怎么使用它们的话。</li>
</ul>
<h2 id="不要争吵">不要争吵</h2>
<p>上面列表中的编辑器都是我和我的朋友（他们都是我认为很优秀的开发者）已经使用了很长时间并且很满意的。</p>
<p>当然还有很多其他很好的编辑器，你可以选择一个你最喜欢的。</p>
<p>选择编辑器就像选择其他工具一样，是很个人化的。具体取决于你的项目，习惯以及个人喜好。</p>

      </fieldset>
      
      <fieldset id='_pHVq7J'>
      <legend>article</legend>
      <h1 id="开发者控制台">开发者控制台</h1>
<p>代码是很容易出现错误的。你也很可能犯错误……哦，我在说什么？只要你是人，你 <strong>一定</strong> 会犯错误（在写代码的时候），除非你是 <a href="https://en.wikipedia.org/wiki/Bender_(Futurama)">机器人</a>。</p>
<p>但在浏览器中，默认情况下用户是看不到错误的。所以，如果脚本中有错误，我们看不到是什么错误，更不能够修复它。</p>
<p>为了发现错误并获得一些与脚本相关且有用的信息，浏览器内置了“开发者工具”。</p>
<p>通常，开发者倾向于使用 Chrome 或 Firefox 进行开发，因为它们有最好的开发者工具。一些其它的浏览器也提供开发者工具，有时还具有一些特殊的功能，通常它们都是在“追赶” Chrome 或 Firefox。所以大多数人都有“最喜欢”的浏览器，当遇到某个浏览器独有的问题的时候，人们就会切换到其它的浏览器。</p>
<p>开发者工具很强大，功能丰富。首先，我们将学习如何打开它们，查找错误和运行 JavaScript 命令。</p>
<h2 id="google-chrome">Google Chrome</h2>
<p>打开网页 <a href="bug.html">bug.html</a>。</p>
<p>在这个页面的 JavaScript 代码中有一个错误。一般的访问者看不到这个错误，所以让我们打开开发者工具看看吧。</p>
<p>按下 <code>key:F12</code> 键，如果你使用 Mac，试试 <code>key:Cmd+Opt+J</code>。</p>
<p>默认情况下，开发者工具会被在 Console 标签页中打开。</p>
<p>就像这样：</p>
<p><img src="chrome.png" alt="chrome"></p>
<p>具体什么样，要看你的 Chrome 版本。它随着时间一直在变，但是都很类似。</p>
<ul>
<li>在这我们能看到红色的错误提示信息。这个场景中，脚本里有一个未知的 &quot;lalala&quot; 命令。</li>
<li>在右边，有个可点击的链接 <code>bug.html:12</code>。这个链接会链接到错误发生的行号。</li>
</ul>
<p>在错误信息的下方，有个 <code>&gt;</code> 标志。它代表“命令行”，在“命令行”中，我们可以输入 JavaScript 命令，按下 <code>key:Enter</code> 来执行。</p>
<p>现在，我们能看到错误就够了。稍后，在 <a href="info:debugging-chrome">info:debugging-chrome</a> 一节中，我们会重新更加深入地学习开发者工具。</p>
<pre><code class="language-smart">通常，当我们向控制台输入一行代码后，按 `key:Enter`，这行代码就会立即执行。

如果想要插入多行代码，请按 `key:Shift+Enter` 来进行换行。这样就可以输入长片段的 JavaScript 代码了。</code></pre>
<h2 id="firefox、edge-和其它浏览器">Firefox、Edge 和其它浏览器</h2>
<p>大多数其它的浏览器都是通过 <code>key:F12</code> 来打开开发者工具。</p>
<p>它们的外观和感觉都非常相似，一旦你学会了它们中的一个（可以先尝试 Chrome），其它的也就很快就可以熟悉了。</p>
<h2 id="safari">Safari</h2>
<p>Safari（Mac 系统中的浏览器，Windows 和 Linux 系统不支持）有一点点不同。我们需要先开启“开发菜单”。</p>
<p>打开“偏好设置”，选择“高级”选项。选中最下方的那个选择框：</p>
<p><img src="safari.png" alt="safari"></p>
<p>现在，我们通过 <code>key:Cmd+Opt+C</code> 就能打开或关闭控制台了。另外注意，有一个名字为“开发”的顶部菜单出现了。它有很多命令和选项。</p>
<h2 id="总结">总结</h2>
<ul>
<li>开发者工具允许我们查看错误、执行命令、检查变量等。</li>
<li>在 Windows 系统中，可以通过 <code>key:F12</code> 开启开发者工具。Mac 系统下，Chrome 需要使用 <code>key:Cmd+Opt+J</code>，Safari 使用 <code>key:Cmd+Opt+C</code>（需要提前开启）。</li>
</ul>
<p>现在我们的环境准备好了。下一章，我们将正式开始学习 JavaScript。</p>

      </fieldset>
      
      <fieldset id='_4XHcUl'>
      <legend>solution</legend>
      <p>[html src=&quot;index.html&quot;]</p>

      </fieldset>
      
      <fieldset id='_CmLl2P'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="显示一个提示语">显示一个提示语</h1>
<p>创建一个页面，然后显示一个消息 “I&#39;m JavaScript!”。</p>
<p>在沙箱中或者在你的硬盘上做这件事都无所谓，只要确保它能运行起来。</p>
<p>[demo src=&quot;solution&quot;]</p>

      </fieldset>
      
      <fieldset id='_8cqsrc'>
      <legend>solution</legend>
      <p>HTML 代码:</p>
<p>[html src=&quot;index.html&quot;]</p>
<p>同一个文件夹中的 <code>alert.js</code> 文件：</p>
<p>[js src=&quot;alert.js&quot;]</p>

      </fieldset>
      
      <fieldset id='_FrQqkA'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="使用外部的脚本显示一个提示语">使用外部的脚本显示一个提示语</h1>
<p>打开前一个任务 <a href="info:task/hello-alert">info:task/hello-alert</a> 的答案。将脚本的内容提取到一个外部的 <code>alert.js</code> 文件中，放置在相同的文件夹中。</p>
<p>打开页面，确保它能够工作。</p>

      </fieldset>
      
      <fieldset id='_Ejegqu'>
      <legend>article</legend>
      <h1 id="hello-world">Hello, world!</h1>
<p>本教程的这一部分内容是关于 JavaScript 语言本身的。</p>
<p>但是，我们需要一个工作环境来运行我们的脚本，由于本教程是在线的，所以浏览器是一个不错的选择。我们会尽可能少地使用浏览器特定的命令（比如 <code>alert</code>），所以如果你打算专注于另一个环境（比如 Node.js），你就不必多花时间来关心这些特定指令了。我们将在本教程的 <a href="/ui">下一部分</a> 中专注于浏览器中的 JavaScript。</p>
<p>首先，让我们看看如何将脚本添加到网页上。对于服务器端环境（如 Node.js），你只需要使用诸如 <code>&quot;node my.js&quot;</code> 的命令行来执行它。</p>
<h2 id="script-标签">“script” 标签</h2>
<p>JavaScript 程序可以在 <code>&lt;script&gt;</code> 标签的帮助下插入到 HTML 文档的任何地方。</p>
<p>比如：</p>
<pre><code class="language-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">HTML</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>script 标签之前...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

*!*
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    alert(<span class="hljs-string">&#x27;Hello, world!&#x27;</span>);
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
*/!*

  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>...script 标签之后<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<pre><code class="language-online">你可以通过点击右上角的“播放”按钮来运行这个例子。</code></pre>
<p><code>&lt;script&gt;</code> 标签中包裹了 JavaScript 代码，当浏览器遇到 <code>&lt;script&gt;</code> 标签，代码会自动运行。</p>
<h2 id="现代的标记（markup）">现代的标记（markup）</h2>
<p><code>&lt;script&gt;</code> 标签有一些现在很少用到的特性（attribute），但是我们可以在老代码中找到它们：</p>
<p><code>type</code> 特性：<code>&lt;script <u>type</u>=...&gt;</code>
: 在老的 HTML4 标准中，要求 script 标签有 <code>type</code> 特性。通常是 <code>type=&quot;text/javascript&quot;</code>。这样的特性声明现在已经不再需要。而且，现代 HTML 标准已经完全改变了此特性的含义。现在，它可以用于 JavaScript 模块。但这是一个高级话题，我们将在本教程的另一部分中探讨 JavaScript 模块。</p>
<p><code>language</code> 特性：<code>&lt;script <u>language</u>=...&gt;</code>
: 这个特性是为了显示脚本使用的语言。这个特性现在已经没有任何意义，因为语言默认就是 JavaScript。不再需要使用它了。</p>
<p>脚本前后的注释。
: 在非常古老的书籍和指南中，你可能会在 <code>&lt;script&gt;</code> 标签里面找到注释，就像这样：</p>
<pre><code>```html no-beautify
&lt;script type=&quot;text/javascript&quot;&gt;&lt;!--
    ...
//--&gt;&lt;/script&gt;
```

现代 JavaScript 中已经不这样使用了。这些注释是用于不支持 `&lt;script&gt;` 标签的古老的浏览器隐藏 JavaScript 代码的。由于最近 15 年内发布的浏览器都没有这样的问题，因此这种注释能帮你辨认出一些老掉牙的代码。</code></pre>
<h2 id="外部脚本">外部脚本</h2>
<p>如果你有大量的 JavaScript 代码，我们可以将它放入一个单独的文件。</p>
<p>脚本文件可以通过 <code>src</code> 特性（attribute）添加到 HTML 文件中。</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/path/to/script.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>这里，<code>/path/to/script.js</code> 是脚本文件从网站根目录开始的绝对路径。当然也可以提供当前页面的相对路径。例如，<code>src =&quot;script.js&quot;</code> 表示当前文件夹中的 <code>&quot;script.js&quot;</code> 文件。</p>
<p>我们也可以提供一个完整的 URL 地址，例如：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>要附加多个脚本，请使用多个标签：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/js/script1.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/js/script2.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
…</code></pre>
<pre><code class="language-smart">一般来说，只有最简单的脚本才嵌入到 HTML 中。更复杂的脚本存放在单独的文件中。

使用独立文件的好处是浏览器会下载它，然后将它保存到浏览器的 [缓存](https://en.wikipedia.org/wiki/Web_cache) 中。

之后，其他页面想要相同的脚本就会从缓存中获取，而不是下载它。所以文件实际上只会下载一次。

这可以节省流量，并使得页面（加载）更快。</code></pre>
<p>````warn header=&quot;如果设置了 <code>src</code> 特性，<code>script</code> 标签内容将会被忽略。&quot;
一个单独的 <code>&lt;script&gt;</code> 标签不能同时有 <code>src</code> 特性和内部包裹的代码。</p>
<p>这将不会工作：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> *!*<span class="hljs-attr">src</span>*/!*=<span class="hljs-string">&quot;file.js&quot;</span>&gt;</span><span class="javascript">
  alert(<span class="hljs-number">1</span>); <span class="hljs-comment">// 此内容会被忽略，因为设定了 src</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>我们必须进行选择，要么使用外部的 <code>&lt;script src=&quot;…&quot;&gt;</code>，要么使用正常包裹代码的 <code>&lt;script&gt;</code>。</p>
<p>为了让上面的例子工作，我们可以将它分成两个 <code>&lt;script&gt;</code> 标签。</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;file.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
  alert(1);
<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<pre><code>
## 总结

- 我们可以使用一个 `&lt;script&gt;` 标签将 JavaScript 代码添加到页面中。
- `type` 和 `language` 特性（attribute）不是必需的。
- 外部的脚本可以通过 `&lt;script src=&quot;path/to/script.js&quot;&gt;&lt;/script&gt;` 的方式插入。


有关浏览器脚本以及它们和网页的关系，还有很多可学的。但是请记住，教程的这部分主要是针对 JavaScript 语言本身的，所以我们不该被浏览器特定的实现分散自己的注意力。我们将使用浏览器作为运行 JavaScript 的一种方式，这种方式非常便于我们在线阅读，但这只是很多种方式中的一种。</code></pre>

      </fieldset>
      
      <fieldset id='_50X1Ao'>
      <legend>article</legend>
      <h1 id="代码结构">代码结构</h1>
<p>我们将要学习的第一个内容就是构建代码块。</p>
<h2 id="语句">语句</h2>
<p>语句是执行行为（action）的语法结构和命令。</p>
<p>我们已经见过了 <code>alert(&#39;Hello, world!&#39;)</code> 这样可以用来显示消息的语句。</p>
<p>我们可以在代码中编写任意数量的语句。语句之间可以使用分号进行分割。</p>
<p>例如，我们将 &quot;Hello World&quot; 这条信息一分为二：</p>
<pre><code class="language-js">alert(<span class="hljs-string">&#x27;Hello&#x27;</span>); alert(<span class="hljs-string">&#x27;World&#x27;</span>);</code></pre>
<p>通常，每条语句独占一行，以提高代码的可读性：</p>
<pre><code class="language-js">alert(<span class="hljs-string">&#x27;Hello&#x27;</span>);
alert(<span class="hljs-string">&#x27;World&#x27;</span>);</code></pre>
<h2 id="分号-semicolon">分号 [#semicolon]</h2>
<p>当存在分行符（line break）时，在大多数情况下可以省略分号。</p>
<p>下面的代码也是可以运行的：</p>
<pre><code class="language-js">alert(<span class="hljs-string">&#x27;Hello&#x27;</span>)
alert(<span class="hljs-string">&#x27;World&#x27;</span>)</code></pre>
<p>在这，JavaScript 将分行符理解成“隐式”的分号。这也被称为 <a href="https://tc39.github.io/ecma262/#sec-automatic-semicolon-insertion">自动分号插入</a>。</p>
<p><strong>在大多数情况下，换行意味着一个分号。但是“大多数情况”并不意味着“总是”！</strong></p>
<p>有很多换行并不是分号的例子，例如：</p>
<pre><code class="language-js">alert(<span class="hljs-number">3</span> +
<span class="hljs-number">1</span>
+ <span class="hljs-number">2</span>);</code></pre>
<p>代码输出 <code>6</code>，因为 JavaScript 并没有在这里插入分号。显而易见的是，如果一行以加号 <code>&quot;+&quot;</code> 结尾，那么这是一个“不完整的表达式”，不需要分号。所以，这个例子得到了预期的结果。</p>
<p><strong>但存在 JavaScript 无法确定是否真的需要自动插入分号的情况。</strong></p>
<p>这种情况下发生的错误是很难被找到和解决的。</p>
<pre><code class="language-smart">如果你好奇地想知道一个这种错误的具体例子，那你可以看看下面这段代码：

```js run
[1, 2].forEach(alert)
```

你不需要考虑方括号 `[]` 和 `forEach` 的含义，现在它们并不重要，之后我们会学习它们。让我们先记住这段代码的运行结果：先显示 `1`，然后显示 `2`。

现在我们在代码前面插入一个 `alert` 语句，并且不加分号：

```js run no-beautify
alert(&quot;There will be an error&quot;)

[1, 2].forEach(alert)
```

现在，如果我们运行代码，只有第一个 `alert` 语句的内容被显示了出来，随后我们收到了一个错误！

但是，如果我们在第一个 `alert` 语句末尾加上一个分号，就工作正常了：
```js run
alert(&quot;All fine now&quot;);

[1, 2].forEach(alert)
```

现在，我们能得到 &quot;All fine now&quot;，然后是 `1` 和 `2`。

无分号的变体（variant）会出现报错，是因为 JavaScript 并不会在方括号 `[...]` 前添加一个隐式的分号。

所以，因为没有自动插入分号，第一个例子中的代码被视为了一条简单的语句，我们从引擎看到的是这样的：

```js run no-beautify
alert(&quot;There will be an error&quot;)[1, 2].forEach(alert)
```

但它应该是两条语句，而不是一条。这种情况下的合并是不对的，所以才会造成错误。诸如此类，还有很多。</code></pre>
<p>即使语句被换行符分隔了，我们依然建议在它们之间加分号。这个规则被社区广泛采用。我们再次强调一下 —— 大部分时候可以省略分号，但是最好不要省略分号，尤其对新手来说。</p>
<h2 id="注释-code-comments">注释 [#code-comments]</h2>
<p>随着时间推移，程序变得越来越复杂。为代码添加 <strong>注释</strong> 来描述它做了什么和为什么要这样做，变得非常有必要了。</p>
<p>你可以在脚本的任何地方添加注释，它们并不会影响代码的执行，因为引擎会直接忽略它们。</p>
<p><strong>单行注释以两个正斜杠字符 <code>//</code> 开始。</strong></p>
<p>这一行的剩余部分是注释。它可能独占一行或者跟随在一条语句的后面。</p>
<p>就像这样：</p>
<pre><code class="language-js"><span class="hljs-comment">// 这行注释独占一行</span>
alert(<span class="hljs-string">&#x27;Hello&#x27;</span>);

alert(<span class="hljs-string">&#x27;World&#x27;</span>); <span class="hljs-comment">// 这行注释跟随在语句后面</span></code></pre>
<p><strong>多行注释以一个正斜杠和星号开始 <code>"/&#42;"</code> 并以一个星号和正斜杆结束 <code>"&#42;/"</code>。</strong></p>
<p>就像这样:</p>
<pre><code class="language-js"><span class="hljs-comment">/* 两个消息的例子。
这是一个多行注释。
*/</span>
alert(<span class="hljs-string">&#x27;Hello&#x27;</span>);
alert(<span class="hljs-string">&#x27;World&#x27;</span>);</code></pre>
<p>注释的内容被忽略了，所以如果我们在 <code>/&#42; ... &#42;/</code> 中放入代码，并不会执行。</p>
<p>有时候，可以很方便地临时禁用代码：</p>
<pre><code class="language-js"><span class="hljs-comment">/* 注释代码
alert(&#x27;Hello&#x27;);
*/</span>
alert(<span class="hljs-string">&#x27;World&#x27;</span>);</code></pre>
<pre><code class="language-smart">在大多数的编辑器中，一行代码可以使用 `key:Ctrl+/` 热键进行单行注释，诸如 `key:Ctrl+Shift+/` 的热键可以进行多行注释（选择代码，然后按下热键）。对于 Mac 电脑，应使用 `key:Cmd` 而不是 `key:Ctrl`，使用 `key:Option` 而不是 `key:Shift`。</code></pre>
<pre><code class="language-warn">不要在 `/*...*/` 内嵌套另一个 `/*...*/`。

下面这段代码报错而无法执行：

```js run no-beautify
/*
  /* 嵌套注释 ?!? */
*/
alert( &#x27;World&#x27; );
```</code></pre>
<p>对你的代码进行注释，这还有什么可犹豫的！</p>
<p>注释会增加代码总量，但这一点也不是什么问题。有很多工具可以帮你在把代码部署到服务器之前缩减代码。这些工具会移除注释，这样注释就不会出现在发布的脚本中。所以，注释对我们的生产没有任何负面影响。</p>
<p>在后面的教程中，会有一章 <a href="info:code-quality">info:code-quality</a> 的内容解释如何更好地写注释。</p>

      </fieldset>
      
      <fieldset id='_ilpsYV'>
      <legend>article</legend>
      <h1 id="现代模式，use-strict">现代模式，&quot;use strict&quot;</h1>
<p>长久以来，JavaScript 不断向前发展且并未带来任何兼容性问题。新的特性被加入，旧的功能也没有改变。</p>
<p>这么做有利于兼容旧代码，但缺点是 JavaScript 创造者的任何错误或不完善的决定也将永远被保留在 JavaScript 语言中。</p>
<p>这种情况一直持续到 2009 年 ECMAScript 5 (ES5) 的出现。ES5 规范增加了新的语言特性并且修改了一些已经存在的特性。为了保证旧的功能能够使用，大部分的修改是默认不生效的。你需要一个特殊的指令 —— <code>&quot;use strict&quot;</code> 来明确地激活这些特性。</p>
<h2 id="use-strict">&quot;use strict&quot;</h2>
<p>这个指令看上去像一个字符串 <code>&quot;use strict&quot;</code> 或者 <code>&#39;use strict&#39;</code>。当它处于脚本文件的顶部时，则整个脚本文件都将以“现代”模式进行工作。</p>
<p>比如：</p>
<pre><code class="language-js"><span class="hljs-meta">&quot;use strict&quot;</span>;

<span class="hljs-comment">// 代码以现代模式工作</span>
...</code></pre>
<p>很快我们就会学习到函数（一种组合命令的方式），所以让我们提前注意一下，<code>&quot;use strict&quot;</code> 可以被放在函数体的开头。这样则可以只在该函数中启用严格模式。但通常人们会在整个脚本中启用严格模式。</p>
<pre><code class="language-warn">请确保 `&quot;use strict&quot;` 出现在脚本的最顶部，否则严格模式可能无法启用。

这里的严格模式就没有被启用：

```js no-strict
alert(&quot;some code&quot;);
// 下面的 &quot;use strict&quot; 会被忽略，必须在最顶部。

&quot;use strict&quot;;

// 严格模式没有被激活
```

只有注释可以出现在 `&quot;use strict&quot;` 的上面。</code></pre>
<p>```warn header=&quot;没有办法取消 <code>use strict</code>&quot;
没有类似于 <code>&quot;no use strict&quot;</code> 这样的指令可以使程序返回默认模式。</p>
<p>一旦进入了严格模式，就没有回头路了。</p>
<pre><code>
## 浏览器控制台

当你使用 [开发者控制台](info:devtools) 运行代码时，请注意它默认是不启动 `use strict` 的。

有时，当 `use strict` 会对代码产生一些影响时，你会得到错误的结果。

那么，怎么在控制台中启用 `use strict` 呢？

首先，你可以尝试搭配使用 `key:Shift+Enter` 按键去输入多行代码，然后将 `use strict` 放在代码最顶部，就像这样：

```js
&#x27;use strict&#x27;; &lt;Shift+Enter 换行&gt;
//  ...你的代码
&lt;按下 Enter 以运行&gt;</code></pre>
<p>它在大部分浏览器中都有效，像 Firefox 和 Chrome。</p>
<p>如果依然不行，例如你使用的是旧版本的浏览器，那么有一种很丑但可靠的启用 <code>use strict</code> 的方法。将你的代码放在这样的包装器中：</p>
<pre><code class="language-js">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">  &#x27;use strict&#x27;</span>;

  <span class="hljs-comment">// ...你的代码...</span>
})()</code></pre>
<h2 id="我们应该使用-use-strict-吗？">我们应该使用 &quot;use strict&quot; 吗？</h2>
<p>这个问题的答案好像很显而易见，但事实并非如此。</p>
<p>有人可能会建议在脚本的最顶部放置 <code>&quot;use strict&quot;</code> 这行代码…… 但你知道更酷的方式吗？</p>
<p>现代 JavaScript 支持 &quot;classes&quot; 和 &quot;modules&quot; —— 高级语言结构（本教程后续章节会讲到），它们会自动启用 <code>use strict</code>。因此，如果我们使用它们，则无需添加 <code>&quot;use strict&quot;</code> 指令。</p>
<p><strong>因此，目前我们欢迎将 <code>&quot;use strict&quot;;</code> 写在脚本的顶部。稍后，当你的代码全都写在了 class 和 module 中时，你则可以将 <code>&quot;use strict&quot;;</code> 这行代码省略掉。</strong></p>
<p>目前，我们已经基本了解了 <code>use strict</code>。</p>
<p>在接下来的章节中，当我们学习语言功能时，我们会看到严格模式与旧的模式之间的差异。幸运的是，差异其实没有那么多。并且，这些差异实际上提升了我们的编程体验。</p>
<p>本教程的所有例子都默认采用严格模式，除非特别指定（非常少）。</p>

      </fieldset>
      
      <fieldset id='_w6kC9c'>
      <legend>solution</legend>
      <p>下面的代码，每一行都对应着任务列表中的对应项。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> admin, name; <span class="hljs-comment">// 一次声明两个变量。</span>

name = <span class="hljs-string">&quot;John&quot;</span>;

admin = name;

alert( admin ); <span class="hljs-comment">// &quot;John&quot;</span></code></pre>

      </fieldset>
      
      <fieldset id='_68ZRR1'>
      <legend>task</legend>
      <p>importance: 2</p>
<hr>
<h1 id="使用变量">使用变量</h1>
<ol>
<li>声明两个变量：<code>admin</code> 和 <code>name</code>。</li>
<li>将值 <code>&quot;John&quot;</code> 赋给 <code>name</code>。</li>
<li>从 <code>name</code> 变量中拷贝其值给 <code>admin</code>。</li>
<li>使用 <code>alert</code> 显示 <code>admin</code> 的值（必须输出 &quot;John&quot;）。</li>
</ol>

      </fieldset>
      
      <fieldset id='_m9s1nB'>
      <legend>solution</legend>
      <h2 id="代表我们星球的变量">代表我们星球的变量</h2>
<p>这很简单：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> ourPlanetName = <span class="hljs-string">&quot;Earth&quot;</span>;</code></pre>
<p>注意，我们也可以用一个更简短的名字 <code>planet</code>，但这样可能并不能表达清楚它指的是哪个星球。再啰嗦一点也挺好的。至少让这个变量别太长就行。</p>
<h2 id="网站当前访问者的名字">网站当前访问者的名字</h2>
<pre><code class="language-js"><span class="hljs-keyword">let</span> currentUserName = <span class="hljs-string">&quot;John&quot;</span>;</code></pre>
<p>同样，如果我们的确知道用户就是当前的用户的话，我们可以使用更短的变量名 <code>userName</code>。</p>
<p>现代编辑器的自动补全可以让长变量名变得容易编写。不要浪费这个特性。一个名字中包含三个词挺好的。</p>
<p>如果你的编辑器没有合适的自动补全功能，换 <a href="/code-editors">一个新的吧</a>。</p>

      </fieldset>
      
      <fieldset id='_RnK6y7'>
      <legend>task</legend>
      <p>importance: 3</p>
<hr>
<h1 id="给出正确的名字">给出正确的名字</h1>
<ol>
<li>使用我们的星球的名字创建一个变量。你会怎么命名这个变量？</li>
<li>创建一个变量来存储当前浏览者的名字。你会怎么命名这个变量？</li>
</ol>

      </fieldset>
      
      <fieldset id='_V270cr'>
      <legend>solution</legend>
      <p>我们通常用大写字母表示“硬编码（hard-coded）”的常量。或者，换句话说就是，当值在执行之前或在被写入代码的时候，我们就知道值是什么了。</p>
<p>在这个代码中 <code>birthday</code> 确实是这样的。因此我们可以使用大写。</p>
<p>在对照组中，<code>age</code> 是在程序运行时计算出的。今天我们有一个年龄，一年以后我们就会有另一个。它在某种意义上不会随着代码的执行而改变。但与 <code>birthday</code> 相比，它还是有一定的可变性：它是计算出来的，因此我们应该使用小写。</p>

      </fieldset>
      
      <fieldset id='_l0mUC8'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="大写的常量？">大写的常量？</h1>
<p>检查下面的代码：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> birthday = <span class="hljs-string">&#x27;18.04.1982&#x27;</span>;

<span class="hljs-keyword">const</span> age = someCode(birthday);</code></pre>
<p>这里我们有一个 <code>birthday</code> 日期常量和通过一些代码（为了保持简短这里没有提供，因为这些细节在这无关紧要）从 <code>birthday</code> 计算出的 <code>age</code> 常量。</p>
<p>对于 <code>birthday</code> 使用大写方式正确吗？那么 <code>age</code> 呢？或者两者都用？</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> BIRTHDAY = <span class="hljs-string">&#x27;18.04.1982&#x27;</span>; <span class="hljs-comment">// 使用大写？</span>

<span class="hljs-keyword">const</span> AGE = someCode(BIRTHDAY); <span class="hljs-comment">// 使用大写？</span></code></pre>

      </fieldset>
      
      <fieldset id='_8rshcv'>
      <legend>article</legend>
      <h1 id="变量">变量</h1>
<p>大多数情况下，JavaScript 应用需要处理信息。这有两个例子：</p>
<ol>
<li>一个网上商店 —— 这里的信息可能包含正在售卖的商品和购物车。</li>
<li>一个聊天应用 —— 这里的信息可能包括用户和消息等等。</li>
</ol>
<p>变量就是用来储存这些信息的。</p>
<h2 id="变量-1">变量</h2>
<p><a href="https://en.wikipedia.org/wiki/Variable_(computer_science)">变量</a> 是数据的“命名存储”。我们可以使用变量来保存商品、访客和其他信息。</p>
<p>在 JavaScript 中创建一个变量，我们需要用到 <code>let</code> 关键字。</p>
<p>下面的语句创建（也可以称为 <strong>声明</strong> 或者 <strong>定义</strong>）了一个名称为 “message” 的变量：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> message;</code></pre>
<p>现在，我们可以通过赋值运算符 <code>=</code> 为变量添加一些数据：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> message;

*!*
message = <span class="hljs-string">&#x27;Hello&#x27;</span>; <span class="hljs-comment">// 保存字符串</span>
*/!*</code></pre>
<p>现在这个字符串已经保存到与该变量相关联的内存区域了，我们可以通过使用该变量名称访问它：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> message;
message = <span class="hljs-string">&#x27;Hello!&#x27;</span>;

*!*
alert(message); <span class="hljs-comment">// 显示变量内容</span>
*/!*</code></pre>
<p>简洁一点，我们可以将变量定义和赋值合并成一行：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> message = <span class="hljs-string">&#x27;Hello!&#x27;</span>; <span class="hljs-comment">// 定义变量，并且赋值</span>

alert(message); <span class="hljs-comment">// Hello!</span></code></pre>
<p>也可以在一行中声明多个变量：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = <span class="hljs-string">&#x27;John&#x27;</span>, age = <span class="hljs-number">25</span>, message = <span class="hljs-string">&#x27;Hello&#x27;</span>;</code></pre>
<p>看上去代码长度更短，但并不推荐这样。为了更好的可读性，请一行只声明一个变量。</p>
<p>多行变量声明有点长，但更容易阅读：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = <span class="hljs-string">&#x27;John&#x27;</span>;
<span class="hljs-keyword">let</span> age = <span class="hljs-number">25</span>;
<span class="hljs-keyword">let</span> message = <span class="hljs-string">&#x27;Hello&#x27;</span>;</code></pre>
<p>一些程序员采用下面的形式书写多个变量：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = <span class="hljs-string">&#x27;John&#x27;</span>,
  age = <span class="hljs-number">25</span>,
  message = <span class="hljs-string">&#x27;Hello&#x27;</span>;</code></pre>
<p>……甚至使用“逗号在前”的形式：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = <span class="hljs-string">&#x27;John&#x27;</span>
  , age = <span class="hljs-number">25</span>
  , message = <span class="hljs-string">&#x27;Hello&#x27;</span>;</code></pre>
<p>技术上讲，这些变体都有一样的效果。所以，这是个个人品味和审美方面的问题。</p>
<p>````smart header=&quot;<code>var</code> 而不是 <code>let</code>&quot;
在较旧的脚本中，你也可能发现另一个关键字 <code>var</code>，而不是 <code>let</code>：</p>
<pre><code class="language-js">*!*<span class="hljs-keyword">var</span>*/!* message = <span class="hljs-string">&#x27;Hello&#x27;</span>;</code></pre>
<p><code>var</code> 关键字与 <code>let</code> <strong>大体</strong> 相同，也用来声明变量，但稍微有些不同，也有点“老派”。</p>
<p><code>let</code> 和 <code>var</code> 之间有些微妙的差别，但目前对于我们来说并不重要。我们将会在 <a href="info:var">info:var</a> 章节中介绍它们。</p>
<pre><code>
## 一个现实生活的类比

如果将变量想象成一个“数据”的盒子，盒子上有一个唯一的标注盒子名字的贴纸。这样我们能更轻松地掌握“变量”的概念。

例如，变量 `message` 可以被想象成一个标有 `&quot;message&quot;` 的盒子，盒子里面的值为 `&quot;Hello!&quot;`：

![](variable.svg)

我们可以在盒子内放入任何值。

并且，这个盒子的值，我们想改变多少次，就可以改变多少次：
```js run
let message;

message = &#x27;Hello!&#x27;;

message = &#x27;World!&#x27;; // 值改变了

alert(message);
```

当值改变的时候，之前的数据就被从变量中删除了：

![](variable-change.svg)

我们还可以声明两个变量，然后将其中一个变量的数据拷贝到另一个变量。

```js run
let hello = &#x27;Hello world!&#x27;;

let message;

*!*
// 将字符串 &#x27;Hello world&#x27; 从变量 hello 拷贝到 message
message = hello;
*/!*

// 现在两个变量保存着相同的数据
alert(hello); // Hello world!
alert(message); // Hello world!
```

````warn header=&quot;声明两次会触发 error&quot;
一个变量应该只被声明一次。

对同一个变量进行重复声明会触发 error：

```js run
let message = &quot;This&quot;;

// 重复 &#x27;let&#x27; 会导致 error
let message = &quot;That&quot;; // SyntaxError: &#x27;message&#x27; has already been declared
```
因此，我们对同一个变量应该只声明一次，之后在不使用 `let` 的情况下对其进行引用。</code></pre>
<pre><code class="language-smart">有趣的是，也存在禁止更改变量值的 [函数式](https://en.wikipedia.org/wiki/Functional_programming) 编程语言。比如 [Scala](http://www.scala-lang.org/) 或 [Erlang](http://www.erlang.org/)。

在这种类型的语言中，一旦值保存在盒子中，就永远存在。如果你试图保存其他值，它会强制创建一个新盒子（声明一个新变量），无法重用之前的变量。

虽然第一次看上去有点奇怪，但是这些语言有很大的发展潜力。不仅如此，在某些领域，比如并行计算，这个限制有一定的好处。研究这样的一门语言（即使不打算很快就用上它）有助于开阔视野。</code></pre>
<h2 id="变量命名-variable-naming">变量命名 [#variable-naming]</h2>
<p>JavaScript 的变量命名有两个限制：</p>
<ol>
<li>变量名称必须仅包含字母，数字，符号 <code>$</code> 和 <code>_</code>。</li>
<li>首字符必须非数字。</li>
</ol>
<p>有效的命名，例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> userName;
<span class="hljs-keyword">let</span> test123;</code></pre>
<p>如果命名包括多个单词，通常采用驼峰式命名法（<a href="https://en.wikipedia.org/wiki/CamelCase">camelCase</a>）。也就是，单词一个接一个，除了第一个单词，其他的每个单词都以大写字母开头：<code>myVeryLongName</code>。</p>
<p>有趣的是，美元符号 <code>&#39;$&#39;</code> 和下划线 <code>&#39;_&#39;</code> 也可以用于变量命名。它们是正常的符号，就跟字母一样，没有任何特殊的含义。</p>
<p>下面的命名是有效的：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> $ = <span class="hljs-number">1</span>; <span class="hljs-comment">// 使用 &quot;$&quot; 声明一个变量</span>
<span class="hljs-keyword">let</span> _ = <span class="hljs-number">2</span>; <span class="hljs-comment">// 现在用 &quot;_&quot; 声明一个变量</span>

alert($ + _); <span class="hljs-comment">// 3</span></code></pre>
<p>下面的变量命名不正确：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> <span class="hljs-number">1</span>a; <span class="hljs-comment">// 不能以数字开始</span>

<span class="hljs-keyword">let</span> my-name; <span class="hljs-comment">// 连字符 &#x27;-&#x27; 不允许用于变量命名</span></code></pre>
<pre><code class="language-smart">命名为 `apple` 和 `AppLE` 的变量是不同的两个变量。</code></pre>
<pre><code class="language-smart">可以使用任何语言，包括西里尔字母（cyrillic letters）甚至是象形文字，就像这样：

```js
let имя = &#x27;...&#x27;;
let 我 = &#x27;...&#x27;;
```

从技术上讲，这样没问题。这样的命名是完全允许的，但是用英文进行变量命名是国际惯例。哪怕我们正在写一个很小的脚本，它也有可能会被使用很久。某个时候，来自其他国家的人可能会需要阅读它。</code></pre>
<pre><code class="language-warn">有一张 [保留字列表](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Keywords)，这张表中的保留字无法用作变量命名，因为它们被用于编程语言本身了。

比如，`let`、`class`、`return`、`function` 都被保留了。

下面的代码将会抛出一个语法错误：

```js run no-beautify
let let = 5; // 不能用 &quot;let&quot; 来命名一个变量，错误！
let return = 5; // 同样，不能使用 &quot;return&quot;，错误！
```</code></pre>
<p>````warn header=&quot;未采用 <code>use strict</code> 下的赋值&quot;</p>
<p>一般，我们需要在使用一个变量前定义它。但是在早期，我们可以不使用 <code>let</code> 进行变量声明，而可以简单地通过赋值来创建一个变量。现在如果我们不在脚本中使用 <code>use strict</code> 声明启用严格模式，这仍然可以正常工作，这是为了保持对旧脚本的兼容。</p>
<pre><code class="language-js"><span class="hljs-comment">// 注意：这个例子中没有 &quot;use strict&quot;</span>

num = <span class="hljs-number">5</span>; <span class="hljs-comment">// 如果变量 &quot;num&quot; 不存在，就会被创建</span>

alert(num); <span class="hljs-comment">// 5</span></code></pre>
<p>上面这是个糟糕的做法，严格模式下会报错。</p>
<pre><code class="language-js"><span class="hljs-meta">&quot;use strict&quot;</span>;

*!*
num = <span class="hljs-number">5</span>; <span class="hljs-comment">// 错误：num 未定义</span>
*/!*</code></pre>
<pre><code>
## 常量

声明一个常数（不变）变量，可以使用 `const` 而非 `let`：

```js
const myBirthday = &#x27;18.04.1982&#x27;;
```

使用 `const` 声明的变量称为“常量”。它们不能被修改，如果你尝试修改就会发现报错：

```js run
const myBirthday = &#x27;18.04.1982&#x27;;

myBirthday = &#x27;01.01.2001&#x27;; // 错误，不能对常量重新赋值
```

当程序员能确定这个变量永远不会改变的时候，就可以使用 `const` 来确保这种行为，并且清楚地向别人传递这一事实。


### 大写形式的常数

一个普遍的做法是将常量用作别名，以便记住那些在执行之前就已知的难以记住的值。

使用大写字母和下划线来命名这些常量。

例如，让我们以所谓的“web”（十六进制）格式为颜色声明常量：

```js run
const COLOR_RED = &quot;#F00&quot;;
const COLOR_GREEN = &quot;#0F0&quot;;
const COLOR_BLUE = &quot;#00F&quot;;
const COLOR_ORANGE = &quot;#FF7F00&quot;;

// ……当我们需要选择一个颜色
let color = COLOR_ORANGE;
alert(color); // #FF7F00
```

好处：

- `COLOR_ORANGE` 比 `&quot;#FF7F00&quot;` 更容易记忆。
- 比起 `COLOR_ORANGE` 而言，`&quot;#FF7F00&quot;` 更容易输错。
- 阅读代码时，`COLOR_ORANGE` 比 `#FF7F00` 更易懂。

什么时候该为常量使用大写命名，什么时候进行常规命名？让我们弄清楚一点。

作为一个“常数”，意味着值永远不变。但是有些常量在执行之前就已知了（比如红色的十六进制值），还有些在执行期间被“计算”出来，但初始赋值之后就不会改变。

例如：
```js
const pageLoadTime = /* 网页加载所需的时间 */;
```

`pageLoadTime` 的值在页面加载之前是未知的，所以采用常规命名。但是它仍然是个常量，因为赋值之后不会改变。

换句话说，大写命名的常量仅用作“硬编码（hard-coded）”值的别名。

## 正确命名变量

谈到变量，还有一件非常重要的事。

一个变量名应该有一个清晰、明显的含义，对其存储的数据进行描述。

变量命名是编程过程中最重要且最复杂的技能之一。快速地浏览变量的命名就知道代码是一个初学者还是有经验的开发者写的。

在一个实际项目中，大多数的时间都被用来修改和扩展现有的代码库，而不是从头开始写一些完全独立的代码。当一段时间后，我们做完其他事情，重新回到我们的代码，找到命名良好的信息要容易得多。换句话说，变量要有个好名字。

声明变量之前，多花点时间思考它的更好的命名。你会受益良多。

一些可以遵循的规则：

- 使用易读的命名，比如 `userName` 或者 `shoppingCart`。
- 离诸如 `a`、`b`、`c` 这种缩写和短名称远一点，除非你真的知道你在干什么。
- 变量名在能够准确描述变量的同时要足够简洁。不好的例子就是 `data` 和 `value`，这样的名称等于什么都没说。如果能够非常明显地从上下文知道数据和值所表达的含义，这样使用它们也是可以的。
- 脑海中的术语要和团队保持一致。如果网站的访客称为“用户”，则我们采用相关的变量命名，比如 `currentUser` 或者 `newUser`，而不要使用 `currentVisitor` 或者一个 `newManInTown`。

听上去很简单？确实如此，但是在实践中选择一个一目了然的变量名称并非如此简单。大胆试试吧。

```smart header=&quot;重用还是新建？&quot;
最后一点，有一些懒惰的程序员，倾向于重用现有的变量，而不是声明一个新的变量。

结果是，这个变量就像是被扔进不同东西盒子，但没有改变它的贴纸。现在里面是什么？谁知道呢。我们需要靠近一点，仔细检查才能知道。

这样的程序员节省了一点变量声明的时间，但却在调试代码的时候损失数十倍时间。

额外声明一个变量绝对是利大于弊的。

现代的 JavaScript 压缩器和浏览器都能够很好地对代码进行优化，所以不会产生性能问题。为不同的值使用不同的变量可以帮助引擎对代码进行优化。
```

## 总结

我们可以使用 `var`、`let` 或 `const` 声明变量来存储数据。

- `let` — 现代的变量声明方式。
- `var` — 老旧的变量声明方式。一般情况下，我们不会再使用它。但是，我们会在 &lt;info:var&gt; 章节介绍 `var` 和 `let` 的微妙差别，以防你需要它们。
- `const` — 类似于 `let`，但是变量的值无法被修改。

变量应当以一种容易理解变量内部是什么的方式进行命名。</code></pre>

      </fieldset>
      
      <fieldset id='_vMBmUD'>
      <legend>solution</legend>
      <p>反引号将包装在 <code>${...}</code> 中的表达式嵌入到了字符串。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;Ilya&quot;</span>;

<span class="hljs-comment">// 表达式为数字 1</span>
alert( <span class="hljs-string">`hello <span class="hljs-subst">${<span class="hljs-number">1</span>}</span>`</span> ); <span class="hljs-comment">// hello 1</span>

<span class="hljs-comment">// 表达式是一个字符串 &quot;name&quot;</span>
alert( <span class="hljs-string">`hello <span class="hljs-subst">${<span class="hljs-string">&quot;name&quot;</span>}</span>`</span> ); <span class="hljs-comment">// hello name</span>

<span class="hljs-comment">// 表达式是一个变量，嵌入进去了。</span>
alert( <span class="hljs-string">`hello <span class="hljs-subst">${name}</span>`</span> ); <span class="hljs-comment">// hello Ilya</span></code></pre>

      </fieldset>
      
      <fieldset id='_SORW9X'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="字符串的引号">字符串的引号</h1>
<p>下面的脚本会输出什么？</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;Ilya&quot;</span>;

alert( <span class="hljs-string">`hello <span class="hljs-subst">${<span class="hljs-number">1</span>}</span>`</span> ); <span class="hljs-comment">// ?</span>

alert( <span class="hljs-string">`hello <span class="hljs-subst">${<span class="hljs-string">&quot;name&quot;</span>}</span>`</span> ); <span class="hljs-comment">// ?</span>

alert( <span class="hljs-string">`hello <span class="hljs-subst">${name}</span>`</span> ); <span class="hljs-comment">// ?</span></code></pre>

      </fieldset>
      
      <fieldset id='_tVvOhQ'>
      <legend>article</legend>
      <h1 id="数据类型">数据类型</h1>
<p>JavaScript 中的值都具有特定的类型。例如，字符串或数字。</p>
<p>在 JavaScript 中有 8 种基本的数据类型（译注：7 种原始类型和 1 种引用类型）。在这里，我们将对它们进行大体的介绍，在下一章中，我们将详细讨论它们。</p>
<p>我们可以将任何类型的值存入变量。例如，一个变量可以在前一刻是个字符串，下一刻就存储一个数字：</p>
<pre><code class="language-js"><span class="hljs-comment">// 没有错误</span>
<span class="hljs-keyword">let</span> message = <span class="hljs-string">&quot;hello&quot;</span>;
message = <span class="hljs-number">123456</span>;</code></pre>
<p>允许这种操作的编程语言，例如 JavaScript，被称为“动态类型”（dynamically typed）的编程语言，意思是虽然编程语言中有不同的数据类型，但是你定义的变量并不会在定义后，被限制为某一数据类型。</p>
<h2 id="number-类型">Number 类型</h2>
<pre><code class="language-js"><span class="hljs-keyword">let</span> n = <span class="hljs-number">123</span>;
n = <span class="hljs-number">12.345</span>;</code></pre>
<p><em>number</em> 类型代表整数和浮点数。</p>
<p>数字可以有很多操作，比如，乘法 <code>*</code>、除法 <code>/</code>、加法 <code>+</code>、减法 <code>-</code> 等等。</p>
<p>除了常规的数字，还包括所谓的“特殊数值（&quot;special numeric values&quot;）”也属于这种类型：<code>Infinity</code>、<code>-Infinity</code> 和 <code>NaN</code>。</p>
<ul>
<li><p><code>Infinity</code> 代表数学概念中的 <a href="https://en.wikipedia.org/wiki/Infinity">无穷大</a> ∞。是一个比任何数字都大的特殊值。</p>
<p>  我们可以通过除以 0 来得到它：</p>
<pre><code class="language-js">alert( <span class="hljs-number">1</span> / <span class="hljs-number">0</span> ); <span class="hljs-comment">// Infinity</span></code></pre>
<p>  或者在代码中直接使用它：</p>
<pre><code class="language-js">alert( <span class="hljs-literal">Infinity</span> ); <span class="hljs-comment">// Infinity</span></code></pre>
</li>
<li><p><code>NaN</code> 代表一个计算错误。它是一个不正确的或者一个未定义的数学操作所得到的结果，比如：</p>
<pre><code class="language-js">alert( <span class="hljs-string">&quot;not a number&quot;</span> / <span class="hljs-number">2</span> ); <span class="hljs-comment">// NaN，这样的除法是错误的</span></code></pre>
<p>  <code>NaN</code> 是粘性的。任何对 <code>NaN</code> 的进一步操作都会返回 <code>NaN</code>：</p>
<pre><code class="language-js">alert( <span class="hljs-string">&quot;not a number&quot;</span> / <span class="hljs-number">2</span> + <span class="hljs-number">5</span> ); <span class="hljs-comment">// NaN</span></code></pre>
<p>  所以，如果在数学表达式中有一个 <code>NaN</code>，会被传播到最终结果。</p>
</li>
</ul>
<pre><code class="language-smart">在 JavaScript 中做数学运算是安全的。我们可以做任何事：除以 0，将非数字字符串视为数字，等等。

脚本永远不会因为一个致命的错误（“死亡”）而停止。最坏的情况下，我们会得到 `NaN` 的结果。</code></pre>
<p>特殊的数值属于 &quot;number&quot; 类型。当然，对“特殊的数值”这个词的一般认识是，它们并不是数字。</p>
<p>我们将在 <a href="info:number">info:number</a> 一节中学习数字的更多细节。</p>
<h2 id="bigint-类型">BigInt 类型</h2>
<p>在 JavaScript 中，&quot;number&quot; 类型无法表示大于 <code>(2<sup>53</sup>-1)</code>（即 <code>9007199254740991</code>），或小于 <code>-(2<sup>53</sup>-1)</code> 的整数。这是其内部表示形式导致的技术限制。</p>
<p>在大多数情况下，这个范围就足够了，但有时我们需要很大的数字，例如用于加密或微秒精度的时间戳。</p>
<p><code>BigInt</code> 类型是最近被添加到 JavaScript 语言中的，用于表示任意长度的整数。</p>
<p>可以通过将 <code>n</code> 附加到整数字段的末尾来创建 <code>BigInt</code> 值。</p>
<pre><code class="language-js"><span class="hljs-comment">// 尾部的 &quot;n&quot; 表示这是一个 BigInt 类型</span>
<span class="hljs-keyword">const</span> bigInt = <span class="hljs-number">1234567890123456789012345678901234567890n</span>;</code></pre>
<p>由于很少需要 <code>BigInt</code> 类型的数字，我们在这没有对其进行讲解，我们在单独的章节 <a href="info:bigint">info:bigint</a> 中专门对其进行了介绍。当你需要使用那样的大数字的时候，可以去阅读该章节。</p>
<pre><code class="language-smart">目前 Firefox/Chrome/Edge/Safari 已经支持 `BigInt` 了，但 IE 还没有。</code></pre>
<p>你可以查看 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt#Browser_compatibility"><em>MDN</em> BigInt 兼容性表</a> 以了解哪些版本的浏览器已经支持 BigInt 了。</p>
<h2 id="string-类型">String 类型</h2>
<p>JavaScript 中的字符串必须被括在引号里。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;Hello&quot;</span>;
<span class="hljs-keyword">let</span> str2 = <span class="hljs-string">&#x27;Single quotes are ok too&#x27;</span>;
<span class="hljs-keyword">let</span> phrase = <span class="hljs-string">`can embed another <span class="hljs-subst">${str}</span>`</span>;</code></pre>
<p>在 JavaScript 中，有三种包含字符串的方式。</p>
<ol>
<li>双引号：<code>&quot;Hello&quot;</code>.</li>
<li>单引号：<code>&#39;Hello&#39;</code>.</li>
<li>反引号：<code>&#96;Hello&#96;</code>.</li>
</ol>
<p>双引号和单引号都是“简单”引用，在 JavaScript 中两者几乎没有什么差别。</p>
<p>反引号是 <strong>功能扩展</strong> 引号。它们允许我们通过将变量和表达式包装在 <code>${…}</code> 中，来将它们嵌入到字符串中。例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;John&quot;</span>;

<span class="hljs-comment">// 嵌入一个变量</span>
alert( <span class="hljs-string">`Hello, *!*<span class="hljs-subst">${name}</span>*/!*!`</span> ); <span class="hljs-comment">// Hello, John!</span>

<span class="hljs-comment">// 嵌入一个表达式</span>
alert( <span class="hljs-string">`the result is *!*<span class="hljs-subst">${<span class="hljs-number">1</span> + <span class="hljs-number">2</span>}</span>*/!*`</span> ); <span class="hljs-comment">// the result is 3</span></code></pre>
<p><code>${…}</code> 内的表达式会被计算，计算结果会成为字符串的一部分。可以在 <code>${…}</code> 内放置任何东西：诸如名为 <code>name</code> 的变量，或者诸如 <code>1 + 2</code> 的算数表达式，或者其他一些更复杂的。</p>
<p>需要注意的是，这仅仅在反引号内有效，其他引号不允许这种嵌入。</p>
<pre><code class="language-js">alert( <span class="hljs-string">&quot;the result is ${1 + 2}&quot;</span> ); <span class="hljs-comment">// the result is ${1 + 2}（使用双引号则不会计算 ${…} 中的内容）</span></code></pre>
<p>我们会在 <a href="info:string">info:string</a> 一节中学习字符串的更多细节。</p>
<pre><code class="language-smart">在一些语言中，单个字符有一个特殊的 &quot;character&quot; 类型，在 C 语言和 Java 语言中被称为 &quot;char&quot;。

在 JavaScript 中没有这种类型。只有一种 `string` 类型，一个字符串可以包含零个（为空）、一个或多个字符。</code></pre>
<h2 id="boolean-类型（逻辑类型）">Boolean 类型（逻辑类型）</h2>
<p>boolean 类型仅包含两个值：<code>true</code> 和 <code>false</code>。</p>
<p>这种类型通常用于存储表示 yes 或 no 的值：<code>true</code> 意味着 “yes，正确”，<code>false</code> 意味着 “no，不正确”。</p>
<p>比如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> nameFieldChecked = <span class="hljs-literal">true</span>; <span class="hljs-comment">// yes, name field is checked</span>
<span class="hljs-keyword">let</span> ageFieldChecked = <span class="hljs-literal">false</span>; <span class="hljs-comment">// no, age field is not checked</span></code></pre>
<p>布尔值也可作为比较的结果：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> isGreater = <span class="hljs-number">4</span> &gt; <span class="hljs-number">1</span>;

alert( isGreater ); <span class="hljs-comment">// true（比较的结果是 &quot;yes&quot;）</span></code></pre>
<p>更详细的内容将会在 <a href="info:logical-operators">info:logical-operators</a> 一节中介绍。</p>
<h2 id="null-值">&quot;null&quot; 值</h2>
<p>特殊的 <code>null</code> 值不属于上述任何一种类型。</p>
<p>它构成了一个独立的类型，只包含 <code>null</code> 值：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> age = <span class="hljs-literal">null</span>;</code></pre>
<p>相比较于其他编程语言，JavaScript 中的 <code>null</code> 不是一个“对不存在的 <code>object</code> 的引用”或者 “null 指针”。</p>
<p>JavaScript 中的 <code>null</code> 仅仅是一个代表“无”、“空”或“值未知”的特殊值。</p>
<p>上面的代码表示 <code>age</code> 是未知的。</p>
<h2 id="undefined-值">&quot;undefined&quot; 值</h2>
<p>特殊值 <code>undefined</code> 和 <code>null</code> 一样自成类型。</p>
<p><code>undefined</code> 的含义是 <code>未被赋值</code>。</p>
<p>如果一个变量已被声明，但未被赋值，那么它的值就是 <code>undefined</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> age;

alert(age); <span class="hljs-comment">// 弹出 &quot;undefined&quot;</span></code></pre>
<p>从技术上讲，可以显式地将 <code>undefined</code> 赋值给变量：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> age = <span class="hljs-number">100</span>;

<span class="hljs-comment">// 将值修改为 undefined</span>
age = <span class="hljs-literal">undefined</span>;

alert(age); <span class="hljs-comment">// &quot;undefined&quot;</span></code></pre>
<p>……但是不建议这样做。通常，使用 <code>null</code> 将一个“空”或者“未知”的值写入变量中，而 <code>undefined</code> 则保留作为未进行初始化的事物的默认初始值。</p>
<h2 id="object-类型和-symbol-类型">object 类型和 symbol 类型</h2>
<p><code>object</code> 类型是一个特殊的类型。</p>
<p>其他所有的数据类型都被称为“原始类型”，因为它们的值只包含一个单独的内容（字符串、数字或者其他）。相反，<code>object</code> 则用于储存数据集合和更复杂的实体。</p>
<p>因为它非常重要，所以我们对其进行单独讲解。在充分学习了原始类型后，我们将会在 <a href="info:object">info:object</a> 一章中介绍 <code>object</code>。</p>
<p><code>symbol</code> 类型用于创建对象的唯一标识符。我们在这里提到 <code>symbol</code> 类型是为了完整性，但我们要在学完 <code>object</code> 类型后再学习它。</p>
<h2 id="typeof-运算符-type-typeof">typeof 运算符 [#type-typeof]</h2>
<p><code>typeof</code> 运算符返回参数的类型。当我们想要分别处理不同类型值的时候，或者想快速进行数据类型检验时，非常有用。</p>
<p>它支持两种语法形式：</p>
<ol>
<li>作为运算符：<code>typeof x</code>。</li>
<li>函数形式：<code>typeof(x)</code>。</li>
</ol>
<p>换言之，有括号和没有括号，得到的结果是一样的。</p>
<p>对 <code>typeof x</code> 的调用会以字符串的形式返回数据类型：</p>
<pre><code class="language-js"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span> <span class="hljs-comment">// &quot;undefined&quot;</span>

<span class="hljs-keyword">typeof</span> <span class="hljs-number">0</span> <span class="hljs-comment">// &quot;number&quot;</span>

<span class="hljs-keyword">typeof</span> <span class="hljs-number">10n</span> <span class="hljs-comment">// &quot;bigint&quot;</span>

<span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span> <span class="hljs-comment">// &quot;boolean&quot;</span>

<span class="hljs-keyword">typeof</span> <span class="hljs-string">&quot;foo&quot;</span> <span class="hljs-comment">// &quot;string&quot;</span>

<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>) <span class="hljs-comment">// &quot;symbol&quot;</span>

*!*
<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Math</span> <span class="hljs-comment">// &quot;object&quot;  (1)</span>
*/!*

*!*
<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span> <span class="hljs-comment">// &quot;object&quot;  (2)</span>
*/!*

*!*
<span class="hljs-keyword">typeof</span> alert <span class="hljs-comment">// &quot;function&quot;  (3)</span>
*/!*</code></pre>
<p>最后三行可能需要额外的说明：</p>
<ol>
<li><code>Math</code> 是一个提供数学运算的内建 <code>object</code>。我们会在 <a href="info:number">info:number</a> 一节中学习它。此处仅作为一个 <code>object</code> 的示例。</li>
<li><code>typeof null</code> 的结果是 <code>&quot;object&quot;</code>。这是官方承认的 <code>typeof</code> 的行为上的错误，这个问题来自于 JavaScript 语言的早期，并为了兼容性而保留了下来。<code>null</code> 绝对不是一个 <code>object</code>。<code>null</code> 有自己的类型，它是一个特殊值。</li>
<li><code>typeof alert</code> 的结果是 <code>&quot;function&quot;</code>，因为 <code>alert</code> 在 JavaScript 语言中是一个函数。我们会在下一章学习函数，那时我们会了解到，在 JavaScript 语言中没有一个特别的 &quot;function&quot; 类型。函数隶属于 <code>object</code> 类型。但是 <code>typeof</code> 会对函数区分对待，并返回 <code>&quot;function&quot;</code>。这也是来自于 JavaScript 语言早期的问题。从技术上讲，这种行为是不正确的，但在实际编程中却非常方便。</li>
</ol>
<h2 id="总结">总结</h2>
<p>JavaScript 中有八种基本的数据类型（译注：前七种为基本数据类型，也称为原始类型，而 <code>object</code> 为复杂数据类型）。</p>
<ul>
<li><code>number</code> 用于任何类型的数字：整数或浮点数，在 <code>±(2<sup>53</sup>-1)</code> 范围内的整数。</li>
<li><code>bigint</code> 用于任意长度的整数。</li>
<li><code>string</code> 用于字符串：一个字符串可以包含 0 个或多个字符，所以没有单独的单字符类型。</li>
<li><code>boolean</code> 用于 <code>true</code> 和 <code>false</code>。</li>
<li><code>null</code> 用于未知的值 —— 只有一个 <code>null</code> 值的独立类型。</li>
<li><code>undefined</code> 用于未定义的值 —— 只有一个 <code>undefined</code> 值的独立类型。</li>
<li><code>symbol</code> 用于唯一的标识符。</li>
<li><code>object</code> 用于更复杂的数据结构。</li>
</ul>
<p>我们可以通过 <code>typeof</code> 运算符查看存储在变量中的数据类型。</p>
<ul>
<li>两种形式：<code>typeof x</code> 或者 <code>typeof(x)</code>。</li>
<li>以字符串的形式返回类型名称，例如 <code>&quot;string&quot;</code>。</li>
<li><code>typeof null</code> 会返回 <code>&quot;object&quot;</code> —— 这是 JavaScript 编程语言的一个错误，实际上它并不是一个 <code>object</code>。</li>
</ul>
<p>在接下来的章节中，我们将重点介绍原始类型值，当你掌握了原始数据类型后，我们将继续学习 <code>object</code>。</p>

      </fieldset>
      
      <fieldset id='_9fF1hv'>
      <legend>solution</legend>
      <p>JavaScript 代码：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> name = prompt(<span class="hljs-string">&quot;What is your name?&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);
alert(name);</code></pre>
<p>整个页面的代码：</p>
<pre><code class="language-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-meta">
    &#x27;use strict&#x27;</span>;

    <span class="hljs-keyword">let</span> name = prompt(<span class="hljs-string">&quot;What is your name?&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);
    alert(name);
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>

      </fieldset>
      
      <fieldset id='_8uCN7h'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="创建一个简单的页面">创建一个简单的页面</h1>
<p>创建一个要求用户输入 <code>name</code>，并通过浏览器窗口对键入的内容进行输出的 web 页面。</p>
<p>[demo]</p>

      </fieldset>
      
      <fieldset id='_8f1K8U'>
      <legend>article</legend>
      <h1 id="交互：alert、prompt-和-confirm">交互：alert、prompt 和 confirm</h1>
<p>由于我们将使用浏览器作为我们的演示环境，让我们看几个与用户交互的函数：<code>alert</code>，<code>prompt</code> 和<code>confirm</code>。</p>
<h2 id="alert">alert</h2>
<p>这个我们前面已经看到过了。它会显示一条信息，并等待用户按下 &quot;OK&quot;。</p>
<p>例如：</p>
<pre><code class="language-js">alert(<span class="hljs-string">&quot;Hello&quot;</span>);</code></pre>
<p>弹出的这个带有信息的小窗口被称为 <strong>模态窗</strong>。&quot;modal&quot; 意味着用户不能与页面的其他部分（例如点击其他按钮等）进行交互，直到他们处理完窗口。在上面示例这种情况下 —— 直到用户点击“确定”按钮。</p>
<h2 id="prompt">prompt</h2>
<p><code>prompt</code> 函数接收两个参数：</p>
<pre><code class="language-js">result = prompt(title, [<span class="hljs-keyword">default</span>]);</code></pre>
<p>浏览器会显示一个带有文本消息的模态窗口，还有 input 框和确定/取消按钮。</p>
<p><code>title</code>
: 显示给用户的文本</p>
<p><code>default</code>
: 可选的第二个参数，指定 input 框的初始值。</p>
<p>```smart header=&quot;语法中的方括号 <code>[...]</code>&quot;
上述语法中 <code>default</code> 周围的方括号表示该参数是可选的，不是必需的。</p>
<pre><code>
访问者可以在提示输入栏中输入一些内容，然后按“确定”键。然后我们在 `result` 中获取该文本。或者他们可以按取消键或按 `key:Esc` 键取消输入，然后我们得到 `null` 作为 `result`。

`prompt` 将返回用户在 `input` 框内输入的文本，如果用户取消了输入，则返回 `null`。

举个例子：

```js run
let age = prompt(&#x27;How old are you?&#x27;, 100);

alert(`You are ${age} years old!`); // You are 100 years old!</code></pre>
<pre><code class="language-warn">第二个参数是可选的。但是如果我们不提供的话，Internet Explorer 会把 `&quot;undefined&quot;` 插入到 prompt。

我们可以在 Internet Explorer 中运行下面这行代码来看看效果：

```js run
let test = prompt(&quot;Test&quot;);
```

所以，为了 prompt 在 IE 中有好的效果，我们建议始终提供第二个参数：

```js run
let test = prompt(&quot;Test&quot;, &#x27;&#x27;); // &lt;-- 用于 IE 浏览器
```</code></pre>
<h2 id="confirm">confirm</h2>
<p>语法：</p>
<pre><code class="language-js">result = confirm(question);</code></pre>
<p><code>confirm</code> 函数显示一个带有 <code>question</code> 以及确定和取消两个按钮的模态窗口。</p>
<p>点击确定返回 <code>true</code>，点击取消返回 <code>false</code>。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> isBoss = confirm(<span class="hljs-string">&quot;Are you the boss?&quot;</span>);

alert( isBoss ); <span class="hljs-comment">// 如果“确定”按钮被按下，则显示 true</span></code></pre>
<h2 id="总结">总结</h2>
<p>我们学习了与用户交互的 3 个浏览器的特定函数：</p>
<p><code>alert</code>
: 显示信息。</p>
<p><code>prompt</code>
: 显示信息要求用户输入文本。点击确定返回文本，点击取消或按下 <code>key:Esc</code> 键返回 <code>null</code>。</p>
<p><code>confirm</code>
: 显示信息等待用户点击确定或取消。点击确定返回 <code>true</code>，点击取消或按下 <code>key:Esc</code> 键返回 <code>false</code>。</p>
<p>这些方法都是模态的：它们暂停脚本的执行，并且不允许用户与该页面的其余部分进行交互，直到窗口被解除。</p>
<p>上述所有方法共有两个限制：</p>
<ol>
<li>模态窗口的确切位置由浏览器决定。通常在页面中心。</li>
<li>窗口的确切外观也取决于浏览器。我们不能修改它。</li>
</ol>
<p>这就是简单的代价。还有其他一些方法可以显示更漂亮的窗口，并与用户进行更丰富的交互，但如果“花里胡哨”不是非常重要，那使用本节讲的这些方法也挺好。</p>

      </fieldset>
      
      <fieldset id='_y8MyRC'>
      <legend>article</legend>
      <h1 id="类型转换">类型转换</h1>
<p>大多数情况下，运算符和函数会自动将赋予它们的值转换为正确的类型。</p>
<p>比如，<code>alert</code> 会自动将任何值都转换为字符串以进行显示。算术运算符会将值转换为数字。</p>
<p>在某些情况下，我们需要将值显式地转换为我们期望的类型。</p>
<pre><code class="language-smart">在本章中，我们不会讨论 object 类型。目前，我们将只学习原始类型。

之后，在我们学习完 object 类型后，我们会在 &lt;info:object-toprimitive&gt; 一章中学习对象 — 原始值转换。</code></pre>
<h2 id="字符串转换">字符串转换</h2>
<p>当我们需要一个字符串形式的值时，就会进行字符串转换。</p>
<p>比如，<code>alert(value)</code> 将 <code>value</code> 转换为字符串类型，然后显示这个值。</p>
<p>我们也可以显式地调用 <code>String(value)</code> 来将 <code>value</code> 转换为字符串类型：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> value = <span class="hljs-literal">true</span>;
alert(<span class="hljs-keyword">typeof</span> value); <span class="hljs-comment">// boolean</span>

*!*
value = <span class="hljs-built_in">String</span>(value); <span class="hljs-comment">// 现在，值是一个字符串形式的 &quot;true&quot;</span>
alert(<span class="hljs-keyword">typeof</span> value); <span class="hljs-comment">// string</span>
*/!*</code></pre>
<p>字符串转换最明显。<code>false</code> 变成 <code>&quot;false&quot;</code>，<code>null</code> 变成 <code>&quot;null&quot;</code> 等。</p>
<h2 id="数字型转换">数字型转换</h2>
<p>在算术函数和表达式中，会自动进行 number 类型转换。</p>
<p>比如，当把除法 <code>/</code> 用于非 number 类型：</p>
<pre><code class="language-js">alert( <span class="hljs-string">&quot;6&quot;</span> / <span class="hljs-string">&quot;2&quot;</span> ); <span class="hljs-comment">// 3, string 类型的值被自动转换成 number 类型后进行计算</span></code></pre>
<p>我们也可以使用 <code>Number(value)</code> 显式地将这个 <code>value</code> 转换为 number 类型。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;123&quot;</span>;
alert(<span class="hljs-keyword">typeof</span> str); <span class="hljs-comment">// string</span>

<span class="hljs-keyword">let</span> num = <span class="hljs-built_in">Number</span>(str); <span class="hljs-comment">// 变成 number 类型 123</span>

alert(<span class="hljs-keyword">typeof</span> num); <span class="hljs-comment">// number</span></code></pre>
<p>当我们从 string 类型源（如文本表单）中读取一个值，但期望输入一个数字时，通常需要进行显式转换。</p>
<p>如果该字符串不是一个有效的数字，转换的结果会是 <code>NaN</code>。例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> age = <span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;an arbitrary string instead of a number&quot;</span>);

alert(age); <span class="hljs-comment">// NaN，转换失败</span></code></pre>
<p>number 类型转换规则：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>变成……</th>
</tr>
</thead>
<tbody><tr>
<td><code>undefined</code></td>
<td><code>NaN</code></td>
</tr>
<tr>
<td><code>null</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>true&nbsp;和&nbsp;false</code></td>
<td><code>1</code> and <code>0</code></td>
</tr>
<tr>
<td><code>string</code></td>
<td>去掉首尾空格后的纯数字字符串中含有的数字。如果剩余字符串为空，则转换结果为 <code>0</code>。否则，将会从剩余字符串中“读取”数字。当类型转换出现 error 时返回 <code>NaN</code>。</td>
</tr>
</tbody></table>
<p>例子：</p>
<pre><code class="language-js">alert( <span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;   123   &quot;</span>) ); <span class="hljs-comment">// 123</span>
alert( <span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;123z&quot;</span>) );      <span class="hljs-comment">// NaN（从字符串“读取”数字，读到 &quot;z&quot; 时出现错误）</span>
alert( <span class="hljs-built_in">Number</span>(<span class="hljs-literal">true</span>) );        <span class="hljs-comment">// 1</span>
alert( <span class="hljs-built_in">Number</span>(<span class="hljs-literal">false</span>) );       <span class="hljs-comment">// 0</span></code></pre>
<p>请注意 <code>null</code> 和 <code>undefined</code> 在这有点不同：<code>null</code> 变成数字 <code>0</code>，<code>undefined</code> 变成 <code>NaN</code>。</p>
<p>大多数数学运算符也执行这种转换，我们将在下一节中进行介绍。</p>
<h2 id="布尔型转换">布尔型转换</h2>
<p>布尔（boolean）类型转换是最简单的一个。</p>
<p>它发生在逻辑运算中（稍后我们将进行条件判断和其他类似的东西），但是也可以通过调用 Boolean(value) 显式地进行转换。</p>
<p>转换规则如下：</p>
<ul>
<li>直观上为“空”的值（如 <code>0</code>、空字符串、<code>null</code>、<code>undefined</code> 和 <code>NaN</code>）将变为 <code>false</code>。</li>
<li>其他值变成 <code>true</code>。</li>
</ul>
<p>比如：</p>
<pre><code class="language-js">alert( <span class="hljs-built_in">Boolean</span>(<span class="hljs-number">1</span>) ); <span class="hljs-comment">// true</span>
alert( <span class="hljs-built_in">Boolean</span>(<span class="hljs-number">0</span>) ); <span class="hljs-comment">// false</span>

alert( <span class="hljs-built_in">Boolean</span>(<span class="hljs-string">&quot;hello&quot;</span>) ); <span class="hljs-comment">// true</span>
alert( <span class="hljs-built_in">Boolean</span>(<span class="hljs-string">&quot;&quot;</span>) ); <span class="hljs-comment">// false</span></code></pre>
<p>````warn header=&quot;请注意：包含 0 的字符串 <code>\&quot;0\&quot;</code> 是 <code>true</code>&quot;
一些编程语言（比如 PHP）视 <code>&quot;0&quot;</code> 为 <code>false</code>。但在 JavaScript 中，非空的字符串总是 <code>true</code>。</p>
<pre><code class="language-js">alert( <span class="hljs-built_in">Boolean</span>(<span class="hljs-string">&quot;0&quot;</span>) ); <span class="hljs-comment">// true</span>
alert( <span class="hljs-built_in">Boolean</span>(<span class="hljs-string">&quot; &quot;</span>) ); <span class="hljs-comment">// 空白，也是 true（任何非空字符串都是 true）</span></code></pre>
<pre><code>
## 总结

有三种常用的类型转换：转换为 string 类型、转换为 number 类型和转换为 boolean 类型。

**字符串转换** —— 转换发生在输出内容的时候，也可以通过 `String(value)` 进行显式转换。原始类型值的 string 类型转换通常是很明显的。

**数字型转换** —— 转换发生在进行算术操作时，也可以通过 `Number(value)` 进行显式转换。

数字型转换遵循以下规则：

| 值 |  变成…… |
|-------|-------------|
| `undefined` | `NaN` |
| `null` | `0` |
| &lt;code&gt;true&amp;nbsp;/&amp;nbsp;false&lt;/code&gt; | `1 / 0` |
| `string` | “按原样读取”字符串，两端的空白会被忽略。空字符串变成 `0`。转换出错则输出 `NaN`。 |

**布尔型转换** —— 转换发生在进行逻辑操作时，也可以通过 `Boolean(value)` 进行显式转换。

布尔型转换遵循以下规则：

| 值 |  变成…… |
|-------|-------------|
| `0`, `null`, `undefined`, `NaN`, `&quot;&quot;` | `false` |
| 其他值 | `true` |


上述的大多数规则都容易理解和记忆。人们通常会犯错误的值得注意的例子有以下几个：

- 对 `undefined` 进行数字型转换时，输出结果为 `NaN`，而非 `0`。
- 对 `&quot;0&quot;` 和只有空格的字符串（比如：`&quot;   &quot;`）进行布尔型转换时，输出结果为 `true`。

我们在本小节没有讲 object 类型的转换。在我们学习完更多关于 JavaScript 的基础知识后，我们会在专门介绍 object 的章节 &lt;info:object-toprimitive&gt; 中详细讲解 object 类型转换。</code></pre>

      </fieldset>
      
      <fieldset id='_NZNRKZ'>
      <legend>solution</legend>
      <p>答案如下：</p>
<ul>
<li><code>a = 2</code></li>
<li><code>b = 2</code></li>
<li><code>c = 2</code></li>
<li><code>d = 1</code></li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">1</span>;

alert( ++a ); <span class="hljs-comment">// 2，前置运算符返回最新值</span>
alert( b++ ); <span class="hljs-comment">// 1，后置运算符返回旧值</span>

alert( a ); <span class="hljs-comment">// 2，自增一次</span>
alert( b ); <span class="hljs-comment">// 2，自增一次</span></code></pre>

      </fieldset>
      
      <fieldset id='_B0PlKf'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="后置运算符和前置运算符">后置运算符和前置运算符</h1>
<p>以下代码中变量 <code>a</code>、<code>b</code>、<code>c</code>、<code>d</code> 的最终值分别是多少？</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">1</span>;

<span class="hljs-keyword">let</span> c = ++a; <span class="hljs-comment">// ?</span>
<span class="hljs-keyword">let</span> d = b++; <span class="hljs-comment">// ?</span></code></pre>

      </fieldset>
      
      <fieldset id='_HyH0xt'>
      <legend>solution</legend>
      <p>答案如下：</p>
<ul>
<li><code>a = 4</code>（乘以 2）</li>
<li><code>x = 5</code>（相当于计算 1 + 4）</li>
</ul>

      </fieldset>
      
      <fieldset id='_88oiGN'>
      <legend>task</legend>
      <p>importance: 3</p>
<hr>
<h1 id="赋值结果">赋值结果</h1>
<p>下面这段代码运行完成后，代码中的 <code>a</code> 和 <code>x</code> 的值是多少？</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">2</span>;

<span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span> + (a *= <span class="hljs-number">2</span>);</code></pre>

      </fieldset>
      
      <fieldset id='_Q9Rky1'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-string">&quot;&quot;</span> + <span class="hljs-number">1</span> + <span class="hljs-number">0</span> = <span class="hljs-string">&quot;10&quot;</span> <span class="hljs-comment">// (1)</span>
<span class="hljs-string">&quot;&quot;</span> - <span class="hljs-number">1</span> + <span class="hljs-number">0</span> = -<span class="hljs-number">1</span> <span class="hljs-comment">// (2)</span>
<span class="hljs-literal">true</span> + <span class="hljs-literal">false</span> = <span class="hljs-number">1</span>
<span class="hljs-number">6</span> / <span class="hljs-string">&quot;3&quot;</span> = <span class="hljs-number">2</span>
<span class="hljs-string">&quot;2&quot;</span> * <span class="hljs-string">&quot;3&quot;</span> = <span class="hljs-number">6</span>
<span class="hljs-number">4</span> + <span class="hljs-number">5</span> + <span class="hljs-string">&quot;px&quot;</span> = <span class="hljs-string">&quot;9px&quot;</span>
<span class="hljs-string">&quot;$&quot;</span> + <span class="hljs-number">4</span> + <span class="hljs-number">5</span> = <span class="hljs-string">&quot;$45&quot;</span>
<span class="hljs-string">&quot;4&quot;</span> - <span class="hljs-number">2</span> = <span class="hljs-number">2</span>
<span class="hljs-string">&quot;4px&quot;</span> - <span class="hljs-number">2</span> = <span class="hljs-literal">NaN</span>
<span class="hljs-number">7</span> / <span class="hljs-number">0</span> = <span class="hljs-literal">Infinity</span>
<span class="hljs-string">&quot;  -9  &quot;</span> + <span class="hljs-number">5</span> = <span class="hljs-string">&quot;  -9  5&quot;</span> <span class="hljs-comment">// (3)</span>
<span class="hljs-string">&quot;  -9  &quot;</span> - <span class="hljs-number">5</span> = -<span class="hljs-number">14</span> <span class="hljs-comment">// (4)</span>
<span class="hljs-literal">null</span> + <span class="hljs-number">1</span> = <span class="hljs-number">1</span> <span class="hljs-comment">// (5)</span>
<span class="hljs-literal">undefined</span> + <span class="hljs-number">1</span> = <span class="hljs-literal">NaN</span> <span class="hljs-comment">// (6)</span>
<span class="hljs-string">&quot; \t \n&quot;</span> - <span class="hljs-number">2</span> = -<span class="hljs-number">2</span> <span class="hljs-comment">// (7)</span></code></pre>
<ol>
<li>有字符串的加法 <code>&quot;&quot; + 1</code>，首先会将数字 <code>1</code> 转换为一个字符串：<code>&quot;&quot; + 1 = &quot;1&quot;</code>，然后我们得到 <code>&quot;1&quot; + 0</code>，再次应用同样的规则得到最终的结果。</li>
<li>减法 <code>-</code>（像大多数数学运算一样）只能用于数字，它会使空字符串 <code>&quot;&quot;</code> 转换为 <code>0</code>。</li>
<li>带字符串的加法会将数字 <code>5</code> 加到字符串之后。</li>
<li>减法始终将字符串转换为数字，因此它会使 <code>&quot; -9  &quot;</code> 转换为数字 <code>-9</code>（忽略了字符串首尾的空格）。</li>
<li><code>null</code> 经过数字转换之后会变为 <code>0</code>。</li>
<li><code>undefined</code> 经过数字转换之后会变为 <code>NaN</code>。</li>
<li>字符串转换为数字时，会忽略字符串的首尾处的空格字符。在这里，整个字符串由空格字符组成，包括 <code>\t</code>、<code>\n</code> 以及它们之间的“常规”空格。因此，类似于空字符串，所以会变为 <code>0</code>。</li>
</ol>

      </fieldset>
      
      <fieldset id='_IGZXiZ'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="类型转换">类型转换</h1>
<p>下面这些表达式的结果是什么？</p>
<pre><code class="language-js"><span class="hljs-string">&quot;&quot;</span> + <span class="hljs-number">1</span> + <span class="hljs-number">0</span>
<span class="hljs-string">&quot;&quot;</span> - <span class="hljs-number">1</span> + <span class="hljs-number">0</span>
<span class="hljs-literal">true</span> + <span class="hljs-literal">false</span>
<span class="hljs-number">6</span> / <span class="hljs-string">&quot;3&quot;</span>
<span class="hljs-string">&quot;2&quot;</span> * <span class="hljs-string">&quot;3&quot;</span>
<span class="hljs-number">4</span> + <span class="hljs-number">5</span> + <span class="hljs-string">&quot;px&quot;</span>
<span class="hljs-string">&quot;$&quot;</span> + <span class="hljs-number">4</span> + <span class="hljs-number">5</span>
<span class="hljs-string">&quot;4&quot;</span> - <span class="hljs-number">2</span>
<span class="hljs-string">&quot;4px&quot;</span> - <span class="hljs-number">2</span>
<span class="hljs-number">7</span> / <span class="hljs-number">0</span>
<span class="hljs-string">&quot;  -9  &quot;</span> + <span class="hljs-number">5</span>
<span class="hljs-string">&quot;  -9  &quot;</span> - <span class="hljs-number">5</span>
<span class="hljs-literal">null</span> + <span class="hljs-number">1</span>
<span class="hljs-literal">undefined</span> + <span class="hljs-number">1</span>
<span class="hljs-string">&quot; \t \n&quot;</span> - <span class="hljs-number">2</span></code></pre>
<p>好好思考一下，把它们写下来然后和答案比较一下。</p>

      </fieldset>
      
      <fieldset id='_911s06'>
      <legend>solution</legend>
      <p>原因是 prompt 以字符串的形式返回用户的输入。</p>
<p>所以变量的值分别为 <code>&quot;1&quot;</code> 和 <code>&quot;2&quot;</code>。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> a = <span class="hljs-string">&quot;1&quot;</span>; <span class="hljs-comment">// prompt(&quot;First number?&quot;, 1);</span>
<span class="hljs-keyword">let</span> b = <span class="hljs-string">&quot;2&quot;</span>; <span class="hljs-comment">// prompt(&quot;Second number?&quot;, 2);</span>

alert(a + b); <span class="hljs-comment">// 12</span></code></pre>
<p>我们应该做的是，在 <code>+</code> 之前将字符串转换为数字。例如，使用 <code>Number()</code> 或在 <code>prompt</code> 前加 <code>+</code>。</p>
<p>例如，就在 <code>prompt</code> 之前加 <code>+</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> a = +prompt(<span class="hljs-string">&quot;First number?&quot;</span>, <span class="hljs-number">1</span>);
<span class="hljs-keyword">let</span> b = +prompt(<span class="hljs-string">&quot;Second number?&quot;</span>, <span class="hljs-number">2</span>);

alert(a + b); <span class="hljs-comment">// 3</span></code></pre>
<p>或在 <code>alert</code> 中：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> a = prompt(<span class="hljs-string">&quot;First number?&quot;</span>, <span class="hljs-number">1</span>);
<span class="hljs-keyword">let</span> b = prompt(<span class="hljs-string">&quot;Second number?&quot;</span>, <span class="hljs-number">2</span>);

alert(+a + +b); <span class="hljs-comment">// 3</span></code></pre>
<p>在最新的代码中，同时使用一元和二元的 <code>+</code>。看起来很有趣，不是吗？</p>

      </fieldset>
      
      <fieldset id='_ayoYcn'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="修正加法">修正加法</h1>
<p>这里有一段代码，要求用户输入两个数字并显示它们的总和。</p>
<p>它的运行结果不正确。下面例子中的输出是 <code>12</code>（对于默认的 prompt 的值）。</p>
<p>为什么会这样？修正它。结果应该是 <code>3</code>。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> a = prompt(<span class="hljs-string">&quot;First number?&quot;</span>, <span class="hljs-number">1</span>);
<span class="hljs-keyword">let</span> b = prompt(<span class="hljs-string">&quot;Second number?&quot;</span>, <span class="hljs-number">2</span>);

alert(a + b); <span class="hljs-comment">// 12</span></code></pre>

      </fieldset>
      
      <fieldset id='_o7ERDQ'>
      <legend>article</legend>
      <h1 id="基础运算符，数学">基础运算符，数学</h1>
<p>我们从学校里了解到过很多运算符，比如说加号 <code>+</code>、乘号 <code>*</code>、减号 <code>-</code> 等。</p>
<p>在本章中，我们将从简单的运算符开始，然后着重介绍 JavaScript 特有的方面，这些是在学校中学习的数学所没有涵盖的。</p>
<h2 id="术语：一元运算符，二元运算符，运算元">术语：“一元运算符”，“二元运算符”，“运算元”</h2>
<p>在正式开始前，我们先简单浏览一下常用术语。</p>
<ul>
<li><p><strong>运算元</strong> —— 运算符应用的对象。比如说乘法运算 <code>5 * 2</code>，有两个运算元：左运算元 <code>5</code> 和右运算元 <code>2</code>。有时候人们也称其为“参数”而不是“运算元”。</p>
</li>
<li><p>如果一个运算符对应的只有一个运算元，那么它是 <strong>一元运算符</strong>。比如说一元负号运算符（unary negation）<code>-</code>，它的作用是对数字进行正负转换：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;

*!*
x = -x;
*/!*
alert( x ); <span class="hljs-comment">// -1，一元负号运算符生效</span></code></pre>
</li>
<li><p>如果一个运算符拥有两个运算元，那么它是 <strong>二元运算符</strong>。减号还存在二元运算符形式：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>, y = <span class="hljs-number">3</span>;
alert( y - x ); <span class="hljs-comment">// 2，二元运算符减号做减运算</span></code></pre>
<p>  严格地说，在上面的示例中，我们使用一个相同的符号表征了两个不同的运算符：负号运算符，即反转符号的一元运算符，减法运算符，是从另一个数减去一个数的二元运算符。</p>
</li>
</ul>
<h2 id="数学">数学</h2>
<p>支持以下数学运算：</p>
<ul>
<li>加法 <code>+</code>,</li>
<li>减法 <code>-</code>,</li>
<li>乘法 <code>*</code>,</li>
<li>除法 <code>/</code>,</li>
<li>取余 <code>%</code>,</li>
<li>求幂 <code>**</code>.</li>
</ul>
<p>前四个都很简单，而 <code>%</code> 和 <code>**</code> 则需要说一说。</p>
<h3 id="取余-">取余 %</h3>
<p>取余运算符是 <code>%</code>，尽管它看起来很像百分数，但实际并无关联。</p>
<p><code>a % b</code> 的结果是 <code>a</code> 整除 <code>b</code> 的 <a href="https://zh.wikipedia.org/zh-hans/%E4%BD%99%E6%95%B0">余数</a>)。</p>
<p>例如：</p>
<pre><code class="language-js">alert( <span class="hljs-number">5</span> % <span class="hljs-number">2</span> ); <span class="hljs-comment">// 1，5 除以 2 的余数</span>
alert( <span class="hljs-number">8</span> % <span class="hljs-number">3</span> ); <span class="hljs-comment">// 2，8 除以 3 的余数</span></code></pre>
<h3 id="求幂-">求幂 **</h3>
<p>求幂运算 <code>a ** b</code> 是 <code>a</code> 乘以自身 <code>b</code> 次。</p>
<p>例如：</p>
<pre><code class="language-js">alert( <span class="hljs-number">2</span> ** <span class="hljs-number">2</span> ); <span class="hljs-comment">// 4  (2 * 2，自乘 2 次)</span>
alert( <span class="hljs-number">2</span> ** <span class="hljs-number">3</span> ); <span class="hljs-comment">// 8  (2 * 2 * 2，自乘 3 次)</span>
alert( <span class="hljs-number">2</span> ** <span class="hljs-number">4</span> ); <span class="hljs-comment">// 16 (2 * 2 * 2 * 2，自乘 4 次)</span></code></pre>
<p>在数学上，求幂的定义也适用于非整数。例如，平方根是以 <code>1/2</code> 为单位的求幂：</p>
<pre><code class="language-js">alert( <span class="hljs-number">4</span> ** (<span class="hljs-number">1</span>/<span class="hljs-number">2</span>) ); <span class="hljs-comment">// 2（1/2 次方与平方根相同)</span>
alert( <span class="hljs-number">8</span> ** (<span class="hljs-number">1</span>/<span class="hljs-number">3</span>) ); <span class="hljs-comment">// 2（1/3 次方与立方根相同)</span></code></pre>
<h2 id="用二元运算符--连接字符串">用二元运算符 + 连接字符串</h2>
<p>我们来看一些学校算术未涉及的 JavaScript 运算符的特性。</p>
<p>通常，加号 <code>+</code> 用于求和。</p>
<p>但是如果加号 <code>+</code> 被应用于字符串，它将合并（连接）各个字符串：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;my&quot;</span> + <span class="hljs-string">&quot;string&quot;</span>;
alert(s); <span class="hljs-comment">// mystring</span></code></pre>
<p>注意：只要任意一个运算元是字符串，那么另一个运算元也将被转化为字符串。</p>
<p>举个例子：</p>
<pre><code class="language-js">alert( <span class="hljs-string">&#x27;1&#x27;</span> + <span class="hljs-number">2</span> ); <span class="hljs-comment">// &quot;12&quot;</span>
alert( <span class="hljs-number">2</span> + <span class="hljs-string">&#x27;1&#x27;</span> ); <span class="hljs-comment">// &quot;21&quot;</span></code></pre>
<p>你看，第一个运算元和第二个运算元，哪个是字符串并不重要。</p>
<p>下面是一个更复杂的例子：</p>
<pre><code class="language-js">alert(<span class="hljs-number">2</span> + <span class="hljs-number">2</span> + <span class="hljs-string">&#x27;1&#x27;</span> ); <span class="hljs-comment">// &quot;41&quot;，不是 &quot;221&quot;</span></code></pre>
<p>在这里，运算符是按顺序工作。第一个 <code>+</code> 将两个数字相加，所以返回 <code>4</code>，然后下一个 <code>+</code> 将字符串 <code>1</code> 加入其中，所以就是 <code>4 + &#39;1&#39; = 41</code>。</p>
<p>二元 <code>+</code> 是唯一一个以这种方式支持字符串的运算符。其他算术运算符只对数字起作用，并且总是将其运算元转换为数字。</p>
<p>下面是减法和除法运算的示例：</p>
<pre><code class="language-js">alert( <span class="hljs-number">6</span> - <span class="hljs-string">&#x27;2&#x27;</span> ); <span class="hljs-comment">// 4，将 &#x27;2&#x27; 转换为数字</span>
alert( <span class="hljs-string">&#x27;6&#x27;</span> / <span class="hljs-string">&#x27;2&#x27;</span> ); <span class="hljs-comment">// 3，将两个运算元都转换为数字</span></code></pre>
<h2 id="数字转化，一元运算符-">数字转化，一元运算符 +</h2>
<p>加号 <code>+</code> 有两种形式。一种是上面我们刚刚讨论的二元运算符，还有一种是一元运算符。</p>
<p>一元运算符加号，或者说，加号 <code>+</code> 应用于单个值，对数字没有任何作用。但是如果运算元不是数字，加号 <code>+</code> 则会将其转化为数字。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-comment">// 对数字无效</span>
<span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;
alert( +x ); <span class="hljs-comment">// 1</span>

<span class="hljs-keyword">let</span> y = -<span class="hljs-number">2</span>;
alert( +y ); <span class="hljs-comment">// -2</span>

*!*
<span class="hljs-comment">// 转化非数字</span>
alert( +<span class="hljs-literal">true</span> ); <span class="hljs-comment">// 1</span>
alert( +<span class="hljs-string">&quot;&quot;</span> );   <span class="hljs-comment">// 0</span>
*/!*</code></pre>
<p>它的效果和 <code>Number(...)</code> 相同，但是更加简短。</p>
<p>我们经常会有将字符串转化为数字的需求。比如，如果我们正在从 HTML 表单中取值，通常得到的都是字符串。如果我们想对它们求和，该怎么办？</p>
<p>二元运算符加号会把它们合并成字符串：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> apples = <span class="hljs-string">&quot;2&quot;</span>;
<span class="hljs-keyword">let</span> oranges = <span class="hljs-string">&quot;3&quot;</span>;

alert( apples + oranges ); <span class="hljs-comment">// &quot;23&quot;，二元运算符加号合并字符串</span></code></pre>
<p>如果我们想把它们当做数字对待，我们需要转化它们，然后再求和：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> apples = <span class="hljs-string">&quot;2&quot;</span>;
<span class="hljs-keyword">let</span> oranges = <span class="hljs-string">&quot;3&quot;</span>;

*!*
<span class="hljs-comment">// 在二元运算符加号起作用之前，所有的值都被转化为了数字</span>
alert( +apples + +oranges ); <span class="hljs-comment">// 5</span>
*/!*

<span class="hljs-comment">// 更长的写法</span>
<span class="hljs-comment">// alert( Number(apples) + Number(oranges) ); // 5</span></code></pre>
<p>从一个数学家的视角来看，大量的加号可能很奇怪。但是从一个程序员的视角，没什么好奇怪的：一元运算符加号首先起作用，它们将字符串转为数字，然后二元运算符加号对它们进行求和。</p>
<p>为什么一元运算符先于二元运算符作用于运算元？接下去我们将讨论到，这是由于它们拥有 <strong>更高的优先级</strong>。</p>
<h2 id="运算符优先级">运算符优先级</h2>
<p>如果一个表达式拥有超过一个运算符，执行的顺序则由 <strong>优先级</strong> 决定。换句话说，所有的运算符中都隐含着优先级顺序。</p>
<p>从小学开始，我们就知道在表达式 <code>1 + 2 * 2</code> 中，乘法先于加法计算。这就是一个优先级问题。乘法比加法拥有 <strong>更高的优先级</strong>。</p>
<p>圆括号拥有最高优先级，所以如果我们对现有的运算顺序不满意，我们可以使用圆括号来修改运算顺序，就像这样：<code>(1 + 2) * 2</code>。</p>
<p>在 JavaScript 中有众多运算符。每个运算符都有对应的优先级数字。数字越大，越先执行。如果优先级相同，则按照由左至右的顺序执行。</p>
<p>这是一个摘抄自 Mozilla 的 <a href="https://developer.mozilla.org/en/JavaScript/Reference/operators/operator_precedence">优先级表</a>（你没有必要把这全记住，但要记住一元运算符优先级高于二元运算符）：</p>
<table>
<thead>
<tr>
<th>优先级</th>
<th>名称</th>
<th>符号</th>
</tr>
</thead>
<tbody><tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td>17</td>
<td>一元加号</td>
<td><code>+</code></td>
</tr>
<tr>
<td>17</td>
<td>一元负号</td>
<td><code>-</code></td>
</tr>
<tr>
<td>16</td>
<td>求幂</td>
<td><code>**</code></td>
</tr>
<tr>
<td>15</td>
<td>乘号</td>
<td><code>*</code></td>
</tr>
<tr>
<td>15</td>
<td>除号</td>
<td><code>/</code></td>
</tr>
<tr>
<td>13</td>
<td>加号</td>
<td><code>+</code></td>
</tr>
<tr>
<td>13</td>
<td>减号</td>
<td><code>-</code></td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td>3</td>
<td>赋值符</td>
<td><code>=</code></td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody></table>
<p>我们可以看到，“一元加号运算符”的优先级是 <code>17</code>，高于“二元加号运算符”的优先级 <code>13</code>。这也是为什么表达式 <code>&quot;+apples + +oranges&quot;</code> 中的一元加号先生效，然后才是二元加法。</p>
<h2 id="赋值运算符">赋值运算符</h2>
<p>我们知道赋值符号 <code>=</code> 也是一个运算符。从优先级表中可以看到它的优先级非常低，只有 <code>3</code>。</p>
<p>这也是为什么，当我们赋值时，比如 <code>x = 2 * 2 + 1</code>，所有的计算先执行，然后 <code>=</code> 才执行，将计算结果存储到 <code>x</code>。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> x = <span class="hljs-number">2</span> * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;

alert( x ); <span class="hljs-comment">// 5</span></code></pre>
<h3 id="赋值--返回一个值">赋值 = 返回一个值</h3>
<p><code>=</code> 是一个运算符，而不是一个有着“魔法”作用的语言结构。</p>
<p>在 JavaScript 中，大多数运算符都会返回一个值。这对于 <code>+</code> 和 <code>-</code> 来说是显而易见的，但对于 <code>=</code> 来说也是如此。</p>
<p>语句 <code>x = value</code> 将值 <code>value</code> 写入 <code>x</code> <strong>然后返回 x</strong>。</p>
<p>下面是一个在复杂语句中使用赋值的例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;
<span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span>;

*!*
<span class="hljs-keyword">let</span> c = <span class="hljs-number">3</span> - (a = b + <span class="hljs-number">1</span>);
*/!*

alert( a ); <span class="hljs-comment">// 3</span>
alert( c ); <span class="hljs-comment">// 0</span></code></pre>
<p>上面这个例子，<code>(a = b + 1)</code> 的结果是赋给 <code>a</code> 的值（也就是 <code>3</code>）。然后该值被用于进一步的运算。</p>
<p>有趣的代码，不是吗？我们应该了解它的工作原理，因为有时我们会在 JavaScript 库中看到它。</p>
<p>不过，请不要写这样的代码。这样的技巧绝对不会使代码变得更清晰或可读。</p>
<h3 id="链式赋值（chaining-assignments）">链式赋值（Chaining assignments）</h3>
<p>另一个有趣的特性是链式赋值：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> a, b, c;

*!*
a = b = c = <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;
*/!*

alert( a ); <span class="hljs-comment">// 4</span>
alert( b ); <span class="hljs-comment">// 4</span>
alert( c ); <span class="hljs-comment">// 4</span></code></pre>
<p>链式赋值从右到左进行计算。首先，对最右边的表达式 <code>2 + 2</code> 求值，然后将其赋给左边的变量：<code>c</code>、<code>b</code> 和 <code>a</code>。最后，所有的变量共享一个值。</p>
<p>同样，出于可读性，最好将这种代码分成几行：</p>
<pre><code class="language-js">c = <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;
b = c;
a = c;</code></pre>
<p>这样可读性更强，尤其是在快速浏览代码的时候。</p>
<h2 id="原地修改">原地修改</h2>
<p>我们经常需要对一个变量做运算，并将新的结果存储在同一个变量中。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> n = <span class="hljs-number">2</span>;
n = n + <span class="hljs-number">5</span>;
n = n * <span class="hljs-number">2</span>;</code></pre>
<p>可以使用运算符 <code>+=</code> 和 <code>*=</code> 来缩写这种表示。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> n = <span class="hljs-number">2</span>;
n += <span class="hljs-number">5</span>; <span class="hljs-comment">// 现在 n = 7（等同于 n = n + 5）</span>
n *= <span class="hljs-number">2</span>; <span class="hljs-comment">// 现在 n = 14（等同于 n = n * 2）</span>

alert( n ); <span class="hljs-comment">// 14</span></code></pre>
<p>所有算术和位运算符都有简短的“修改并赋值”运算符：<code>/=</code> 和 <code>-=</code> 等。</p>
<p>这类运算符的优先级与普通赋值运算符的优先级相同，所以它们在大多数其他运算之后执行：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> n = <span class="hljs-number">2</span>;

n *= <span class="hljs-number">3</span> + <span class="hljs-number">5</span>;

alert( n ); <span class="hljs-comment">// 16 （右边部分先被计算，等同于 n *= 8）</span></code></pre>
<h2 id="自增自减">自增/自减</h2>
<!-- 在标题中无法写出 --，因为内置的解析器会将其转换为“长破折号” —— -->

<p>对一个数进行加一、减一是最常见的数学运算符之一。</p>
<p>所以，对此有一些专门的运算符：</p>
<ul>
<li><p><strong>自增</strong> <code>++</code> 将变量与 1 相加：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> counter = <span class="hljs-number">2</span>;
counter++;      <span class="hljs-comment">// 和 counter = counter + 1 效果一样，但是更简洁</span>
alert( counter ); <span class="hljs-comment">// 3</span></code></pre>
</li>
<li><p><strong>自减</strong> <code>--</code> 将变量与 1 相减：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> counter = <span class="hljs-number">2</span>;
counter--;      <span class="hljs-comment">// 和 counter = counter - 1 效果一样，但是更简洁</span>
alert( counter ); <span class="hljs-comment">// 1</span></code></pre>
</li>
</ul>
<pre><code class="language-warn">自增/自减只能应用于变量。试一下，将其应用于数值（比如 `5++`）则会报错。</code></pre>
<p>运算符 <code>++</code> 和 <code>--</code> 可以置于变量前，也可以置于变量后。</p>
<ul>
<li>当运算符置于变量后，被称为“后置形式”：<code>counter++</code>。</li>
<li>当运算符置于变量前，被称为“前置形式”：<code>++counter</code>。</li>
</ul>
<p>两者都做同一件事：将变量 <code>counter</code> 与 <code>1</code> 相加。</p>
<p>那么它们有区别吗？有，但只有当我们使用 <code>++/--</code> 的返回值时才能看到区别。</p>
<p>详细点说。我们知道，所有的运算符都有返回值。自增/自减也不例外。前置形式返回一个新的值，但后置返回原来的值（做加法/减法之前的值）。</p>
<p>为了直观看到区别，看下面的例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> counter = <span class="hljs-number">1</span>;
<span class="hljs-keyword">let</span> a = ++counter; <span class="hljs-comment">// (*)</span>

alert(a); <span class="hljs-comment">// *!*2*/!*</span></code></pre>
<p><code>(*)</code> 所在的行是前置形式 <code>++counter</code>，对 <code>counter</code> 做自增运算，返回的是新的值 <code>2</code>。因此 <code>alert</code> 显示的是 <code>2</code>。</p>
<p>下面让我们看看后置形式：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> counter = <span class="hljs-number">1</span>;
<span class="hljs-keyword">let</span> a = counter++; <span class="hljs-comment">// (*) 将 ++counter 改为 counter++</span>

alert(a); <span class="hljs-comment">// *!*1*/!*</span></code></pre>
<p><code>(*)</code> 所在的行是后置形式 <code>counter++</code>，它同样对 <code>counter</code> 做加法，但是返回的是 <strong>旧值</strong>（做加法之前的值）。因此 <code>alert</code> 显示的是 <code>1</code>。</p>
<p>总结：</p>
<ul>
<li><p>如果自增/自减的值不会被使用，那么两者形式没有区别：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;
counter++;
++counter;
alert( counter ); <span class="hljs-comment">// 2，以上两行作用相同</span></code></pre>
</li>
<li><p>如果我们想要对变量进行自增操作，<strong>并且</strong> 需要立刻使用自增后的值，那么我们需要使用前置形式：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;
alert( ++counter ); <span class="hljs-comment">// 1</span></code></pre>
</li>
<li><p>如果我们想要将一个数加一，但是我们想使用其自增之前的值，那么我们需要使用后置形式：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;
alert( counter++ ); <span class="hljs-comment">// 0</span></code></pre>
</li>
</ul>
<pre><code class="language-smart">`++/--` 运算符同样可以在表达式内部使用。它们的优先级比绝大部分的算数运算符要高。

举个例子：

```js run
let counter = 1;
alert( 2 * ++counter ); // 4
```

与下方例子对比：

```js run
let counter = 1;
alert( 2 * counter++ ); // 2，因为 counter++ 返回的是“旧值”
```

尽管从技术层面上来说可行，但是这样的写法会降低代码的可阅读性。在一行上做多个操作 —— 这样并不好。

当阅读代码时，快速的视觉“纵向”扫描会很容易漏掉 `counter++`，这样的自增操作并不明显。

我们建议用“一行一个行为”的模式：

```js run
let counter = 1;
alert( 2 * counter );
counter++;
```</code></pre>
<h2 id="位运算符">位运算符</h2>
<p>位运算符把运算元当做 32 位整数，并在它们的二进制表现形式上操作。</p>
<p>这些运算符不是 JavaScript 特有的。大部分的编程语言都支持这些运算符。</p>
<p>下面是位运算符：</p>
<ul>
<li>按位与 ( <code>&amp;</code> )</li>
<li>按位或 ( <code>|</code> )</li>
<li>按位异或 ( <code>^</code> )</li>
<li>按位非 ( <code>~</code> )</li>
<li>左移 ( <code>&lt;&lt;</code> )</li>
<li>右移 ( <code>&gt;&gt;</code> )</li>
<li>无符号右移 ( <code>&gt;&gt;&gt;</code> )</li>
</ul>
<p>这些运算符很少被使用，一般是我们需要在最低级别（位）上操作数字时才使用。我们不会很快用到这些运算符，因为在 Web 开发中很少使用它们，但在某些特殊领域中，例如密码学，它们很有用。当你需要了解它们的时候，可以阅读 MDN 上的 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators">位操作符</a> 一文。</p>
<h2 id="逗号运算符">逗号运算符</h2>
<p>逗号运算符 <code>,</code> 是最少见最不常使用的运算符之一。有时候它会被用来写更简短的代码，因此为了能够理解代码，我们需要了解它。</p>
<p>逗号运算符能让我们处理多个语句，使用 <code>,</code> 将它们分开。每个语句都运行了，但是只有最后的语句的结果会被返回。</p>
<p>举个例子：</p>
<pre><code class="language-js">*!*
<span class="hljs-keyword">let</span> a = (<span class="hljs-number">1</span> + <span class="hljs-number">2</span>, <span class="hljs-number">3</span> + <span class="hljs-number">4</span>);
*/!*

alert( a ); <span class="hljs-comment">// 7（3 + 4 的结果）</span></code></pre>
<p>这里，第一个语句 <code>1 + 2</code> 运行了，但是它的结果被丢弃了。随后计算 <code>3 + 4</code>，并且该计算结果被返回。</p>
<pre><code class="language-smart">请注意逗号运算符的优先级非常低，比 `=` 还要低，因此上面你的例子中圆括号非常重要。

如果没有圆括号：`a = 1 + 2, 3 + 4` 会先执行 `+`，将数值相加得到 `a = 3, 7`，然后赋值运算符 `=` 执行, &#x27;a = 3&#x27;，然后逗号之后的数值 `7` 不会再执行，它被忽略掉了。相当于 `(a = 1 + 2), 3 + 4`。</code></pre>
<p>为什么我们需要这样一个运算符，它只返回最后一个值呢？</p>
<p>有时候，人们会使用它把几个行为放在一行上来进行复杂的运算。</p>
<p>举个例子：</p>
<pre><code class="language-js"><span class="hljs-comment">// 一行上有三个运算符</span>
<span class="hljs-keyword">for</span> (*!*a = <span class="hljs-number">1</span>, b = <span class="hljs-number">3</span>, c = a * b*/!*; a &lt; <span class="hljs-number">10</span>; a++) {
 ...
}</code></pre>
<p>这样的技巧在许多 JavaScript 框架中都有使用，这也是为什么我们提到它。但是通常它并不能提升代码的可读性，使用它之前，我们要想清楚。</p>

      </fieldset>
      
      <fieldset id='_cKj2rW'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-number">5</span> &gt; <span class="hljs-number">4</span> → <span class="hljs-literal">true</span>
<span class="hljs-string">&quot;apple&quot;</span> &gt; <span class="hljs-string">&quot;pineapple&quot;</span> → <span class="hljs-literal">false</span>
<span class="hljs-string">&quot;2&quot;</span> &gt; <span class="hljs-string">&quot;12&quot;</span> → <span class="hljs-literal">true</span>
<span class="hljs-literal">undefined</span> == <span class="hljs-literal">null</span> → <span class="hljs-literal">true</span>
<span class="hljs-literal">undefined</span> === <span class="hljs-literal">null</span> → <span class="hljs-literal">false</span>
<span class="hljs-literal">null</span> == <span class="hljs-string">&quot;\n0\n&quot;</span> → <span class="hljs-literal">false</span>
<span class="hljs-literal">null</span> === +<span class="hljs-string">&quot;\n0\n&quot;</span> → <span class="hljs-literal">false</span></code></pre>
<p>结果的原因：</p>
<ol>
<li>数字间比较大小，显然得 true。</li>
<li>按词典顺序比较，得 false。<code>&quot;a&quot;</code> 比 <code>&quot;p&quot;</code> 小。</li>
<li>与第 2 题同理，首位字符 <code>&quot;2&quot;</code> 大于 <code>&quot;1&quot;</code>。</li>
<li><code>null</code> 只与 <code>undefined</code> 互等。</li>
<li>严格相等模式下，类型不同得 false。</li>
<li>与第 4 题同理，<code>null</code> 只与 <code>undefined</code> 相等。</li>
<li>不同类型严格不相等。</li>
</ol>

      </fieldset>
      
      <fieldset id='_92L5AQ'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="值的比较">值的比较</h1>
<p>以下表达式的执行结果是？</p>
<pre><code class="language-js"><span class="hljs-number">5</span> &gt; <span class="hljs-number">4</span>
<span class="hljs-string">&quot;apple&quot;</span> &gt; <span class="hljs-string">&quot;pineapple&quot;</span>
<span class="hljs-string">&quot;2&quot;</span> &gt; <span class="hljs-string">&quot;12&quot;</span>
<span class="hljs-literal">undefined</span> == <span class="hljs-literal">null</span>
<span class="hljs-literal">undefined</span> === <span class="hljs-literal">null</span>
<span class="hljs-literal">null</span> == <span class="hljs-string">&quot;\n0\n&quot;</span>
<span class="hljs-literal">null</span> === +<span class="hljs-string">&quot;\n0\n&quot;</span></code></pre>

      </fieldset>
      
      <fieldset id='_AzJTmQ'>
      <legend>article</legend>
      <h1 id="值的比较">值的比较</h1>
<p>我们知道，在数学中有很多用于比较大小的运算符。</p>
<p>在 JavaScript 中，它们的编写方式如下：</p>
<ul>
<li>大于 / 小于：<code>a &gt; b</code>，<code>a &lt; b</code>。</li>
<li>大于等于 / 小于等于：<code>a &gt;= b</code>，<code>a &lt;= b</code>。</li>
<li>检查两个值的相等：<code>a == b</code>，请注意双等号 <code>==</code> 表示相等性检查，而单等号 <code>a = b</code> 表示赋值。</li>
<li>检查两个值不相等。不相等在数学中的符号是 <code>&ne;</code>，但在 JavaScript 中写成 <code>a != b</code>。</li>
</ul>
<p>在本文中，我们将进一步了解不同类型的比较，JavaScript 是如何进行比较的，包括一些重要的特殊性。</p>
<p>在文末给出了一些秘诀，帮助你避免“javascript 陷阱”相关的问题。</p>
<h2 id="比较结果为-boolean-类型">比较结果为 Boolean 类型</h2>
<p>所有比较运算符均返回布尔值：</p>
<ul>
<li><code>true</code> —— 表示“yes（是）”，“correct（正确）”或“the truth（真）”。</li>
<li><code>false</code> ——  表示“no（否）”，“wrong（错误）”或“not the truth（非真）”。</li>
</ul>
<p>示例：</p>
<pre><code class="language-js">alert( <span class="hljs-number">2</span> &gt; <span class="hljs-number">1</span> );  <span class="hljs-comment">// true（正确）</span>
alert( <span class="hljs-number">2</span> == <span class="hljs-number">1</span> ); <span class="hljs-comment">// false（错误）</span>
alert( <span class="hljs-number">2</span> != <span class="hljs-number">1</span> ); <span class="hljs-comment">// true（正确）</span></code></pre>
<p>和其他类型的值一样，比较的结果可以被赋值给任意变量：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> result = <span class="hljs-number">5</span> &gt; <span class="hljs-number">4</span>; <span class="hljs-comment">// 把比较的结果赋值给 result</span>
alert( result ); <span class="hljs-comment">// true</span></code></pre>
<h2 id="字符串比较">字符串比较</h2>
<p>在比较字符串的大小时，JavaScript 会使用“字典（dictionary）”或“词典（lexicographical）”顺序进行判定。</p>
<p>换言之，字符串是按字符（母）逐个进行比较的。</p>
<p>例如：</p>
<pre><code class="language-js">alert( <span class="hljs-string">&#x27;Z&#x27;</span> &gt; <span class="hljs-string">&#x27;A&#x27;</span> ); <span class="hljs-comment">// true</span>
alert( <span class="hljs-string">&#x27;Glow&#x27;</span> &gt; <span class="hljs-string">&#x27;Glee&#x27;</span> ); <span class="hljs-comment">// true</span>
alert( <span class="hljs-string">&#x27;Bee&#x27;</span> &gt; <span class="hljs-string">&#x27;Be&#x27;</span> ); <span class="hljs-comment">// true</span></code></pre>
<p>字符串的比较算法非常简单：</p>
<ol>
<li>首先比较两个字符串的首位字符大小。</li>
<li>如果一方字符较大（或较小），则该字符串大于（或小于）另一个字符串。算法结束。</li>
<li>否则，如果两个字符串的首位字符相等，则继续取出两个字符串各自的后一位字符进行比较。</li>
<li>重复上述步骤进行比较，直到比较完成某字符串的所有字符为止。</li>
<li>如果两个字符串的字符同时用完，那么则判定它们相等，否则未结束（还有未比较的字符）的字符串更大。</li>
</ol>
<p>在上面的例子中，<code>&#39;Z&#39; &gt; &#39;A&#39;</code> 在算法的第 1 步就得到了返回结果，而字符串 <code>Glow</code> 与 <code>Glee</code> 则继续逐个字符比较：</p>
<ol>
<li><code>G</code> 和 <code>G</code> 相等。</li>
<li><code>l</code> 和 <code>l</code> 相等。</li>
<li><code>o</code> 比 <code>e</code> 大，算法停止，第一个字符串大于第二个。</li>
</ol>
<pre><code class="language-smart">在上面的算法中，比较大小的逻辑与字典或电话簿中的排序很像，但也不完全相同。

比如说，字符串比较对字母大小写是敏感的。大写的 `&quot;A&quot;` 并不等于小写的 `&quot;a&quot;`。哪一个更大呢？实际上小写的 `&quot;a&quot;` 更大。这是因为在 JavaScript 使用的内部编码表中（Unicode），小写字母的字符索引值更大。我们会在 &lt;info:string&gt; 这章讨论更多关于字符串的细节。</code></pre>
<h2 id="不同类型间的比较">不同类型间的比较</h2>
<p>当对不同类型的值进行比较时，JavaScript 会首先将其转化为数字（number）再判定大小。</p>
<p>例如：</p>
<pre><code class="language-js">alert( <span class="hljs-string">&#x27;2&#x27;</span> &gt; <span class="hljs-number">1</span> ); <span class="hljs-comment">// true，字符串 &#x27;2&#x27; 会被转化为数字 2</span>
alert( <span class="hljs-string">&#x27;01&#x27;</span> == <span class="hljs-number">1</span> ); <span class="hljs-comment">// true，字符串 &#x27;01&#x27; 会被转化为数字 1</span></code></pre>
<p>对于布尔类型值，<code>true</code> 会被转化为 <code>1</code>、<code>false</code> 转化为 <code>0</code>。</p>
<p>例如：</p>
<pre><code class="language-js">alert( <span class="hljs-literal">true</span> == <span class="hljs-number">1</span> ); <span class="hljs-comment">// true</span>
alert( <span class="hljs-literal">false</span> == <span class="hljs-number">0</span> ); <span class="hljs-comment">// true</span></code></pre>
<pre><code class="language-smart">有时候，以下两种情况会同时发生：

- 若直接比较两个值，其结果是相等的。
- 若把两个值转为布尔值，它们可能得出完全相反的结果，即一个是 `true`，一个是 `false`。

例如：

```js run
let a = 0;
alert( Boolean(a) ); // false

let b = &quot;0&quot;;
alert( Boolean(b) ); // true

alert(a == b); // true!
```

对于 JavaScript 而言，这种现象其实挺正常的。因为 JavaScript 会把待比较的值转化为数字后再做比较（因此 `&quot;0&quot;` 变成了 `0`）。若只是将一个变量转化为 `Boolean` 值，则会使用其他的类型转换规则。</code></pre>
<h2 id="严格相等">严格相等</h2>
<p>普通的相等性检查 <code>==</code> 存在一个问题，它不能区分出 <code>0</code> 和 <code>false</code>：</p>
<pre><code class="language-js">alert( <span class="hljs-number">0</span> == <span class="hljs-literal">false</span> ); <span class="hljs-comment">// true</span></code></pre>
<p>也同样无法区分空字符串和 <code>false</code>：</p>
<pre><code class="language-js">alert( <span class="hljs-string">&#x27;&#x27;</span> == <span class="hljs-literal">false</span> ); <span class="hljs-comment">// true</span></code></pre>
<p>这是因为在比较不同类型的值时，处于相等判断符号 <code>==</code> 两侧的值会先被转化为数字。空字符串和 <code>false</code> 也是如此，转化后它们都为数字 0。</p>
<p>如果我们需要区分 <code>0</code> 和 <code>false</code>，该怎么办？</p>
<p><strong>严格相等运算符 <code>===</code> 在进行比较时不会做任何的类型转换。</strong></p>
<p>换句话说，如果 <code>a</code> 和 <code>b</code> 属于不同的数据类型，那么 <code>a === b</code> 不会做任何的类型转换而立刻返回 <code>false</code>。</p>
<p>让我们试试：</p>
<pre><code class="language-js">alert( <span class="hljs-number">0</span> === <span class="hljs-literal">false</span> ); <span class="hljs-comment">// false，因为被比较值的数据类型不同</span></code></pre>
<p>同样的，与“不相等”符号 <code>!=</code> 类似，“严格不相等”表示为 <code>!==</code>。</p>
<p>严格相等的运算符虽然写起来稍微长一些，但是它能够很清楚地显示代码意图，降低你犯错的可能性。</p>
<h2 id="对-null-和-undefined-进行比较">对 null 和 undefined 进行比较</h2>
<p>当使用 <code>null</code> 或 <code>undefined</code> 与其他值进行比较时，其返回结果常常出乎你的意料。</p>
<p>当使用严格相等 <code>===</code> 比较二者时 
: 它们不相等，因为它们属于不同的类型。</p>
<pre><code>```js run
alert( null === undefined ); // false
```</code></pre>
<p>当使用非严格相等 <code>==</code> 比较二者时
: JavaScript 存在一个特殊的规则，会判定它们相等。它们俩就像“一对恋人”，仅仅等于对方而不等于其他任何的值（只在非严格相等下成立）。</p>
<pre><code>```js run
alert( null == undefined ); // true
```</code></pre>
<p>当使用数学式或其他比较方法 <code>&lt; &gt; &lt;= &gt;=</code> 时：
: <code>null/undefined</code> 会被转化为数字：<code>null</code> 被转化为 <code>0</code>，<code>undefined</code> 被转化为 <code>NaN</code>。</p>
<p>下面让我们看看，这些规则会带来什么有趣的现象。同时更重要的是，我们需要从中学会如何远离这些特性带来的“陷阱”。</p>
<h3 id="奇怪的结果：null-vs-0">奇怪的结果：null vs 0</h3>
<p>通过比较 <code>null</code> 和 0 可得：</p>
<pre><code class="language-js">alert( <span class="hljs-literal">null</span> &gt; <span class="hljs-number">0</span> );  <span class="hljs-comment">// (1) false</span>
alert( <span class="hljs-literal">null</span> == <span class="hljs-number">0</span> ); <span class="hljs-comment">// (2) false</span>
alert( <span class="hljs-literal">null</span> &gt;= <span class="hljs-number">0</span> ); <span class="hljs-comment">// (3) *!*true*/!*</span></code></pre>
<p>是的，上面的结果完全打破了你对数学的认识。在最后一行代码显示“<code>null</code> 大于等于 0”的情况下，前两行代码中一定会有一个是正确的，然而事实表明它们的结果都是 false。</p>
<p>为什么会出现这种反常结果，这是因为相等性检查 <code>==</code> 和普通比较符 <code>&gt; &lt; &gt;= &lt;=</code> 的代码逻辑是相互独立的。进行值的比较时，<code>null</code> 会被转化为数字，因此它被转化为了 <code>0</code>。这就是为什么（3）中 <code>null &gt;= 0</code> 返回值是 true，（1）中 <code>null &gt; 0</code> 返回值是 false。</p>
<p>另一方面，<code>undefined</code> 和 <code>null</code> 在相等性检查 <code>==</code> 中不会进行任何的类型转换，它们有自己独立的比较规则，所以除了它们之间互等外，不会等于任何其他的值。这就解释了为什么（2）中 <code>null == 0</code> 会返回 false。</p>
<h3 id="特立独行的-undefined">特立独行的 undefined</h3>
<p><code>undefined</code> 不应该被与其他值进行比较：</p>
<pre><code class="language-js">alert( <span class="hljs-literal">undefined</span> &gt; <span class="hljs-number">0</span> ); <span class="hljs-comment">// false (1)</span>
alert( <span class="hljs-literal">undefined</span> &lt; <span class="hljs-number">0</span> ); <span class="hljs-comment">// false (2)</span>
alert( <span class="hljs-literal">undefined</span> == <span class="hljs-number">0</span> ); <span class="hljs-comment">// false (3)</span></code></pre>
<p>为何它看起来如此厌恶 0？返回值都是 false！</p>
<p>原因如下：</p>
<ul>
<li><code>(1)</code> 和 <code>(2)</code> 都返回 <code>false</code> 是因为 <code>undefined</code> 在比较中被转换为了 <code>NaN</code>，而 <code>NaN</code> 是一个特殊的数值型值，它与任何值进行比较都会返回 <code>false</code>。</li>
<li><code>(3)</code> 返回 <code>false</code> 是因为这是一个相等性检查，而 <code>undefined</code> 只与 <code>null</code> 相等，不会与其他值相等。</li>
</ul>
<h3 id="避免问题">避免问题</h3>
<p>我们为何要研究上述示例？我们需要时刻记得这些古怪的规则吗？不，其实不需要。虽然随着代码写得越来越多，我们对这些规则也都会烂熟于胸，但是我们需要更为可靠的方法来避免潜在的问题：</p>
<ul>
<li>除了严格相等 <code>===</code> 外，其他但凡是有 <code>undefined/null</code> 参与的比较，我们都需要格外小心。</li>
<li>除非你非常清楚自己在做什么，否则永远不要使用 <code>&gt;= &gt; &lt; &lt;=</code> 去比较一个可能为 <code>null/undefined</code> 的变量。对于取值可能是 <code>null/undefined</code> 的变量，请按需要分别检查它的取值情况。</li>
</ul>
<h2 id="总结">总结</h2>
<ul>
<li>比较运算符始终返回布尔值。</li>
<li>字符串的比较，会按照“词典”顺序逐字符地比较大小。</li>
<li>当对不同类型的值进行比较时，它们会先被转化为数字（不包括严格相等检查）再进行比较。</li>
<li>在非严格相等 <code>==</code> 下，<code>null</code> 和 <code>undefined</code> 相等且各自不等于任何其他的值。</li>
<li>在使用 <code>&gt;</code> 或 <code>&lt;</code> 进行比较时，需要注意变量可能为 <code>null/undefined</code> 的情况。比较好的方法是单独检查变量是否等于 <code>null/undefined</code>。</li>
</ul>

      </fieldset>
      
      <fieldset id='_4fqtfC'>
      <legend>solution</legend>
      <p><strong>是的，它会</strong></p>
<p>任何非空字符串（<code>&quot;0&quot;</code> 不是空字符串）的逻辑值都是 <code>true</code>。</p>
<p>我们可以执行下面的代码来进行验证：</p>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;0&quot;</span>) {
  alert( <span class="hljs-string">&#x27;Hello&#x27;</span> );
}</code></pre>

      </fieldset>
      
      <fieldset id='_1lbmPd'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="if（值为-0-的字符串）">if（值为 0 的字符串）</h1>
<p><code>alert</code> 弹窗会出来吗？</p>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;0&quot;</span>) {
  alert( <span class="hljs-string">&#x27;Hello&#x27;</span> );
}</code></pre>

      </fieldset>
      
      <fieldset id='_gxTunO'>
      <legend>solution</legend>
      <p>[html run src=&quot;ifelse_task2/index.html&quot;]</p>

      </fieldset>
      
      <fieldset id='_O736GF'>
      <legend>task</legend>
      <p>importance: 2</p>
<hr>
<h1 id="javascript-的名字">JavaScript 的名字</h1>
<p>使用 <code>if..else</code> 结构，实现提问 &quot;What is the &quot;official&quot; name of JavaScript?&quot; 的代码</p>
<p>如果访问者输入了 &quot;ECMAScript&quot;，输出就提示 &quot;Right!&quot;，否则 — 输出：&quot;Didn&#39;t know? ECMAScript!&quot;</p>
<p><img src="ifelse_task2.svg" alt=""></p>
<p>[demo src=&quot;ifelse_task2&quot;]</p>

      </fieldset>
      
      <fieldset id='_MbBmj9'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-keyword">let</span> value = prompt(<span class="hljs-string">&#x27;Type a number&#x27;</span>, <span class="hljs-number">0</span>);

<span class="hljs-keyword">if</span> (value &gt; <span class="hljs-number">0</span>) {
  alert( <span class="hljs-number">1</span> );
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &lt; <span class="hljs-number">0</span>) {
  alert( -<span class="hljs-number">1</span> );
} <span class="hljs-keyword">else</span> {
  alert( <span class="hljs-number">0</span> );
}</code></pre>

      </fieldset>
      
      <fieldset id='_qjDjC8'>
      <legend>task</legend>
      <p>importance: 2</p>
<hr>
<h1 id="显示符号">显示符号</h1>
<p>使用 <code>if..else</code> 语句，编写代码实现通过 <code>prompt</code> 获取一个数字并用 <code>alert</code> 显示结果：</p>
<ul>
<li>如果这个数字大于 0，就显示 <code>1</code>，</li>
<li>如果这个数字小于 0，就显示 <code>-1</code>，</li>
<li>如果这个数字等于 0，就显示 <code>0</code>。</li>
</ul>
<p>在这个任务中，我们假设输入永远是一个数字。</p>
<p>[demo src=&quot;if_sign&quot;]</p>

      </fieldset>
      
      <fieldset id='_qFb7XY'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-keyword">let</span> result = (a + b &lt; <span class="hljs-number">4</span>) ? <span class="hljs-string">&#x27;Below&#x27;</span> : <span class="hljs-string">&#x27;Over&#x27;</span>;</code></pre>

      </fieldset>
      
      <fieldset id='_DzikgU'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="使用--重写-if-语句">使用 &#39;?&#39; 重写 &#39;if&#39; 语句</h1>
<p>使用条件运算符 <code>&#39;?&#39;</code> 重写下面的 <code>if</code> 语句：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> result;

<span class="hljs-keyword">if</span> (a + b &lt; <span class="hljs-number">4</span>) {
  result = <span class="hljs-string">&#x27;Below&#x27;</span>;
} <span class="hljs-keyword">else</span> {
  result = <span class="hljs-string">&#x27;Over&#x27;</span>;
}</code></pre>

      </fieldset>
      
      <fieldset id='_2GtWnS'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-keyword">let</span> message = (login == <span class="hljs-string">&#x27;Employee&#x27;</span>) ? <span class="hljs-string">&#x27;Hello&#x27;</span> :
  (login == <span class="hljs-string">&#x27;Director&#x27;</span>) ? <span class="hljs-string">&#x27;Greetings&#x27;</span> :
  (login == <span class="hljs-string">&#x27;&#x27;</span>) ? <span class="hljs-string">&#x27;No login&#x27;</span> :
  <span class="hljs-string">&#x27;&#x27;</span>;</code></pre>

      </fieldset>
      
      <fieldset id='_7IrjKj'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="使用--重写-ifelse-语句">使用 &#39;?&#39; 重写 &#39;if..else&#39; 语句</h1>
<p>使用多个三元运算符 <code>&#39;?&#39;</code> 重写下面的 <code>if..else</code> 语句。</p>
<p>为了增强代码可读性，建议将代码分成多行。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> message;

<span class="hljs-keyword">if</span> (login == <span class="hljs-string">&#x27;Employee&#x27;</span>) {
  message = <span class="hljs-string">&#x27;Hello&#x27;</span>;
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (login == <span class="hljs-string">&#x27;Director&#x27;</span>) {
  message = <span class="hljs-string">&#x27;Greetings&#x27;</span>;
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (login == <span class="hljs-string">&#x27;&#x27;</span>) {
  message = <span class="hljs-string">&#x27;No login&#x27;</span>;
} <span class="hljs-keyword">else</span> {
  message = <span class="hljs-string">&#x27;&#x27;</span>;
}</code></pre>

      </fieldset>
      
      <fieldset id='_ba9z6c'>
      <legend>article</legend>
      <h1 id="条件分支：if-和-">条件分支：if 和 &#39;?&#39;</h1>
<p>有时我们需要根据不同条件执行不同的操作。</p>
<p>我们可以使用 <code>if</code> 语句和条件运算符 <code>?</code>（也称为“问号”运算符）来实现。</p>
<h2 id="if-语句">&quot;if&quot; 语句</h2>
<p><code>if(...)</code> 语句计算括号里的条件表达式，如果计算结果是 <code>true</code>，就会执行对应的代码块。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> year = prompt(<span class="hljs-string">&#x27;In which year was ECMAScript-2015 specification published?&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>);

*!*
<span class="hljs-keyword">if</span> (year == <span class="hljs-number">2015</span>) alert( <span class="hljs-string">&#x27;You are right!&#x27;</span> );
*/!*</code></pre>
<p>在上面这个例子中，条件是一个简单的相等性检查（<code>year == 2015</code>），但它还可以更复杂。</p>
<p>如果有多个语句要执行，我们必须将要执行的代码块封装在大括号内：</p>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (year == <span class="hljs-number">2015</span>) {
  alert( <span class="hljs-string">&quot;That&#x27;s correct!&quot;</span> );
  alert( <span class="hljs-string">&quot;You&#x27;re so smart!&quot;</span> );
}</code></pre>
<p>建议每次使用 if 语句都用大括号 <code>{}</code> 来包装代码块，即使只有一条语句。这样可以提高代码可读性。</p>
<h2 id="布尔转换">布尔转换</h2>
<p><code>if (…)</code> 语句会计算圆括号内的表达式，并将计算结果转换为布尔型。</p>
<p>让我们回顾一下 <a href="info:type-conversions">info:type-conversions</a> 一章中的转换规则：</p>
<ul>
<li>数字 <code>0</code>、空字符串 <code>&quot;&quot;</code>、<code>null</code>、<code>undefined</code> 和 <code>NaN</code> 都会被转换成 <code>false</code>。因为它们被称为 &quot;falsy&quot; 值。</li>
<li>其他值被转换为 <code>true</code>，所以它们被称为 &quot;truthy&quot;。</li>
</ul>
<p>所以，下面这个条件下的代码永远不会执行：</p>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (<span class="hljs-number">0</span>) { <span class="hljs-comment">// 0 是 falsy</span>
  ...
}</code></pre>
<p>……但下面的条件 —— 始终有效：</p>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) { <span class="hljs-comment">// 1 是 truthy</span>
  ...
}</code></pre>
<p>我们也可以将未计算的布尔值传入 <code>if</code> 语句，像这样：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> cond = (year == <span class="hljs-number">2015</span>); <span class="hljs-comment">// 相等运算符的结果是 true 或 false</span>

<span class="hljs-keyword">if</span> (cond) {
  ...
}</code></pre>
<h2 id="else-语句">&quot;else&quot; 语句</h2>
<p><code>if</code> 语句有时会包含一个可选的 &quot;else&quot; 块。如果判断条件不成立，就会执行它内部的代码。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> year = prompt(<span class="hljs-string">&#x27;In which year was ECMAScript-2015 specification published?&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>);

<span class="hljs-keyword">if</span> (year == <span class="hljs-number">2015</span>) {
  alert( <span class="hljs-string">&#x27;You guessed it right!&#x27;</span> );
} <span class="hljs-keyword">else</span> {
  alert( <span class="hljs-string">&#x27;How can you be so wrong?&#x27;</span> ); <span class="hljs-comment">// 2015 以外的任何值</span>
}</code></pre>
<h2 id="多个条件：else-if">多个条件：&quot;else if&quot;</h2>
<p>有时我们需要测试一个条件的几个变体。我们可以通过使用 <code>else if</code> 子句实现。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> year = prompt(<span class="hljs-string">&#x27;In which year was ECMAScript-2015 specification published?&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>);

<span class="hljs-keyword">if</span> (year &lt; <span class="hljs-number">2015</span>) {
  alert( <span class="hljs-string">&#x27;Too early...&#x27;</span> );
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (year &gt; <span class="hljs-number">2015</span>) {
  alert( <span class="hljs-string">&#x27;Too late&#x27;</span> );
} <span class="hljs-keyword">else</span> {
  alert( <span class="hljs-string">&#x27;Exactly!&#x27;</span> );
}</code></pre>
<p>在上面的代码中，JavaScript 先先检查 <code>year &lt; 2015</code>。如果条件不符合，就会转到下一个条件 <code>year &gt; 2015</code>。如果这个条件也不符合，则会显示最后一个 <code>alert</code>。</p>
<p>可以有更多的 <code>else if</code> 块。结尾的 <code>else</code> 是可选的。</p>
<h2 id="条件运算符-">条件运算符 &#39;?&#39;</h2>
<p>有时我们需要根据一个条件去赋值一个变量。</p>
<p>如下所示：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> accessAllowed;
<span class="hljs-keyword">let</span> age = prompt(<span class="hljs-string">&#x27;How old are you?&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>);

*!*
<span class="hljs-keyword">if</span> (age &gt; <span class="hljs-number">18</span>) {
  accessAllowed = <span class="hljs-literal">true</span>;
} <span class="hljs-keyword">else</span> {
  accessAllowed = <span class="hljs-literal">false</span>;
}
*/!*

alert(accessAllowed);</code></pre>
<p>所谓的“条件”或“问号”运算符让我们可以更简短地达到目的。</p>
<p>这个运算符通过问号 <code>?</code> 表示。有时它被称为三元运算符，被称为“三元”是因为该运算符中有三个操作数。实际上它是 JavaScript 中唯一一个有这么多操作数的运算符。</p>
<p>语法：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> result = condition ? value1 : value2;</code></pre>
<p>计算条件结果，如果结果为真，则返回 <code>value1</code>，否则返回 <code>value2</code>。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> accessAllowed = (age &gt; <span class="hljs-number">18</span>) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;</code></pre>
<p>技术上讲，我们可以省略 <code>age &gt; 18</code> 外面的括号。问号运算符的优先级较低，所以它会在比较运算符 <code>&gt;</code> 后执行。</p>
<p>下面这个示例会执行和前面那个示例相同的操作：</p>
<pre><code class="language-js"><span class="hljs-comment">// 比较运算符 &quot;age &gt; 18&quot; 首先执行</span>
<span class="hljs-comment">//（不需要将其包含在括号中）</span>
<span class="hljs-keyword">let</span> accessAllowed = age &gt; <span class="hljs-number">18</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;</code></pre>
<p>但括号可以使代码可读性更强，所以我们建议使用它们。</p>
<pre><code class="language-smart">在上面的例子中，你可以不使用问号运算符，因为比较本身就返回 `true/false`：

```js
// 下面代码同样可以实现
let accessAllowed = age &gt; 18;
```</code></pre>
<h2 id="多个-">多个 &#39;?&#39;</h2>
<p>使用一系列问号 <code>?</code> 运算符可以返回一个取决于多个条件的值。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> age = prompt(<span class="hljs-string">&#x27;age?&#x27;</span>, <span class="hljs-number">18</span>);

<span class="hljs-keyword">let</span> message = (age &lt; <span class="hljs-number">3</span>) ? <span class="hljs-string">&#x27;Hi, baby!&#x27;</span> :
  (age &lt; <span class="hljs-number">18</span>) ? <span class="hljs-string">&#x27;Hello!&#x27;</span> :
  (age &lt; <span class="hljs-number">100</span>) ? <span class="hljs-string">&#x27;Greetings!&#x27;</span> :
  <span class="hljs-string">&#x27;What an unusual age!&#x27;</span>;

alert( message );</code></pre>
<p>可能很难一下子看出发生了什么。但经过仔细观察，我们可以看到它只是一个普通的检查序列。</p>
<ol>
<li>第一个问号检查 <code>age &lt; 3</code>。</li>
<li>如果为真 — 返回 <code>&#39;Hi, baby!&#39;</code>。否则，会继续执行冒号 <code>&quot;:&quot;</code> 后的表达式，检查 <code>age &lt; 18</code>。</li>
<li>如果为真 — 返回 <code>&#39;Hello!&#39;</code>。否则，会继续执行下一个冒号 <code>&quot;:&quot;</code> 后的表达式，检查 <code>age &lt; 100</code>。</li>
<li>如果为真 — 返回 <code>&#39;Greetings!&#39;</code>。否则，会继续执行最后一个冒号 <code>&quot;:&quot;</code> 后面的表达式，返回 <code>&#39;What an unusual age!&#39;</code>。</li>
</ol>
<p>这是使用 <code>if..else</code> 实现上面的逻辑的写法：</p>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (age &lt; <span class="hljs-number">3</span>) {
  message = <span class="hljs-string">&#x27;Hi, baby!&#x27;</span>;
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (age &lt; <span class="hljs-number">18</span>) {
  message = <span class="hljs-string">&#x27;Hello!&#x27;</span>;
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (age &lt; <span class="hljs-number">100</span>) {
  message = <span class="hljs-string">&#x27;Greetings!&#x27;</span>;
} <span class="hljs-keyword">else</span> {
  message = <span class="hljs-string">&#x27;What an unusual age!&#x27;</span>;
}</code></pre>
<h2 id="-的非常规使用">&#39;?&#39; 的非常规使用</h2>
<p>有时可以使用问号 <code>?</code> 来代替 <code>if</code> 语句：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> company = prompt(<span class="hljs-string">&#x27;Which company created JavaScript?&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>);

*!*
(company == <span class="hljs-string">&#x27;Netscape&#x27;</span>) ?
   alert(<span class="hljs-string">&#x27;Right!&#x27;</span>) : alert(<span class="hljs-string">&#x27;Wrong.&#x27;</span>);
*/!*</code></pre>
<p>根据条件 <code>company ==&#39;Netscape&#39;</code>，要么执行 <code>?</code> 后面的第一个表达式并显示对应内容，要么执行第二个表达式并显示对应内容。</p>
<p>在这里我们不是把结果赋值给变量。而是根据条件执行不同的代码。</p>
<p><strong>不建议这样使用问号运算符。</strong></p>
<p>这种写法比 <code>if</code> 语句更短，对一些程序员很有吸引力。但它的可读性差。</p>
<p>下面是使用 <code>if</code> 语句实现相同功能的代码，进行下比较：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> company = prompt(<span class="hljs-string">&#x27;Which company created JavaScript?&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>);

*!*
<span class="hljs-keyword">if</span> (company == <span class="hljs-string">&#x27;Netscape&#x27;</span>) {
  alert(<span class="hljs-string">&#x27;Right!&#x27;</span>);
} <span class="hljs-keyword">else</span> {
  alert(<span class="hljs-string">&#x27;Wrong.&#x27;</span>);
}
*/!*</code></pre>
<p>因为我们的眼睛垂直扫描代码。所以，跨越几行的代码块比长而水平的代码更易于理解。</p>
<p>问号 <code>?</code> 的作用是根据条件返回一个或另一个值。请正确使用它。当需要执行不同的代码分支时，请使用 <code>if</code>。</p>

      </fieldset>
      
      <fieldset id='_eM5Tjr'>
      <legend>solution</legend>
      
      </fieldset>
      
      <fieldset id='_dZ4myb'>
      <legend>task</legend>
      
      </fieldset>
      
      <fieldset id='_2SDKNa'>
      <legend>solution</legend>
      <p>答案：首先是 <code>1</code>，然后是 <code>2</code>。</p>
<pre><code class="language-js">alert( alert(<span class="hljs-number">1</span>) || <span class="hljs-number">2</span> || alert(<span class="hljs-number">3</span>) );</code></pre>
<p>对 <code>alert</code> 的调用没有返回值。或者说返回的是 <code>undefined</code>。</p>
<ol>
<li>第一个或运算 <code>||</code> 对它的左值 <code>alert(1)</code> 进行了计算。这就显示了第一条信息 <code>1</code>。</li>
<li>函数 <code>alert</code> 返回了 <code>undefined</code>，所以或运算继续检查第二个操作数以寻找真值。</li>
<li>第二个操作数 <code>2</code> 是真值，所以执行就中断了。<code>2</code> 被返回，并且被外层的 alert 显示。</li>
</ol>
<p>这里不会显示 <code>3</code>，因为运算没有抵达 <code>alert(3)</code>。</p>

      </fieldset>
      
      <fieldset id='_aqrsjb'>
      <legend>task</legend>
      <p>importance: 3</p>
<hr>
<h1 id="或运算和-alerts-的结果是什么？">或运算和 alerts 的结果是什么？</h1>
<p>下面的代码将会输出什么？</p>
<pre><code class="language-js">alert( alert(<span class="hljs-number">1</span>) || <span class="hljs-number">2</span> || alert(<span class="hljs-number">3</span>) );</code></pre>

      </fieldset>
      
      <fieldset id='_g1TXtW'>
      <legend>solution</legend>
      
      </fieldset>
      
      <fieldset id='_oJZ9Ct'>
      <legend>task</legend>
      
      </fieldset>
      
      <fieldset id='_pgfKQD'>
      <legend>solution</legend>
      <p>答案：<code>1</code>，然后 <code>undefined</code>。</p>
<pre><code class="language-js">alert( alert(<span class="hljs-number">1</span>) &amp;&amp; alert(<span class="hljs-number">2</span>) );</code></pre>
<p>调用 <code>alert</code> 返回了 <code>undefined</code>（它只展示消息，所以没有有意义的返回值）。</p>
<p>因此，<code>&amp;&amp;</code> 计算了它左边的操作数（显示 <code>1</code>），然后立即停止了，因为 <code>undefined</code> 是一个假值。<code>&amp;&amp;</code> 就是寻找假值然后返回它，所以运算结束。</p>

      </fieldset>
      
      <fieldset id='_lZU49S'>
      <legend>task</legend>
      <p>importance: 3</p>
<hr>
<h1 id="与运算连接的-alerts-的结果是什么？">与运算连接的 alerts 的结果是什么？</h1>
<p>这段代码将会显示什么？</p>
<pre><code class="language-js">alert( alert(<span class="hljs-number">1</span>) &amp;&amp; alert(<span class="hljs-number">2</span>) );</code></pre>

      </fieldset>
      
      <fieldset id='_LGaTzV'>
      <legend>solution</legend>
      <p>答案：<code>3</code>。</p>
<pre><code class="language-js">alert( <span class="hljs-literal">null</span> || <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-number">3</span> || <span class="hljs-number">4</span> );</code></pre>
<p>与运算 <code>&amp;&amp;</code> 的优先级比 <code>||</code> 高，所以它第一个被执行。</p>
<p>结果是 <code>2 &amp;&amp; 3 = 3</code>，所以表达式变成了：</p>
<pre><code>null || 3 || 4</code></pre>
<p>现在的结果就是第一个真值：<code>3</code>。</p>

      </fieldset>
      
      <fieldset id='_cliDD5'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="或运算、与运算、或运算串联的结果">或运算、与运算、或运算串联的结果</h1>
<p>结果将会是什么？</p>
<pre><code class="language-js">alert( <span class="hljs-literal">null</span> || <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-number">3</span> || <span class="hljs-number">4</span> );</code></pre>

      </fieldset>
      
      <fieldset id='_z2VvFn'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-keyword">if</span> (age &gt;= <span class="hljs-number">14</span> &amp;&amp; age &lt;= <span class="hljs-number">90</span>)</code></pre>

      </fieldset>
      
      <fieldset id='_BsQnr9'>
      <legend>task</legend>
      <p>importance: 3</p>
<hr>
<h1 id="检查值是否位于范围区间内">检查值是否位于范围区间内</h1>
<p>写一个“if”条件句来检查 <code>age</code> 是否位于 <code>14</code> 到 <code>90</code> 的闭区间。</p>
<p>“闭区间”意味着，<code>age</code> 的值可以取 <code>14</code> 或 <code>90</code>。</p>

      </fieldset>
      
      <fieldset id='_52j2QO'>
      <legend>solution</legend>
      <p>第一个表达式：</p>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (!(age &gt;= <span class="hljs-number">14</span> &amp;&amp; age &lt;= <span class="hljs-number">90</span>))</code></pre>
<p>第二个表达式：</p>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (age &lt; <span class="hljs-number">14</span> || age &gt; <span class="hljs-number">90</span>)</code></pre>

      </fieldset>
      
      <fieldset id='_Rez5AT'>
      <legend>task</legend>
      <p>importance: 3</p>
<hr>
<h1 id="检查值是否位于范围之外">检查值是否位于范围之外</h1>
<p>写一个 <code>if</code> 条件句，检查 <code>age</code> 是否不位于 14 到 90 的闭区间。</p>
<p>创建两个表达式：第一个用非运算 <code>!</code>，第二个不用。</p>

      </fieldset>
      
      <fieldset id='_XzJU18'>
      <legend>solution</legend>
      <p>答案：第一个和第三个将会被执行。</p>
<p>详解：</p>
<pre><code class="language-js"><span class="hljs-comment">// 执行。</span>
<span class="hljs-comment">// -1 || 0 的结果为 -1，真值</span>
<span class="hljs-keyword">if</span> (-<span class="hljs-number">1</span> || <span class="hljs-number">0</span>) alert( <span class="hljs-string">&#x27;first&#x27;</span> );

<span class="hljs-comment">// 不执行。</span>
<span class="hljs-comment">// -1 &amp;&amp; 0 = 0，假值</span>
<span class="hljs-keyword">if</span> (-<span class="hljs-number">1</span> &amp;&amp; <span class="hljs-number">0</span>) alert( <span class="hljs-string">&#x27;second&#x27;</span> );

<span class="hljs-comment">// 执行</span>
<span class="hljs-comment">// &amp;&amp; 运算的优先级比 || 高</span>
<span class="hljs-comment">// 所以 -1 &amp;&amp; 1 先执行，给出如下运算链：</span>
<span class="hljs-comment">// null || -1 &amp;&amp; 1  -&gt;  null || 1  -&gt;  1</span>
<span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> || -<span class="hljs-number">1</span> &amp;&amp; <span class="hljs-number">1</span>) alert( <span class="hljs-string">&#x27;third&#x27;</span> );</code></pre>

      </fieldset>
      
      <fieldset id='_0KRRm3'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="一个关于-if-的问题">一个关于 &quot;if&quot; 的问题</h1>
<p>下面哪一个 <code>alert</code> 将会被执行？</p>
<p><code>if(...)</code> 语句内表达式的结果是什么？</p>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (-<span class="hljs-number">1</span> || <span class="hljs-number">0</span>) alert( <span class="hljs-string">&#x27;first&#x27;</span> );
<span class="hljs-keyword">if</span> (-<span class="hljs-number">1</span> &amp;&amp; <span class="hljs-number">0</span>) alert( <span class="hljs-string">&#x27;second&#x27;</span> );
<span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> || -<span class="hljs-number">1</span> &amp;&amp; <span class="hljs-number">1</span>) alert( <span class="hljs-string">&#x27;third&#x27;</span> );</code></pre>

      </fieldset>
      
      <fieldset id='_gDXKqb'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-keyword">let</span> userName = prompt(<span class="hljs-string">&quot;Who&#x27;s there?&quot;</span>, <span class="hljs-string">&#x27;&#x27;</span>);

<span class="hljs-keyword">if</span> (userName == <span class="hljs-string">&#x27;Admin&#x27;</span>) {

  <span class="hljs-keyword">let</span> pass = prompt(<span class="hljs-string">&#x27;Password?&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>);

  <span class="hljs-keyword">if</span> (pass == <span class="hljs-string">&#x27;TheMaster&#x27;</span>) {
    alert( <span class="hljs-string">&#x27;Welcome!&#x27;</span> );
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pass == <span class="hljs-string">&#x27;&#x27;</span> || pass == <span class="hljs-literal">null</span>) {
    alert( <span class="hljs-string">&#x27;Canceled&#x27;</span> );
  } <span class="hljs-keyword">else</span> {
    alert( <span class="hljs-string">&#x27;Wrong password&#x27;</span> );
  }

} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (userName == <span class="hljs-string">&#x27;&#x27;</span> || userName == <span class="hljs-literal">null</span>) {
  alert( <span class="hljs-string">&#x27;Canceled&#x27;</span> );
} <span class="hljs-keyword">else</span> {
  alert( <span class="hljs-string">&quot;I don&#x27;t know you&quot;</span> );
}</code></pre>
<p>请注意 <code>if</code> 块中水平方向的缩进。技术上是非必需的，但会增加代码的可读性。</p>

      </fieldset>
      
      <fieldset id='_lFLSaW'>
      <legend>task</legend>
      <p>importance: 3</p>
<hr>
<h1 id="登陆验证">登陆验证</h1>
<p>实现使用 <code>prompt</code> 进行登陆校验的代码。</p>
<p>如果访问者输入 <code>&quot;Admin&quot;</code>，那么使用 <code>prompt</code> 引导获取密码，如果输入的用户名为空或者按下了 <code>key:Esc</code> 键 —— 显示 &quot;Canceled&quot;，如果是其他字符串 —— 显示 &quot;I don&#39;t know you&quot;。</p>
<p>密码的校验规则如下：</p>
<ul>
<li>如果输入的是 &quot;TheMaster&quot;，显示 &quot;Welcome!&quot;，</li>
<li>其他字符串 —— 显示 &quot;Wrong password&quot;，</li>
<li>空字符串或取消了输入，显示 &quot;Canceled.&quot;。</li>
</ul>
<p>流程图：</p>
<p><img src="ifelse_task.svg" alt=""></p>
<p>请使用嵌套的 <code>if</code> 块。注意代码整体的可读性。</p>
<p>提示：将空字符串输入，prompt 会获取到一个空字符串 <code>&#39;&#39;</code>。Prompt 运行过程中，按下 <code>key:ESC</code> 键会得到 <code>null</code>。</p>
<p>[demo]</p>

      </fieldset>
      
      <fieldset id='_Mjg4AR'>
      <legend>article</legend>
      <h1 id="逻辑运算符">逻辑运算符</h1>
<p>JavaScript 里有三个逻辑运算符：<code>||</code>（或），<code>&amp;&amp;</code>（与），<code>!</code>（非）。</p>
<p>虽然它们被称为“逻辑”运算符，但这些运算符却可以被应用于任意类型的值，而不仅仅是布尔值。它们的结果也同样可以是任意类型。</p>
<p>让我们来详细看一下。</p>
<h2 id="（或）">||（或）</h2>
<p>两个竖线符号表示了“或”运算：</p>
<pre><code class="language-js">result = a || b;</code></pre>
<p>在传统的编程中，逻辑或仅能够操作布尔值。如果参与运算的任意一个参数为 <code>true</code>，返回的结果就为 <code>true</code>，否则返回 <code>false</code>。</p>
<p>在 JavaScript 中，逻辑运算符更加灵活强大。但是首先我们看一下操作数是布尔值的时候发生了什么。</p>
<p>下面是四种可能的逻辑组合：</p>
<pre><code class="language-js">alert( <span class="hljs-literal">true</span> || <span class="hljs-literal">true</span> );   <span class="hljs-comment">// true</span>
alert( <span class="hljs-literal">false</span> || <span class="hljs-literal">true</span> );  <span class="hljs-comment">// true</span>
alert( <span class="hljs-literal">true</span> || <span class="hljs-literal">false</span> );  <span class="hljs-comment">// true</span>
alert( <span class="hljs-literal">false</span> || <span class="hljs-literal">false</span> ); <span class="hljs-comment">// false</span></code></pre>
<p>正如我们所见，除了两个操作数都是 <code>false</code> 的情况，结果都是 <code>true</code>。</p>
<p>如果操作数不是布尔值，那么它将会被转化为布尔值来参与运算。</p>
<p>例如，数字 <code>1</code> 将会被作为 <code>true</code>，数字 <code>0</code> 则作为 <code>false</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> || <span class="hljs-number">0</span>) { <span class="hljs-comment">// 工作原理相当于 if( true || false )</span>
  alert( <span class="hljs-string">&#x27;truthy!&#x27;</span> );
}</code></pre>
<p>大多数情况，逻辑或 <code>||</code> 会被用在 <code>if</code> 语句中，用来测试是否有 <strong>任何</strong> 给定的条件为 <code>true</code>。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> hour = <span class="hljs-number">9</span>;

*!*
<span class="hljs-keyword">if</span> (hour &lt; <span class="hljs-number">10</span> || hour &gt; <span class="hljs-number">18</span>) {
*/!*
  alert( <span class="hljs-string">&#x27;The office is closed.&#x27;</span> );
}</code></pre>
<p>我们可以传入更多的条件：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> hour = <span class="hljs-number">12</span>;
<span class="hljs-keyword">let</span> isWeekend = <span class="hljs-literal">true</span>;

<span class="hljs-keyword">if</span> (hour &lt; <span class="hljs-number">10</span> || hour &gt; <span class="hljs-number">18</span> || isWeekend) {
  alert( <span class="hljs-string">&#x27;The office is closed.&#x27;</span> ); <span class="hljs-comment">// 是周末</span>
}</code></pre>
<h2 id="或运算寻找第一个真值">或运算寻找第一个真值</h2>
<p>上文提到的逻辑处理多少有些传统了。下面让我们看看 JavaScript 的“附加”特性。</p>
<p>拓展的算法如下所示。</p>
<p>给定多个参与或运算的值：</p>
<pre><code class="language-js">result = value1 || value2 || value3;</code></pre>
<p>或运算符 <code>||</code> 做了如下的事情：</p>
<ul>
<li>从左到右依次计算操作数。</li>
<li>处理每一个操作数时，都将其转化为布尔值。如果结果是 <code>true</code>，就停止计算，返回这个操作数的初始值。</li>
<li>如果所有的操作数都被计算过（也就是，转换结果都是 <code>false</code>），则返回最后一个操作数。</li>
</ul>
<p>返回的值是操作数的初始形式，不会做布尔转换。</p>
<p>也就是，一个或运算 <code>&quot;||&quot;</code> 的链，将返回第一个真值，如果不存在真值，就返回该链的最后一个值。</p>
<p>例如：</p>
<pre><code class="language-js">alert( <span class="hljs-number">1</span> || <span class="hljs-number">0</span> ); <span class="hljs-comment">// 1（1 是真值）</span>

alert( <span class="hljs-literal">null</span> || <span class="hljs-number">1</span> ); <span class="hljs-comment">// 1（1 是第一个真值）</span>
alert( <span class="hljs-literal">null</span> || <span class="hljs-number">0</span> || <span class="hljs-number">1</span> ); <span class="hljs-comment">// 1（第一个真值）</span>

alert( <span class="hljs-literal">undefined</span> || <span class="hljs-literal">null</span> || <span class="hljs-number">0</span> ); <span class="hljs-comment">// 0（所有的转化结果都是 false，返回最后一个值）</span></code></pre>
<p>与“纯粹的、传统的、仅仅处理布尔值的或运算”相比，这个规则就引起了一些很有趣的用法。</p>
<ol>
<li><p><strong>获取变量列表或者表达式的第一个真值。</strong></p>
<p> 例如，我们有 <code>firstName</code>、<code>lastName</code> 和 <code>nickName</code> 变量，都是可选的。</p>
<p> 我们用或运算 <code>||</code> 来选择有值的那一个，并显示出来（如果没有设置，则用 <code>匿名（anonymous）</code>）：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> firstName = <span class="hljs-string">&quot;&quot;</span>;
<span class="hljs-keyword">let</span> lastName = <span class="hljs-string">&quot;&quot;</span>;
<span class="hljs-keyword">let</span> nickName = <span class="hljs-string">&quot;SuperCoder&quot;</span>;

*!*
alert( firstName || lastName || nickName || <span class="hljs-string">&quot;Anonymous&quot;</span>); <span class="hljs-comment">// SuperCoder</span>
*/!*</code></pre>
<p> 如果所有变量都为假（falsy)，结果就是 <code>Anonymous</code>。</p>
</li>
<li><p><strong>短路求值（Short-circuit evaluation）。</strong></p>
<p> 或运算符 <code>||</code> 的另一个特点是所谓的“短路求值”。</p>
<p> 它的意思是，<code>||</code> 对其参数进行处理，直到达到第一个真值，然后立即返回该值，而无需处理其他参数。</p>
<p> 如果操作数不仅仅是一个值，而是一个有副作用的表达式，例如变量赋值或函数调用，那么这一特性的重要性就变得显而易见了。</p>
<p> 在下面这个例子中，只会打印第二条信息：</p>
<pre><code class="language-js">*!*<span class="hljs-literal">true</span>*/!* || alert(<span class="hljs-string">&quot;not printed&quot;</span>);
*!*<span class="hljs-literal">false</span>*/!* || alert(<span class="hljs-string">&quot;printed&quot;</span>);</code></pre>
<p> 在第一行中，或运算符 <code>||</code> 在遇到 <code>true</code> 时立即停止运算，所以 <code>alert</code> 没有运行。</p>
<p> 有时，人们利用这个特性，只在左侧的条件为假时才执行命令。</p>
</li>
</ol>
<h2 id="（与）">&amp;&amp;（与）</h2>
<p>两个 &amp; 符号表示 <code>&amp;&amp;</code> 与操作：</p>
<pre><code class="language-js">result = a &amp;&amp; b;</code></pre>
<p>传统的编程中，当两个操作数都是真值，与操作返回 <code>true</code>，否则返回 <code>false</code>：</p>
<pre><code class="language-js">alert( <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-literal">true</span> );   <span class="hljs-comment">// true</span>
alert( <span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-literal">true</span> );  <span class="hljs-comment">// false</span>
alert( <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-literal">false</span> );  <span class="hljs-comment">// false</span>
alert( <span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-literal">false</span> ); <span class="hljs-comment">// false</span></code></pre>
<p>使用 <code>if</code> 语句的例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> hour = <span class="hljs-number">12</span>;
<span class="hljs-keyword">let</span> minute = <span class="hljs-number">30</span>;

<span class="hljs-keyword">if</span> (hour == <span class="hljs-number">12</span> &amp;&amp; minute == <span class="hljs-number">30</span>) {
  alert( <span class="hljs-string">&#x27;Time is 12:30&#x27;</span> );
}</code></pre>
<p>就像或运算一样，与运算的操作数可以是任意类型的值：</p>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> &amp;&amp; <span class="hljs-number">0</span>) { <span class="hljs-comment">// 作为 true &amp;&amp; false 来执行</span>
  alert( <span class="hljs-string">&quot;won&#x27;t work, because the result is falsy&quot;</span> );
}</code></pre>
<h2 id="与操作寻找第一个假值">与操作寻找第一个假值</h2>
<p>给出多个参加与运算的值：</p>
<pre><code class="language-js">result = value1 &amp;&amp; value2 &amp;&amp; value3;</code></pre>
<p>与运算 <code>&amp;&amp;</code> 做了如下的事：</p>
<ul>
<li>从左到右依次计算操作数。</li>
<li>将处理每一个操作数时，都将其转化为布尔值。如果结果是 <code>false</code>，就停止计算，并返回这个操作数的初始值。</li>
<li>如果所有的操作数都被计算过（也就是，转换结果都是 <code>true</code>），则返回最后一个操作数。</li>
</ul>
<p>换句话说，与运算符返回第一个假值，如果没有假值就返回最后一个值。</p>
<p>上面的规则和或运算很像。区别就是与运算返回第一个假值而或操作返回第一个真值。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-comment">// 如果第一个运算符是真值，</span>
<span class="hljs-comment">// 与操作返回第二个操作数：</span>
alert( <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-number">0</span> ); <span class="hljs-comment">// 0</span>
alert( <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-number">5</span> ); <span class="hljs-comment">// 5</span>

<span class="hljs-comment">// 如果第一个运算符是假值，</span>
<span class="hljs-comment">// 与操作直接返回它。第二个操作数被忽略</span>
alert( <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-number">5</span> ); <span class="hljs-comment">// null</span>
alert( <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-string">&quot;no matter what&quot;</span> ); <span class="hljs-comment">// 0</span></code></pre>
<p>我们也可以在一行代码上串联多个值。查看第一个假值是否被返回：</p>
<pre><code class="language-js">alert( <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-number">3</span> ); <span class="hljs-comment">// null</span></code></pre>
<p>如果所有的值都是真值，最后一个值将会被返回：</p>
<pre><code class="language-js">alert( <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-number">3</span> ); <span class="hljs-comment">// 3，最后一个值</span></code></pre>
<p>````smart header=&quot;与运算 <code>&amp;&amp;</code> 在或运算符 <code>||</code> 之前执行&quot;
与运算 <code>&amp;&amp;</code> 的优先级比或运算 <code>||</code> 要高。</p>
<p>所以代码 <code>a &amp;&amp; b || c &amp;&amp; d</code> 完全跟 <code>&amp;&amp;</code> 表达式加了括号一样：<code>(a &amp;&amp; b) || (c &amp;&amp; d)</code>。</p>
<pre><code>
````warn header=&quot;不要用 || 或 &amp;&amp; 来取代 `if`&quot;
有时候，有人会用与运算符 `&amp;&amp;` 来“简化 `if`”。

例如：

```js run
let x = 1;

(x &gt; 0) &amp;&amp; alert( &#x27;Greater than zero!&#x27; );
```

`&amp;&amp;` 右边的代码只有运算抵达到那里才能被执行。也就是，当且仅当 `(x &gt; 0)` 返回了真值。

所以我们基本可以类似地得到：

```js run
let x = 1;

if (x &gt; 0) alert( &#x27;Greater than zero!&#x27; );
```

虽然使用 `&amp;&amp;` 写出的变体看起来更短，但 `if` 更明显，并且往往更具可读性。因此，我们建议根据每个语法结构的用途来使用：如果我们想要 `if`，就使用 `if`；如果我们想要逻辑与，就使用 `&amp;&amp;`。</code></pre>
<h2 id="（非）">!（非）</h2>
<p>感叹符号 <code>!</code> 表示布尔非运算。</p>
<p>语法相当简单：</p>
<pre><code class="language-js">result = !value;</code></pre>
<p>运算符接受一个参数，并按如下运作：</p>
<ol>
<li>将操作数转化为布尔类型：<code>true/false</code>。</li>
<li>返回相反的值。</li>
</ol>
<p>例如：</p>
<pre><code class="language-js">alert( !<span class="hljs-literal">true</span> ); <span class="hljs-comment">// false</span>
alert( !<span class="hljs-number">0</span> ); <span class="hljs-comment">// true</span></code></pre>
<p>两个非运算 <code>!!</code> 有时候用来将某个值转化为布尔类型：</p>
<pre><code class="language-js">alert( !!<span class="hljs-string">&quot;non-empty string&quot;</span> ); <span class="hljs-comment">// true</span>
alert( !!<span class="hljs-literal">null</span> ); <span class="hljs-comment">// false</span></code></pre>
<p>也就是，第一个非运算将该值转化为布尔类型并取反，第二个非运算再次取反。最后我们就得到了一个任意值到布尔值的转化。</p>
<p>有更多详细的方法可以完成同样的事 —— 一个内置的 <code>Boolean</code> 函数：</p>
<pre><code class="language-js">alert( <span class="hljs-built_in">Boolean</span>(<span class="hljs-string">&quot;non-empty string&quot;</span>) ); <span class="hljs-comment">// true</span>
alert( <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">null</span>) ); <span class="hljs-comment">// false</span></code></pre>
<p>非运算符 <code>!</code> 的优先级在所有逻辑运算符里面最高，所以它总是在 <code>&amp;&amp;</code> 和 <code>||</code> 前执行。</p>

      </fieldset>
      
      <fieldset id='_kaaOPq'>
      <legend>article</legend>
      <h1 id="空值合并运算符-">空值合并运算符 &#39;??&#39;</h1>
<p>[recent browser=&quot;new&quot;]</p>
<p>空值合并运算符 <code>??</code> 提供了一种简短的语法，用来获取列表中第一个“已定义”的变量（译注：即值不是 <code>null</code> 或 <code>undefined</code> 的变量）。</p>
<p><code>a ?? b</code> 的结果是：</p>
<ul>
<li><code>a</code>，如果 <code>a</code> 不是 <code>null</code> 或 <code>undefined</code>，</li>
<li><code>b</code>，其他情况。</li>
</ul>
<p>所以，<code>x = a ?? b</code> 是下面这个表达式的简写：</p>
<pre><code class="language-js">x = (a !== <span class="hljs-literal">null</span> &amp;&amp; a !== <span class="hljs-literal">undefined</span>) ? a : b;</code></pre>
<p>下面是一个更长一点的例子。</p>
<p>假设，我们有一个用户，变量 <code>firstName</code>、<code>lastName</code> 和 <code>nickName</code> 分别对应用户的名字、姓氏和昵称。如果用户决定不输入任何值，那么这些变量都可能是未定义的。</p>
<p>我们想要显示用户的名称：显示这三个变量中的一个，如果都没有设置值，则显示 &quot;Anonymous&quot;。</p>
<p>让我们使用 <code>??</code> 运算符选择第一个已定义的变量：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> firstName = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">let</span> lastName = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">let</span> nickName = <span class="hljs-string">&quot;Supercoder&quot;</span>;

<span class="hljs-comment">// 显示第一个不是 null/undefined 的值</span>
*!*
alert(firstName ?? lastName ?? nickName ?? <span class="hljs-string">&quot;Anonymous&quot;</span>); <span class="hljs-comment">// Supercoder</span>
*/!*</code></pre>
<h2 id="与--比较">与 || 比较</h2>
<p>或运算符 <code>||</code> 可以与 <code>??</code> 运算符以同样的方式使用。正如 <a href="info:logical-operators#or-finds-the-first-truthy-value">上一章</a> 所讲的，我们可以用 <code>||</code> 替换上面示例中的 <code>??</code>，也可以获得相同的结果。</p>
<p>重要的区别是：</p>
<ul>
<li><code>||</code> 返回第一个 <strong>真</strong> 值。</li>
<li><code>??</code> 返回第一个 <strong>已定义的</strong> 值。</li>
</ul>
<p>当我们想将 <code>null/undefined</code> 与 <code>0</code> 区别对待时，这个区别至关重要。</p>
<p>例如，考虑下面这种情况：</p>
<pre><code class="language-js">height = height ?? <span class="hljs-number">100</span>;</code></pre>
<p>如果 <code>height</code> 未定义，则将其赋值为 <code>100</code>。</p>
<p>让我们将其与 <code>||</code> 进行比较：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> height = <span class="hljs-number">0</span>;

alert(height || <span class="hljs-number">100</span>); <span class="hljs-comment">// 100</span>
alert(height ?? <span class="hljs-number">100</span>); <span class="hljs-comment">// 0</span></code></pre>
<p>在这个例子中，<code>height || 100</code> 将值为 <code>0</code> 的 <code>height</code> 视为未设置的（unset），与 <code>null</code>、<code>undefined</code> 以及任何其他假（falsy）值同等对待。因此得到的结果是 <code>100</code>。</p>
<p><code>height ?? 100</code> 仅当 <code>height</code> 确实是 <code>null</code> 或 <code>undefined</code> 时才返回 <code>100</code>。因此，<code>alert</code> 按原样显示了 <code>height</code> 值 <code>0</code>。</p>
<p>哪种行为更好取决于特定的使用场景。当高度 <code>0</code> 为有效值时，<code>??</code> 运算符更适合。</p>
<h2 id="优先级">优先级</h2>
<p><code>??</code> 运算符的优先级相当低：在 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table">MDN table</a> 中为 <code>5</code>。</p>
<p>因此，<code>??</code> 在大多数其他运算之后，但在 <code>=</code> 和 <code>?</code> 之前进行运算。</p>
<p>如果我们需要在复杂表达式中使用 <code>??</code> 进行取值，需要考虑加括号：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> height = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">let</span> width = <span class="hljs-literal">null</span>;

<span class="hljs-comment">// 重要：使用括号</span>
<span class="hljs-keyword">let</span> area = (height ?? <span class="hljs-number">100</span>) * (width ?? <span class="hljs-number">50</span>);

alert(area); <span class="hljs-comment">// 5000</span></code></pre>
<p>否则，如果我们省略了括号，<code>*</code> 的优先级比 <code>??</code> 高，会优先执行。</p>
<p>运算过程将等同于下面这个表达式：</p>
<pre><code class="language-js"><span class="hljs-comment">// 可能不正确的</span>
<span class="hljs-keyword">let</span> area = height ?? (<span class="hljs-number">100</span> * width) ?? <span class="hljs-number">50</span>;</code></pre>
<p>这里还有一个相关的语言级别的限制。</p>
<p><strong>出于安全原因，禁止将 <code>??</code> 运算符与 <code>&amp;&amp;</code> 和 <code>||</code> 运算符一起使用。</strong></p>
<p>下面的代码会触发一个语法错误：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-number">2</span> ?? <span class="hljs-number">3</span>; <span class="hljs-comment">// Syntax error</span></code></pre>
<p>这个限制无疑是值得商榷的，但是它被添加到语言规范中是为了避免编程错误，因为人们开始使用 <code>??</code> 替代 <code>||</code>。</p>
<p>可以明确地使用括号来解决这个问题：</p>
<pre><code class="language-js">*!*
<span class="hljs-keyword">let</span> x = (<span class="hljs-number">1</span> &amp;&amp; <span class="hljs-number">2</span>) ?? <span class="hljs-number">3</span>; <span class="hljs-comment">// 起作用</span>
*/!*

alert(x); <span class="hljs-comment">// 2</span></code></pre>
<h2 id="总结">总结</h2>
<ul>
<li><p>空值合并运算符 <code>??</code> 提供了一种简洁的方式获取列表中“已定义”的值。</p>
<p>  它被用于为变量分配默认值：</p>
<pre><code class="language-js"><span class="hljs-comment">// 当 height 的值为 null 或 undefined 时，将 height 的值设置为 100</span>
height = height ?? <span class="hljs-number">100</span>;</code></pre>
</li>
<li><p><code>??</code> 运算符的优先级非常低，只略高于 <code>?</code> 和 <code>=</code>。</p>
</li>
<li><p>如果没有明确添加括号，不能将其与 <code>||</code> 或 <code>&amp;&amp;</code> 一起使用。</p>
</li>
</ul>

      </fieldset>
      
      <fieldset id='_iKyDWM'>
      <legend>solution</legend>
      <p>答案是：<code>1</code>。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">3</span>;

<span class="hljs-keyword">while</span> (i) {
  alert( i-- );
}</code></pre>
<p>每次循环迭代都将 <code>i</code> 减  <code>1</code>。当检查到 <code>i = 0</code> 时，<code>while(i)</code> 循环停止。</p>
<p>因此，此循环执行的步骤如下（“循环展开”）：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">3</span>;

alert(i--); <span class="hljs-comment">// 显示 3，i 减至 2</span>

alert(i--) <span class="hljs-comment">// 显示 2，i 减至 1</span>

alert(i--) <span class="hljs-comment">// 显示 1，i 减至 0</span>

<span class="hljs-comment">// 完成，while(i) 检查循环条件并停止循环</span></code></pre>

      </fieldset>
      
      <fieldset id='_4BqFui'>
      <legend>task</legend>
      <p>importance: 3</p>
<hr>
<h1 id="最后一次循环的值">最后一次循环的值</h1>
<p>此代码最后一次 alert 值是多少？为什么？</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">3</span>;

<span class="hljs-keyword">while</span> (i) {
  alert( i-- );
}</code></pre>

      </fieldset>
      
      <fieldset id='_mOWrfW'>
      <legend>solution</legend>
      <p>这个题目展现了 i++/++i 两种形式在比较中导致的不同结果。</p>
<ol>
<li><p><strong>从 1 到 4</strong></p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span> (++i &lt; <span class="hljs-number">5</span>) alert( i );</code></pre>
<p> 第一个值是 <code>i = 1</code>，因为 <code>++i</code> 首先递增 <code>i</code> 然后返回新值。因此先比较 <code>1 &lt; 5</code> 然后通过 <code>alert</code> 显示 <code>1</code>。</p>
<p> 然后按照 <code>2, 3, 4…</code> —— 数值一个接着一个被显示出来。在比较中使用的都是递增后的值，因为 <code>++</code> 在变量前。</p>
<p> 最终，<code>i = 4</code> 时，在 <code>++i &lt; 5</code> 的比较中，<code>i</code> 值递增至 <code>5</code>，所以 <code>while(5 &lt; 5)</code> 不符合循环条件，循环停止。所以没有显示 <code>5</code>。</p>
</li>
<li><p><strong>从 1 到 5</strong></p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span> (i++ &lt; <span class="hljs-number">5</span>) alert( i );</code></pre>
<p> 第一个值也是 <code>i = 1</code>。后缀形式 <code>i++</code> 递增 <code>i</code> 然后返回 <strong>旧</strong> 值，因此比较 <code>i++ &lt; 5</code> 将使用 <code>i = 0</code>（与 <code>++i &lt; 5</code> 不同）。</p>
<p> 但 <code>alert</code> 调用是独立的。这是在递增和比较之后执行的另一条语句。因此它得到了当前的 <code>i = 1</code>。</p>
<p> 接下来是 <code>2, 3,4…</code></p>
<p> 我们在 <code>i = 4</code> 时暂停，前缀形式 <code>++i</code> 会递增 <code>i</code> 并在比较中使用新值 <code>5</code>。但我们这里是后缀形式 <code>i++</code>。因此，它将 <code>i</code> 递增到 <code>5</code>，但返回旧值。因此实际比较的是 <code>while(4 &lt; 5)</code> —— true，程序继续执行 <code>alert</code>。</p>
<p> <code>i = 5</code> 是最后一个值，因为下一步比较 <code>while(5 &lt; 5)</code> 为 false。</p>
</li>
</ol>

      </fieldset>
      
      <fieldset id='_5f5iuN'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="while-循环显示哪些值？">while 循环显示哪些值？</h1>
<p>对于每次循环，写出你认为会显示的值，然后与答案进行比较。</p>
<p>以下两个循环的 <code>alert</code> 值是否相同？</p>
<ol>
<li><p>前缀形式 <code>++i</code>:</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span> (++i &lt; <span class="hljs-number">5</span>) alert( i );</code></pre>
</li>
<li><p>后缀形式 <code>i++</code></p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span> (i++ &lt; <span class="hljs-number">5</span>) alert( i );</code></pre>
</li>
</ol>

      </fieldset>
      
      <fieldset id='_e6AA6P'>
      <legend>solution</legend>
      <p><strong>答案：在这两种情况下都是从 <code>0</code> 到 <code>4</code>。</strong></p>
<pre><code class="language-js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) alert( i );

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) alert( i );</code></pre>
<p>这可以很容易地从 <code>for</code> 算法中推导出：</p>
<ol>
<li>在一切开始之前执行 <code>i = 0</code>。</li>
<li>检查 <code>i &lt; 5</code> 条件</li>
<li>如果 <code>true</code> —— 执行循环体并 <code>alert(i)</code>，然后进行 <code>i++</code></li>
</ol>
<p>递增 <code>i++</code> 与检查条件（2）分开。这只是另一种写法。</p>
<p>在这没使用返回的递增值，因此 <code>i++</code> 和 <code>++i</code>之间没有区别。</p>

      </fieldset>
      
      <fieldset id='_gdhxZe'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="for-循环显示哪些值？">&quot;for&quot; 循环显示哪些值？</h1>
<p>对于每次循环，写下它将显示的值。然后与答案进行比较。</p>
<p>两次循环 <code>alert</code> 值是否相同？</p>
<ol>
<li><p>后缀形式：</p>
<pre><code class="language-js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) alert( i );</code></pre>
</li>
<li><p>前缀形式：</p>
<pre><code class="language-js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) alert( i );</code></pre>
</li>
</ol>

      </fieldset>
      
      <fieldset id='_FCXq0R'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">10</span>; i++) {
  <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
    alert( i );
  }
}</code></pre>
<p>我们使用 &quot;modulo&quot; 运算符 <code>%</code> 来获取余数，并检查奇偶性。</p>

      </fieldset>
      
      <fieldset id='_a1bgQU'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="使用-for-循环输出偶数">使用 for 循环输出偶数</h1>
<p>使用 <code>for</code> 循环输出从 <code>2</code> 到 <code>10</code> 的偶数。</p>
<p>[demo]</p>

      </fieldset>
      
      <fieldset id='_SgP0YW'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">3</span>) {
  alert( <span class="hljs-string">`number <span class="hljs-subst">${i}</span>!`</span> );
  i++;
}</code></pre>

      </fieldset>
      
      <fieldset id='_HB6hNk'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="用-while-替换-for">用 &quot;while&quot; 替换 &quot;for&quot;</h1>
<p>重写代码，在保证不改变其行为的情况下，将 <code>for</code> 循环更改为 <code>while</code>（输出应保持不变）。</p>
<pre><code class="language-js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {
  alert( <span class="hljs-string">`number <span class="hljs-subst">${i}</span>!`</span> );
}</code></pre>

      </fieldset>
      
      <fieldset id='_FMQqpd'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-keyword">let</span> num;

<span class="hljs-keyword">do</span> {
  num = prompt(<span class="hljs-string">&quot;Enter a number greater than 100?&quot;</span>, <span class="hljs-number">0</span>);
} <span class="hljs-keyword">while</span> (num &lt;= <span class="hljs-number">100</span> &amp;&amp; num);</code></pre>
<p>两个检查都为真时，继续执行 <code>do..while</code> 循环：</p>
<ol>
<li>检查 <code>num &lt;= 100</code> —— 即输入值仍然不大于 <code>100</code>。</li>
<li>当 <code>num</code> 为 <code>null</code> 或空字符串时，<code>&amp;&amp; num</code> 的结果为 false。那么 <code>while</code> 循环也会停止。</li>
</ol>
<p>P.S. 如果 <code>num</code> 为 <code>null</code>，那么 <code>num &lt;= 100</code> 为 <code>true</code>。因此用户单击取消，如果没有第二次检查，循环就不会停止。两次检查都是必须的。</p>

      </fieldset>
      
      <fieldset id='_HM5bdF'>
      <legend>task</legend>
      <h2 id="importance-5">importance: 5</h2>
<h1 id="重复输入，直到正确为止">重复输入，直到正确为止</h1>
<p>编写一个提示用户输入大于 <code>100</code> 的数字的循环。如果用户输入其他数值 —— 请他重新输入。</p>
<p>循环一直在请求一个数字，直到用户输入了一个大于 <code>100</code> 的数字、取消输入或输入了一个空行为止。</p>
<p>在这我们假设用户只会输入数字。在本题目中，不需要对非数值输入进行特殊处理。</p>
<p>[demo]</p>

      </fieldset>
      
      <fieldset id='_ADwnjB'>
      <legend>solution</legend>
      <p>这个题目有很多解法。</p>
<p>我们使用一个嵌套循环：</p>
<pre><code class="language-js">对于间隔中的每个 i {
  检查在 <span class="hljs-number">1</span>~i 之间，是否有 i 的除数
  如果有 =&gt; 这个 i 不是素数
  如果没有 =&gt; 这个 i 是素数，输出出来
}</code></pre>
<p>使用标签的代码：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> n = <span class="hljs-number">10</span>;

nextPrime:
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) { <span class="hljs-comment">// 对每个自然数 i</span>

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">2</span>; j &lt; i; j++) { <span class="hljs-comment">// 寻找一个除数……</span>
    <span class="hljs-keyword">if</span> (i % j == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span> nextPrime; <span class="hljs-comment">// 不是素数，则继续检查下一个</span>
  }

  alert( i ); <span class="hljs-comment">// 输出素数</span>
}</code></pre>
<p>这段代码有很大的优化空间。例如，我们可以从 <code>2</code> 到 <code>i</code> 的平方根之间的数中寻找除数。无论怎样，如果我们想要在很大的数字范围内实现高效率，我们需要改变实现方法，依赖高等数学和复杂算法，如<a href="https://en.wikipedia.org/wiki/Quadratic_sieve">二次筛选法（Quadratic sieve）</a>，<a href="https://en.wikipedia.org/wiki/General_number_field_sieve">普通数域筛选法（General number field sieve）</a>等。</p>
<p>译注：素数也称为质数，对本答案的代码进一步优化，其实就是一道 LeetCode 算法题，感兴趣的可以点击链接查看如何通过 <a href="https://dingxuewen.com/leetcode-js-leviding/easy/204.count-primes/204.count-primes.html">埃拉托斯特尼筛法筛选素数</a>。</p>

      </fieldset>
      
      <fieldset id='_3BXKQC'>
      <legend>task</legend>
      <p>importance: 3</p>
<hr>
<h1 id="输出素数（prime）">输出素数（prime）</h1>
<p>大于 <code>1</code> 且不能被除了 <code>1</code> 和它本身以外的任何数整除的整数叫做<a href="https://en.wikipedia.org/wiki/Prime_number">素数</a>。</p>
<p>换句话说，<code>n &gt; 1</code> 且不能被 <code>1</code> 和 <code>n</code> 以外的任何数整除的整数，被称为素数。</p>
<p>例如，<code>5</code> 是素数，因为它不能被 <code>2</code>、<code>3</code> 和 <code>4</code> 整除，会产生余数。</p>
<p><strong>写一个可以输出 <code>2</code> 到 <code>n</code> 之间的所有素数的代码。</strong></p>
<p>当 <code>n = 10</code>，结果输出 <code>2、3、5、7</code>。</p>
<p>P.S. 代码应适用于任何 <code>n</code>，而不是对任何固定值进行硬性调整。</p>

      </fieldset>
      
      <fieldset id='_y7trOL'>
      <legend>article</legend>
      <h1 id="循环：while-和-for">循环：while 和 for</h1>
<p>我们经常需要重复执行一些操作。</p>
<p>例如，我们需要将列表中的商品逐个输出，或者运行相同的代码将数字 1 到 10 逐个输出。</p>
<p><strong>循环</strong> 是一种重复运行同一代码的方法。</p>
<h2 id="while-循环">&quot;while&quot; 循环</h2>
<p><code>while</code> 循环的语法如下：</p>
<pre><code class="language-js"><span class="hljs-keyword">while</span> (condition) {
  <span class="hljs-comment">// 代码</span>
  <span class="hljs-comment">// 所谓的“循环体” </span>
}</code></pre>
<p>当 <code>condition</code> 为 <code>true</code> 时，执行循环体的 <code>code</code>。</p>
<p>例如，以下将循环输出当 <code>i &lt; 3</code> 时的 <code>i</code> 值：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">3</span>) { <span class="hljs-comment">// 依次显示 0、1 和 2</span>
  alert( i );
  i++;
}</code></pre>
<p>循环体的单次执行叫作 <strong>一次迭代</strong>。上面示例中的循环进行了三次迭代。</p>
<p>如果上述示例中没有 <code>i++</code>，那么循环（理论上）会永远重复执行下去。实际上，浏览器提供了阻止这种循环的方法，我们可以通过终止进程，来停掉服务器端的 JavaScript。</p>
<p>任何表达式或变量都可以是循环条件，而不仅仅是比较。在 <code>while</code> 中的循环条件会被计算，计算结果会被转化为布尔值。</p>
<p>例如，<code>while (i != 0)</code> 可简写为 <code>while (i)</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">3</span>;
*!*
<span class="hljs-keyword">while</span> (i) { <span class="hljs-comment">// 当 i 变成 0 时，条件为 false，循环终止</span>
*/!*
  alert( i );
  i--;
}</code></pre>
<pre><code class="language-smart">如果循环体只有一条语句，则可以省略大括号 `{…}`：

```js run
let i = 3;
*!*
while (i) alert(i--);
*/!*
```</code></pre>
<h2 id="dowhile-循环">&quot;do..while&quot; 循环</h2>
<p>使用 <code>do..while</code> 语法可以将条件检查移至循环体 <strong>下面</strong>：</p>
<pre><code class="language-js"><span class="hljs-keyword">do</span> {
  <span class="hljs-comment">// 循环体</span>
} <span class="hljs-keyword">while</span> (condition);</code></pre>
<p>循环首先执行循环体，然后检查条件，当条件为真时，重复执行循环体。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">do</span> {
  alert( i );
  i++;
} <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">3</span>);</code></pre>
<p>这种形式的语法很少使用，除非你希望不管条件是否为真，循环体 <strong>至少执行一次</strong>。通常我们更倾向于使用另一个形式：<code>while(…) {…}</code>。</p>
<h2 id="for-循环">&quot;for&quot; 循环</h2>
<p><code>for</code> 循环更加复杂，但它是最常使用的循环形式。</p>
<p><code>for</code> 循环看起来就像这样：</p>
<pre><code class="language-js"><span class="hljs-keyword">for</span> (begin; condition; step) {
  <span class="hljs-comment">// ……循环体……</span>
}</code></pre>
<p>我们通过示例来了解一下这三个部分的含义。下述循环从 <code>i</code> 等于 <code>0</code> 到 <code>3</code>（但不包括 <code>3</code>）运行 <code>alert(i)</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) { <span class="hljs-comment">// 结果为 0、1、2</span>
  alert(i);
}</code></pre>
<p>我们逐个部分分析 <code>for</code> 循环：</p>
<table>
<thead>
<tr>
<th>语句段</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>begin</td>
<td><code>i = 0</code></td>
<td>进入循环时执行一次。</td>
</tr>
<tr>
<td>condition</td>
<td><code>i &lt; 3</code></td>
<td>在每次循环迭代之前检查，如果为 false，停止循环。</td>
</tr>
<tr>
<td>body（循环体）</td>
<td><code>alert(i)</code></td>
<td>条件为真时，重复运行。</td>
</tr>
<tr>
<td>step</td>
<td><code>i++</code></td>
<td>在每次循环体迭代后执行。</td>
</tr>
</tbody></table>
<p>一般循环算法的工作原理如下：</p>
<pre><code>开始运行
→ (如果 condition 成立 → 运行 body 然后运行 step)
→ (如果 condition 成立 → 运行 body 然后运行 step)
→ (如果 condition 成立 → 运行 body 然后运行 step)
→ ...</code></pre>
<p>所以，<code>begin</code> 执行一次，然后进行迭代：每次检查 <code>condition</code> 后，执行 <code>body</code> 和 <code>step</code>。</p>
<p>如果你这是第一次接触循环，那么回到这个例子，在一张纸上重现它逐步运行的过程，可能会对你有所帮助。</p>
<p>以下是在这个示例中发生的事：</p>
<pre><code class="language-js"><span class="hljs-comment">// for (let i = 0; i &lt; 3; i++) alert(i)</span>

<span class="hljs-comment">// 开始</span>
<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>
<span class="hljs-comment">// 如果条件为真，运行下一步</span>
<span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">3</span>) { alert(i); i++ }
<span class="hljs-comment">// 如果条件为真，运行下一步</span>
<span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">3</span>) { alert(i); i++ }
<span class="hljs-comment">// 如果条件为真，运行下一步</span>
<span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">3</span>) { alert(i); i++ }
<span class="hljs-comment">// ……结束，因为现在 i == 3</span></code></pre>
<pre><code class="language-smart">这里“计数”变量 `i` 是在循环中声明的。这叫做“内联”变量声明。这样的变量只在循环中可见。

```js run
for (*!*let*/!* i = 0; i &lt; 3; i++) {
  alert(i); // 0, 1, 2
}
alert(i); // 错误，没有这个变量。
```

除了定义一个变量，我们也可以使用现有的变量：

```js run
let i = 0;

for (i = 0; i &lt; 3; i++) { // 使用现有的变量
  alert(i); // 0, 1, 2
}

alert(i); //3，可见，因为是在循环之外声明的
```
</code></pre>
<h3 id="省略语句段">省略语句段</h3>
<p><code>for</code> 循环的任何语句段都可以被省略。</p>
<p>例如，如果我们在循环开始时不需要做任何事，我们就可以省略 <code>begin</code> 语句段。</p>
<p>就像这样：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// 我们已经声明了 i 并对它进行了赋值</span>

<span class="hljs-keyword">for</span> (; i &lt; <span class="hljs-number">3</span>; i++) { <span class="hljs-comment">// 不再需要 &quot;begin&quot; 语句段</span>
  alert( i ); <span class="hljs-comment">// 0, 1, 2</span>
}</code></pre>
<p>我们也可以移除 <code>step</code> 语句段：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;

<span class="hljs-keyword">for</span> (; i &lt; <span class="hljs-number">3</span>;) {
  alert( i++ );
}</code></pre>
<p>该循环与 <code>while (i &lt; 3)</code> 等价。</p>
<p>实际上我们可以删除所有内容，从而创建一个无限循环：</p>
<pre><code class="language-js"><span class="hljs-keyword">for</span> (;;) {
  <span class="hljs-comment">// 无限循环</span>
}</code></pre>
<p>请注意 <code>for</code> 的两个 <code>;</code> 必须存在，否则会出现语法错误。</p>
<h2 id="跳出循环">跳出循环</h2>
<p>通常条件为假时，循环会终止。</p>
<p>但我们随时都可以使用 <code>break</code> 指令强制退出。</p>
<p>例如，下面这个循环要求用户输入一系列数字，在输入的内容不是数字时“终止”循环。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;

<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {

  <span class="hljs-keyword">let</span> value = +prompt(<span class="hljs-string">&quot;Enter a number&quot;</span>, <span class="hljs-string">&#x27;&#x27;</span>);

*!*
  <span class="hljs-keyword">if</span> (!value) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// (*)</span>
*/!*

  sum += value;

}
alert( <span class="hljs-string">&#x27;Sum: &#x27;</span> + sum );</code></pre>
<p>如果用户输入空行或取消输入，在 <code>(*)</code> 行的 <code>break</code> 指令会被激活。它立刻终止循环，将控制权传递给循环后的第一行，即，<code>alert</code>。</p>
<p>根据需要，&quot;无限循环 + <code>break</code>&quot; 的组合非常适用于不必在循环开始/结束时检查条件，但需要在中间甚至是主体的多个位置进行条件检查的情况。</p>
<h2 id="继续下一次迭代-continue">继续下一次迭代 [#continue]</h2>
<p><code>continue</code> 指令是 <code>break</code> 的“轻量版”。它不会停掉整个循环。而是停止当前这一次迭代，并强制启动新一轮循环（如果条件允许的话）。</p>
<p>如果我们完成了当前的迭代，并且希望继续执行下一次迭代，我们就可以使用它。</p>
<p>下面这个循环使用 <code>continue</code> 来只输出奇数：</p>
<pre><code class="language-js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {

  <span class="hljs-comment">//如果为真，跳过循环体的剩余部分。</span>
  *!*<span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;*/!*

  alert(i); <span class="hljs-comment">// 1，然后 3，5，7，9</span>
}</code></pre>
<p>对于偶数的 <code>i</code> 值，<code>continue</code> 指令会停止本次循环的继续执行，将控制权传递给下一次 <code>for</code> 循环的迭代（使用下一个数字）。因此 <code>alert</code> 仅被奇数值调用。</p>
<p>````smart header=&quot;<code>continue</code> 指令利于减少嵌套&quot;
显示奇数的循环可以像下面这样：</p>
<pre><code class="language-js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {

  <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) {
    alert( i );
  }

}</code></pre>
<p>从技术角度看，它与上一个示例完全相同。当然，我们可以将代码包装在 <code>if</code> 块而不使用 <code>continue</code>。</p>
<p>但在副作用方面，它多创建了一层嵌套（大括号内的 <code>alert</code> 调用）。如果 <code>if</code> 中代码有多行，则可能会降低代码整体的可读性。</p>
<pre><code>
````warn header=&quot;禁止 `break/continue` 在 ‘?’ 的右边&quot;
请注意非表达式的语法结构不能与三元运算符 `?` 一起使用。特别是 `break/continue` 这样的指令是不允许这样使用的。

例如，我们使用如下代码：

```js
if (i &gt; 5) {
  alert(i);
} else {
  continue;
}
```

……用问号重写：


```js no-beautify
(i &gt; 5) ? alert(i) : *!*continue*/!*; // continue 不允许在这个位置
```

……代码会停止运行，并显示有语法错误。

这是不（建议）使用问号 `?` 运算符替代 `if` 语句的另一个原因。</code></pre>
<h2 id="breakcontinue-标签">break/continue 标签</h2>
<p>有时候我们需要从一次从多层嵌套的循环中跳出来。</p>
<p>例如，下述代码中我们的循环使用了 <code>i</code> 和 <code>j</code>，从 <code>(0,0)</code> 到 <code>(3,3)</code> 提示坐标 <code>(i, j)</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++) {

    <span class="hljs-keyword">let</span> input = prompt(<span class="hljs-string">`Value at coords (<span class="hljs-subst">${i}</span>,<span class="hljs-subst">${j}</span>)`</span>, <span class="hljs-string">&#x27;&#x27;</span>);

    <span class="hljs-comment">// 如果我想从这里退出并直接执行 alert(&#x27;Done!&#x27;)</span>
  }
}

alert(<span class="hljs-string">&#x27;Done!&#x27;</span>);</code></pre>
<p>我们需要提供一种方法，以在用户取消输入时来停止这个过程。</p>
<p>在 <code>input</code> 之后的普通 <code>break</code> 只会打破内部循环。这还不够 —— 标签可以实现这一功能！</p>
<p><strong>标签</strong> 是在循环之前带有冒号的标识符：</p>
<pre><code class="language-js">labelName: <span class="hljs-keyword">for</span> (...) {
  ...
}</code></pre>
<p><code>break &lt;labelName&gt;</code> 语句跳出循环至标签处：</p>
<pre><code class="language-js">*!*outer:*/!* for (let i = 0; i &lt; 3; i++) {

  for (let j = 0; j &lt; 3; j++) {

    let input = prompt(`Value at coords (${i},${j})`, &#x27;&#x27;);

    // 如果是空字符串或被取消，则中断并跳出这两个循环。
    if (!input) *!*break outer*/!*; // (*)

    // 用得到的值做些事……
  }
}
alert(&#x27;Done!&#x27;);</code></pre>
<p>上述代码中，<code>break outer</code> 向上寻找名为 <code>outer</code> 的标签并跳出当前循环。</p>
<p>因此，控制权直接从 <code>(*)</code> 转至 <code>alert(&#39;Done!&#39;)</code>。</p>
<p>我们还可以将标签移至单独一行：</p>
<pre><code class="language-js">outer:
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) { ... }</code></pre>
<p><code>continue</code> 指令也可以与标签一起使用。在这种情况下，执行跳转到标记循环的下一次迭代。</p>
<pre><code class="language-warn">标签不允许我们跳到代码的任意位置。

例如，这样做是不可能的：
```js
break label;  // 无法跳转到这个标签

label: for (...)
```

只有在循环内部才能调用 `break/continue`，并且标签必须位于指令上方的某个位置。 </code></pre>
<h2 id="总结">总结</h2>
<p>我们学习了三种循环：</p>
<ul>
<li><code>while</code> —— 每次迭代之前都要检查条件。</li>
<li><code>do..while</code> —— 每次迭代后都要检查条件。</li>
<li><code>for (;;)</code> —— 每次迭代之前都要检查条件，可以使用其他设置。</li>
</ul>
<p>通常使用 <code>while(true)</code> 来构造“无限”循环。这样的循环和其他循环一样，都可以通过 <code>break</code> 指令来终止。</p>
<p>如果我们不想在当前迭代中做任何事，并且想要转移至下一次迭代，那么可以使用 <code>continue</code> 指令。</p>
<p><code>break/continue</code> 支持循环前的标签。标签是 <code>break/continue</code> 跳出嵌套循环以转到外部的唯一方法。</p>

      </fieldset>
      
      <fieldset id='_cUrL74'>
      <legend>solution</legend>
      <p>为了精确实现 <code>switch</code> 的功能，<code>if</code> 必须使用严格相等 <code>&#39;===&#39;</code>。</p>
<p>对于给定的字符串，一个简单的 <code>&#39;==&#39;</code> 也可以。</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">browser == <span class="hljs-string">&#x27;Edge&#x27;</span></span>)</span> {
  alert(<span class="hljs-string">&quot;You&#x27;ve got the Edge!&quot;</span>);
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (browser == <span class="hljs-string">&#x27;Chrome&#x27;</span>
 || browser == <span class="hljs-string">&#x27;Firefox&#x27;</span>
 || browser == <span class="hljs-string">&#x27;Safari&#x27;</span>
 || browser == <span class="hljs-string">&#x27;Opera&#x27;</span>) {
  alert( <span class="hljs-string">&#x27;Okay we support these browsers too&#x27;</span> );
} <span class="hljs-keyword">else</span> {
  alert( <span class="hljs-string">&#x27;We hope that this page looks ok!&#x27;</span> );
}</code></pre>
<p>请注意：将 <code>browser == &#39;Chrome&#39; || browser == &#39;Firefox&#39; …</code> 结构分成多行可读性更高。</p>
<p>但 <code>switch</code> 结构更清晰明了。</p>

      </fieldset>
      
      <fieldset id='_heDWyL'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="将-switch-结构重写为-if-结构">将 &quot;switch&quot; 结构重写为 &quot;if&quot; 结构</h1>
<p>将下面 <code>switch</code> 结构的代码写成 <code>if..else</code> 结构：</p>
<pre><code class="language-js"><span class="hljs-keyword">switch</span> (browser) {
  <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Edge&#x27;</span>:
    alert( <span class="hljs-string">&quot;You&#x27;ve got the Edge!&quot;</span> );
    <span class="hljs-keyword">break</span>;

  <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Chrome&#x27;</span>:
  <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Firefox&#x27;</span>:
  <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Safari&#x27;</span>:
  <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Opera&#x27;</span>:
    alert( <span class="hljs-string">&#x27;Okay we support these browsers too&#x27;</span> );
    <span class="hljs-keyword">break</span>;

  <span class="hljs-keyword">default</span>:
    alert( <span class="hljs-string">&#x27;We hope that this page looks ok!&#x27;</span> );
}</code></pre>

      </fieldset>
      
      <fieldset id='_FyTGBU'>
      <legend>solution</legend>
      <p>前两个检查为前两个 <code>case</code>，第三个检查分为两种情况：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> a = +prompt(<span class="hljs-string">&#x27;a?&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>);

<span class="hljs-keyword">switch</span> (a) {
  <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
    alert( <span class="hljs-number">0</span> );
    <span class="hljs-keyword">break</span>;

  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
    alert( <span class="hljs-number">1</span> );
    <span class="hljs-keyword">break</span>;

  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
  <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
    alert( <span class="hljs-string">&#x27;2,3&#x27;</span> );
*!*
    <span class="hljs-keyword">break</span>;
*/!*
}</code></pre>
<p>请注意：最后的 <code>break</code> 不是必须的。但是为了让代码可扩展我们要把它加上。</p>
<p>有可能之后我们想要再添加一个 <code>case</code>，例如 <code>case 4</code>。如果我们忘记在它之前添加一个 break，那么在 case 3 执行结束后可能会出现错误。所以这是一种自我保险。</p>

      </fieldset>
      
      <fieldset id='_VMfcC8'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="将-if-结构重写为-switch-结构">将 &quot;if&quot; 结构重写为 &quot;switch&quot; 结构</h1>
<p>用 <code>switch</code> 重写以下代码：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> a = +prompt(<span class="hljs-string">&#x27;a?&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>);

<span class="hljs-keyword">if</span> (a == <span class="hljs-number">0</span>) {
  alert( <span class="hljs-number">0</span> );
}
<span class="hljs-keyword">if</span> (a == <span class="hljs-number">1</span>) {
  alert( <span class="hljs-number">1</span> );
}

<span class="hljs-keyword">if</span> (a == <span class="hljs-number">2</span> || a == <span class="hljs-number">3</span>) {
  alert( <span class="hljs-string">&#x27;2,3&#x27;</span> );
}</code></pre>

      </fieldset>
      
      <fieldset id='_BTjRuu'>
      <legend>article</legend>
      <h1 id="switch-语句">&quot;switch&quot; 语句</h1>
<p><code>switch</code> 语句可以替代多个 <code>if</code> 判断。</p>
<p><code>switch</code> 语句为多分支选择的情况提供了一个更具描述性的方式。</p>
<h2 id="语法">语法</h2>
<p><code>switch</code> 语句有至少一个 <code>case</code> 代码块和一个可选的 <code>default</code> 代码块。</p>
<p>就像这样：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-title">switch</span>(<span class="hljs-params">x</span>)</span> {
  <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;value1&#x27;</span>:  <span class="hljs-comment">// if (x === &#x27;value1&#x27;)</span>
    ...
    [<span class="hljs-keyword">break</span>]

  <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;value2&#x27;</span>:  <span class="hljs-comment">// if (x === &#x27;value2&#x27;)</span>
    ...
    [<span class="hljs-keyword">break</span>]

  <span class="hljs-attr">default</span>:
    ...
    [<span class="hljs-keyword">break</span>]
}</code></pre>
<ul>
<li>比较 <code>x</code> 值与第一个 <code>case</code>（也就是 <code>value1</code>）是否严格相等，然后比较第二个 <code>case</code>（<code>value2</code>）以此类推。</li>
<li>如果相等，<code>switch</code> 语句就执行相应 <code>case</code> 下的代码块，直到遇到最靠近的 <code>break</code> 语句（或者直到 <code>switch</code> 语句末尾）。</li>
<li>如果没有符合的 case，则执行 <code>default</code> 代码块（如果 <code>default</code> 存在）。</li>
</ul>
<h2 id="举个例子">举个例子</h2>
<p><code>switch</code> 的例子（高亮的部分是执行的 <code>case</code> 部分）：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;

<span class="hljs-keyword">switch</span> (a) {
  <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
    alert( <span class="hljs-string">&#x27;Too small&#x27;</span> );
    <span class="hljs-keyword">break</span>;
*!*
  <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:
    alert( <span class="hljs-string">&#x27;Exactly!&#x27;</span> );
    <span class="hljs-keyword">break</span>;
*/!*
  <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:
    alert( <span class="hljs-string">&#x27;Too large&#x27;</span> );
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">default</span>:
    alert( <span class="hljs-string">&quot;I don&#x27;t know such values&quot;</span> );
}</code></pre>
<p>这里的 <code>switch</code> 从第一个 <code>case</code> 分支开始将 <code>a</code> 的值与 <code>case</code> 后的值进行比较，第一个 <code>case</code> 后的值为 <code>3</code> 匹配失败。</p>
<p>然后比较 <code>4</code>。匹配，所以从 <code>case 4</code> 开始执行直到遇到最近的 <code>break</code>。</p>
<p><strong>如果没有 <code>break</code>，程序将不经过任何检查就会继续执行下一个 <code>case</code>。</strong></p>
<p>无 <code>break</code> 的例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;

<span class="hljs-keyword">switch</span> (a) {
  <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
    alert( <span class="hljs-string">&#x27;Too small&#x27;</span> );
*!*
  <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:
    alert( <span class="hljs-string">&#x27;Exactly!&#x27;</span> );
  <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:
    alert( <span class="hljs-string">&#x27;Too big&#x27;</span> );
  <span class="hljs-keyword">default</span>:
    alert( <span class="hljs-string">&quot;I don&#x27;t know such values&quot;</span> );
*/!*
}</code></pre>
<p>在上面的例子中我们会看到连续执行的三个 <code>alert</code>：</p>
<pre><code class="language-js">alert( <span class="hljs-string">&#x27;Exactly!&#x27;</span> );
alert( <span class="hljs-string">&#x27;Too big&#x27;</span> );
alert( <span class="hljs-string">&quot;I don&#x27;t know such values&quot;</span> );</code></pre>
<p>````smart header=&quot;任何表达式都可以成为 <code>switch/case</code> 的参数&quot;
<code>switch</code> 和 <code>case</code> 都允许任意表达式。</p>
<p>比如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> a = <span class="hljs-string">&quot;1&quot;</span>;
<span class="hljs-keyword">let</span> b = <span class="hljs-number">0</span>;

<span class="hljs-keyword">switch</span> (+a) {
*!*
  <span class="hljs-keyword">case</span> b + <span class="hljs-number">1</span>:
    alert(<span class="hljs-string">&quot;this runs, because +a is 1, exactly equals b+1&quot;</span>);
    <span class="hljs-keyword">break</span>;
*/!*

  <span class="hljs-keyword">default</span>:
    alert(<span class="hljs-string">&quot;this doesn&#x27;t run&quot;</span>);
}</code></pre>
<p>这里 <code>+a</code> 返回 <code>1</code>，这个值跟 <code>case</code> 中 <code>b + 1</code> 相比较，然后执行对应的代码。</p>
<pre><code>
## &quot;case&quot; 分组

共享同一段代码的几个 `case` 分支可以被分为一组：

比如，如果我们想让 `case 3` 和 `case 5` 执行同样的代码：

```js run no-beautify
let a = 3;

switch (a) {
  case 4:
    alert(&#x27;Right!&#x27;);
    break;

*!*
  case 3: // (*) 下面这两个 case 被分在一组
  case 5:
    alert(&#x27;Wrong!&#x27;);
    alert(&quot;Why don&#x27;t you take a math class?&quot;);
    break;
*/!*

  default:
    alert(&#x27;The result is strange. Really.&#x27;);
}
```

现在 `3` 和 `5` 都显示相同的信息。

`switch/case` 有通过 case 进行“分组”的能力，其实是 switch 语句没有 `break` 时的副作用。因为没有 `break`，`case 3` 会从 `(*)` 行执行到 `case 5`。

## 类型很关键

强调一下，这里的相等是严格相等。被比较的值必须是相同的类型才能进行匹配。

比如，我们来看下面的代码：

```js run
let arg = prompt(&quot;Enter a value?&quot;)
switch (arg) {
  case &#x27;0&#x27;:
  case &#x27;1&#x27;:
    alert( &#x27;One or zero&#x27; );
    break;

  case &#x27;2&#x27;:
    alert( &#x27;Two&#x27; );
    break;

  case 3:
    alert( &#x27;Never executes!&#x27; );
    break;
  default:
    alert( &#x27;An unknown value&#x27; )
}
```

1. 在 `prompt` 对话框输入 `0`、`1`，第一个 `alert` 弹出。
2. 输入 `2`，第二个 `alert` 弹出。 
3. 但是输入 `3`，因为 `prompt` 的结果是字符串类型的 `&quot;3&quot;`，不严格相等 `===` 于数字类型的 `3`，所以 `case 3` 不会执行！因此 `case 3` 部分是一段无效代码。所以会执行 `default` 分支。
</code></pre>

      </fieldset>
      
      <fieldset id='_aiBrnX'>
      <legend>solution</legend>
      <p>没有区别。</p>

      </fieldset>
      
      <fieldset id='_RZpVp3'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="是否需要-else？">是否需要 “else”？</h1>
<p>如果参数 <code>age</code> 大于 <code>18</code>，那么下面的函数将返回 <code>true</code>。</p>
<p>否则它将会要求进行确认，并返回确认结果：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkAge</span>(<span class="hljs-params">age</span>) </span>{
  <span class="hljs-keyword">if</span> (age &gt; <span class="hljs-number">18</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
*!*
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">return</span> confirm(<span class="hljs-string">&#x27;Did parents allow you?&#x27;</span>);
  }
*/!*
}</code></pre>
<p>如果 <code>else</code> 被删除，函数的工作方式会不同吗？</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkAge</span>(<span class="hljs-params">age</span>) </span>{
  <span class="hljs-keyword">if</span> (age &gt; <span class="hljs-number">18</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
*!*
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">return</span> confirm(<span class="hljs-string">&#x27;Did parents allow you?&#x27;</span>);
*/!*
}</code></pre>
<p>这两个变体的行为是否有区别？</p>

      </fieldset>
      
      <fieldset id='_4vkMPc'>
      <legend>solution</legend>
      <p>使用问号运算符 <code>&#39;?&#39;</code>：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkAge</span>(<span class="hljs-params">age</span>) </span>{
  <span class="hljs-keyword">return</span> (age &gt; <span class="hljs-number">18</span>) ? <span class="hljs-literal">true</span> : confirm(<span class="hljs-string">&#x27;Did parents allow you?&#x27;</span>);
}</code></pre>
<p>使用或运算符 <code>||</code>（最短的变体）：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkAge</span>(<span class="hljs-params">age</span>) </span>{
  <span class="hljs-keyword">return</span> (age &gt; <span class="hljs-number">18</span>) || confirm(<span class="hljs-string">&#x27;Did parents allow you?&#x27;</span>);
}</code></pre>
<p>请注意此处不需要 <code>age &gt; 18</code> 左右的括号。写上括号是为了提高可读性。</p>

      </fieldset>
      
      <fieldset id='_GZORIi'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="使用--或者--重写函数">使用 &#39;?&#39; 或者 &#39;||&#39; 重写函数</h1>
<p>如果参数 <code>age</code> 大于 <code>18</code>，那么下面的函数返回 <code>true</code>。</p>
<p>否则它将会要求进行确认，并返回确认结果：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkAge</span>(<span class="hljs-params">age</span>) </span>{
  <span class="hljs-keyword">if</span> (age &gt; <span class="hljs-number">18</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> confirm(<span class="hljs-string">&#x27;Do you have your parents permission to access this page?&#x27;</span>);
  }
}</code></pre>
<p>重写这个函数并保证效果相同，不使用 <code>if</code>，且只需一行代码。</p>
<p>编写 <code>checkAge</code> 的两个变体：</p>
<ol>
<li>使用问号运算符 <code>?</code></li>
<li>使用或运算符 <code>||</code></li>
</ol>

      </fieldset>
      
      <fieldset id='_eVH2ib'>
      <legend>solution</legend>
      <p>使用 <code>if</code> 的解决方案：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">min</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">if</span> (a &lt; b) {
    <span class="hljs-keyword">return</span> a;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> b;
  }
}</code></pre>
<p>使用问号运算符 <code>&#39;?&#39;</code> 的解决方案：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">min</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">return</span> a &lt; b ? a : b;
}</code></pre>
<p>P.S. 在 <code>a == b</code> 的情况下，返回什么都无关紧要。</p>

      </fieldset>
      
      <fieldset id='_I9Ebl2'>
      <legend>task</legend>
      <p>importance: 1</p>
<hr>
<h1 id="函数-mina-b">函数 min(a, b)</h1>
<p>写一个返回数字 <code>a</code> 和 <code>b</code> 中较小的那个数字的函数 <code>min(a,b)</code>。</p>
<p>例如：</p>
<pre><code class="language-js">min(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>) == <span class="hljs-number">2</span>
min(<span class="hljs-number">3</span>, -<span class="hljs-number">1</span>) == -<span class="hljs-number">1</span>
min(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) == <span class="hljs-number">1</span></code></pre>

      </fieldset>
      
      <fieldset id='_asHjbj'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pow</span>(<span class="hljs-params">x, n</span>) </span>{
  <span class="hljs-keyword">let</span> result = x;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) {
    result *= x;
  }

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-keyword">let</span> x = prompt(<span class="hljs-string">&quot;x?&quot;</span>, <span class="hljs-string">&#x27;&#x27;</span>);
<span class="hljs-keyword">let</span> n = prompt(<span class="hljs-string">&quot;n?&quot;</span>, <span class="hljs-string">&#x27;&#x27;</span>);

<span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) {
  alert(<span class="hljs-string">`Power <span class="hljs-subst">${n}</span> is not supported, use a positive integer`</span>);
} <span class="hljs-keyword">else</span> {
  alert( pow(x, n) );
}</code></pre>

      </fieldset>
      
      <fieldset id='_6cvBrW'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="函数-powxn">函数 pow(x,n)</h1>
<p>写一个函数 <code>pow(x,n)</code>，返回 <code>x</code> 的 <code>n</code> 次方。换句话说，将 <code>x</code> 与自身相乘 <code>n</code> 次，返回最终结果。</p>
<pre><code class="language-js">pow(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>) = <span class="hljs-number">3</span> * <span class="hljs-number">3</span> = <span class="hljs-number">9</span>
pow(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>) = <span class="hljs-number">3</span> * <span class="hljs-number">3</span> * <span class="hljs-number">3</span> = <span class="hljs-number">27</span>
pow(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>) = <span class="hljs-number">1</span> * <span class="hljs-number">1</span> * ...*<span class="hljs-number">1</span> = <span class="hljs-number">1</span></code></pre>
<p>创建一个 web  页面，提示输入 <code>x</code> 和 <code>n</code>，然后返回 <code>pow(x,n)</code> 的运算结果。</p>
<p>[demo]</p>
<p>P.S. 在这个任务中，函数应该只支持自然数 <code>n</code>：从 <code>1</code> 开始的整数。</p>

      </fieldset>
      
      <fieldset id='_N1RnY8'>
      <legend>article</legend>
      <h1 id="函数">函数</h1>
<p>我们经常需要在脚本的许多地方执行很相似的操作。</p>
<p>例如，当访问者登录、注销或者在其他地方时，我们需要显示一条好看的信息。</p>
<p>函数是程序的主要“构建模块”。函数使该段代码可以被调用很多次，而不需要写重复的代码。</p>
<p>我们已经看到了内置函数的示例，如 <code>alert(message)</code>、<code>prompt(message, default)</code> 和 <code>confirm(question)</code>。但我们也可以创建自己的函数。</p>
<h2 id="函数声明">函数声明</h2>
<p>使用 <strong>函数声明</strong> 创建函数。</p>
<p>看起来就像这样：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showMessage</span>(<span class="hljs-params"></span>) </span>{
  alert( <span class="hljs-string">&#x27;Hello everyone!&#x27;</span> );
}</code></pre>
<p><code>function</code> 关键字首先出现，然后是 <strong>函数名</strong>，然后是括号之间的 <strong>参数</strong> 列表（用逗号分隔，在上述示例中为空），最后是花括号之间的代码（即“函数体”）。</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">name</span>(<span class="hljs-params">parameters</span>) </span>{
  ...body...
}</code></pre>
<p>我们的新函数可以通过名称调用：<code>showMessage()</code>。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showMessage</span>(<span class="hljs-params"></span>) </span>{
  alert( <span class="hljs-string">&#x27;Hello everyone!&#x27;</span> );
}

*!*
showMessage();
showMessage();
*/!*</code></pre>
<p>调用 <code>showMessage()</code> 执行函数的代码。这里我们会看到显示两次消息。</p>
<p>这个例子清楚地演示了函数的主要目的之一：避免代码重复。</p>
<p>如果我们需要更改消息或其显示方式，只需在一个地方修改代码：输出它的函数。</p>
<h2 id="局部变量">局部变量</h2>
<p>在函数中声明的变量只在该函数内部可见。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showMessage</span>(<span class="hljs-params"></span>) </span>{
*!*
  <span class="hljs-keyword">let</span> message = <span class="hljs-string">&quot;Hello, I&#x27;m JavaScript!&quot;</span>; <span class="hljs-comment">// 局部变量</span>
*/!*

  alert( message );
}

showMessage(); <span class="hljs-comment">// Hello, I&#x27;m JavaScript!</span>

alert( message ); <span class="hljs-comment">// &lt;-- 错误！变量是函数的局部变量</span></code></pre>
<h2 id="外部变量">外部变量</h2>
<p>函数也可以访问外部变量，例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> *!*userName*/!* = <span class="hljs-string">&#x27;John&#x27;</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showMessage</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> message = <span class="hljs-string">&#x27;Hello, &#x27;</span> + *!*userName*/!*;
  alert(message);
}

showMessage(); <span class="hljs-comment">// Hello, John</span></code></pre>
<p>函数对外部变量拥有全部的访问权限。函数也可以修改外部变量。</p>
<p>例如：</p>
<pre><code class="language-js">let *!*userName*/!* = &#x27;John&#x27;;

function showMessage() {
  *!*userName*/!* = &quot;Bob&quot;; // (1) 改变外部变量

  let message = &#x27;Hello, &#x27; + *!*userName*/!*;
  alert(message);
}

alert( userName ); // *!*John*/!* 在函数调用之前

showMessage();

alert( userName ); // *!*Bob*/!*，值被函数修改了</code></pre>
<p>只有在没有局部变量的情况下才会使用外部变量。</p>
<p>如果在函数内部声明了同名变量，那么函数会 <strong>遮蔽</strong> 外部变量。例如，在下面的代码中，函数使用局部的 <code>userName</code>，而外部变量被忽略：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> userName = <span class="hljs-string">&#x27;John&#x27;</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showMessage</span>(<span class="hljs-params"></span>) </span>{
*!*
  <span class="hljs-keyword">let</span> userName = <span class="hljs-string">&quot;Bob&quot;</span>; <span class="hljs-comment">// 声明一个局部变量</span>
*/!*

  <span class="hljs-keyword">let</span> message = <span class="hljs-string">&#x27;Hello, &#x27;</span> + userName; <span class="hljs-comment">// *!*Bob*/!*</span>
  alert(message);
}

<span class="hljs-comment">// 函数会创建并使用它自己的 userName</span>
showMessage();

alert( userName ); <span class="hljs-comment">// *!*John*/!*，未被更改，函数没有访问外部变量。</span></code></pre>
<pre><code class="language-smart">任何函数之外声明的变量，例如上述代码中的外部变量 `userName`，都被称为 **全局** 变量。

全局变量在任意函数中都是可见的（除非被局部变量遮蔽）。

减少全局变量的使用是一种很好的做法。现代的代码有很少甚至没有全局变量。大多数变量存在于它们的函数中。但是有时候，全局变量能够用于存储项目级别的数据。</code></pre>
<h2 id="参数">参数</h2>
<p>我们可以使用参数（也称“函数参数”）来将任意数据传递给函数。</p>
<p>在如下示例中，函数有两个参数：<code>from</code> 和 <code>text</code>。</p>
<pre><code class="language-js">function showMessage(*!*from, text*/!*) { // 参数：from 和 text
  alert(from + &#x27;: &#x27; + text);
}

*!*
showMessage(&#x27;Ann&#x27;, &#x27;Hello!&#x27;); // Ann: Hello! (*)
showMessage(&#x27;Ann&#x27;, &quot;What&#x27;s up?&quot;); // Ann: What&#x27;s up? (**)
*/!*</code></pre>
<p>当函数在 <code>(*)</code> 和 <code>(**)</code> 行中被调用时，给定值被复制到了局部变量 <code>from</code> 和 <code>text</code>。然后函数使用它们进行计算。</p>
<p>这里还有一个例子：我们有一个变量 <code>from</code>，并将它传递给函数。请注意：函数会修改 <code>from</code>，但在函数外部看不到更改，因为函数修改的是复制的变量值副本：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showMessage</span>(<span class="hljs-params"><span class="hljs-keyword">from</span>, text</span>) </span>{

*!*
  <span class="hljs-keyword">from</span> = <span class="hljs-string">&#x27;*&#x27;</span> + <span class="hljs-keyword">from</span> + <span class="hljs-string">&#x27;*&#x27;</span>; <span class="hljs-comment">// 让 &quot;from&quot; 看起来更优雅</span>
*/!*

  alert( <span class="hljs-keyword">from</span> + <span class="hljs-string">&#x27;: &#x27;</span> + text );
}

<span class="hljs-keyword">let</span> <span class="hljs-keyword">from</span> = <span class="hljs-string">&quot;Ann&quot;</span>;

showMessage(<span class="hljs-keyword">from</span>, <span class="hljs-string">&quot;Hello&quot;</span>); <span class="hljs-comment">// *Ann*: Hello</span>

<span class="hljs-comment">// &quot;from&quot; 值相同，函数修改了一个局部的副本。</span>
alert( <span class="hljs-keyword">from</span> ); <span class="hljs-comment">// Ann</span></code></pre>
<h2 id="默认值">默认值</h2>
<p>如果未提供参数，那么其默认值则是 <code>undefined</code>。</p>
<p>例如，之前提到的函数 <code>showMessage(from, text)</code> 可以只使用一个参数调用：</p>
<pre><code class="language-js">showMessage(<span class="hljs-string">&quot;Ann&quot;</span>);</code></pre>
<p>那不是错误，这样调用将输出 <code>&quot;*Ann*: undefined&quot;</code>。这里没有参数 <code>text</code>，所以程序假定 <code>text === undefined</code>。</p>
<p>如果我们想在本示例中设定“默认”的 <code>text</code>，那么我们可以在 <code>=</code> 之后指定它：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showMessage</span>(<span class="hljs-params"><span class="hljs-keyword">from</span>, *!*text = <span class="hljs-string">&quot;no text given&quot;</span>*/!*</span>) </span>{
  alert( <span class="hljs-keyword">from</span> + <span class="hljs-string">&quot;: &quot;</span> + text );
}

showMessage(<span class="hljs-string">&quot;Ann&quot;</span>); <span class="hljs-comment">// Ann: no text given</span></code></pre>
<p>现在如果 <code>text</code> 参数未被传递，它将会得到值 <code>&quot;no text given&quot;</code>。</p>
<p>这里 <code>&quot;no text given&quot;</code> 是一个字符串，但它可以是更复杂的表达式，并且只会在缺少参数时才会被计算和分配。所以，这也是可能的：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showMessage</span>(<span class="hljs-params"><span class="hljs-keyword">from</span>, text = anotherFunction()</span>) </span>{
  <span class="hljs-comment">// anotherFunction() 仅在没有给定 text 时执行</span>
  <span class="hljs-comment">// 其运行结果将成为 text 的值 </span>
}</code></pre>
<pre><code class="language-smart">在 JavaScript 中，每次函数在没带个别参数的情况下被调用，默认参数会被计算出来。

在上面的例子中，每次 `showMessage()` 不带 `text` 参数被调用时，`anotherFunction()` 就会被调用。</code></pre>
<h3 id="后备的默认参数">后备的默认参数</h3>
<p>有些时候，将参数默认值的设置放在函数执行（相较更后期）而不是函数声明的时候，也能行得通。</p>
<p>为了判断参数是否被省略掉，我们可以拿它跟 <code>undefined</code> 做比较：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showMessage</span>(<span class="hljs-params">text</span>) </span>{
*!*
  <span class="hljs-keyword">if</span> (text === <span class="hljs-literal">undefined</span>) {
    text = <span class="hljs-string">&#x27;empty message&#x27;</span>;
  }
*/!*

  alert(text);
}

showMessage(); <span class="hljs-comment">// empty message</span></code></pre>
<p>……或者我们可以使用 <code>||</code> 运算符：</p>
<pre><code class="language-js"><span class="hljs-comment">// 如果 &quot;text&quot; 参数被省略或者被传入空字符串，则赋值为 &#x27;empty&#x27;</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showMessage</span>(<span class="hljs-params">text</span>) </span>{
  text = text || <span class="hljs-string">&#x27;empty&#x27;</span>;
  ...
}</code></pre>
<p>现代 JavaScript 引擎支持 <a href="info:nullish-coalescing-operator">空值合并运算符</a> <code>??</code>，当可能遇到其他假值时它更有优势，如 <code>0</code> 会被视为正常值不被合并：</p>
<pre><code class="language-js"><span class="hljs-comment">// 如果没有传入 &quot;count&quot; 参数，则显示 &quot;unknown&quot;</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showCount</span>(<span class="hljs-params">count</span>) </span>{
  alert(count ?? <span class="hljs-string">&quot;unknown&quot;</span>);
}

showCount(<span class="hljs-number">0</span>); <span class="hljs-comment">// 0</span>
showCount(<span class="hljs-literal">null</span>); <span class="hljs-comment">// unknown</span>
showCount(); <span class="hljs-comment">// unknown</span></code></pre>
<h2 id="返回值">返回值</h2>
<p>函数可以将一个值返回到调用代码中作为结果。</p>
<p>最简单的例子是将两个值相加的函数：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a, b</span>) </span>{
  *!*<span class="hljs-keyword">return</span>*/!* a + b;
}

<span class="hljs-keyword">let</span> result = sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
alert( result ); <span class="hljs-comment">// 3</span></code></pre>
<p>指令 <code>return</code> 可以在函数的任意位置。当执行到达时，函数停止，并将值返回给调用代码（分配给上述代码中的 <code>result</code>）。</p>
<p>在一个函数中可能会出现很多次 <code>return</code>。例如：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkAge</span>(<span class="hljs-params">age</span>) </span>{
  <span class="hljs-keyword">if</span> (age &gt;= <span class="hljs-number">18</span>) {
*!*
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
*/!*
  } <span class="hljs-keyword">else</span> {
*!*
    <span class="hljs-keyword">return</span> confirm(<span class="hljs-string">&#x27;Got a permission from the parents?&#x27;</span>);
*/!*
  }
}

<span class="hljs-keyword">let</span> age = prompt(<span class="hljs-string">&#x27;How old are you?&#x27;</span>, <span class="hljs-number">18</span>);

<span class="hljs-keyword">if</span> ( checkAge(age) ) {
  alert( <span class="hljs-string">&#x27;Access granted&#x27;</span> );
} <span class="hljs-keyword">else</span> {
  alert( <span class="hljs-string">&#x27;Access denied&#x27;</span> );
}</code></pre>
<p>只使用 <code>return</code> 但没有返回值也是可行的。但这会导致函数立即退出。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showMovie</span>(<span class="hljs-params">age</span>) </span>{
  <span class="hljs-keyword">if</span> ( !checkAge(age) ) {
*!*
    <span class="hljs-keyword">return</span>;
*/!*
  }

  alert( <span class="hljs-string">&quot;Showing you the movie&quot;</span> ); <span class="hljs-comment">// (*)</span>
  <span class="hljs-comment">// ...</span>
}</code></pre>
<p>在上述代码中，如果 <code>checkAge(age)</code> 返回 <code>false</code>，那么 <code>showMovie</code> 将不会运行到 <code>alert</code>。</p>
<p>````smart header=&quot;空值的 <code>return</code> 或没有 <code>return</code> 的函数返回值为 <code>undefined</code>&quot;
如果函数无返回值，它就会像返回 <code>undefined</code> 一样：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doNothing</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">/* 没有代码 */</span> }

alert( doNothing() === <span class="hljs-literal">undefined</span> ); <span class="hljs-comment">// true</span></code></pre>
<p>空值的 <code>return</code> 和 <code>return undefined</code> 等效：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doNothing</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span>;
}

alert( doNothing() === <span class="hljs-literal">undefined</span> ); <span class="hljs-comment">// true</span></code></pre>
<pre><code>
````warn header=&quot;不要在 `return` 与返回值之间添加新行&quot;
对于 `return` 的长表达式，可能你会很想将其放在单独一行，如下所示：

```js
return
 (some + long + expression + or + whatever * f(a) + f(b))
```
但这不行，因为 JavaScript 默认会在 `return` 之后加上分号。上面这段代码和下面这段代码运行流程相同：

```js
return*!*;*/!*
 (some + long + expression + or + whatever * f(a) + f(b))
```

因此，实际上它的返回值变成了空值。

如果我们想要将返回的表达式写成跨多行的形式，那么应该在 `return` 的同一行开始写此表达式。或者至少按照如下的方式放上左括号：

```js
return (
  some + long + expression
  + or +
  whatever * f(a) + f(b)
  )
```
然后它就能像我们预想的那样正常运行了。</code></pre>
<h2 id="函数命名-function-naming">函数命名 [#function-naming]</h2>
<p>函数就是行为（action）。所以它们的名字通常是动词。它应该简短且尽可能准确地描述函数的作用。这样读代码的人就能清楚地知道这个函数的功能。</p>
<p>一种普遍的做法是用动词前缀来开始一个函数，这个前缀模糊地描述了这个行为。团队内部必须就前缀的含义达成一致。</p>
<p>例如，以 <code>&quot;show&quot;</code> 开头的函数通常会显示某些内容。</p>
<p>函数以 XX 开始……</p>
<ul>
<li><code>&quot;get…&quot;</code> —— 返回一个值，</li>
<li><code>&quot;calc…&quot;</code> —— 计算某些内容，</li>
<li><code>&quot;create…&quot;</code> —— 创建某些内容，</li>
<li><code>&quot;check…&quot;</code> —— 检查某些内容并返回 boolean 值，等。</li>
</ul>
<p>这类名字的示例：</p>
<pre><code class="language-js">showMessage(..)     <span class="hljs-comment">// 显示信息</span>
getAge(..)          <span class="hljs-comment">// 返回 age（gets it somehow）</span>
calcSum(..)         <span class="hljs-comment">// 计算求和并返回结果</span>
createForm(..)      <span class="hljs-comment">// 创建表格（通常会返回它）</span>
checkPermission(..) <span class="hljs-comment">// 检查权限并返回 true/false</span></code></pre>
<p>有了前缀，只需瞥一眼函数名，就可以了解它的功能是什么，返回什么样的值。</p>
<pre><code class="language-smart">一个函数应该只包含函数名所指定的功能，而不是做更多与函数名无关的功能。

两个独立的行为通常需要两个函数，即使它们通常被一起调用（在这种情况下，我们可以创建第三个函数来调用这两个函数）。

有几个违反这一规则的例子：

- `getAge` —— 如果它通过 `alert` 将 age 显示出来，那就有问题了（只应该是获取）。
- `createForm` —— 如果它包含修改文档的操作，例如向文档添加一个表单，那就有问题了（只应该创建表单并返回）。
- `checkPermission` —— 如果它显示 `access granted/denied` 消息，那就有问题了（只应执行检查并返回结果）。

这些例子假设函数名前缀具有通用的含义。你和你的团队可以自定义这些函数名前缀的含义，但是通常都没有太大的不同。无论怎样，你都应该对函数名前缀的含义、带特定前缀的函数可以做什么以及不可以做什么有深刻的了解。所有相同前缀的函数都应该遵守相同的规则。并且，团队成员应该形成共识。</code></pre>
<pre><code class="language-smart">常用的函数有时会有**非常短**的名字。

例如，[jQuery](http://jquery.com) 框架用 `$` 定义一个函数。[LoDash](http://lodash.com/) 库的核心函数用 `_` 命名。

这些都是例外，一般而言，函数名应简明扼要且具有描述性。</code></pre>
<h2 id="函数--注释">函数 == 注释</h2>
<p>函数应该简短且只有一个功能。如果这个函数功能复杂，那么把该函数拆分成几个小的函数是值得的。有时候遵循这个规则并不是那么容易，但这绝对是件好事。</p>
<p>一个单独的函数不仅更容易测试和调试 —— 它的存在本身就是一个很好的注释！</p>
<p>例如，比较如下两个函数 <code>showPrimes(n)</code>。它们的功能都是输出到 <code>n</code> 的 <a href="https://en.wikipedia.org/wiki/Prime_number">素数</a>。</p>
<p>第一个变体使用了一个标签：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showPrimes</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-attr">nextPrime</span>: <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) {

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">2</span>; j &lt; i; j++) {
      <span class="hljs-keyword">if</span> (i % j == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span> nextPrime;
    }

    alert( i ); <span class="hljs-comment">// 一个素数</span>
  }
}</code></pre>
<p>第二个变体使用附加函数 <code>isPrime(n)</code> 来检验素数：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showPrimes</span>(<span class="hljs-params">n</span>) </span>{

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) {
    *!*<span class="hljs-keyword">if</span> (!isPrime(i)) <span class="hljs-keyword">continue</span>;*/!*

    alert(i);  <span class="hljs-comment">// 一个素数</span>
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isPrime</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) {
    <span class="hljs-keyword">if</span> ( n % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}</code></pre>
<p>第二个变体更容易理解，不是吗？我们通过函数名（<code>isPrime</code>）就可以看出函数的行为，而不需要通过代码。人们通常把这样的代码称为 <strong>自描述</strong>。</p>
<p>因此，即使我们不打算重用它们，也可以创建函数。函数可以让代码结构更清晰，可读性更强。</p>
<h2 id="总结">总结</h2>
<p>函数声明方式如下所示：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">name</span>(<span class="hljs-params">parameters, delimited, by, comma</span>) </span>{
  <span class="hljs-comment">/* code */</span>
}</code></pre>
<ul>
<li>作为参数传递给函数的值，会被复制到函数的局部变量。</li>
<li>函数可以访问外部变量。但它只能从内到外起作用。函数外部的代码看不到函数内的局部变量。</li>
<li>函数可以返回值。如果没有返回值，则其返回的结果是 <code>undefined</code>。</li>
</ul>
<p>为了使代码简洁易懂，建议在函数中主要使用局部变量和参数，而不是外部变量。</p>
<p>与不获取参数但将修改外部变量作为副作用的函数相比，获取参数、使用参数并返回结果的函数更容易理解。</p>
<p>函数命名：</p>
<ul>
<li>函数名应该清楚地描述函数的功能。当我们在代码中看到一个函数调用时，一个好的函数名能够让我们马上知道这个函数的功能是什么，会返回什么。</li>
<li>一个函数是一个行为，所以函数名通常是动词。</li>
<li>目前有许多优秀的函数名前缀，如 <code>create…</code>、<code>show…</code>、<code>get…</code>、<code>check…</code> 等等。使用它们来提示函数的作用吧。</li>
</ul>
<p>函数是脚本的主要构建块。现在我们已经介绍了基本知识，现在我们就可以开始创建和使用函数了。但这只是学习和使用函数的开始。我们将继续学习更多函数的相关知识，更深入地研究它们的先进特征。</p>

      </fieldset>
      
      <fieldset id='_do5TPj'>
      <legend>article</legend>
      <h1 id="函数表达式">函数表达式</h1>
<p>在 JavaScript 中，函数不是“神奇的语言结构”，而是一种特殊的值。</p>
<p>我们在前面章节使用的语法称为 <strong>函数声明</strong>：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>{
  alert( <span class="hljs-string">&quot;Hello&quot;</span> );
}</code></pre>
<p>另一种创建函数的语法称为 <strong>函数表达式</strong>。</p>
<p>通常会写成这样：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  alert( <span class="hljs-string">&quot;Hello&quot;</span> );
};</code></pre>
<p>在这里，函数被创建并像其他赋值一样，被明确地分配给了一个变量。不管函数是被怎样定义的，都只是一个存储在变量 <code>sayHi</code> 中的值。</p>
<p>上面这两段示例代码的意思是一样的：“创建一个函数，并把它存进变量 <code>sayHi</code>”。</p>
<p>我们还可以用 <code>alert</code> 打印这个变量值：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>{
  alert( <span class="hljs-string">&quot;Hello&quot;</span> );
}

*!*
alert( sayHi ); <span class="hljs-comment">// 显示函数代码</span>
*/!*</code></pre>
<p>注意，最后一行代码并不会运行函数，因为 <code>sayHi</code> 后没有括号。在其他编程语言中，只要提到函数的名称都会导致函数的调用执行，但 JavaScript 可不是这样。</p>
<p>在 JavaScript 中，函数是一个值，所以我们可以把它当成值对待。上面代码显示了一段字符串值，即函数的源码。</p>
<p>的确，在某种意义上说一个函数是一个特殊值，我们可以像 <code>sayHi()</code> 这样调用它。</p>
<p>但它依然是一个值，所以我们可以像使用其他类型的值一样使用它。</p>
<p>我们可以复制函数到其他变量：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>{   <span class="hljs-comment">// (1) 创建</span>
  alert( <span class="hljs-string">&quot;Hello&quot;</span> );
}

<span class="hljs-keyword">let</span> func = sayHi;    <span class="hljs-comment">// (2) 复制</span>

func(); <span class="hljs-comment">// Hello     // (3) 运行复制的值（正常运行）！</span>
sayHi(); <span class="hljs-comment">// Hello    //     这里也能运行（为什么不行呢）</span></code></pre>
<p>解释一下上段代码发生的细节：</p>
<ol>
<li><code>(1)</code> 行声明创建了函数，并把它放入到变量 <code>sayHi</code>。</li>
<li><code>(2)</code> 行将 <code>sayHi</code> 复制到了变量 <code>func</code>。请注意：<code>sayHi</code> 后面没有括号。如果有括号，<code>func = sayHi()</code> 会把 <code>sayHi()</code> 的调用结果写进<code>func</code>，而不是 <code>sayHi</code> <strong>函数</strong> 本身。</li>
<li>现在函数可以通过 <code>sayHi()</code> 和 <code>func()</code> 两种方式进行调用。</li>
</ol>
<p>注意，我们也可以在第一行中使用函数表达式来声明 <code>sayHi</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  alert( <span class="hljs-string">&quot;Hello&quot;</span> );
};

<span class="hljs-keyword">let</span> func = sayHi;
<span class="hljs-comment">// ...</span></code></pre>
<p>这两种声明的函数是一样的。</p>
<pre><code class="language-smart">你可能想知道，为什么函数表达式结尾有一个分号 `;`，而函数声明没有：

```js
function sayHi() {
  // ...
}

let sayHi = function() {
  // ...
}*!*;*/!*
```

答案很简单：
- 在代码块的结尾不需要加分号 `;`，像 `if { ... }`，`for {  }`，`function f { }` 等语法结构后面都不用加。
- 函数表达式是在语句内部的：`let sayHi = ...;`，作为一个值。它不是代码块而是一个赋值语句。不管值是什么，都建议在语句末尾添加分号 `;`。所以这里的分号与函数表达式本身没有任何关系，它只是用于终止语句。</code></pre>
<h2 id="回调函数">回调函数</h2>
<p>让我们多举几个例子，看看如何将函数作为值来传递以及如何使用函数表达式。</p>
<p>我们写一个包含三个参数的函数 <code>ask(question, yes, no)</code>：</p>
<p><code>question</code>
: 关于问题的文本</p>
<p><code>yes</code>
: 当回答为 &quot;Yes&quot; 时，要运行的脚本</p>
<p><code>no</code>
: 当回答为 &quot;No&quot; 时，要运行的脚本</p>
<p>函数需要提出 <code>question</code>（问题），并根据用户的回答，调用 <code>yes()</code> 或 <code>no()</code>：</p>
<pre><code class="language-js">*!*
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ask</span>(<span class="hljs-params">question, yes, no</span>) </span>{
  <span class="hljs-keyword">if</span> (confirm(question)) yes()
  <span class="hljs-keyword">else</span> no();
}
*/!*

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showOk</span>(<span class="hljs-params"></span>) </span>{
  alert( <span class="hljs-string">&quot;You agreed.&quot;</span> );
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showCancel</span>(<span class="hljs-params"></span>) </span>{
  alert( <span class="hljs-string">&quot;You canceled the execution.&quot;</span> );
}

<span class="hljs-comment">// 用法：函数 showOk 和 showCancel 被作为参数传入到 ask</span>
ask(<span class="hljs-string">&quot;Do you agree?&quot;</span>, showOk, showCancel);</code></pre>
<p>在实际开发中，这样的的函数是非常有用的。实际开发与上述示例最大的区别是，实际开发中的函数会通过更加复杂的方式与用户进行交互，而不是通过简单的 <code>confirm</code>。在浏览器中，这样的函数通常会绘制一个漂亮的提问窗口。但这是另外一件事了。</p>
<p><code>ask</code> 的两个参数值 <code>showOk</code> 和 <code>showCancel</code> 可以被称为 <strong>回调函数</strong> 或简称 <strong>回调</strong>。</p>
<p>主要思想是我们传递一个函数，并期望在稍后必要时将其“回调”。在我们的例子中，<code>showOk</code> 是回答 &quot;yes&quot; 的回调，<code>showCancel</code> 是回答 &quot;no&quot; 的回调。</p>
<p>我们可以用函数表达式对同样的函数进行大幅简写：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ask</span>(<span class="hljs-params">question, yes, no</span>) </span>{
  <span class="hljs-keyword">if</span> (confirm(question)) yes()
  <span class="hljs-keyword">else</span> no();
}

*!*
ask(
  <span class="hljs-string">&quot;Do you agree?&quot;</span>,
  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ alert(<span class="hljs-string">&quot;You agreed.&quot;</span>); },
  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ alert(<span class="hljs-string">&quot;You canceled the execution.&quot;</span>); }
);
*/!*</code></pre>
<p>这里直接在 <code>ask(...)</code> 调用内进行函数声明。这两个函数没有名字，所以叫 <strong>匿名函数</strong>。这样的函数在 <code>ask</code> 外无法访问（因为没有对它们分配变量），不过这正是我们想要的。</p>
<p>这样的代码在我们的脚本中非常常见，这正符合 JavaScript 语言的思想。</p>
<pre><code class="language-smart">字符串或数字等常规值代表 **数据**。

函数可以被视为一个 **行为（action）**。

我们可以在变量之间传递它们，并在需要时运行。</code></pre>
<h2 id="函数表达式-vs-函数声明">函数表达式 vs 函数声明</h2>
<p>让我们来总结一下函数声明和函数表达式之间的主要区别。</p>
<p>首先是语法：如何通过代码对它们进行区分。</p>
<ul>
<li><p><strong>函数声明</strong>：在主代码流中声明为单独的语句的函数。</p>
<pre><code class="language-js"><span class="hljs-comment">// 函数声明</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">return</span> a + b;
}</code></pre>
</li>
<li><p><strong>函数表达式</strong>：在一个表达式中或另一个语法结构中创建的函数。下面这个函数是在赋值表达式 <code>=</code> 右侧创建的：
   </p>
<pre><code class="language-js"><span class="hljs-comment">// 函数表达式</span>
<span class="hljs-keyword">let</span> sum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">return</span> a + b;
};</code></pre>
</li>
</ul>
<p>更细微的差别是，JavaScript 引擎会在 <strong>什么时候</strong> 创建函数。</p>
<p><strong>函数表达式是在代码执行到达时被创建，并且仅从那一刻起可用。</strong></p>
<p>一旦代码执行到赋值表达式 <code>let sum = function…</code> 的右侧，此时就会开始创建该函数，并且可以从现在开始使用（分配，调用等）。</p>
<p>函数声明则不同。</p>
<p><strong>在函数声明被定义之前，它就可以被调用。</strong></p>
<p>例如，一个全局函数声明对整个脚本来说都是可见的，无论它被写在这个脚本的哪个位置。</p>
<p>这是内部算法的原故。当 JavaScript <strong>准备</strong> 运行脚本时，首先会在脚本中寻找全局函数声明，并创建这些函数。我们可以将其视为“初始化阶段”。</p>
<p>在处理完所有函数声明后，代码才被执行。所以运行时能够使用这些函数。</p>
<p>例如下面的代码会正常工作：</p>
<pre><code class="language-js">*!*
sayHi(<span class="hljs-string">&quot;John&quot;</span>); <span class="hljs-comment">// Hello, John</span>
*/!*

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params">name</span>) </span>{
  alert( <span class="hljs-string">`Hello, <span class="hljs-subst">${name}</span>`</span> );
}</code></pre>
<p>函数声明 <code>sayHi</code> 是在 JavaScript 准备运行脚本时被创建的，在这个脚本的任何位置都可见。</p>
<p>……如果它是一个函数表达式，它就不会工作：</p>
<pre><code class="language-js">*!*
sayHi(<span class="hljs-string">&quot;John&quot;</span>); <span class="hljs-comment">// error!</span>
*/!*

<span class="hljs-keyword">let</span> sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{  <span class="hljs-comment">// (*) no magic any more</span>
  alert( <span class="hljs-string">`Hello, <span class="hljs-subst">${name}</span>`</span> );
};</code></pre>
<p>函数表达式在代码执行到它时才会被创建。只会发生在 <code>(*)</code> 行。为时已晚。</p>
<p>函数声明的另外一个特殊的功能是它们的块级作用域。</p>
<p><strong>严格模式下，当一个函数声明在一个代码块内时，它在该代码块内的任何位置都是可见的。但在代码块外不可见。</strong></p>
<p>例如，想象一下我们需要依赖于在代码运行过程中获得的变量 <code>age</code> 声明一个函数 <code>welcome()</code>。并且我们计划在之后的某个时间使用它。</p>
<p>如果我们使用函数声明，以下则代码不能如愿工作：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> age = prompt(<span class="hljs-string">&quot;What is your age?&quot;</span>, <span class="hljs-number">18</span>);

<span class="hljs-comment">// 有条件地声明一个函数</span>
<span class="hljs-keyword">if</span> (age &lt; <span class="hljs-number">18</span>) {

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">welcome</span>(<span class="hljs-params"></span>) </span>{
    alert(<span class="hljs-string">&quot;Hello!&quot;</span>);
  }

} <span class="hljs-keyword">else</span> {

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">welcome</span>(<span class="hljs-params"></span>) </span>{
    alert(<span class="hljs-string">&quot;Greetings!&quot;</span>);
  }

}

<span class="hljs-comment">// ……稍后使用</span>
*!*
welcome(); <span class="hljs-comment">// Error: welcome is not defined</span>
*/!*</code></pre>
<p>这是因为函数声明只在它所在的代码块中可见。</p>
<p>下面是另一个例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> age = <span class="hljs-number">16</span>; <span class="hljs-comment">// 拿 16 作为例子</span>

<span class="hljs-keyword">if</span> (age &lt; <span class="hljs-number">18</span>) {
*!*
  welcome();               <span class="hljs-comment">// \   (运行)</span>
*/!*
                           <span class="hljs-comment">//  |</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">welcome</span>(<span class="hljs-params"></span>) </span>{     <span class="hljs-comment">//  |  </span>
    alert(<span class="hljs-string">&quot;Hello!&quot;</span>);       <span class="hljs-comment">//  |  函数声明在声明它的代码块内任意位置都可用</span>
  }                        <span class="hljs-comment">//  |  </span>
                           <span class="hljs-comment">//  |</span>
*!*
  welcome();               <span class="hljs-comment">// /   (运行)</span>
*/!*

} <span class="hljs-keyword">else</span> {

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">welcome</span>(<span class="hljs-params"></span>) </span>{
    alert(<span class="hljs-string">&quot;Greetings!&quot;</span>);
  }
}

<span class="hljs-comment">// 在这里，我们在花括号外部调用函数，我们看不到它们内部的函数声明。</span>


*!*
welcome(); <span class="hljs-comment">// Error: welcome is not defined</span>
*/!*</code></pre>
<p>我们怎么才能让 <code>welcome</code> 在 <code>if</code> 外可见呢？</p>
<p>正确的做法是使用函数表达式，并将 <code>welcome</code> 赋值给在 <code>if</code> 外声明的变量，并具有正确的可见性。</p>
<p>下面的代码可以如愿运行：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> age = prompt(<span class="hljs-string">&quot;What is your age?&quot;</span>, <span class="hljs-number">18</span>);

<span class="hljs-keyword">let</span> welcome;

<span class="hljs-keyword">if</span> (age &lt; <span class="hljs-number">18</span>) {

  welcome = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    alert(<span class="hljs-string">&quot;Hello!&quot;</span>);
  };

} <span class="hljs-keyword">else</span> {

  welcome = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    alert(<span class="hljs-string">&quot;Greetings!&quot;</span>);
  };

}

*!*
welcome(); <span class="hljs-comment">// 现在可以了</span>
*/!*</code></pre>
<p>或者我们可以使用问号运算符 <code>?</code> 来进一步对代码进行简化：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> age = prompt(<span class="hljs-string">&quot;What is your age?&quot;</span>, <span class="hljs-number">18</span>);

<span class="hljs-keyword">let</span> welcome = (age &lt; <span class="hljs-number">18</span>) ?
  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ alert(<span class="hljs-string">&quot;Hello!&quot;</span>); } :
  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ alert(<span class="hljs-string">&quot;Greetings!&quot;</span>); };

*!*
welcome(); <span class="hljs-comment">// 现在可以了</span>
*/!*</code></pre>
<pre><code class="language-smart">根据经验，当我们需要声明一个函数时，首先考虑函数声明语法。它能够为组织代码提供更多的灵活性。因为我们可以在声明这些函数之前调用这些函数。

这对代码可读性也更好，因为在代码中查找 `function f(…) {…}` 比 `let f = function(…) {…}` 更容易。函数声明更“醒目”。

……但是，如果由于某种原因而导致函数声明不适合我们（我们刚刚看过上面的例子），那么应该使用函数表达式。</code></pre>
<h2 id="总结">总结</h2>
<ul>
<li>函数是值。它们可以在代码的任何地方被分配，复制或声明。</li>
<li>如果函数在主代码流中被声明为单独的语句，则称为“函数声明”。</li>
<li>如果该函数是作为表达式的一部分创建的，则称其“函数表达式”。</li>
<li>在执行代码块之前，内部算法会先处理函数声明。所以函数声明在其被声明的代码块内的任何位置都是可见的。</li>
<li>函数表达式在执行流程到达时创建。</li>
</ul>
<p>在大多数情况下，当我们需要声明一个函数时，最好使用函数声明，因为函数在被声明之前也是可见的。这使我们在代码组织方面更具灵活性，通常也会使得代码可读性更高。</p>
<p>所以，仅当函数声明不适合对应的任务时，才应使用函数表达式。在本章中，我们已经看到了几个例子，以后还会看到更多的例子。</p>

      </fieldset>
      
      <fieldset id='_5RIeqp'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ask</span>(<span class="hljs-params">question, yes, no</span>) </span>{
  <span class="hljs-keyword">if</span> (confirm(question)) yes()
  <span class="hljs-keyword">else</span> no();
}

ask(
  <span class="hljs-string">&quot;Do you agree?&quot;</span>,
*!*
  <span class="hljs-function">() =&gt;</span> alert(<span class="hljs-string">&quot;You agreed.&quot;</span>),
  <span class="hljs-function">() =&gt;</span> alert(<span class="hljs-string">&quot;You canceled the execution.&quot;</span>)
*/!*
);</code></pre>
<p>是不是看起来精简多了？</p>

      </fieldset>
      
      <fieldset id='_qOJ4uH'>
      <legend>task</legend>
      <h1 id="用箭头函数重写">用箭头函数重写</h1>
<p>用箭头函数重写下面的函数表达式：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ask</span>(<span class="hljs-params">question, yes, no</span>) </span>{
  <span class="hljs-keyword">if</span> (confirm(question)) yes()
  <span class="hljs-keyword">else</span> no();
}

ask(
  <span class="hljs-string">&quot;Do you agree?&quot;</span>,
  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ alert(<span class="hljs-string">&quot;You agreed.&quot;</span>); },
  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ alert(<span class="hljs-string">&quot;You canceled the execution.&quot;</span>); }
);</code></pre>

      </fieldset>
      
      <fieldset id='_bcef69'>
      <legend>article</legend>
      <h1 id="箭头函数，基础知识">箭头函数，基础知识</h1>
<p>创建函数还有另外一种非常简单的语法，并且这种方法通常比函数表达式更好。</p>
<p>它被称为“箭头函数”，因为它看起来像这样：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> func = <span class="hljs-function">(<span class="hljs-params">arg1, arg2, ...argN</span>) =&gt;</span> expression</code></pre>
<p>……这里创建了一个函数 <code>func</code>，它接受参数 <code>arg1..argN</code>，然后使用参数对右侧的 <code>expression</code> 求值并返回其结果。</p>
<p>换句话说，它是下面这段代码的更短的版本：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> func = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arg1, arg2, ...argN</span>) </span>{
  <span class="hljs-keyword">return</span> expression;
};</code></pre>
<p>让我们来看一个具体的例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> sum = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b;

<span class="hljs-comment">/* 这个箭头函数是下面这个函数的更短的版本：

let sum = function(a, b) {
  return a + b;
};
*/</span>

alert( sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) ); <span class="hljs-comment">// 3</span></code></pre>
<p>可以看到 <code>(a, b) =&gt; a + b</code> 表示一个函数接受两个名为 <code>a</code> 和 <code>b</code> 的参数。在执行时，它将对表达式 <code>a + b</code> 求值，并返回计算结果。</p>
<ul>
<li><p>如果我们只有一个参数，还可以省略掉参数外的圆括号，使代码更短。</p>
<p>  例如：</p>
<pre><code class="language-js">*!*
<span class="hljs-keyword">let</span> double = <span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n * <span class="hljs-number">2</span>;
<span class="hljs-comment">// 差不多等同于：let double = function(n) { return n * 2 }</span>
*/!*

alert( double(<span class="hljs-number">3</span>) ); <span class="hljs-comment">// 6</span></code></pre>
</li>
<li><p>如果没有参数，括号将是空的（但括号应该保留）：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> sayHi = <span class="hljs-function">() =&gt;</span> alert(<span class="hljs-string">&quot;Hello!&quot;</span>);

sayHi();</code></pre>
</li>
</ul>
<p>箭头函数可以像函数表达式一样使用。</p>
<p>例如，动态创建一个函数：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> age = prompt(<span class="hljs-string">&quot;What is your age?&quot;</span>, <span class="hljs-number">18</span>);

<span class="hljs-keyword">let</span> welcome = (age &lt; <span class="hljs-number">18</span>) ?
  <span class="hljs-function">() =&gt;</span> alert(<span class="hljs-string">&#x27;Hello&#x27;</span>) :
  <span class="hljs-function">() =&gt;</span> alert(<span class="hljs-string">&quot;Greetings!&quot;</span>);

welcome();</code></pre>
<p>一开始，箭头函数可能看起来并不熟悉，也不容易读懂，但一旦我们看习惯了之后，这种情况很快就会改变。</p>
<p>箭头函数对于简单的单行行为（action）来说非常方便，尤其是当我们懒得打太多字的时候。</p>
<h2 id="多行的箭头函数">多行的箭头函数</h2>
<p>上面的例子从 <code>=&gt;</code> 的左侧获取参数，然后使用参数计算右侧表达式的值。</p>
<p>但有时我们需要更复杂一点的东西，比如多行的表达式或语句。这也是可以做到的，但是我们应该用花括号括起来。然后使用一个普通的 <code>return</code> 将需要返回的值进行返回。</p>
<p>就像这样：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> sum = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> {  <span class="hljs-comment">// 花括号表示开始一个多行函数</span>
  <span class="hljs-keyword">let</span> result = a + b;
*!*
  <span class="hljs-keyword">return</span> result; <span class="hljs-comment">// 如果我们使用了花括号，那么我们需要一个显式的 “return” </span>
*/!*
};

alert( sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) ); <span class="hljs-comment">// 3</span></code></pre>
<pre><code class="language-smart">在这里，我们赞扬了箭头函数的简洁性。但还不止这些！

箭头函数还有其他有趣的特性。

为了更深入地学习它们，我们首先需要了解一些 JavaScript 其他方面的知识，因此我们将在后面的 &lt;info:arrow-functions&gt; 一章中再继续研究箭头函数。

现在，我们已经可以用箭头函数进行单行行为和回调了。</code></pre>
<h2 id="总结">总结</h2>
<p>对于一行代码的函数来说，箭头函数是相当方便的。它具体有两种：</p>
<ol>
<li>不带花括号：<code>(...args) =&gt; expression</code> — 右侧是一个表达式：函数计算表达式并返回其结果。</li>
<li>带花括号：<code>(...args) =&gt; { body }</code> — 花括号允许我们在函数中编写多个语句，但是我们需要显式地 <code>return</code> 来返回一些内容。</li>
</ol>

      </fieldset>
      
      <fieldset id='_5xOoHg'>
      <legend>article</legend>
      <h1 id="javascript-特性">JavaScript 特性</h1>
<p>本章简要回顾我们到现在为止学到的 JavaScript 特性，并特别注意了一些细节。</p>
<h2 id="代码结构">代码结构</h2>
<p>语句用分号分隔：</p>
<pre><code class="language-js">alert(<span class="hljs-string">&#x27;Hello&#x27;</span>); alert(<span class="hljs-string">&#x27;World&#x27;</span>);</code></pre>
<p>通常，换行符也被视为分隔符，因此下面的例子也能正常运行：</p>
<pre><code class="language-js">alert(<span class="hljs-string">&#x27;Hello&#x27;</span>)
alert(<span class="hljs-string">&#x27;World&#x27;</span>)</code></pre>
<p>这就是所谓的「自动分号插入」。但有时它不起作用，例如：</p>
<pre><code class="language-js">alert(<span class="hljs-string">&quot;There will be an error after this message&quot;</span>)

[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>].forEach(alert)</code></pre>
<p>大多数代码风格指南都认为我们应该在每个语句后面都加上分号。</p>
<p>在代码块 <code>{...}</code> 后以及有代码块的语法结构（例如循环）后不需要加分号：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// 函数声明后不需要加分号</span>
}

<span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params">;;</span>)</span> {
  <span class="hljs-comment">// 循环语句后不需要加分号</span>
}</code></pre>
<p>……但即使我们在某处添加了「额外的」分号，这也不是错误。分号会被忽略的。</p>
<p>更多内容：<a href="info:structure">info:structure</a>。</p>
<h2 id="严格模式">严格模式</h2>
<p>为了完全启用现代 JavaScript 的所有特性，我们应该在脚本顶部写上 <code>&quot;use strict&quot;</code> 指令。</p>
<pre><code class="language-js"><span class="hljs-meta">&#x27;use strict&#x27;</span>;

...</code></pre>
<p>该指令必须位于 JavaScript 脚本的顶部或函数体的开头。</p>
<p>如果没有 <code>&quot;use strict&quot;</code>，所有东西仍可以正常工作，但是某些特性的表现方式与旧式「兼容」方式相同。我们通常更喜欢现代的方式。</p>
<p>语言的一些现代特征（比如我们将来要学习的类）会隐式地启用严格模式。</p>
<p>更多内容：<a href="info:strict-mode">info:strict-mode</a>。</p>
<h2 id="变量">变量</h2>
<p>可以使用以下方式声明变量：</p>
<ul>
<li><code>let</code></li>
<li><code>const</code>（不变的，不能被改变）</li>
<li><code>var</code>（旧式的，稍后会看到）</li>
</ul>
<p>一个变量名可以由以下组成：</p>
<ul>
<li>字母和数字，但是第一个字符不能是数字。</li>
<li>字符 <code>$</code> 和 <code>_</code> 是允许的，用法同字母。</li>
<li>非拉丁字母和象形文字也是允许的，但通常不会使用。</li>
</ul>
<p>变量是动态类型的，它们可以存储任何值：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;
x = <span class="hljs-string">&quot;John&quot;</span>;</code></pre>
<p>有 8 种数据类型：</p>
<ul>
<li><code>number</code> — 可以是浮点数，也可以是整数，</li>
<li><code>bigint</code> — 用于任意长度的整数，</li>
<li><code>string</code> — 字符串类型，</li>
<li><code>boolean</code> — 逻辑值：<code>true/false</code>，</li>
<li><code>null</code> — 具有单个值 <code>null</code> 的类型，表示“空”或“不存在”，</li>
<li><code>undefined</code> — 具有单个值 <code>undefined</code> 的类型，表示“未分配（未定义）”，</li>
<li><code>object</code> 和 <code>symbol</code> — 对于复杂的数据结构和唯一标识符，我们目前还没学习这个类型。</li>
</ul>
<p><code>typeof</code> 运算符返回值的类型，但有两个例外：</p>
<pre><code class="language-js"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span> == <span class="hljs-string">&quot;object&quot;</span> <span class="hljs-comment">// JavaScript 编程语言的设计错误</span>
<span class="hljs-keyword">typeof</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{} == <span class="hljs-string">&quot;function&quot;</span> <span class="hljs-comment">// 函数被特殊对待</span></code></pre>
<p>更多内容：<a href="info:variables">info:variables</a> 和 <a href="info:types">info:types</a>。</p>
<h2 id="交互">交互</h2>
<p>我们使用浏览器作为工作环境，所以基本的 UI 功能将是：</p>
<p><a href="mdn:api/Window/prompt"><code>prompt(question[, default])</code></a>
: 提出一个问题，并返回访问者输入的内容，如果他按下「取消」则返回 <code>null</code>。</p>
<p><a href="mdn:api/Window/confirm"><code>confirm(question)</code></a>
: 提出一个问题，并建议用户在“确定”和“取消”之间进行选择。选择结果以 <code>true/false</code> 形式返回。</p>
<p><a href="mdn:api/Window/alert"><code>alert(message)</code></a>
: 输出一个 <code>消息</code>。</p>
<p>这些函数都会产生 <strong>模态框</strong>，它们会暂停代码执行并阻止访问者与页面的其他部分进行交互，直到用户做出回答为止。</p>
<p>举个例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> userName = prompt(<span class="hljs-string">&quot;Your name?&quot;</span>, <span class="hljs-string">&quot;Alice&quot;</span>);
<span class="hljs-keyword">let</span> isTeaWanted = confirm(<span class="hljs-string">&quot;Do you want some tea?&quot;</span>);

alert( <span class="hljs-string">&quot;Visitor: &quot;</span> + userName ); <span class="hljs-comment">// Alice</span>
alert( <span class="hljs-string">&quot;Tea wanted: &quot;</span> + isTeaWanted ); <span class="hljs-comment">// true</span></code></pre>
<p>更多内容：<a href="info:alert-prompt-confirm">info:alert-prompt-confirm</a>。</p>
<h2 id="运算符">运算符</h2>
<p>JavaScript 支持以下运算符：</p>
<p>算数运算符
: 常规的：<code>+ - * /</code>（加减乘除），取余运算符 <code>%</code> 和幂运算符 <code>**</code>。</p>
<pre><code>二进制加号 `+` 可以连接字符串。如果任何一个操作数是一个字符串，那么另一个操作数也将被转换为字符串：

```js run
alert( &#x27;1&#x27; + 2 ); // &#x27;12&#x27;，字符串
alert( 1 + &#x27;2&#x27; ); // &#x27;12&#x27;，字符串
```</code></pre>
<p>赋值
: 简单的赋值：<code>a = b</code> 和合并了其他操作的赋值：<code>a * = 2</code>。</p>
<p>按位运算符
: 按位运算符在最低位级上操作 32 位的整数：详见 <a href="mdn:/JavaScript/Reference/Operators/Bitwise_Operators">文档</a>。</p>
<p>三元运算符
: 唯一具有三个参数的操作：<code>cond ? resultA : resultB</code>。如果 <code>cond</code> 是真的，则返回 <code>resultA</code>，否则返回 <code>resultB</code>。</p>
<p>逻辑运算符
: 逻辑与 <code>&amp;&amp;</code> 和或 <code>||</code> 执行短路运算，然后返回运算停止处的值（<code>true</code>/<code>false</code> 不是必须的）。逻辑非 <code>!</code> 将操作数转换为布尔值并返回其相反的值。</p>
<p>空值合并运算符
: <code>??</code> 运算符从一列变量中，选取值为已定义的值（defined value）的变量。<code>a ?? b</code> 的结果是 <code>a</code>，除非 <code>a</code> 为 <code>null/undefined</code>，这时结果是 <code>b</code>。</p>
<p>比较运算符
: 对不同类型的值进行相等检查时，运算符 <code>==</code> 会将不同类型的值转换为数字（除了 <code>null</code> 和 <code>undefined</code>，它们彼此相等而没有其他情况），所以下面的例子是相等的：</p>
<pre><code>```js run
alert( 0 == false ); // true
alert( 0 == &#x27;&#x27; ); // true
```

其他比较也将转换为数字。

严格相等运算符 `===` 不会进行转换：不同的类型总是指不同的值。

值 `null` 和 `undefined` 是特殊的：它们只在 `==` 下相等，且不相等于其他任何值。

大于/小于比较，在比较字符串时，会按照字符顺序逐个字符地进行比较。其他类型则被转换为数字。</code></pre>
<p>其他运算符
: 还有很少一部分其他运算符，如逗号运算符。</p>
<p>更多内容：<a href="info:operators">info:operators</a>，<a href="info:comparison">info:comparison</a>，<a href="info:logical-operators">info:logical-operators</a>，<a href="info:nullish-coalescing-operator">info:nullish-coalescing-operator</a>。</p>
<h2 id="循环">循环</h2>
<ul>
<li><p>我们涵盖了 3 种类型的循环：</p>
<pre><code class="language-js"><span class="hljs-comment">// 1</span>
<span class="hljs-keyword">while</span> (condition) {
  ...
}

<span class="hljs-comment">// 2</span>
<span class="hljs-keyword">do</span> {
  ...
} <span class="hljs-keyword">while</span> (condition);

<span class="hljs-comment">// 3</span>
<span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++</span>)</span> {
  ...
}</code></pre>
</li>
<li><p>在 <code>for(let...)</code> 循环内部声明的变量，只在该循环内可见。但我们也可以省略 <code>let</code> 并重用已有的变量。</p>
</li>
<li><p>指令 <code>break/continue</code> 允许退出整个循环/当前迭代。使用标签来打破嵌套循环。</p>
</li>
</ul>
<p>更多内容：<a href="info:while-for">info:while-for</a>。</p>
<p>稍后我们将学习更多类型的循环来处理对象。</p>
<h2 id="switch-结构">&quot;switch&quot; 结构</h2>
<p>&quot;switch&quot; 结构可以替代多个 <code>if</code> 检查。它内部使用 <code>===</code>（严格相等）进行比较。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> age = prompt(<span class="hljs-string">&#x27;Your age?&#x27;</span>, <span class="hljs-number">18</span>);

<span class="hljs-keyword">switch</span> (age) {
  <span class="hljs-keyword">case</span> <span class="hljs-number">18</span>:
    alert(<span class="hljs-string">&quot;Won&#x27;t work&quot;</span>); <span class="hljs-comment">// prompt 的结果是一个字符串，而不是数字</span>
    <span class="hljs-keyword">break</span>;

  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;18&quot;</span>:
    alert(<span class="hljs-string">&quot;This works!&quot;</span>);
    <span class="hljs-keyword">break</span>;

  <span class="hljs-keyword">default</span>:
    alert(<span class="hljs-string">&quot;Any value not equal to one above&quot;</span>);
}</code></pre>
<p>详情请见：<a href="info:switch">info:switch</a>。</p>
<h2 id="函数">函数</h2>
<p>我们介绍了三种在 JavaScript 中创建函数的方式：</p>
<ol>
<li><p>函数声明：主代码流中的函数</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">let</span> result = a + b;

  <span class="hljs-keyword">return</span> result;
}</code></pre>
</li>
<li><p>函数表达式：表达式上下文中的函数</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> sum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">let</span> result = a + b;

  <span class="hljs-keyword">return</span> result;
}</code></pre>
</li>
<li><p>箭头函数：</p>
<pre><code class="language-js"><span class="hljs-comment">// 表达式在右侧</span>
<span class="hljs-keyword">let</span> sum = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b;

<span class="hljs-comment">// 或带 {...} 的多行语法，此处需要 return：</span>
<span class="hljs-keyword">let</span> sum = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-comment">// 没有参数</span>
<span class="hljs-keyword">let</span> sayHi = <span class="hljs-function">() =&gt;</span> alert(<span class="hljs-string">&quot;Hello&quot;</span>);

<span class="hljs-comment">// 有一个参数</span>
<span class="hljs-keyword">let</span> double = <span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n * <span class="hljs-number">2</span>;</code></pre>
</li>
</ol>
<ul>
<li>函数可能具有局部变量：在函数内部声明的变量。这类变量只在函数内部可见。</li>
<li>参数可以有默认值：<code>function sum(a = 1, b = 2) {...}</code>。</li>
<li>函数总是返回一些东西。如果没有 <code>return</code> 语句，那么返回的结果是 <code>undefined</code>。</li>
</ul>
<p>详细内容：请见 <a href="info:function-basics">info:function-basics</a>，<a href="info:arrow-functions-basics">info:arrow-functions-basics</a>。</p>
<h2 id="更多内容">更多内容</h2>
<p>这些是 JavaScript 特性的简要概述。截至目前，我们仅仅学习了基础知识。随着教程的深入，你会发现 JavaScript 的更多特性和高级特性。</p>

      </fieldset>
      
      <fieldset id='_VaoaOM'>
      <legend>article</legend>
      <h1 id="在-chrome-中调试">在 Chrome 中调试</h1>
<p>在编写更复杂的代码前，让我们先来聊聊调试吧。</p>
<p><a href="https://en.wikipedia.org/wiki/Debugging">调试</a> 是指在一个脚本中找出并修复错误的过程。所有的现代浏览器和大多数其他环境都支持调试工具 —— 开发者工具中的一个令调试更加容易的特殊用户界面。它也可以让我们一步步地跟踪代码以查看当前实际运行情况。</p>
<p>在这里我们将会使用 Chrome（谷歌浏览器），因为它拥有足够多的功能，其他大部分浏览器的功能也与之类似。</p>
<h2 id="资源（sources）面板">“资源（Sources）”面板</h2>
<p>你的 Chrome 版本可能看起来有一点不同，但是它应该还是处于很明显的位置。</p>
<ul>
<li>在 Chrome 中打开 <a href="debugging/index.html">示例页面</a>。</li>
<li>使用快捷键 <code>key:F12</code>（Mac：<code>key:Cmd+Opt+I</code>）打开开发者工具。</li>
<li>选择 <code>Sources（资源）</code> 面板。</li>
</ul>
<p>如果你是第一次这么做，那你应该会看到下面这个样子：</p>
<p><img src="chrome-open-sources.svg" alt=""></p>
<p>切换按钮 <span class="devtools" style="background-position:-172px -98px"></span> 会打开文件列表的选项卡。</p>
<p>让我们在预览树中点击和选择 <code>hello.js</code>。这里应该会如下图所示：</p>
<p><img src="chrome-tabs.svg" alt=""></p>
<p>资源（Sources）面板包含三个部分：</p>
<ol>
<li><strong>文件导航（File Navigator）</strong> 区域列出了 HTML、JavaScript、CSS 和包括图片在内的其他依附于此页面的文件。Chrome 扩展程序也会显示在这。</li>
<li><strong>代码编辑（Code Editor）</strong> 区域展示源码。</li>
<li><strong>JavaScript 调试（JavaScript Debugging）</strong> 区域是用于调试的，我们很快就会来探索它。</li>
</ol>
<p>现在你可以再次点击切换按钮 <span class="devtools" style="background-position:-172px -122px"></span> 隐藏资源列表来给代码腾出一些空间。</p>
<h2 id="控制台（console）">控制台（Console）</h2>
<p>如果我们按下 <code>key:Esc</code>，下面会出现一个控制台，我们可以输入一些命令然后按下 <code>key:Enter</code> 来执行。</p>
<p>语句执行完毕之后，其执行结果会显示在下面。</p>
<p>例如，<code>1+2</code> 将会返回 <code>3</code>，<code>hello(&quot;debugger&quot;)</code> 函数什么也不返回，因此结果是 <code>undefined</code>：</p>
<p><img src="chrome-sources-console.svg" alt=""></p>
<h2 id="断点（breakpoints）">断点（Breakpoints）</h2>
<p>我们来看看 <a href="debugging/index.html">示例页面</a> 发生了什么。在 <code>hello.js</code> 中，点击第 <code>4</code> 行。是的，就点击数字 <code>&quot;4&quot;</code> 上，不是点击代码。</p>
<p>恭喜你！你已经设置了一个断点。现在，请在第 <code>8</code> 行的数字上也点击一下。</p>
<p>看起来应该是这样的（蓝色是你应该点击的地方）：</p>
<p><img src="chrome-sources-breakpoint.svg" alt=""></p>
<p><strong>断点</strong> 是调试器会自动暂停 JavaScript 执行的地方。</p>
<p>当代码被暂停时，我们可以检查当前的变量，在控制台执行命令等等。换句话说，我们可以调试它。</p>
<p>我们总是可以在右侧的面板中找到断点的列表。当我们在数个文件中有许多断点时，这是非常有用的。它允许我们：</p>
<ul>
<li>快速跳转至代码中的断点（通过点击右侧面板中的对应的断点）。</li>
<li>通过取消选中断点来临时禁用对应的断点。</li>
<li>通过右键单击并选择移除来删除一个断点。</li>
<li>……等等。</li>
</ul>
<pre><code class="language-smart">在行号上 **右键单击** 允许你创建一个 **条件** 断点。只有当给定的表达式为真（即满足条件）时才会被触发。

当我们需要在特定的变量值或参数的情况下暂停程序执行时，这种调试方法就很有用了。</code></pre>
<h2 id="debugger-命令">Debugger 命令</h2>
<p>我们也可以使用 <code>debugger</code> 命令来暂停代码，像这样：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">let</span> phrase = <span class="hljs-string">`Hello, <span class="hljs-subst">${name}</span>!`</span>;

*!*
  <span class="hljs-keyword">debugger</span>;  <span class="hljs-comment">// &lt;-- 调试器会在这停止</span>
*/!*

  say(phrase);
}</code></pre>
<p>当我们在一个代码编辑器中并且不想切换到浏览器在开发者工具中查找脚本来设置断点时，这真的是非常方便。</p>
<h2 id="暂停并查看">暂停并查看</h2>
<p>在我们的例子中，<code>hello()</code> 函数在页面加载期间被调用，因此激活调试器的最简单的方法（在我们已经设置了断点后）就是 —— 重新加载页面。因此让我们按下 <code>key:F5</code>（Windows，Linux）或 <code>key:Cmd+R</code>（Mac）吧。</p>
<p>设置断点之后，程序会在第 4 行暂停执行：</p>
<p><img src="chrome-sources-debugger-pause.svg" alt=""></p>
<p>请打开右侧的信息下拉列表（箭头指示出的地方）。这里允许你查看当前的代码状态：</p>
<ol>
<li><p><strong><code>察看（Watch）</code> —— 显示任意表达式的当前值。</strong></p>
<p> 你可以点击加号 <code>+</code> 然后输入一个表达式。调试器将随时显示它的值，并在执行过程中自动重新计算该表达式。</p>
</li>
<li><p><strong><code>调用栈（Call Stack）</code> —— 显示嵌套的调用链。</strong></p>
<p> 此时，调试器正在 <code>hello()</code> 的调用链中，被 <code>index.html</code> 中的一个脚本调用（这里没有函数，因此显示 &quot;anonymous&quot;）</p>
<p> 如果你点击了一个堆栈项，调试器将跳到对应的代码处，并且还可以查看其所有变量。</p>
</li>
<li><p><strong><code>作用域（Scope）</code> —— 显示当前的变量。</strong></p>
<p> <code>Local</code> 显示当前函数中的变量，你还可以在源代码中看到它们的值高亮显示了出来。</p>
<p> <code>Global</code> 显示全局变量（不在任何函数中）。</p>
<p> 这里还有一个 <code>this</code> 关键字，目前我们还没有学到它，不过我们很快就会学习它了。</p>
</li>
</ol>
<h2 id="跟踪执行">跟踪执行</h2>
<p>现在是 <strong>跟踪</strong> 脚本的时候了。</p>
<p>在右侧面板的顶部是一些关于跟踪脚本的按钮。让我们来使用它们吧。</p>
<!-- https://github.com/ChromeDevTools/devtools-frontend/blob/master/front_end/Images/src/largeIcons.svg -->
<p><span class="devtools" style="background-position:-146px -168px"></span> —— “恢复（Resume）”：继续执行，快捷键 <code>key:F8</code>。
: 继续执行。如果没有其他的断点，那么程序就会继续执行，并且调试器不会再控制程序。</p>
<pre><code>我们点击它一下之后，我们会看到这样的情况：

![](chrome-sources-debugger-trace-1.svg)

执行恢复了，执行到 `say()` 函数中的另外一个断点后暂停在了那里。看一下右边的 &quot;Call stack&quot;。它已经增加了一个调用信息。我们现在在 `say()` 里面。</code></pre>
<p><span class="devtools" style="background-position:-200px -190px"></span> —— “下一步（Step）”：运行下一条指令，快捷键 <code>key:F9</code>。
: 运行下一条语句。如果我们现在点击它，<code>alert</code> 会被显示出来。</p>
<pre><code>一次接一次地点击此按钮，整个脚本的所有语句会被逐个执行。</code></pre>
<p><span class="devtools" style="background-position:-62px -192px"></span> —— “跨步（Step over）”：运行下一条指令，但 <strong>不会进入到一个函数中</strong>，快捷键 <code>key:F10</code>。
: 跟上一条命令“下一步（Step）”类似，但如果下一条语句是函数调用则表现不同。这里的函数指的是：不是内置的如 <code>alert</code> 函数等，而是我们自己写的函数。</p>
<pre><code>“下一步（Step）”命令进入函数内部并在第一行暂停执行，而“跨步（Step over）”在无形中执行函数调用，跳过了函数的内部。

执行会在该函数执行后立即暂停。

如果我们对该函数的内部执行不感兴趣，这命令会很有用。</code></pre>
<p><span class="devtools" style="background-position:-4px -194px"></span> —— “步入（Step into）”，快捷键 <code>key:F11</code>。
: 和“下一步（Step）”类似，但在异步函数调用情况下表现不同。如果你刚刚才开始学 JavaScript，那么你可以先忽略此差异，因为我们还没有用到异步调用。</p>
<pre><code>至于之后，只需要记住“下一步（Step）”命令会忽略异步行为，例如 `setTimeout`（计划的函数调用），它会过一段时间再执行。而“步入（Step into）”会进入到代码中并等待（如果需要）。详见 [DevTools 手册](https://developers.google.com/web/updates/2018/01/devtools#async)。</code></pre>
<p><span class="devtools" style="background-position:-32px -194px"></span> —— “步出（Step out）”：继续执行到当前函数的末尾，快捷键 <code>key:Shift+F11</code>。
: 继续执行代码并停止在当前函数的最后一行。当我们使用 <span class="devtools" style="background-position:-200px -190px"></span> 偶然地进入到一个嵌套调用，但是我们又对这个函数不感兴趣时，我们想要尽可能的继续执行到最后的时候是非常方便的。</p>
<p><span class="devtools" style="background-position:-61px -74px"></span> —— 启用/禁用所有的断点。
: 这个按钮不会影响程序的执行。只是一个批量操作断点的开/关。</p>
<p><span class="devtools" style="background-position:-264px -4px"></span> —— 启用/禁用出现错误时自动暂停脚本执行。
: 当启动此功能并且开发者工具是打开着的时候，任何一个脚本的错误都会导致该脚本执行自动暂停。然后我们可以分析变量来看一下什么出错了。因此如果我们的脚本因为错误挂掉的时候，我们可以打开调试器，启用这个选项然后重载页面，查看一下哪里导致它挂掉了和当时的上下文是什么。</p>
<pre><code class="language-smart">在代码中的某一行上右键，在显示的关联菜单（context menu）中点击一个非常有用的名为 &quot;Continue to here&quot; 的选项。

当你想要向前移动很多步到某一行为止，但是又懒得设置一个断点时非常的方便。</code></pre>
<h2 id="日志记录">日志记录</h2>
<p>想要输出一些东西到控制台上？<code>console.log</code> 函数可以满足你。</p>
<p>例如：将从 <code>0</code> 到 <code>4</code> 的值输出到控制台上：</p>
<pre><code class="language-js"><span class="hljs-comment">// 打开控制台来查看</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;value&quot;</span>, i);
}</code></pre>
<p>普通用户看不到这个输出，它是在控制台里面的。要想看到它 —— 要么打开开发者工具中的 Console（控制台）选项卡，要么在一个其他的选项卡中按下 <code>key:Esc</code>：这会在下方打开一个控制台。</p>
<p>如果我们在代码中有足够的日志记录，那么我们可以从记录中看到刚刚发生了什么，而不需要借助调试器。</p>
<h2 id="总结">总结</h2>
<p>我们可以看到，这里有 3 种方式来暂停一个脚本：</p>
<ol>
<li>一个断点。</li>
<li><code>debugger</code> 语句。</li>
<li>一个错误（如果开发者工具是打开状态，并且按钮 <span class="devtools" style="background-position:-90px -146px"></span> 是开启的状态）。</li>
</ol>
<p>当脚本执行暂停时，我们就可以进行调试 —— 检查变量，跟踪代码来查看执行出错的位置。</p>
<p>开发人员工具中的选项比本文介绍的多得多。完整的手册请点击这个链接查看：<a href="https://developers.google.com/web/tools/chrome-devtools">https://developers.google.com/web/tools/chrome-devtools</a>。</p>
<p>本章节的内容足够让你上手代码调试了，但是之后，尤其是你做了大量关于浏览器的东西后，推荐你查看上面那个链接中讲的开发者工具更高级的功能。</p>
<p>对了，你也可以点击开发者工具中的其他地方来看一下会显示什么。这可能是你学习开发者工具最快的方式了。不要忘了还有右键单击和关联菜单哟。</p>

      </fieldset>
      
      <fieldset id='_Lwhxxn'>
      <legend>solution</legend>
      <p>你可以注意到以下几点：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pow</span>(<span class="hljs-params">x,n</span>)  // &lt;- 参数之间没有空格
</span>{  <span class="hljs-comment">// &lt;- 花括号独占了一行</span>
  <span class="hljs-keyword">let</span> result=<span class="hljs-number">1</span>;   <span class="hljs-comment">// &lt;- = 号两边没有空格</span>
  <span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;n;i++</span>)</span> {result*=x;}   <span class="hljs-comment">// &lt;- 没有空格</span>
  <span class="hljs-comment">// { ... } 里面的内容应该在新的一行上</span>
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-keyword">let</span> x=prompt(<span class="hljs-string">&quot;x?&quot;</span>,<span class="hljs-string">&#x27;&#x27;</span>), n=prompt(<span class="hljs-string">&quot;n?&quot;</span>,<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// &lt;-- 从技术的角度来看是可以的，</span>
<span class="hljs-comment">// 但是拆分成 2 行会更好，并且这里也缺了空格和分号 ;</span>
<span class="hljs-keyword">if</span> (n&lt;=<span class="hljs-number">0</span>)  <span class="hljs-comment">// &lt;- (n &lt;= 0) 里面没有空格，并且应该在本行上面加一个空行</span>
{   <span class="hljs-comment">// &lt;- 花括号独占了一行</span>
  <span class="hljs-comment">// 下面的一行代码太长了，可以将其拆分成 2 行以提高可读性</span>
  alert(<span class="hljs-string">`Power <span class="hljs-subst">${n}</span> is not supported, please enter an integer number greater than zero`</span>);
}
<span class="hljs-keyword">else</span> <span class="hljs-comment">// &lt;- 可以像 &quot;} else {&quot; 这样写在一行上</span>
{
  alert(pow(x,n))  <span class="hljs-comment">// 缺失了空格和分号 ;</span>
}</code></pre>
<p>修改后的版本：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pow</span>(<span class="hljs-params">x, n</span>) </span>{
  <span class="hljs-keyword">let</span> result = <span class="hljs-number">1</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
    result *= x;
  }

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-keyword">let</span> x = prompt(<span class="hljs-string">&quot;x?&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);
<span class="hljs-keyword">let</span> n = prompt(<span class="hljs-string">&quot;n?&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);

<span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) {
  alert(<span class="hljs-string">`Power <span class="hljs-subst">${n}</span> is not supported,
    please enter an integer number greater than zero`</span>);
} <span class="hljs-keyword">else</span> {
  alert( pow(x, n) );
}</code></pre>

      </fieldset>
      
      <fieldset id='_jufgcU'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="不好的风格">不好的风格</h1>
<p>下面的代码风格有什么问题？</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pow</span>(<span class="hljs-params">x,n</span>)
</span>{
  <span class="hljs-keyword">let</span> result=<span class="hljs-number">1</span>;
  <span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;n;i++</span>)</span> {result*=x;}
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-keyword">let</span> x=prompt(<span class="hljs-string">&quot;x?&quot;</span>,<span class="hljs-string">&#x27;&#x27;</span>), n=prompt(<span class="hljs-string">&quot;n?&quot;</span>,<span class="hljs-string">&#x27;&#x27;</span>)
<span class="hljs-keyword">if</span> (n&lt;=<span class="hljs-number">0</span>)
{
  alert(<span class="hljs-string">`Power <span class="hljs-subst">${n}</span> is not supported, please enter an integer number greater than zero`</span>);
}
<span class="hljs-keyword">else</span>
{
  alert(pow(x,n))
}</code></pre>
<p>修复它。</p>

      </fieldset>
      
      <fieldset id='_kYODsv'>
      <legend>article</legend>
      <h1 id="代码风格">代码风格</h1>
<p>我们的代码必须尽可能的清晰和易读。</p>
<p>这实际上是一种编程艺术 —— 以一种正确并且人们易读的方式编码来完成一个复杂的任务。一个良好的代码风格大大有助于实现这一点。</p>
<h2 id="语法">语法</h2>
<p>下面是一个备忘单，其中列出了一些建议的规则（详情请参阅下文）：</p>
<p><img src="code-style.svg" alt=""></p>
<!--
```js
function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}

let x = prompt("x?", "");
let n = prompt("n?", "");

if (n < 0) {
  alert(`Power ${n} is not supported,
    please enter a non-negative integer number`);
} else {
  alert( pow(x, n) );
}
```

-->

<p>现在，让我们详细讨论一下这些规则和它们的原因吧。</p>
<pre><code class="language-warn">没有什么规则是“刻在石头上”的。这些是风格偏好，而不是宗教教条。</code></pre>
<h3 id="花括号">花括号</h3>
<p>在大多数的 JavaScript 项目中，花括号以 &quot;Egyptian&quot; 风格（译注：&quot;egyptian&quot; 风格又称 K&amp;R 风格 — 代码段的开括号位于一行的末尾，而不是另起一行的风格）书写，左花括号与相应的关键词在同一行上 — 而不是新起一行。左括号前还应该有一个空格，如下所示：</p>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (condition) {
  <span class="hljs-comment">// do this</span>
  <span class="hljs-comment">// ...and that</span>
  <span class="hljs-comment">// ...and that</span>
}</code></pre>
<p>单行构造（如 <code>if (condition) doSomething()</code>）也是一个重要的用例。我们是否应该使用花括号？如果是，那么在哪里？</p>
<p>下面是这几种情况的注释，你可以自己判断一下它们的可读性：</p>
<ol>
<li>😠 初学者常这样写。非常不好！这里不需要花括号：<pre><code class="language-js"><span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) *!*{*<span class="hljs-regexp">/!*alert(`Power ${n} is not supported`);*!*}*/</span>!*</code></pre>
</li>
<li>😠 拆分为单独的行，不带花括号。永远不要这样做，添加新行很容易出错：<pre><code class="language-js"><span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>)
  alert(<span class="hljs-string">`Power <span class="hljs-subst">${n}</span> is not supported`</span>);</code></pre>
</li>
<li>😏 写成一行，不带花括号 — 如果短的话，也是可以的：<pre><code class="language-js"><span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) alert(<span class="hljs-string">`Power <span class="hljs-subst">${n}</span> is not supported`</span>);</code></pre>
</li>
<li>😃 最好的方式：<pre><code class="language-js"><span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) {
  alert(<span class="hljs-string">`Power <span class="hljs-subst">${n}</span> is not supported`</span>);
}</code></pre>
</li>
</ol>
<p>对于很短的代码，写成一行是可以接受的：例如 <code>if (cond) return null</code>。但是代码块（最后一个示例）通常更具可读性。</p>
<h3 id="行的长度">行的长度</h3>
<p>没有人喜欢读一长串代码，最好将代码分割一下。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-comment">// 回勾引号 ` 允许将字符串拆分为多行</span>
<span class="hljs-keyword">let</span> str = <span class="hljs-string">`
  ECMA International&#x27;s TC39 is a group of JavaScript developers,
  implementers, academics, and more, collaborating with the community
  to maintain and evolve the definition of JavaScript.
`</span>;</code></pre>
<p>对于 <code>if</code> 语句：</p>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (
  id === <span class="hljs-number">123</span> &amp;&amp;
  moonPhase === <span class="hljs-string">&#x27;Waning Gibbous&#x27;</span> &amp;&amp;
  zodiacSign === <span class="hljs-string">&#x27;Libra&#x27;</span>
) {
  letTheSorceryBegin();
}</code></pre>
<p>一行代码的最大长度应该在团队层面上达成一致。通常是 80 或 120 个字符。</p>
<h3 id="缩进">缩进</h3>
<p>有两种类型的缩进：</p>
<ul>
<li><p><strong>水平方向上的缩进：2 或 4 个空格。</strong></p>
<p>  一个水平缩进通常由 2 或 4 个空格或者 &quot;Tab&quot; 制表符（key <code>key:Tab</code>）构成。选择哪一个方式是一场古老的圣战。如今空格更普遍一点。</p>
<p>  选择空格而不是 tabs 的优点之一是，这允许你做出比 “Tab” 制表符更加灵活的缩进配置。</p>
<p>  例如，我们可以将参数与左括号对齐，像下面这样：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-title">show</span>(<span class="hljs-params">parameters,
     aligned, <span class="hljs-comment">// 左边有 5 个空格</span>
     one,
     after,
     another
  </span>)</span> {
  <span class="hljs-comment">// ...</span>
}</code></pre>
</li>
<li><p><strong>垂直方向上的缩进：用于将代码拆分成逻辑块的空行。</strong></p>
<p>  即使是单个函数通常也被分割为数个逻辑块。在下面的示例中，初始化的变量、主循环结构和返回值都被垂直分割了：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pow</span>(<span class="hljs-params">x, n</span>) </span>{
  <span class="hljs-keyword">let</span> result = <span class="hljs-number">1</span>;
  <span class="hljs-comment">//              &lt;--</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
    result *= x;
  }
  <span class="hljs-comment">//              &lt;--</span>
  <span class="hljs-keyword">return</span> result;
}</code></pre>
<p>  插入一个额外的空行有助于使代码更具可读性。写代码时，不应该出现连续超过 9 行都没有被垂直分割的代码。</p>
</li>
</ul>
<h3 id="分号">分号</h3>
<p>每一个语句后面都应该有一个分号。即使它可以被跳过。</p>
<p>有一些编程语言的分号确实是可选的，那些语言中也很少使用分号。但是在 JavaScript 中，极少数情况下，换行符有时不会被解释为分号，这时代码就容易出错。更多内容请参阅 <a href="info:structure#semicolon">info:structure#semicolon</a> 一章的内容。</p>
<p>如果你是一个有经验的 JavaScript 程序员，你可以选择像 <a href="https://standardjs.com/">StandardJS</a> 这样的无分号的代码风格。否则，最好使用分号以避免可能出现的陷阱。大多数开发人员都应该使用分号。</p>
<h3 id="嵌套的层级">嵌套的层级</h3>
<p>尽量避免代码嵌套层级过深。</p>
<p>例如，在循环中，有时候使用 <a href="info:while-for#continue"><code>continue</code></a> 指令以避免额外的嵌套是一个好主意。</p>
<p>例如，不应该像下面这样添加嵌套的 <code>if</code> 条件：</p>
<pre><code class="language-js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
  <span class="hljs-keyword">if</span> (cond) {
    ... <span class="hljs-comment">// &lt;- 又一层嵌套</span>
  }
}</code></pre>
<p>我们可以这样写：</p>
<pre><code class="language-js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
  <span class="hljs-keyword">if</span> (!cond) *!*<span class="hljs-keyword">continue</span>*/!*;
  ...  <span class="hljs-comment">// &lt;- 没有额外的嵌套</span>
}</code></pre>
<p>使用 <code>if/else</code> 和 <code>return</code> 也可以做类似的事情。</p>
<p>例如，下面的两个结构是相同的。</p>
<p>第一个：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pow</span>(<span class="hljs-params">x, n</span>) </span>{
  <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) {
    alert(<span class="hljs-string">&quot;Negative &#x27;n&#x27; not supported&quot;</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">let</span> result = <span class="hljs-number">1</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
      result *= x;
    }

    <span class="hljs-keyword">return</span> result;
  }
}</code></pre>
<p>第二个：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pow</span>(<span class="hljs-params">x, n</span>) </span>{
  <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) {
    alert(<span class="hljs-string">&quot;Negative &#x27;n&#x27; not supported&quot;</span>);
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-keyword">let</span> result = <span class="hljs-number">1</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
    result *= x;
  }

  <span class="hljs-keyword">return</span> result;
}</code></pre>
<p>但是第二个更具可读性，因为 <code>n &lt; 0</code> 这个“特殊情况”在一开始就被处理了。一旦条件通过检查，代码执行就可以进入到“主”代码流，而不需要额外的嵌套。</p>
<h2 id="函数位置">函数位置</h2>
<p>如果你正在写几个“辅助”函数和一些使用它们的代码，那么有三种方式来组织这些函数。</p>
<ol>
<li><p>在调用这些函数的代码的 <strong>上方</strong> 声明这些函数：</p>
<pre><code class="language-js"><span class="hljs-comment">// *!*函数声明*/!*</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createElement</span>(<span class="hljs-params"></span>) </span>{
  ...
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setHandler</span>(<span class="hljs-params">elem</span>) </span>{
  ...
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">walkAround</span>(<span class="hljs-params"></span>) </span>{
  ...
}

<span class="hljs-comment">// *!*调用函数的代码*/!*</span>
<span class="hljs-keyword">let</span> elem = createElement();
setHandler(elem);
walkAround();</code></pre>
</li>
<li><p>先写调用代码，再写函数</p>
<pre><code class="language-js"><span class="hljs-comment">// *!*调用函数的代码*/!*</span>
<span class="hljs-keyword">let</span> elem = createElement();
setHandler(elem);
walkAround();

<span class="hljs-comment">// --- *!*辅助函数*/!* ---</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createElement</span>(<span class="hljs-params"></span>) </span>{
  ...
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setHandler</span>(<span class="hljs-params">elem</span>) </span>{
  ...
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">walkAround</span>(<span class="hljs-params"></span>) </span>{
  ...
}</code></pre>
</li>
<li><p>混合：在第一次使用一个函数时，对该函数进行声明。</p>
</li>
</ol>
<p>大多数情况下，第二种方式更好。</p>
<p>这是因为阅读代码时，我们首先想要知道的是“它做了什么”。如果代码先行，那么在整个程序的最开始就展示出了这些信息。之后，可能我们就不需要阅读这些函数了，尤其是它们的名字清晰地展示出了它们的功能的时候。</p>
<h2 id="风格指南">风格指南</h2>
<p>风格指南包含了“如果编写”代码的通用规则，例如：使用哪个引号、用多少空格来缩进、一行代码最大长度等非常多的细节。</p>
<p>当团队中的所有成员都使用相同的风格指南时，代码看起来将是统一的。无论是团队中谁写的，都是一样的风格。</p>
<p>当然，一个团队可以制定他们自己的风格指南，但是没必要这样做。现在已经有了很多制定好的代码风格指南可供选择。</p>
<p>一些受欢迎的选择：</p>
<ul>
<li><a href="https://google.github.io/styleguide/jsguide.html">Google JavaScript 风格指南</a></li>
<li><a href="https://github.com/airbnb/javascript">Airbnb JavaScript 风格指南</a></li>
<li><a href="https://github.com/rwaldron/idiomatic.js">Idiomatic.JS</a></li>
<li><a href="https://standardjs.com/">StandardJS</a></li>
<li>还有很多……</li>
</ul>
<p>如果你是一个初学者，你可以从本章中上面的内容开始。然后你可以浏览其他风格指南，并选择一个你最喜欢的。</p>
<h2 id="自动检查器">自动检查器</h2>
<p>检查器（Linters）是可以自动检查代码样式，并提出改进建议的工具。</p>
<p>它们的妙处在于进行代码风格检查时，还可以发现一些代码错误，例如变量或函数名中的错别字。因此，即使你不想坚持某一种特定的代码风格，我也建议你安装一个检查器。</p>
<p>下面是一些最出名的代码检查工具：</p>
<ul>
<li><a href="http://www.jslint.com/">JSLint</a> — 第一批检查器之一。</li>
<li><a href="http://www.jshint.com/">JSHint</a> — 比 JSLint 多了更多设置。</li>
<li><a href="http://eslint.org/">ESLint</a> — 应该是最新的一个。</li>
</ul>
<p>它们都能够做好代码检查。我使用的是 <a href="http://eslint.org/">ESLint</a>。</p>
<p>大多数检查器都可以与编辑器集成在一起：只需在编辑器中启用插件并配置代码风格即可。</p>
<p>例如，要使用 ESLint 你应该这样做：</p>
<ol>
<li>安装 <a href="https://nodejs.org/">Node.JS</a>。</li>
<li>使用 <code>npm install -g eslint</code> 命令（npm 是一个 JavaScript 包安装工具）安装 ESLint。</li>
<li>在你的 JavaScript 项目的根目录（包含该项目的所有文件的那个文件夹）创建一个名为 <code>.eslintrc</code> 的配置文件。</li>
<li>在集成了 ESLint 的编辑器中安装/启用插件。大多数编辑器都有这个选项。</li>
</ol>
<p>下面是一个 <code>.eslintrc</code> 文件的例子：</p>
<pre><code class="language-js">{
  <span class="hljs-string">&quot;extends&quot;</span>: <span class="hljs-string">&quot;eslint:recommended&quot;</span>,
  <span class="hljs-string">&quot;env&quot;</span>: {
    <span class="hljs-string">&quot;browser&quot;</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-string">&quot;node&quot;</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-string">&quot;es6&quot;</span>: <span class="hljs-literal">true</span>
  },
  <span class="hljs-string">&quot;rules&quot;</span>: {
    <span class="hljs-string">&quot;no-console&quot;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&quot;indent&quot;</span>: [<span class="hljs-string">&quot;warning&quot;</span>, <span class="hljs-number">2</span>]
  }
}</code></pre>
<p>这里的 <code>&quot;extends&quot;</code> 指令表示我们是基于 &quot;eslint:recommended&quot; 的设置项而进行设置的。之后，我们制定我们自己的规则。</p>
<p>你也可以从网上下载风格规则集并进行扩展。有关安装的更多详细信息，请参见 <a href="http://eslint.org/docs/user-guide/getting-started">http://eslint.org/docs/user-guide/getting-started</a>。</p>
<p>此外，某些 IDE 有内置的检查器，这非常方便，但是不像 ESLint 那样可自定义。</p>
<h2 id="总结">总结</h2>
<p>本章描述的（和提到的代码风格指南中的）所有语法规则，都旨在帮助你提高代码可读性。它们都是值得商榷的。</p>
<p>当我们思考如何写“更好”的代码的时候，我们应该问自己的问题是：“什么可以让代码可读性更高，更容易被理解？”和“什么可以帮助我们避免错误？”这些是我们讨论和选择代码风格时要牢记的主要原则。</p>
<p>阅读流行的代码风格指南，可以帮助你了解有关代码风格的变化趋势和最佳实践的最新想法。</p>

      </fieldset>
      
      <fieldset id='_QLacYV'>
      <legend>article</legend>
      <h1 id="注释">注释</h1>
<p>正如我们在 <a href="info:structure">info:structure</a> 一章所了解到的那样，注释可以是以 <code>//</code> 开始的单行注释，也可以是 <code>/* ... */</code> 结构的多行注释。</p>
<p>我们通常通过注释来描述代码怎样工作和为什么这样工作。</p>
<p>乍一看，写注释可能很简单，但初学者在编程的时候，经常错误地使用注释。</p>
<h2 id="糟糕的注释">糟糕的注释</h2>
<p>新手倾向于使用注释来解释“代码中发生了什么”。就像这样：</p>
<pre><code class="language-js"><span class="hljs-comment">// 这里的代码会先做这件事（……）然后做那件事（……）</span>
<span class="hljs-comment">// ……谁知道还有什么……</span>
very;
complex;
code;</code></pre>
<p>但在好的代码中，这种“解释性”注释的数量应该是最少的。严格地说，就算没有它们，代码也应该很容易理解。</p>
<p>关于这一点有一个很棒的原则：“如果代码不够清晰以至于需要一个注释，那么或许它应该被重写。”</p>
<h3 id="配方：分解函数">配方：分解函数</h3>
<p>有时候，用一个函数来代替一个代码片段是更好的，就像这样：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showPrimes</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-attr">nextPrime</span>:
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) {

*!*
    <span class="hljs-comment">// 检测 i 是否是一个质数（素数）</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">2</span>; j &lt; i; j++) {
      <span class="hljs-keyword">if</span> (i % j == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span> nextPrime;
    }
*/!*

    alert(i);
  }
}</code></pre>
<p>更好的变体，使用一个分解出来的函数 <code>isPrime</code>：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showPrimes</span>(<span class="hljs-params">n</span>) </span>{

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) {
    *!*<span class="hljs-keyword">if</span> (!isPrime(i)) <span class="hljs-keyword">continue</span>;*/!*

    alert(i);  
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isPrime</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) {
    <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}</code></pre>
<p>现在我们可以很容易地理解代码了。函数自己就变成了一个注释。这种代码被称为 <strong>自描述型</strong> 代码。</p>
<h3 id="配方：创建函数">配方：创建函数</h3>
<p>如果我们有一个像下面这样很长的代码块：</p>
<pre><code class="language-js"><span class="hljs-comment">// 在这里我们添加威士忌（译注：国外的一种酒）</span>
<span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++</span>)</span> {
  <span class="hljs-keyword">let</span> drop = getWhiskey();
  smell(drop);
  add(drop, glass);
}

<span class="hljs-comment">// 在这里我们添加果汁</span>
<span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> t = <span class="hljs-number">0</span>; t &lt; <span class="hljs-number">3</span>; t++</span>)</span> {
  <span class="hljs-keyword">let</span> tomato = getTomato();
  examine(tomato);
  <span class="hljs-keyword">let</span> juice = press(tomato);
  add(juice, glass);
}

<span class="hljs-comment">// ...</span></code></pre>
<p>我们像下面这样，将上面的代码重构为函数，可能会是一个更好的变体：</p>
<pre><code class="language-js">addWhiskey(glass);
addJuice(glass);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addWhiskey</span>(<span class="hljs-params">container</span>) </span>{
  <span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++</span>)</span> {
    <span class="hljs-keyword">let</span> drop = getWhiskey();
    <span class="hljs-comment">//...</span>
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addJuice</span>(<span class="hljs-params">container</span>) </span>{
  <span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> t = <span class="hljs-number">0</span>; t &lt; <span class="hljs-number">3</span>; t++</span>)</span> {
    <span class="hljs-keyword">let</span> tomato = getTomato();
    <span class="hljs-comment">//...</span>
  }
}</code></pre>
<p>同样，函数本身就可以告诉我们发生了什么。没有什么地方需要注释。并且分割之后代码的结构也更好了。每一个函数做什么、需要什么和返回什么都非常地清晰。</p>
<p>实际上，我们不能完全避免“解释型”注释。例如在一些复杂的算法中，会有一些出于优化的目的而做的一些巧妙的“调整”。但是通常情况下，我们应该尽可能地保持代码的简单和“自我描述”性。</p>
<h2 id="好的注释">好的注释</h2>
<p>所以，解释性注释通常来说都是不好的。那么哪一种注释才是好的呢？</p>
<p>描述架构
: 对组件进行高层次的整体概括，它们如何相互作用、各种情况下的控制流程是什么样的……简而言之 —— 代码的鸟瞰图。有一个专门用于构建代码的高层次架构图，以对代码进行解释的特殊编程语言 <a href="http://wikipedia.org/wiki/Unified_Modeling_Language">UML</a>。绝对值得学习。</p>
<p>记录函数的参数和用法
: 有一个专门用于记录函数的语法 <a href="http://en.wikipedia.org/wiki/JSDoc">JSDoc</a>：用法、参数和返回值。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-comment">/**
 * 返回 x 的 n 次幂的值。
 *
 * <span class="hljs-doctag">@param <span class="hljs-type">{number}</span> </span>x 要改变的值。
 * <span class="hljs-doctag">@param <span class="hljs-type">{number}</span> </span>n 幂数，必须是一个自然数。
 * <span class="hljs-doctag">@return <span class="hljs-type">{number}</span> </span>x 的 n 次幂的值。
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pow</span>(<span class="hljs-params">x, n</span>) </span>{
  ...
}</code></pre>
<p>这种注释可以帮助我们理解函数的目的，并且不需要研究其内部的实现代码，就可以直接正确地使用它。</p>
<p>顺便说一句，很多诸如 <a href="https://www.jetbrains.com/webstorm/">WebStorm</a> 这样的编辑器，都可以很好地理解和使用这些注释，来提供自动补全和一些自动化代码检查工作。</p>
<p>当然，也有一些像 <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3</a> 这样的工具，可以通过注释直接生成 HTML 文档。你可以在 <a href="http://usejsdoc.org/">http://usejsdoc.org/</a> 阅读更多关于 JSDoc 的信息。</p>
<p>为什么任务以这种方式解决？
: 写了什么代码很重要。但是为什么 <strong>不</strong> 那样写可能对于理解正在发生什么更重要。为什么任务是通过这种方式解决的？代码并没有给出答案。</p>
<pre><code>如果有很多种方法都可以解决这个问题，为什么偏偏是这一种？尤其当它不是最显而易见的那一种的时候。

没有这样的注释的话，就可能会发生下面的情况：
1. 你（或者你的同事）打开了前一段时间写的代码，看到它不是最理想的实现方式。
2. 你会想：“我当时是有多蠢啊，现在我真是太聪明了”，然后用“更显而易见且正确的”方式重写了一遍。
3. ……重写的这股冲动劲是好的。但是在重写的过程中你发现“更显而易见”的解决方案实际上是有缺陷的。你甚至依稀地想起了为什么会这样，因为你很久之前就已经尝试过这样做了。于是你又还原了那个正确的实现，但是时间已经浪费了。

解决方案的注释非常的重要。它们可以帮助你以正确的方式继续开发。</code></pre>
<p>代码有哪些巧妙的特性？它们被用在了什么地方？
: 如果代码存在任何巧妙和不显而易见的方法，那绝对需要注释。</p>
<h2 id="总结">总结</h2>
<p>一个好的开发者的标志之一就是他的注释：它们的存在甚至它们的缺席（译注：在该注释的地方注释，在不需要注释的地方则不注释，甚至写得好的自描述函数本身就是一种注释）。</p>
<p>好的注释可以使我们更好地维护代码，一段时间之后依然可以更高效地回到代码高效开发。</p>
<p><strong>注释这些内容：</strong></p>
<ul>
<li>整体架构，高层次的观点。</li>
<li>函数的用法。</li>
<li>重要的解决方案，特别是在不是很明显时。</li>
</ul>
<p><strong>避免注释：</strong></p>
<ul>
<li>描述“代码如何工作”和“代码做了什么”。</li>
<li>避免在代码已经足够简单或代码有很好的自描述性而不需要注释的情况下，还写些没必要的注释。</li>
</ul>
<p>注释也被用于一些如 JSDoc3 等文档自动生成工具：它们读取注释然后生成 HTML 文档（或者其他格式的文档）。</p>

      </fieldset>
      
      <fieldset id='_fCHZuR'>
      <legend>article</legend>
      <h1 id="忍者代码">忍者代码</h1>
<pre><code class="language-quote">学而不思则罔，思而不学则殆。</code></pre>
<p>过去的程序员忍者使用这些技巧，来使代码维护者的头脑更加敏锐。</p>
<p>代码审查大师在测试任务中寻找它们。</p>
<p>一些新入门的开发者有时候甚至比忍者程序员能够更好地使用它们。</p>
<p>仔细阅读本文，找出你是谁 —— 一个忍者、一个新手、或者一个代码审查者？</p>
<pre><code class="language-warn">许多人试图追随忍者的脚步。只有极少数成功了。</code></pre>
<h2 id="简洁是智慧的灵魂">简洁是智慧的灵魂</h2>
<p>把代码尽可能写得短。展示出你是多么的聪明啊。</p>
<p>在编程中，多使用一些巧妙的编程语言特性。</p>
<p>例如，看一下这个三元运算符 <code>&#39;?&#39;</code>：</p>
<pre><code class="language-js"><span class="hljs-comment">// 从一个著名的 JavaScript 库中截取的代码</span>
i = i ? i &lt; <span class="hljs-number">0</span> ? <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, len + i) : i : <span class="hljs-number">0</span>;</code></pre>
<p>很酷，对吗？如果你这样写了，那些看到这一行代码并尝试去理解 <code>i</code> 的值是什么的开发者们，就会有一个“快活的”的时光了。然后会来找你寻求答案。</p>
<p>告诉他短一点总是更好的。引导他进入忍者之路。</p>
<h2 id="一个字母的变量">一个字母的变量</h2>
<pre><code class="language-quote">道隐无名。夫唯道善贷且成。</code></pre>
<p>另一个缩减代码量的方法是，到处使用单字母的变量名。例如 <code>a</code>、<code>b</code> 或 <code>c</code>。</p>
<p>短变量就像森林中真正的忍者一样，一下就找不到了。没有人能够通过编辑器的“搜索”功能找到它。即使有人做到了，他也不能“破译”出变量名 <code>a</code> 或 <code>b</code> 到底是什么意思。</p>
<p>……但是有一个例外情况。一个真正的忍者绝不会在 <code>&quot;for&quot;</code> 循环中使用 <code>i</code> 作为计数器。在任何地方都可以，但是这里不会用。你随便一找，就能找到很多不寻常的字母。例如 <code>x</code> 或 <code>y</code>。</p>
<p>使用一个不寻常的变量多酷啊，尤其是在长达 1-2 页（如果可以的话，你可以写得更长）的循环体中使用的时候。如果某人要研究循环内部实现的时候，他就很难很快地找出变量 <code>x</code> 其实是循环计数器啦。</p>
<h2 id="使用缩写">使用缩写</h2>
<p>如果团队规则中禁止使用一个字母和模糊的命名 — 那就缩短命名，使用缩写吧。</p>
<p>像这样：</p>
<ul>
<li><code>list</code> -&gt; <code>lst</code></li>
<li><code>userAgent</code> -&gt; <code>ua</code></li>
<li><code>browser</code> -&gt; <code>brsr</code></li>
<li>……等</li>
</ul>
<p>只有具有真正良好直觉的人，才能够理解这样的命名。尽可能缩短一切。只有真正有价值的人，才能够维护这种代码的开发。</p>
<h2 id="soar-high，抽象化。">Soar high，抽象化。</h2>
<pre><code class="language-quote">大方无隅，&lt;br&gt;
大器晚成，&lt;br&gt;
大音希声，&lt;br&gt;
大象无形。</code></pre>
<p>当选择一个名字时，尽可能尝试使用最抽象的词语。例如 <code>obj</code>、<code>data</code>、<code>value</code>、<code>item</code> 和 <code>elem</code> 等。</p>
<ul>
<li><p><strong>一个变量的理想名称是 <code>data</code>。</strong> 在任何能用的地方都使用它。的确，每个变量都持有 <strong>数据（data）</strong>，对吧？</p>
<p>  ……但是 <code>data</code> 已经用过了怎么办？可以尝试一下 <code>value</code>，它也很普遍。毕竟，一个变量总会有一个 <strong>值（value）</strong>，对吧？</p>
</li>
<li><p><strong>根据变量的类型为变量命名：<code>str</code>、<code>num</code>……</strong></p>
<p>  尝试一下吧。新手可能会诧异 — 这些名字对于忍者来说真的有用吗？事实上，有用的！</p>
<p>  一方面，变量名仍然有着一些含义。它说明了变量内是什么：一个字符串、一个数字或是其他的东西。但是当一个局外人试图理解代码时，他会惊讶地发现实际上没有任何有效信息！最终就无法修改你精心思考过的代码。</p>
<p>  我们可以通过代码调试，很容易地看出值的类型。但是变量名的含义呢？它存了哪一个字符串或数字？</p>
<p>  如果思考的深度不够，是没有办法搞明白的。</p>
</li>
<li><p><strong>……但是如果找不到更多这样的名字呢？</strong> 可以加一个数字：<code>data1, item2, elem5</code>……</p>
</li>
</ul>
<h2 id="注意测试">注意测试</h2>
<p>只有一个真正细心的程序员才能理解你的代码。但是怎么检验呢？</p>
<p><strong>方式之一 —— 使用相似的变量名，像 <code>date</code> 和 <code>data</code>。</strong></p>
<p>尽你所能地将它们混合在一起。</p>
<p>想快速阅读这种代码是不可能的。并且如果有一个错别字时……额……我们卡在这儿好长时间了，到饭点了 (⊙v⊙)。</p>
<h2 id="智能同义词">智能同义词</h2>
<pre><code class="language-quote">最难的事情是在黑暗的房间里找到一只黑猫，尤其是如果没有猫。</code></pre>
<p>对 <strong>同一个</strong> 东西使用 <strong>类似</strong> 的命名，可以使生活更有趣，并且能够展现你的创造力。</p>
<p>例如，函数前缀。如果一个函数的功能是在屏幕上展示一个消息 — 名称可以以 <code>display…</code> 开头，例如 <code>displayMessage</code>。如果另一个函数展示别的东西，比如一个用户名，名称可以以 <code>show…</code> 开始（例如 <code>showName</code>）。</p>
<p>暗示这些函数之间有微妙的差异，实际上并没有。</p>
<p>与团队中的其他忍者们达成一个协议：如果张三在他的代码中以 <code>display...</code> 来开始一个“显示”函数，那么李四可以用 <code>render..</code>，王二可以使用 <code>paint...</code>。你可以发现代码变得多么地有趣多样呀。</p>
<p>……现在是帽子戏法！</p>
<p>对于有非常重要的差异的两个函数 — 使用相同的前缀。</p>
<p>例如，<code>printPage(page)</code> 函数会使用一个打印机（printer）。<code>printText(text)</code> 函数会将文字显示到屏幕上。让一个不熟悉的读者来思考一下：“名字为 <code>printMessage(message)</code> 的函数会将消息放到哪里呢？打印机还是屏幕上？”。为了让代码真正耀眼，<code>printMessage(message)</code> 应该将消息输出到新窗口中！</p>
<h2 id="重用名字">重用名字</h2>
<pre><code class="language-quote">始制有名，&lt;br&gt;
名亦既有，&lt;br&gt;
夫亦将知止，&lt;br&gt;
知止可以不殆。</code></pre>
<p>仅在绝对必要时才添加新变量。</p>
<p>否则，重用已经存在的名字。直接把新值写进变量即可。</p>
<p>在一个函数中，尝试仅使用作为参数传递的变量。</p>
<p>这样就很难确定这个变量的值现在是什么了。也不知道它是从哪里来的。目的是提高阅读代码的人的直觉和记忆力。一个直觉较弱的人必须逐行分析代码，跟踪每个代码分支中的更改。</p>
<p><strong>这个方法的一个进阶方案是，在循环或函数中偷偷地替换掉它的值。</strong></p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ninjaFunction</span>(<span class="hljs-params">elem</span>) </span>{
  <span class="hljs-comment">// 基于变量 elem 进行工作的 20 行代码</span>

  elem = clone(elem);

  <span class="hljs-comment">// 又 20 行代码，现在使用的是 clone 后的 elem 变量。</span>
}</code></pre>
<p>想要在后半部分中使用 <code>elem</code> 的程序员会感到很诧异……只有在调试期间，检查代码之后，他才会发现他正在使用克隆过的变量！</p>
<p>经常看到这样的代码，即使对经验丰富的忍者来说也是致命的。</p>
<h2 id="下划线的乐趣">下划线的乐趣</h2>
<p>在变量名前加上下划线 <code>_</code> 和 <code>__</code>。例如 <code>_name</code> 和 <code>__value</code>。如果只有你知道它们的含义，那就非常棒了。或者，加这些下划线只是为了好玩儿，没有任何含义，那就更棒了！</p>
<p>加下划线可谓是一箭双雕。首先，代码变得更长，可读性更低；并且，你的开发者小伙伴可能会花费很长时间，来弄清楚下划线是什么意思。</p>
<p>聪明的忍者会在代码的一个地方使用下划线，然后在其他地方刻意避免使用它们。这会使代码变得更加脆弱，并提高了代码未来出现错误的可能性。</p>
<h2 id="展示你的爱">展示你的爱</h2>
<p>向大家展现一下你那丰富的情感！像 <code>superElement</code>、<code>megaFrame</code> 和 <code>niceItem</code> 这样的名字一定会启发读者。</p>
<p>事实上，从一方面来说，看似写了一些东西：<code>super..</code>、<code>mega..</code>、<code>nice..</code>。但从另一方面来说 — 并没有提供任何细节。阅读代码的人可能需要耗费一到两个小时的带薪工作时间，冥思苦想来寻找一个隐藏的含义。</p>
<h2 id="重叠外部变量">重叠外部变量</h2>
<pre><code class="language-quote">处明者不见暗中一物，&lt;br&gt;
处暗者能见明中区事。</code></pre>
<p>对函数内部和外部的变量，使用相同的名称。很简单，不用费劲想新的名称。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> *!*user*/!* = authenticateUser();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> *!*user*/!* = anotherValue();
  ...
  ...许多行代码...
  ...
  ... <span class="hljs-comment">// &lt;-- 某个程序员想要在这里使用 user 变量……</span>
  ...
}</code></pre>
<p>在研究 <code>render</code> 内部代码的程序员可能不会注意到，有一个内部变量 <code>user</code> 屏蔽了外部的 <code>user</code> 变量。</p>
<p>然后他会假设 <code>user</code> 仍然是外部的变量然后使用它，<code>authenticateUser()</code> 的结果……陷阱出来啦！你好呀，调试器……</p>
<h2 id="无处不在的副作用！">无处不在的副作用！</h2>
<p>有些函数看起来它们不会改变任何东西。例如 <code>isReady()</code>，<code>checkPermission()</code>，<code>findTags()</code>……它们被假定用于执行计算、查找和返回数据，而不会更改任何它们自身之外的数据。这被称为“无副作用”。</p>
<p><strong>一个非常惊喜的技巧就是，除了主要任务之外，给它们添加一个“有用的”行为。</strong></p>
<p>当你的同事看到被命名为 <code>is..</code>、<code>check..</code> 或 <code>find...</code> 的函数改变了某些东西的时候，他脸上肯定是一脸懵逼的表情 — 这会扩大你的理性界限。</p>
<p><strong>另一个惊喜的方式是，返回非标准的结果。</strong></p>
<p>展示你原来的想法！让调用 <code>checkPermission</code> 时的返回值不是 <code>true/false</code>，而是一个包含检查结果的复杂对象。</p>
<p>那些尝试写 <code>if (checkPermission(..))</code> 的开发者，会很疑惑为什么它不能工作。告诉他们：“去读文档吧”。然后给出这篇文章。</p>
<h2 id="强大的函数！">强大的函数！</h2>
<pre><code class="language-quote">大道泛兮，&lt;br&gt;
其左可右。</code></pre>
<p>不要让函数受限于名字中写的内容。拓宽一些。</p>
<p>例如，函数 <code>validateEmail(email)</code> 可以（除了检查邮件的正确性之外）显示一个错误消息并要求重新输入邮件。</p>
<p>额外的行为在函数名称中不应该很明显。一个真正的忍者会使它们在代码中也不明显。</p>
<p><strong>将多个行为合并到一起，可以保护你的代码不被重用。</strong></p>
<p>想象一下，另一个开发者只想检查邮箱而不想输出任何信息。你的函数 <code>validateEmail(email)</code> 对他而言就不合适啦。所以他不会找你问关于这些函数的任何事而打断你的思考。</p>
<h2 id="总结">总结</h2>
<p>上面的所有“建议”都是从真实的代码中提炼而来的……有时候，这些代码是由有经验的开发者写的。也许比你更有经验 ;）</p>
<ul>
<li>遵从其中的一丢丢，你的代码就会变得充满惊喜。</li>
<li>遵从其中的一大部分，你的代码将真正成为你的代码，没有人会想改变它。</li>
<li>遵从所有，你的代码将成为寻求启发的年轻开发者的宝贵案例。</li>
</ul>

      </fieldset>
      
      <fieldset id='_aYXwDN'>
      <legend>solution</legend>
      <p>这些测试代码展示了开发人员在编写测试代码时遇到的一些疑惑。</p>
<p>我们这里实际上有三条测试，但是用了一个函数来放置 3 个断言语句。</p>
<p>有时用这种方式编写会更容易，但是如果发生错误，那么到底什么出错了就很不明显。</p>
<p>如果错误发生在一个复杂的执行流的中间，那么我们就必须找出那个点的数据。我们必须 <strong>调试测试</strong>。</p>
<p>将测试分成多个具有明确输入和输出的 <code>it</code> 代码块会更好。</p>
<p>像是这样：</p>
<pre><code class="language-js">describe(<span class="hljs-string">&quot;Raises x to power n&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  it(<span class="hljs-string">&quot;5 in the power of 1 equals 5&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    assert.equal(pow(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>), <span class="hljs-number">5</span>);
  });

  it(<span class="hljs-string">&quot;5 in the power of 2 equals 25&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    assert.equal(pow(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>), <span class="hljs-number">25</span>);
  });

  it(<span class="hljs-string">&quot;5 in the power of 3 equals 125&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    assert.equal(pow(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>), <span class="hljs-number">125</span>);
  });
});</code></pre>
<p>我们使用 <code>describe</code> 和一组 <code>it</code> 代码块替换掉了单个的 <code>it</code>。现在，如果某个测试失败了，我们可以清楚地看到数据是什么。</p>
<p>此外，我们可以通过编写 <code>it.only</code> 而不是 <code>it</code> 来隔离单个测试，并以独立模式运行它：</p>
<pre><code class="language-js">describe(<span class="hljs-string">&quot;Raises x to power n&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  it(<span class="hljs-string">&quot;5 in the power of 1 equals 5&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    assert.equal(pow(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>), <span class="hljs-number">5</span>);
  });

*!*
  <span class="hljs-comment">// Mocha 将只运行这个代码块</span>
  it.only(<span class="hljs-string">&quot;5 in the power of 2 equals 25&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    assert.equal(pow(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>), <span class="hljs-number">25</span>);
  });
*/!*

  it(<span class="hljs-string">&quot;5 in the power of 3 equals 125&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    assert.equal(pow(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>), <span class="hljs-number">125</span>);
  });
});</code></pre>

      </fieldset>
      
      <fieldset id='_RRQ6LK'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="测试代码中有什么错误？">测试代码中有什么错误？</h1>
<p>下面这个 <code>pow</code> 的测试代码有什么错误？</p>
<pre><code class="language-js">it(<span class="hljs-string">&quot;Raises x to the power n&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;

  <span class="hljs-keyword">let</span> result = x;
  assert.equal(pow(x, <span class="hljs-number">1</span>), result);

  result *= x;
  assert.equal(pow(x, <span class="hljs-number">2</span>), result);

  result *= x;
  assert.equal(pow(x, <span class="hljs-number">3</span>), result);
});</code></pre>
<p>附：从语法上来说这些测试代码是正确且通过的。</p>

      </fieldset>
      
      <fieldset id='_y3YFIN'>
      <legend>article</legend>
      <h1 id="使用-mocha-进行自动化测试">使用 Mocha 进行自动化测试</h1>
<p>自动化测试将被用于进一步的任务中，并且还将被广泛应用在实际项目中。</p>
<h2 id="为什么我们需要测试？">为什么我们需要测试？</h2>
<p>当我们在写一个函数时，我们通常可以想象出它应该做什么：哪些参数会给出哪些结果。</p>
<p>在开发期间，我们可以通过运行程序来检查它并将结果与预期进行比较。例如，我们可以在控制台中这么做。</p>
<p>如果出了问题 —— 那么我们会修复代码，然后再一次运行并检查结果 —— 直到它工作为止。</p>
<p>但这样的手动“重新运行”是不完美的。</p>
<p><strong>当通过手动重新运行来测试代码时，很容易漏掉一些东西。</strong></p>
<p>例如，我们要创建一个函数 <code>f</code>。写一些代码，然后测试：<code>f(1)</code> 可以执行，但是 <code>f(2)</code> 不执行。我们修复了一下代码，现在 <code>f(2)</code> 可以执行了。看起来已经搞定了？但是我们忘了重新测试 <code>f(1)</code>。这样有可能会导致出现错误。</p>
<p>这是非常典型的。当我们在开发一些东西时，我们会保留很多可能需要的用例。但是不要想着程序员在每一次代码修改后都去检查所有的案例。所以这就很容易造成修复了一个问题却造成另一个问题的情况。</p>
<p><strong>自动化测试意味着测试是独立于代码的。它们以各种方式运行我们的函数，并将结果与预期结果进行比较。</strong></p>
<h2 id="行为驱动开发（bdd）">行为驱动开发（BDD）</h2>
<p>我们来使用一种名为 <a href="http://en.wikipedia.org/wiki/Behavior-driven_development">行为驱动开发</a> 或简言为 BDD 的技术。</p>
<p><strong>BDD 包含了三部分内容：测试、文档和示例。</strong></p>
<p>为了理解 BDD，我们将研究一个实际的开发案例。</p>
<h2 id="开发-pow：规范">开发 “pow”：规范</h2>
<p>我们想要创建一个函数 <code>pow(x, n)</code> 来计算 <code>x</code> 的 <code>n</code> 次幂（<code>n</code> 为整数）。我们假设 <code>n≥0</code>。</p>
<p>这个任务只是一个例子：JavaScript 中有一个 <code>**</code> 运算符可以用于幂运算。但是在这里我们专注于可以应用于更复杂任务的开发流程上。</p>
<p>在创建函数 <code>pow</code> 的代码之前，我们可以想象函数应该做什么并且描述出来。</p>
<p>这样的描述被称作 <strong>规范（specification, spec）</strong>，包含用例的描述以及针对它们的测试，如下所示：</p>
<pre><code class="language-js">describe(<span class="hljs-string">&quot;pow&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{

  it(<span class="hljs-string">&quot;raises to n-th power&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    assert.equal(pow(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-number">8</span>);
  });

});</code></pre>
<p>正如你所看到的，一个规范包含三个主要的模块：</p>
<p><code>describe(&quot;title&quot;, function() { ... })</code>
: 表示我们正在描述的功能是什么。在我们的例子中我们正在描述函数 <code>pow</code>。用于组织“工人（workers）” —— <code>it</code> 代码块。</p>
<p><code>it(&quot;use case description&quot;, function() { ... })</code>
: <code>it</code> 里面的描述部分，我们以一种 <strong>易于理解</strong> 的方式描述特定的用例，第二个参数是用于对其进行测试的函数。</p>
<p><code>assert.equal(value1, value2)</code>
: <code>it</code> 块中的代码，如果实现是正确的，它应该在执行的时候不产生任何错误。</p>
<pre><code>`assert.*` 函数用于检查 `pow` 函数是否按照预期工作。在这里我们使用了其中之一 —— `assert.equal`，它会对参数进行比较，如果它们不相等则会抛出一个错误。这里它检查了 `pow(2, 3)` 的值是否等于 `8`。还有其他类型的比较和检查，我们将在后面介绍到。</code></pre>
<p>规范可以被执行，它将运行在 <code>it</code> 块中指定的测试。我们稍后会看到。</p>
<h2 id="开发流程">开发流程</h2>
<p>开发流程通常看起来像这样：</p>
<ol>
<li>编写初始规范，测试最基本的功能。</li>
<li>创建一个最初始的实现。</li>
<li>检查它是否工作，我们运行测试框架 <a href="http://mochajs.org/">Mocha</a>（很快会有更多细节）来运行测试。当功能未完成时，将显示错误。我们持续修正直到一切都能工作。</li>
<li>现在我们有一个带有测试的能工作的初步实现。</li>
<li>我们增加更多的用例到规范中，或许目前的程序实现还不支持。无法通过测试。</li>
<li>回到第 3 步，更新程序直到测试不会抛出错误。</li>
<li>重复第 3 步到第 6 步，直到功能完善。</li>
</ol>
<p>如此来看，开发就是不断地 <strong>迭代</strong>。我们写规范，实现它，确保测试通过，然后写更多的测试，确保它们工作等等。最后，我们有了一个能工作的实现和针对它的测试。</p>
<p>让我们在我们的开发案例中看看这个开发流程吧。</p>
<p>在我们的案例中，第一步已经完成了：我们有一个针对 <code>pow</code> 的初始规范。因此让我们来实现它吧。但在此之前，让我们用一些 JavaScript 库来运行测试，就是看看测试是通过了还是失败了。</p>
<h2 id="行为规范">行为规范</h2>
<p>在本教程中，我们将使用以下 JavaScript 库进行测试：</p>
<ul>
<li><a href="http://mochajs.org/">Mocha</a> —— 核心框架：提供了包括通用型测试函数 <code>describe</code> 和 <code>it</code>，以及用于运行测试的主函数。</li>
<li><a href="http://chaijs.com">Chai</a> —— 提供很多断言（assertion）支持的库。它提供了很多不同的断言，现在我们只需要用 <code>assert.equal</code>。</li>
<li><a href="http://sinonjs.org/">Sinon</a> —— 用于监视函数、模拟内置函数和其他函数的库，我们在后面才会用到它。</li>
</ul>
<p>这些库都既适用于浏览器端，也适用于服务器端。这里我们将使用浏览器端的变体。</p>
<p>包含这些框架和 <code>pow</code> 规范的完整的 HTML 页面：</p>
<pre><code class="language-html"></code></pre>
<p>该页面可分为五个部分：</p>
<ol>
<li><code>&lt;head&gt;</code> —— 添加用于测试的第三方库和样式文件。</li>
<li><code>&lt;script&gt;</code> 包含测试函数，在我们的例子中 —— 和 <code>pow</code> 相关的代码。</li>
<li>测试代码 —— 在我们的案例中是名为 <code>test.js</code> 的脚本，它包含上面 <code>describe(&quot;pow&quot;, ...)</code> 的那些代码。</li>
<li>HTML 元素 <code>&lt;div id=&quot;mocha&quot;&gt;</code> 将被 Mocha 用来输出结果。</li>
<li>可以使用 <code>mocha.run()</code> 命令来开始测试。</li>
</ol>
<p>结果：</p>
<p>[iframe height=250 src=&quot;pow-1&quot; border=1 edit]</p>
<p>到目前为止，测试失败了，出现了一个错误。这是合乎逻辑的：我们的 <code>pow</code> 是一个空函数，因此 <code>pow(2,3)</code> 返回了 <code>undefined</code> 而不是 <code>8</code>。</p>
<p>未来，我们会注意到有更高级的测试工具，像是 <a href="https://karma-runner.github.io/">karma</a> 或其他的，使自动运行许多不同的测试变得更容易。</p>
<h2 id="初始实现">初始实现</h2>
<p>为了可以通过测试，让我们写一个 <code>pow</code> 的简单实现：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pow</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-number">8</span>; <span class="hljs-comment">// :) 我们作弊啦！</span>
}</code></pre>
<p>哇哦，现在它可以工作了。</p>
<p>[iframe height=250 src=&quot;pow-min&quot; border=1 edit]</p>
<h2 id="改进规范">改进规范</h2>
<p>我们所做的这些绝对是作弊。函数是不起作用的：尝试计算 <code>pow(3,4)</code> 的话就会得到一个不正确的结果，但是测试却通过了。</p>
<p>……但是这种情况却是在实际中相当典型例子。测试通过了，但是函数却是错误的。我们的规范是不完善的。我们需要给它添加更多的测试用例。</p>
<p>这里我们又添加了一个测试来检查 <code>pow(3, 4) = 81</code>。</p>
<p>我们可以选择两种方式中的任意一种来组织测试代码：</p>
<ol>
<li><p>第一种 —— 在同一个 <code>it</code> 中再添加一个 <code>assert</code>：</p>
<pre><code class="language-js">describe(<span class="hljs-string">&quot;pow&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{

  it(<span class="hljs-string">&quot;raises to n-th power&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    assert.equal(pow(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-number">8</span>);
*!*
    assert.equal(pow(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>), <span class="hljs-number">81</span>);
*/!*
  });

});</code></pre>
</li>
<li><p>第二种 —— 写两个测试：</p>
<pre><code class="language-js">describe(<span class="hljs-string">&quot;pow&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{

  it(<span class="hljs-string">&quot;2 raised to power 3 is 8&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    assert.equal(pow(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-number">8</span>);
  });

  it(<span class="hljs-string">&quot;3 raised to power 4 is 81&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    assert.equal(pow(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>), <span class="hljs-number">81</span>);
  });

});</code></pre>
</li>
</ol>
<p>主要的区别是，当 <code>assert</code> 触发一个错误时，<code>it</code> 代码块会立即终止。因此，在第一种方式中，如果第一个 <code>assert</code> 失败了，我们将永远不会看到第二个 <code>assert</code> 的结果。</p>
<p>保持测试之间独立，有助于我们获知代码中正在发生什么，因此第二种方式更好一点。</p>
<p>除此之外，还有一个规范值得遵循。</p>
<p><strong>一个测试检查一个东西。</strong></p>
<p>如果我们在看测试代码的时候，发现在其中有两个相互独立的检查 —— 最好将它拆分成两个更简单的检查。</p>
<p>因此让我们继续使用第二种方式。</p>
<p>结果：</p>
<p>[iframe height=250 src=&quot;pow-2&quot; edit border=&quot;1&quot;]</p>
<p>正如我们可以想到的，第二条测试失败了。当然啦，我们的函数总会返回 <code>8</code>，而 <code>assert</code> 期望的是 <code>81</code>。</p>
<h2 id="改进实现">改进实现</h2>
<p>让我们写一些更加实际的代码来通过测试吧：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pow</span>(<span class="hljs-params">x, n</span>) </span>{
  <span class="hljs-keyword">let</span> result = <span class="hljs-number">1</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
    result *= x;
  }

  <span class="hljs-keyword">return</span> result;
}</code></pre>
<p>为了确保函数可以很好地工作，我们来使用更多值测试它吧。除了手动地编写 <code>it</code> 代码块，我们可以使用 <code>for</code> 循环来生成它们：</p>
<pre><code class="language-js">describe(<span class="hljs-string">&quot;pow&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeTest</span>(<span class="hljs-params">x</span>) </span>{
    <span class="hljs-keyword">let</span> expected = x * x * x;
    it(<span class="hljs-string">`<span class="hljs-subst">${x}</span> in the power 3 is <span class="hljs-subst">${expected}</span>`</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      assert.equal(pow(x, <span class="hljs-number">3</span>), expected);
    });
  }

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>; x &lt;= <span class="hljs-number">5</span>; x++) {
    makeTest(x);
  }

});</code></pre>
<p>结果：</p>
<p>[iframe height=250 src=&quot;pow-3&quot; edit border=&quot;1&quot;]</p>
<h2 id="嵌套描述">嵌套描述</h2>
<p>我们继续添加更多的测试。但在此之前，我们需要注意到辅助函数 <code>makeTest</code> 和 <code>for</code> 应该被组合到一起。我们在其他测试中不需要 <code>makeTest</code>，只有在 <code>for</code> 循环中需要它：它们共同的任务就是检查 <code>pow</code> 是如何自乘至给定的幂次方。</p>
<p>使用嵌套的 <code>describe</code> 来进行分组：</p>
<pre><code class="language-js">describe(<span class="hljs-string">&quot;pow&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{

*!*
  describe(<span class="hljs-string">&quot;raises x to power 3&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
*/!*

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeTest</span>(<span class="hljs-params">x</span>) </span>{
      <span class="hljs-keyword">let</span> expected = x * x * x;
      it(<span class="hljs-string">`<span class="hljs-subst">${x}</span> in the power 3 is <span class="hljs-subst">${expected}</span>`</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        assert.equal(pow(x, <span class="hljs-number">3</span>), expected);
      });
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>; x &lt;= <span class="hljs-number">5</span>; x++) {
      makeTest(x);
    }

*!*
  });
*/!*

  <span class="hljs-comment">// ……可以在这里写更多的测试代码，describe 和 it 都可以添加在这。</span>
});</code></pre>
<p>嵌套的 <code>describe</code> 定义了一个新的 &quot;subgroup&quot; 测试。在输出中我们可以看到带有标题的缩进：</p>
<p>[iframe height=250 src=&quot;pow-4&quot; edit border=&quot;1&quot;]</p>
<p>将来，我们可以在顶级域中使用 <code>it</code> 和 <code>describe</code> 的辅助函数添加更多的 <code>it</code> 和 <code>describe</code>，它们不会看到 <code>makeTest</code>。</p>
<p>````smart header=&quot;<code>before/after</code> 和 <code>beforeEach/afterEach</code>&quot;
我们可以设置 <code>before/after</code> 函数来在运行测试之前/之后执行。也可以使用 <code>beforeEach/afterEach</code> 函数来设置在执行 <strong>每一个</strong> <code>it</code> 之前/之后执行。</p>
<p>例如：</p>
<pre><code class="language-js">describe(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{

  before(<span class="hljs-function">() =&gt;</span> alert(<span class="hljs-string">&quot;Testing started – before all tests&quot;</span>));
  after(<span class="hljs-function">() =&gt;</span> alert(<span class="hljs-string">&quot;Testing finished – after all tests&quot;</span>));

  beforeEach(<span class="hljs-function">() =&gt;</span> alert(<span class="hljs-string">&quot;Before a test – enter a test&quot;</span>));
  afterEach(<span class="hljs-function">() =&gt;</span> alert(<span class="hljs-string">&quot;After a test – exit a test&quot;</span>));

  it(<span class="hljs-string">&#x27;test 1&#x27;</span>, <span class="hljs-function">() =&gt;</span> alert(<span class="hljs-number">1</span>));
  it(<span class="hljs-string">&#x27;test 2&#x27;</span>, <span class="hljs-function">() =&gt;</span> alert(<span class="hljs-number">2</span>));

});</code></pre>
<p>运行顺序将为：</p>
<pre><code>Testing started – before all tests (before)
Before a test – enter a test (beforeEach)
1
After a test – exit a test   (afterEach)
Before a test – enter a test (beforeEach)
2
After a test – exit a test   (afterEach)
Testing finished – after all tests (after)</code></pre>
<p>[edit src=&quot;beforeafter&quot; title=&quot;Open the example in the sandbox.&quot;]</p>
<p>通常，<code>beforeEach/afterEach</code> 和 <code>before/after</code> 被用于执行初始化，清零计数器或做一些介于每个测试（或测试组）之间的事情。</p>
<pre><code>
## 延伸规范

`pow` 的基础功能已经完成了。第一次迭代开发完成啦。当我们庆祝和喝完香槟之后，让我们继续改进它吧。

正如前面所说，函数 `pow(x, n)` 适用于正整数 `n`。

JavaScript 函数通常会返回 `NaN` 以表示一个数学错误。接下来我们对无效的 `n` 值执行相同的操作。

让我们首先将这个行为加到规范中(!)：

```js
describe(&quot;pow&quot;, function() {

  // ...

  it(&quot;for negative n the result is NaN&quot;, function() {
*!*
    assert.isNaN(pow(2, -1));
*/!*
  });

  it(&quot;for non-integer n the result is NaN&quot;, function() {
*!*
    assert.isNaN(pow(2, 1.5));    
*/!*
  });

});
```

新测试的结果：

[iframe height=530 src=&quot;pow-nan&quot; edit border=&quot;1&quot;]

新加的测试失败了，因为我们的实现方式是不支持它们的。这就是 BDD 的做法：我们首先写一些暂时无法通过的测试，然后去实现它们。

```smart header=&quot;Other assertions&quot;
请注意断言语句 `assert.isNaN`：它用来检查 `NaN`。

在 [Chai](http://chaijs.com) 中也有其他的断言，例如：

- `assert.equal(value1, value2)` —— 检查相等 `value1 == value2`。
- `assert.strictEqual(value1, value2)` —— 检查严格相等 `value1 === value2`。
- `assert.notEqual`，`assert.notStrictEqual` —— 执行和上面相反的检查。
- `assert.isTrue(value)` —— 检查 `value === true`。
- `assert.isFalse(value)` —— 检查 `value === false`。
- ……完整的列表请见 [docs](http://chaijs.com/api/assert/)
```

因此我们应该给 `pow` 再加几行：

```js
function pow(x, n) {
*!*
  if (n &lt; 0) return NaN;
  if (Math.round(n) != n) return NaN;
*/!*

  let result = 1;

  for (let i = 0; i &lt; n; i++) {
    result *= x;
  }

  return result;
}
```

现在它可以工作了，所有的测试也都通过了：

[iframe height=300 src=&quot;pow-full&quot; edit border=&quot;1&quot;]

[edit src=&quot;pow-full&quot; title=&quot;Open the full final example in the sandbox.&quot;]

## 总结

在 BDD 中，规范先行，实现在后。最后我们同时拥有了规范和代码。

规范有三种使用方式：

1. 作为 **测试** —— 保证代码正确工作。
2. 作为 **文档** —— `describe` 和 `it` 的标题告诉我们函数做了什么。
3. 作为 **案例** —— 测试实际工作的例子展示了一个函数可以被怎样使用。

有了规范，我们可以安全地改进、修改甚至重写函数，并确保它仍然正确地工作。

这在一个函数会被用在多个地方的大型项目中尤其重要。当我们改变这样一个函数时，没有办法手动检查每个使用它们的地方是否仍旧正确。

如果没有测试，一般有两个办法：

1. 展示修改，无论修改了什么。然后我们的用户遇到了 bug，这应该是我们没有手动完成某些检查。
2. 如果对出错的惩罚比较严重，并且没有测试，那么大家会很害怕修改这样的函数，然后这些代码就会越来越陈旧，没有人会想接触它。这很不利于发展。

**自动化测试则有助于避免这样的问题！**

如果这个项目被测试代码覆盖了，就不会出现这种问题。在任何修改之后，我们都可以运行测试，并在几秒钟内看到大量的检查。

**另外，一个经过良好测试的代码通常都有更好的架构。**

当然，这是因为覆盖了自动化测试的代码更容易修改和改进。但还有另一个原因。

要编写测试，代码的组织方式应确保每个函数都有一个清晰描述的任务、定义良好的输入和输出。这意味着从一开始就有一个好的架构。

在实际开发中有时候可能并不容易，有时很难在写实际代码之前编写规范，因为还不清楚它应该如何表现。但一般来说，编写测试使得开发更快更稳定。

在本教程的后面部分，你将遇到许多包含了测试的任务。所以你会看到更多的实际例子。

编写测试需要良好的 JavaScript 知识。但我们刚刚开始学习它。因此，为了解决所有问题，到目前为止，你不需要编写测试，但是你应该已经能够阅读测试了，即使它们比本章中的内容稍微复杂一些。</code></pre>

      </fieldset>
      
      <fieldset id='_hzL76F'>
      <legend>article</legend>
      <h1 id="polyfill">Polyfill</h1>
<p>JavaScript 语言在稳步发展。也会定期出现一些对语言的新提议，它们会被分析讨论，如果认为有价值，就会被加入到 <a href="https://tc39.github.io/ecma262/">https://tc39.github.io/ecma262/</a> 的列表中，然后被加到 <a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">规范</a> 中。</p>
<p>JavaScript 引擎背后的团队关于首先要实现什么有着他们自己想法。他们可能会决定执行草案中的建议，并推迟已经在规范中的内容，因为它们不太有趣或者难以实现。</p>
<p>因此，一个 JavaScript 引擎只能实现标准中的一部分是很常见的情况。</p>
<p>查看语言特性的当前支持状态的一个很好的页面是 <a href="https://kangax.github.io/compat-table/es6/">https://kangax.github.io/compat-table/es6/</a>（它很大，我们现在还有很多东西要学）。</p>
<h2 id="babel">Babel</h2>
<p>当我们使用语言的一些现代特性时，一些引擎可能无法支持这样的代码。正如上所述，并不是所有功能在任何地方都有实现。</p>
<p>这就是 Babel 来拯救的东西。</p>
<p><a href="https://babeljs.io">Babel</a> 是一个 <a href="https://en.wikipedia.org/wiki/Source-to-source_compiler">transpiler</a>。它将现代的 JavaScript 代码转化为以前的标准形式。</p>
<p>实际上，Babel 包含了两部分：</p>
<ol>
<li><p>第一，用于重写代码的 transpiler 程序。开发者在自己的电脑上运行它。它以之前的语言标准对代码进行重写。然后将代码传到面向用户的网站。像 <a href="http://webpack.github.io/">webpack</a> 这样的现代项目构建系统，提供了在每次代码改变时自动运行 transpiler 的方法，因此很容易集成在开发过程中。</p>
</li>
<li><p>第二，polyfill。</p>
<p> 新的语言特性可能包括新的内建函数和语法结构。
 transpiler 会重写代码，将语法结构转换为旧的结构。但是对于新的内建函数，需要我们去实现。JavaScript 是一个高度动态化的语言。脚本可以添加/修改任何函数，从而使它们的行为符合现代标准。</p>
<p> 更新/添加新函数的脚本称为 “polyfill”。它“填补”了缺口，并添加了缺少的实现。</p>
<p> 两个有意思的 polyfills 是：</p>
<ul>
<li><a href="https://github.com/zloirock/core-js">core js</a> 支持很多，允许只包含需要的功能。</li>
<li><a href="http://polyfill.io">polyfill.io</a> 根据功能和用户的浏览器，为脚本提供 polyfill 的服务。</li>
</ul>
</li>
</ol>
<p>所以，如果我们要使用现代语言功能，transpiler 和 polyfill 是必要的。</p>
<h2 id="教程中的案例">教程中的案例</h2>
<pre><code class="language-online">大多数例子都是可运行的，例如：

```js run
alert(&#x27;Press the &quot;Play&quot; button in the upper-right corner to run&#x27;);
```

只有在你的浏览器支持它时才会工作的现代 JS 例子。</code></pre>
<pre><code class="language-offline">当你正在阅读离线版本时，在 PDF 中，示例是不可运行的。在 EPUB 格式中，部分例子可以运行。</code></pre>
<p>Google Chrome 通常是对新语言特性支持更新最快的，在没有任何 transpiler 的情况下，也能很好地运行前沿的演示，当然其他的现代浏览器也挺好。</p>

      </fieldset>
      
      <fieldset id='_pGEHlw'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-keyword">let</span> user = {};
user.name = <span class="hljs-string">&quot;John&quot;</span>;
user.surname = <span class="hljs-string">&quot;Smith&quot;</span>;
user.name = <span class="hljs-string">&quot;Pete&quot;</span>;
<span class="hljs-keyword">delete</span> user.name;</code></pre>

      </fieldset>
      
      <fieldset id='_K4mOjB'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="你好，对象">你好，对象</h1>
<p>按下面的要求写代码，一条对应一行代码：</p>
<ol>
<li>创建一个空的对象 <code>user</code>。</li>
<li>为这个对象增加一个属性，键是 <code>name</code>，值是 <code>John</code>。</li>
<li>再增加一个属性，键是 <code>surname</code>，值是 <code>Smith</code>。</li>
<li>把键为 <code>name</code> 的属性的值改成 <code>Pete</code>。</li>
<li>删除这个对象中键为 <code>name</code> 的属性。</li>
</ol>

      </fieldset>
      
      <fieldset id='_KdxLcf'>
      <legend>solution</legend>
      <p>只需要遍历这个对象，如果对象存在任何属性则 <code>return false</code>。</p>

      </fieldset>
      
      <fieldset id='_k1GI7N'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="检查空对象">检查空对象</h1>
<p>写一个 <code>isEmpty(obj)</code> 函数，当对象没有属性的时候返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p>应该像这样：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> schedule = {};

alert( isEmpty(schedule) ); <span class="hljs-comment">// true</span>

schedule[<span class="hljs-string">&quot;8:30&quot;</span>] = <span class="hljs-string">&quot;get up&quot;</span>;

alert( isEmpty(schedule) ); <span class="hljs-comment">// false</span></code></pre>

      </fieldset>
      
      <fieldset id='_HJ3Rad'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-keyword">let</span> salaries = {
  <span class="hljs-attr">John</span>: <span class="hljs-number">100</span>,
  <span class="hljs-attr">Ann</span>: <span class="hljs-number">160</span>,
  <span class="hljs-attr">Pete</span>: <span class="hljs-number">130</span>
};

<span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> salaries) {
  sum += salaries[key];
}

alert(sum); <span class="hljs-comment">// 390</span></code></pre>

      </fieldset>
      
      <fieldset id='_RqXk8y'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="对象属性求和">对象属性求和</h1>
<p>我们有一个保存着团队成员工资的对象：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> salaries = {
  <span class="hljs-attr">John</span>: <span class="hljs-number">100</span>,
  <span class="hljs-attr">Ann</span>: <span class="hljs-number">160</span>,
  <span class="hljs-attr">Pete</span>: <span class="hljs-number">130</span>
}</code></pre>
<p>写一段代码求出我们的工资总和，将计算结果保存到变量 <code>sum</code>。从所给的信息来看，结果应该是 <code>390</code>。</p>
<p>如果 <code>salaries</code> 是一个空对象，那结果就为 <code>0</code>。</p>

      </fieldset>
      
      <fieldset id='_dY4HOn'>
      <legend>solution</legend>
      
      </fieldset>
      
      <fieldset id='_EcCHZE'>
      <legend>task</legend>
      <p>importance: 3</p>
<hr>
<h1 id="数值属性都乘以-2">数值属性都乘以 2</h1>
<p>创建一个 <code>multiplyNumeric(obj)</code> 函数，把 <code>obj</code> 所有的数值属性都乘以 <code>2</code>。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-comment">// 在调用之前</span>
<span class="hljs-keyword">let</span> menu = {
  <span class="hljs-attr">width</span>: <span class="hljs-number">200</span>,
  <span class="hljs-attr">height</span>: <span class="hljs-number">300</span>,
  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;My menu&quot;</span>
};

multiplyNumeric(menu);

<span class="hljs-comment">// 调用函数之后</span>
menu = {
  <span class="hljs-attr">width</span>: <span class="hljs-number">400</span>,
  <span class="hljs-attr">height</span>: <span class="hljs-number">600</span>,
  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;My menu&quot;</span>
};</code></pre>
<p>注意 <code>multiplyNumeric</code> 函数不需要返回任何值，它应该就地修改对象。</p>
<p>P.S. 用 <code>typeof</code> 检查值类型。</p>

      </fieldset>
      
      <fieldset id='_r1Gx5D'>
      <legend>article</legend>
      <h1 id="对象">对象</h1>
<p>正如我们在 <a href="info:types">info:types</a> 一章学到的，JavaScript 中有八种数据类型。有七种原始类型，因为它们的值只包含一种东西（字符串，数字或者其他）。</p>
<p>相反，对象则用来存储键值对和更复杂的实体。在 JavaScript 中，对象几乎渗透到了这门编程语言的方方面面。所以，在我们深入理解这门语言之前，必须先理解对象。</p>
<p>我们可以通过使用带有可选 <strong>属性列表</strong> 的花括号 <code>{…}</code> 来创建对象。一个属性就是一个键值对（&quot;key: value&quot;），其中键（<code>key</code>）是一个字符串（也叫做属性名），值（<code>value</code>）可以是任何值。</p>
<p>我们可以把对象想象成一个带有签名文件的文件柜。每一条数据都基于键（<code>key</code>）存储在文件中。这样我们就可以很容易根据文件名（也就是“键”）查找文件或添加/删除文件了。</p>
<p><img src="object.svg" alt=""></p>
<p>我们可以用下面两种语法中的任一种来创建一个空的对象（“空柜子”）：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(); <span class="hljs-comment">// “构造函数” 的语法</span>
<span class="hljs-keyword">let</span> user = {};  <span class="hljs-comment">// “字面量” 的语法</span></code></pre>
<p><img src="object-user-empty.svg" alt=""></p>
<p>通常，我们用花括号。这种方式我们叫做<strong>字面量</strong>。</p>
<h2 id="文本和属性">文本和属性</h2>
<p>我们可以在创建对象的时候，立即将一些属性以键值对的形式放到 <code>{...}</code> 中。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {     <span class="hljs-comment">// 一个对象</span>
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,  <span class="hljs-comment">// 键 &quot;name&quot;，值 &quot;John&quot;</span>
  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>        <span class="hljs-comment">// 键 &quot;age&quot;，值 30</span>
};</code></pre>
<p>属性有键（或者也可以叫做“名字”或“标识符”），位于冒号 <code>&quot;:&quot;</code> 的前面，值在冒号的右边。</p>
<p>在 <code>user</code> 对象中，有两个属性：</p>
<ol>
<li>第一个的键是 <code>&quot;name&quot;</code>，值是 <code>&quot;John&quot;</code>。</li>
<li>第二个的键是 <code>&quot;age&quot;</code>，值是 <code>30</code>。</li>
</ol>
<p>生成的 <code>user</code> 对象可以被想象为一个放置着两个标记有 &quot;name&quot; 和 &quot;age&quot; 的文件的柜子。</p>
<p><img src="object-user.svg" alt="user object"></p>
<p>我们可以随时添加、删除和读取文件。</p>
<p>可以使用点符号访问属性值：</p>
<pre><code class="language-js"><span class="hljs-comment">// 读取文件的属性：</span>
alert( user.name ); <span class="hljs-comment">// John</span>
alert( user.age ); <span class="hljs-comment">// 30</span></code></pre>
<p>属性的值可以是任意类型，让我们加个布尔类型：</p>
<pre><code class="language-js">user.isAdmin = <span class="hljs-literal">true</span>;</code></pre>
<p><img src="object-user-isadmin.svg" alt="user object 2"></p>
<p>我们可以用 <code>delete</code> 操作符移除属性：</p>
<pre><code class="language-js"><span class="hljs-keyword">delete</span> user.age;</code></pre>
<p><img src="object-user-delete.svg" alt="user object 3"></p>
<p>我们也可以用多字词语来作为属性名，但必须给它们加上引号：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,
  <span class="hljs-string">&quot;likes birds&quot;</span>: <span class="hljs-literal">true</span>  <span class="hljs-comment">// 多词属性名必须加引号</span>
};</code></pre>
<p><img src="object-user-props.svg" alt=""></p>
<p>列表中的最后一个属性应以逗号结尾：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>*!*,*/!*
}</code></pre>
<p>这叫做尾随（trailing）或悬挂（hanging）逗号。这样便于我们添加、删除和移动属性，因为所有的行都是相似的。</p>
<pre><code class="language-smart">请注意：用 `const` 声明的对象 **能** 被修改。

例如：

```js run
const user = {
  name: &quot;John&quot;
};

*!*
user.name = &quot;Pete&quot;; // (*)
*/!*

alert(user.name); // Pete
```

`(*)` 行似乎会触发一个错误，但实际并没有。`const` 声明仅固定了 `user` 的值，而不是值（该对象）里面的内容。

仅当我们尝试将 `user=...` 作为一个整体进行赋值时，`const` 会抛出错误。

有另一种将对象属性变为常量的方式，我们将在后面的 &lt;info:property-descriptors&gt; 一章中学习它。</code></pre>
<h2 id="方括号">方括号</h2>
<p>对于多词属性，点操作就不能用了：</p>
<pre><code class="language-js"><span class="hljs-comment">// 这将提示有语法错误</span>
user.likes birds = <span class="hljs-literal">true</span></code></pre>
<p>JavaScript 理解不了。它认为我们在处理 <code>user.likes</code>，然后在遇到意外的 <code>birds</code> 时给出了语法错误。</p>
<p>点符号要求 <code>key</code> 是有效的变量标识符。这意味着：不包含空格，不以数字开头，也不包含特殊字符（允许使用 <code>$</code> 和 <code>_</code>）。</p>
<p>有另一种方法，就是使用方括号，可用于任何字符串：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {};

<span class="hljs-comment">// 设置</span>
user[<span class="hljs-string">&quot;likes birds&quot;</span>] = <span class="hljs-literal">true</span>;

<span class="hljs-comment">// 读取</span>
alert(user[<span class="hljs-string">&quot;likes birds&quot;</span>]); <span class="hljs-comment">// true</span>

<span class="hljs-comment">// 删除</span>
<span class="hljs-keyword">delete</span> user[<span class="hljs-string">&quot;likes birds&quot;</span>];</code></pre>
<p>现在一切都可行了。请注意方括号中的字符串要放在引号中，单引号或双引号都可以。</p>
<p>方括号同样提供了一种可以通过任意表达式来获取属性名的方法 —— 跟语义上的字符串不同 —— 比如像类似于下面的变量：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> key = <span class="hljs-string">&quot;likes birds&quot;</span>;

<span class="hljs-comment">// 跟 user[&quot;likes birds&quot;] = true; 一样</span>
user[key] = <span class="hljs-literal">true</span>;</code></pre>
<p>在这里，变量 <code>key</code> 可以是程序运行时计算得到的，也可以是根据用户的输入得到的。然后我们可以用它来访问属性。这给了我们很大的灵活性。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>
};

<span class="hljs-keyword">let</span> key = prompt(<span class="hljs-string">&quot;What do you want to know about the user?&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>);

<span class="hljs-comment">// 访问变量</span>
alert( user[key] ); <span class="hljs-comment">// John（如果输入 &quot;name&quot;）</span></code></pre>
<p>点符号不能以类似的方式使用：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>
};

<span class="hljs-keyword">let</span> key = <span class="hljs-string">&quot;name&quot;</span>;
alert( user.key ) <span class="hljs-comment">// undefined</span></code></pre>
<h3 id="计算属性">计算属性</h3>
<p>当创建一个对象时，我们可以在对象字面量中使用方括号。这叫做 <strong>计算属性</strong>。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> fruit = prompt(<span class="hljs-string">&quot;Which fruit to buy?&quot;</span>, <span class="hljs-string">&quot;apple&quot;</span>);

<span class="hljs-keyword">let</span> bag = {
*!*
  [fruit]: <span class="hljs-number">5</span>, <span class="hljs-comment">// 属性名是从 fruit 变量中得到的</span>
*/!*
};

alert( bag.apple ); <span class="hljs-comment">// 5 如果 fruit=&quot;apple&quot;</span></code></pre>
<p>计算属性的含义很简单：<code>[fruit]</code> 含义是属性名应该从 <code>fruit</code> 变量中获取。</p>
<p>所以，如果一个用户输入 <code>&quot;apple&quot;</code>，<code>bag</code> 将变为 <code>{apple: 5}</code>。</p>
<p>本质上，这跟下面的语法效果相同：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> fruit = prompt(<span class="hljs-string">&quot;Which fruit to buy?&quot;</span>, <span class="hljs-string">&quot;apple&quot;</span>);
<span class="hljs-keyword">let</span> bag = {};

<span class="hljs-comment">// 从 fruit 变量中获取值</span>
bag[fruit] = <span class="hljs-number">5</span>;</code></pre>
<p>……但是看起来更好。</p>
<p>我们可以在方括号中使用更复杂的表达式：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> fruit = <span class="hljs-string">&#x27;apple&#x27;</span>;
<span class="hljs-keyword">let</span> bag = {
  [fruit + <span class="hljs-string">&#x27;Computers&#x27;</span>]: <span class="hljs-number">5</span> <span class="hljs-comment">// bag.appleComputers = 5</span>
};</code></pre>
<p>方括号比点符号更强大。它允许任何属性名和变量，但写起来也更加麻烦。</p>
<p>所以，大部分时间里，当属性名是已知且简单的时候，就使用点符号。如果我们需要一些更复杂的内容，那么就用方括号。</p>
<h2 id="属性值简写">属性值简写</h2>
<p>在实际开发中，我们通常用已存在的变量当做属性名。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeUser</span>(<span class="hljs-params">name, age</span>) </span>{
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">name</span>: name,
    <span class="hljs-attr">age</span>: age,
    <span class="hljs-comment">// ……其他的属性</span>
  };
}

<span class="hljs-keyword">let</span> user = makeUser(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-number">30</span>);
alert(user.name); <span class="hljs-comment">// John</span></code></pre>
<p>在上面的例子中，属性名跟变量名一样。这种通过变量生成属性的应用场景很常见，在这有一种特殊的 <strong>属性值缩写</strong> 方法，使属性名变得更短。</p>
<p>可以用 <code>name</code> 来代替 <code>name:name</code> 像下面那样：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeUser</span>(<span class="hljs-params">name, age</span>) </span>{
*!*
  <span class="hljs-keyword">return</span> {
    name, <span class="hljs-comment">// 与 name: name 相同</span>
    age,  <span class="hljs-comment">// 与 age: age 相同</span>
    <span class="hljs-comment">// ...</span>
  };
*/!*
}</code></pre>
<p>我们可以把属性名简写方式和正常方式混用：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  name,  <span class="hljs-comment">// 与 name:name 相同</span>
  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>
};</code></pre>
<h2 id="属性名称限制">属性名称限制</h2>
<p>我们已经知道，变量名不能是编程语言的某个保留字，如 &quot;for&quot;、&quot;let&quot;、&quot;return&quot; 等……</p>
<p>但对象的属性名并不受此限制：</p>
<pre><code class="language-js"><span class="hljs-comment">// 这些属性都没问题</span>
<span class="hljs-keyword">let</span> obj = {
  <span class="hljs-attr">for</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">let</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">return</span>: <span class="hljs-number">3</span>
};

alert( obj.for + obj.let + obj.return );  <span class="hljs-comment">// 6</span></code></pre>
<p>简而言之，属性命名没有限制。属性名可以是任何字符串或者 symbol（一种特殊的标志符类型，将在后面介绍）。</p>
<p>其他类型会被自动地转换为字符串。</p>
<p>例如，当数字 <code>0</code> 被用作对象的属性的键时，会被转换为字符串 <code>&quot;0&quot;</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> obj = {
  <span class="hljs-number">0</span>: <span class="hljs-string">&quot;test&quot;</span> <span class="hljs-comment">// 等同于 &quot;0&quot;: &quot;test&quot;</span>
};

<span class="hljs-comment">// 都会输出相同的属性（数字 0 被转为字符串 &quot;0&quot;）</span>
alert( obj[<span class="hljs-string">&quot;0&quot;</span>] ); <span class="hljs-comment">// test</span>
alert( obj[<span class="hljs-number">0</span>] ); <span class="hljs-comment">// test (相同的属性)</span></code></pre>
<p>这里有个小陷阱：一个名为 <code>__proto__</code> 的属性。我们不能将它设置为一个非对象的值：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> obj = {};
obj.__proto__ = <span class="hljs-number">5</span>; <span class="hljs-comment">// 分配一个数字</span>
alert(obj.__proto__); <span class="hljs-comment">// [object Object] — 值为对象，与预期结果不同</span></code></pre>
<p>我们从代码中可以看出来，把它赋值为 <code>5</code> 的操作被忽略了。</p>
<p>我们将在 <a href="info:prototype-inheritance">后续章节</a> 中学习 <code>__proto__</code> 的特殊性质，并给出了 <a href="info:prototype-methods">解决此问题的方法</a>。</p>
<h2 id="属性存在性测试，in-操作符">属性存在性测试，&quot;in&quot; 操作符</h2>
<p>相比于其他语言，JavaScript 的对象有一个需要注意的特性：能够被访问任何属性。即使属性不存在也不会报错！</p>
<p>读取不存在的属性只会得到 <code>undefined</code>。所以我们可以很容易地判断一个属性是否存在：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {};

alert( user.noSuchProperty === <span class="hljs-literal">undefined</span> ); <span class="hljs-comment">// true 意思是没有这个属性</span></code></pre>
<p>这里还有一个特别的，检查属性是否存在的操作符 <code>&quot;in&quot;</code>。</p>
<p>语法是：</p>
<pre><code class="language-js"><span class="hljs-string">&quot;key&quot;</span> <span class="hljs-keyword">in</span> object</code></pre>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> };

alert( <span class="hljs-string">&quot;age&quot;</span> <span class="hljs-keyword">in</span> user ); <span class="hljs-comment">// true，user.age 存在</span>
alert( <span class="hljs-string">&quot;blabla&quot;</span> <span class="hljs-keyword">in</span> user ); <span class="hljs-comment">// false，user.blabla 不存在。</span></code></pre>
<p>请注意，<code>in</code> 的左边必须是 <strong>属性名</strong>。通常是一个带引号的字符串。</p>
<p>如果我们省略引号，就意味着左边是一个变量，它应该包含要判断的实际属性名。例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = { <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> };

<span class="hljs-keyword">let</span> key = <span class="hljs-string">&quot;age&quot;</span>;
alert( *!*key*<span class="hljs-regexp">/!* in user ); /</span><span class="hljs-regexp">/ true，属性 &quot;age&quot; 存在</span></code></pre>
<p>为何会有 <code>in</code> 运算符呢？与 <code>undefined</code> 进行比较来判断还不够吗？</p>
<p>确实，大部分情况下与 <code>undefined</code> 进行比较来判断就可以了。但有一个例外情况，这种比对方式会有问题，但 <code>in</code> 运算符的判断结果仍是对的。</p>
<p>那就是属性存在，但存储的值是 <code>undefined</code> 的时候：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> obj = {
  <span class="hljs-attr">test</span>: <span class="hljs-literal">undefined</span>
};

alert( obj.test ); <span class="hljs-comment">// 显示 undefined，所以属性不存在？</span>

alert( <span class="hljs-string">&quot;test&quot;</span> <span class="hljs-keyword">in</span> obj ); <span class="hljs-comment">// true，属性存在！</span></code></pre>
<p>在上面的代码中，属性 <code>obj.test</code> 事实上是存在的，所以 <code>in</code> 操作符检查通过。</p>
<p>这种情况很少发生，因为通常情况下不应该给对象赋值 <code>undefined</code>。我们通常会用 <code>null</code> 来表示未知的或者空的值。因此，<code>in</code> 运算符是代码中的特殊来宾。</p>
<h2 id="forin-循环">&quot;for..in&quot; 循环</h2>
<p>为了遍历一个对象的所有键（key），可以使用一个特殊形式的循环：<code>for..in</code>。这跟我们在前面学到的 <code>for(;;)</code> 循环是完全不一样的东西。</p>
<p>语法：</p>
<pre><code class="language-js"><span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> object) {
  <span class="hljs-comment">// 对此对象属性中的每个键执行的代码</span>
}</code></pre>
<p>例如，让我们列出 <code>user</code> 所有的属性：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,
  <span class="hljs-attr">isAdmin</span>: <span class="hljs-literal">true</span>
};

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> user) {
  <span class="hljs-comment">// keys</span>
  alert( key );  <span class="hljs-comment">// name, age, isAdmin</span>
  <span class="hljs-comment">// 属性键的值</span>
  alert( user[key] ); <span class="hljs-comment">// John, 30, true</span>
}</code></pre>
<p>注意，所有的 &quot;for&quot; 结构体都允许我们在循环中定义变量，像这里的 <code>let key</code>。</p>
<p>同样，我们可以用其他属性名来替代 <code>key</code>。例如 <code>&quot;for(let prop in obj)&quot;</code> 也很常用。</p>
<h3 id="像对象一样排序">像对象一样排序</h3>
<p>对象有顺序吗？换句话说，如果我们遍历一个对象，我们获取属性的顺序是和属性添加时的顺序相同吗？这靠谱吗？</p>
<p>简短的回答是：“有特别的顺序”：整数属性会被进行排序，其他属性则按照创建的顺序显示。详情如下：</p>
<p>例如，让我们考虑一个带有电话号码的对象：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> codes = {
  <span class="hljs-string">&quot;49&quot;</span>: <span class="hljs-string">&quot;Germany&quot;</span>,
  <span class="hljs-string">&quot;41&quot;</span>: <span class="hljs-string">&quot;Switzerland&quot;</span>,
  <span class="hljs-string">&quot;44&quot;</span>: <span class="hljs-string">&quot;Great Britain&quot;</span>,
  <span class="hljs-comment">// ..,</span>
  <span class="hljs-string">&quot;1&quot;</span>: <span class="hljs-string">&quot;USA&quot;</span>
};

*!*
<span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> code <span class="hljs-keyword">in</span> codes</span>)</span> {
  alert(code); <span class="hljs-comment">// 1, 41, 44, 49</span>
}
*/!*</code></pre>
<p>对象可用于面向用户的建议选项列表。如果我们的网站主要面向德国观众，那么我们可能希望 <code>49</code> 排在第一。</p>
<p>但如果我们执行代码，会看到完全不同的现象：</p>
<ul>
<li>USA (1) 排在了最前面</li>
<li>然后是 Switzerland (41) 及其它。</li>
</ul>
<p>因为这些电话号码是整数，所以它们以升序排列。所以我们看到的是 <code>1, 41, 44, 49</code>。</p>
<pre><code class="language-smart">这里的“整数属性”指的是一个可以在不做任何更改的情况下与一个整数进行相互转换的字符串。

所以，&quot;49&quot; 是一个整数属性名，因为我们把它转换成整数，再转换回来，它还是一样的。但是 &quot;+49&quot; 和 &quot;1.2&quot; 就不行了：

```js run
// Math.trunc 是内置的去除小数部分的方法。
alert( String(Math.trunc(Number(&quot;49&quot;))) ); // &quot;49&quot;，相同，整数属性
alert( String(Math.trunc(Number(&quot;+49&quot;))) ); // &quot;49&quot;，不同于 &quot;+49&quot; ⇒ 不是整数属性
alert( String(Math.trunc(Number(&quot;1.2&quot;))) ); // &quot;1&quot;，不同于 &quot;1.2&quot; ⇒ 不是整数属性
```</code></pre>
<p>……此外，如果属性名不是整数，那它们就按照创建时的顺序来排序，例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">surname</span>: <span class="hljs-string">&quot;Smith&quot;</span>
};
user.age = <span class="hljs-number">25</span>; <span class="hljs-comment">// 增加一个</span>

*!*
<span class="hljs-comment">// 非整数属性是按照创建的顺序来排列的</span>
*/!*
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> prop <span class="hljs-keyword">in</span> user) {
  alert( prop ); <span class="hljs-comment">// name, surname, age</span>
}</code></pre>
<p>所以，为了解决电话号码的问题，我们可以使用非整数属性名来 <strong>欺骗</strong> 程序。只需要给每个键名加一个加号 <code>&quot;+&quot;</code> 前缀就行了。</p>
<p>像这样：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> codes = {
  <span class="hljs-string">&quot;+49&quot;</span>: <span class="hljs-string">&quot;Germany&quot;</span>,
  <span class="hljs-string">&quot;+41&quot;</span>: <span class="hljs-string">&quot;Switzerland&quot;</span>,
  <span class="hljs-string">&quot;+44&quot;</span>: <span class="hljs-string">&quot;Great Britain&quot;</span>,
  <span class="hljs-comment">// ..,</span>
  <span class="hljs-string">&quot;+1&quot;</span>: <span class="hljs-string">&quot;USA&quot;</span>
};

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> code <span class="hljs-keyword">in</span> codes) {
  alert( +code ); <span class="hljs-comment">// 49, 41, 44, 1</span>
}</code></pre>
<p>现在跟预想的一样了。</p>
<h2 id="总结">总结</h2>
<p>对象是具有一些特殊特性的关联数组。</p>
<p>它们存储属性（键值对），其中：</p>
<ul>
<li>属性的键必须是字符串或者 symbol（通常是字符串）。</li>
<li>值可以是任何类型。</li>
</ul>
<p>我们可以用下面的方法访问属性：</p>
<ul>
<li>点符号: <code>obj.property</code>。</li>
<li>方括号 <code>obj[&quot;property&quot;]</code>，方括号允许从变量中获取键，例如 <code>obj[varWithKey]</code>。</li>
</ul>
<p>其他操作：</p>
<ul>
<li>删除属性：<code>delete obj.prop</code>。</li>
<li>检查是否存在给定键的属性：<code>&quot;key&quot; in obj</code>。</li>
<li>遍历对象：<code>for(let key in obj)</code> 循环。</li>
</ul>
<p>我们在这一章学习的叫做“普通对象（plain object）”，或者就叫对象。</p>
<p>JavaScript 中还有很多其他类型的对象：</p>
<ul>
<li><code>Array</code> 用于存储有序数据集合，</li>
<li><code>Date</code> 用于存储时间日期，</li>
<li><code>Error</code> 用于存储错误信息。</li>
<li>……等等。</li>
</ul>
<p>它们有着各自特别的特性，我们将在后面学习到。有时候大家会说“Array 类型”或“Date 类型”，但其实它们并不是自身所属的类型，而是属于一个对象类型即 &quot;object&quot;。它们以不同的方式对 &quot;object&quot; 做了一些扩展。</p>
<p>JavaScript 中的对象非常强大。这里我们只接触了其冰山一角。在后面的章节中，我们将频繁使用对象进行编程，并学习更多关于对象的知识。</p>

      </fieldset>
      
      <fieldset id='_a1k3KR'>
      <legend>article</legend>
      <h1 id="对象拷贝，引用">对象拷贝，引用</h1>
<p>对象与原始类型其中一个基本的区别是：对象“通过引用的形式”被存储和拷贝。</p>
<p>原始类型值：字符串，数字，布尔值 —— 被“作为整体”赋值/拷贝。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> message = <span class="hljs-string">&quot;Hello!&quot;</span>;
<span class="hljs-keyword">let</span> phrase = message;</code></pre>
<p>结果我们就有了两个独立的变量，每个都存储着字符串 <code>&quot;Hello!&quot;</code>。</p>
<p><img src="variable-copy-value.svg" alt=""></p>
<p>对象不是这样的。</p>
<p><strong>变量存储的不是对象自身，而是该对象的“内存地址”，换句话说就是一个对该对象的“引用”。</strong></p>
<p>下面是这个对象的示意图：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>
};</code></pre>
<p><img src="variable-contains-reference.svg" alt=""></p>
<p>这里，该对象被存储在内存中的某处。而变量 <code>user</code> 保存的是对此处的“引用”。</p>
<p><strong>当一个对象变量被拷贝 —— 引用则被拷贝，而该对象并没有被复制。</strong></p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> };

<span class="hljs-keyword">let</span> admin = user; <span class="hljs-comment">// 拷贝引用</span></code></pre>
<p>现在我们有了两个变量，它们保存的都是对同一个对象的引用：</p>
<p><img src="variable-copy-reference.svg" alt=""></p>
<p>我们可以用任何变量来访问该对象并修改它的内容：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = { <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> };

<span class="hljs-keyword">let</span> admin = user;

*!*
admin.name = <span class="hljs-string">&#x27;Pete&#x27;</span>; <span class="hljs-comment">// 通过 &quot;admin&quot; 引用来修改</span>
*/!*

alert(*!*user.name*<span class="hljs-regexp">/!*); /</span><span class="hljs-regexp">/ &#x27;Pete&#x27;，修改能通过 &quot;user&quot; 引用看到</span></code></pre>
<p>上面的例子说明这里只有一个对象。就像我们有个带两把钥匙的锁柜，并使用其中一把钥匙（<code>admin</code>）来打开它。那么，我们如果之后用另外一把钥匙（<code>user</code>），就也能看到所作的改变。</p>
<h2 id="通过引用来比较">通过引用来比较</h2>
<p>对于对象来说，普通相等 <code>==</code> 和严格相等 <code>===</code> 是两个作用结果完全一样的运算符。</p>
<p><strong>仅当两个对象为同一对象时，两者才相等。</strong></p>
<p>这里两个变量都引用同一个对象，所以它们相等：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> a = {};
<span class="hljs-keyword">let</span> b = a; <span class="hljs-comment">// 拷贝引用</span>

alert( a == b ); <span class="hljs-comment">// true，都引用同一对象</span>
alert( a === b ); <span class="hljs-comment">// true</span></code></pre>
<p>而这里两个独立的对象则并不相等，即使它们都为空：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> a = {};
<span class="hljs-keyword">let</span> b = {}; <span class="hljs-comment">// 两个独立的对象</span>

alert( a == b ); <span class="hljs-comment">// false</span></code></pre>
<p>对于类似 <code>obj1 &gt; obj2</code> 的比较，或者跟一个原始类型值的比较 <code>obj == 5</code>，对象都会被转换为原始值。我们很快就会学到对象是如何转换的，但是说实话，类似的比较很少出现，通常是在编程错误的时候才会出现这种情况。</p>
<h2 id="克隆与合并，objectassign">克隆与合并，Object.assign</h2>
<p>那么，拷贝一个对象变量会又创建一个对相同对象的引用。</p>
<p>但是，如果我们想要复制一个对象，那该怎么做呢？创建一个独立的拷贝，克隆？</p>
<p>这也是可行的，但稍微有点困难，因为 JavaScript 没有提供对此操作的内建的方法。实际上，也很少需要这样做。通过引用进行拷贝在大多数情况下已经很好了。</p>
<p>但是，如果我们真的想要这样做，那么就需要创建一个新对象，并通过遍历现有属性的结构，在原始类型值的层面，将其复制到新对象，以复制已有对象的结构。</p>
<p>就像这样：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>
};

*!*
<span class="hljs-keyword">let</span> clone = {}; <span class="hljs-comment">// 新的空对象</span>

<span class="hljs-comment">// 将 user 中所有的属性拷贝到其中</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> user) {
  clone[key] = user[key];
}
*/!*

<span class="hljs-comment">// 现在 clone 是带有相同内容的完全独立的对象</span>
clone.name = <span class="hljs-string">&quot;Pete&quot;</span>; <span class="hljs-comment">// 改变了其中的数据</span>

alert( user.name ); <span class="hljs-comment">// 原来的对象中的 name 属性依然是 John</span></code></pre>
<p>我们也可以使用 <a href="mdn:js/Object/assign">Object.assign</a> 方法来达成同样的效果。</p>
<p>语法是：</p>
<pre><code class="language-js"><span class="hljs-built_in">Object</span>.assign(dest, [src1, src2, src3...])</code></pre>
<ul>
<li>第一个参数 <code>dest</code> 是指目标对象。</li>
<li>更后面的参数 <code>src1, ..., srcN</code>（可按需传递多个参数）是源对象。</li>
<li>该方法将所有源对象的属性拷贝到目标对象 <code>dest</code> 中。换句话说，从第二个开始的所有参数的属性都被拷贝到第一个参数的对象中。</li>
<li>调用结果返回 <code>dest</code>。</li>
</ul>
<p>例如，我们可以用它来合并多个对象：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> };

<span class="hljs-keyword">let</span> permissions1 = { <span class="hljs-attr">canView</span>: <span class="hljs-literal">true</span> };
<span class="hljs-keyword">let</span> permissions2 = { <span class="hljs-attr">canEdit</span>: <span class="hljs-literal">true</span> };

*!*
<span class="hljs-comment">// 将 permissions1 和 permissions2 中的所有属性都拷贝到 user 中</span>
<span class="hljs-built_in">Object</span>.assign(user, permissions1, permissions2);
*/!*

<span class="hljs-comment">// 现在 user = { name: &quot;John&quot;, canView: true, canEdit: true }</span></code></pre>
<p>如果被拷贝的属性的属性名已经存在，那么它会被覆盖：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> };

<span class="hljs-built_in">Object</span>.assign(user, { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Pete&quot;</span> });

alert(user.name); <span class="hljs-comment">// 现在 user = { name: &quot;Pete&quot; }</span></code></pre>
<p>我们也可以用 <code>Object.assign</code> 代替 <code>for..in</code> 循环来进行简单克隆：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>
};

*!*
<span class="hljs-keyword">let</span> clone = <span class="hljs-built_in">Object</span>.assign({}, user);
*/!*</code></pre>
<p>它将 <code>user</code> 中的所有属性拷贝到了一个空对象中，并返回这个新的对象。</p>
<h2 id="深层克隆">深层克隆</h2>
<p>到现在为止，我们都假设 <code>user</code> 的所有属性均为原始类型。但属性可以是对其他对象的引用。那应该怎样处理它们呢？</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">sizes</span>: {
    <span class="hljs-attr">height</span>: <span class="hljs-number">182</span>,
    <span class="hljs-attr">width</span>: <span class="hljs-number">50</span>
  }
};

alert( user.sizes.height ); <span class="hljs-comment">// 182</span></code></pre>
<p>现在这样拷贝 <code>clone.sizes = user.sizes</code> 已经不足够了，因为 <code>user.sizes</code> 是个对象，它会以引用形式被拷贝。因此 <code>clone</code> 和 <code>user</code> 会共用一个 sizes：</p>
<p>就像这样：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">sizes</span>: {
    <span class="hljs-attr">height</span>: <span class="hljs-number">182</span>,
    <span class="hljs-attr">width</span>: <span class="hljs-number">50</span>
  }
};

<span class="hljs-keyword">let</span> clone = <span class="hljs-built_in">Object</span>.assign({}, user);

alert( user.sizes === clone.sizes ); <span class="hljs-comment">// true，同一个对象</span>

<span class="hljs-comment">// user 和 clone 分享同一个 sizes</span>
user.sizes.width++;       <span class="hljs-comment">// 通过其中一个改变属性值</span>
alert(clone.sizes.width); <span class="hljs-comment">// 51，能从另外一个看到变更的结果</span></code></pre>
<p>为了解决此问题，我们应该使用会检查每个 <code>user[key]</code> 的值的克隆循环，如果值是一个对象，那么也要复制它的结构。这就叫“深拷贝”。</p>
<p>这里有一个标准的深拷贝算法，它不仅能处理上面的例子，还能应对更多复杂的情况，它被称为 <a href="https://html.spec.whatwg.org/multipage/structured-data.html#safe-passing-of-structured-data">结构化拷贝算法</a>。</p>
<p>我们可以用递归来实现。或者不自己造轮子，使用现成的实现，例如 JavaScript 库 <a href="https://lodash.com">lodash</a> 中的 <a href="https://lodash.com/docs#cloneDeep">_.cloneDeep(obj)</a>。</p>
<h2 id="总结">总结</h2>
<p>对象通过引用被赋值和拷贝。换句话说，一个变量存储的不是“对象的值”，而是一个对值的“引用”（内存地址）。因此，拷贝此类变量或将其作为函数参数传递时，所拷贝的是引用，而不是对象本身。</p>
<p>所有通过被拷贝的引用的操作（如添加、删除属性）都作用在同一个对象上。</p>
<p>为了创建“真正的拷贝”（一个克隆），我们可以使用 <code>Object.assign</code> 来做所谓的“浅拷贝”（嵌套对象被通过引用进行拷贝）或者使用“深拷贝”函数，例如 <a href="https://lodash.com/docs#cloneDeep">_.cloneDeep(obj)</a>。</p>

      </fieldset>
      
      <fieldset id='_ajvNsw'>
      <legend>article</legend>
      <h1 id="垃圾回收">垃圾回收</h1>
<p>对于开发者来说，JavaScript 的内存管理是自动的、无形的。我们创建的原始值、对象、函数……这一切都会占用内存。</p>
<p>当我们不再需要某个东西时会发生什么？JavaScript 引擎如何发现它并清理它？</p>
<h2 id="可达性（reachability）">可达性（Reachability）</h2>
<p>JavaScript 中主要的内存管理概念是 <strong>可达性</strong>。</p>
<p>简而言之，“可达”值是那些以某种方式可访问或可用的值。它们一定是存储在内存中的。</p>
<ol>
<li><p>这里列出固有的可达值的基本集合，这些值明显不能被释放。</p>
<p> 比方说：</p>
<ul>
<li><p>当前函数的局部变量和参数。</p>
</li>
<li><p>嵌套调用时，当前调用链上所有函数的变量与参数。</p>
</li>
<li><p>全局变量。</p>
</li>
<li><p>（还有一些内部的）</p>
<p>这些值被称作 <strong>根（roots）</strong>。</p>
</li>
</ul>
</li>
<li><p>如果一个值可以通过引用或引用链从根访问任何其他值，则认为该值是可达的。</p>
<p> 比方说，如果全局变量中有一个对象，并且该对象有一个属性引用了另一个对象，则该对象被认为是可达的。而且它引用的内容也是可达的。下面是详细的例子。</p>
</li>
</ol>
<p>在 JavaScript 引擎中有一个被称作 <a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">垃圾回收器</a> 的东西在后台执行。它监控着所有对象的状态，并删除掉那些已经不可达的。</p>
<h2 id="一个简单的例子">一个简单的例子</h2>
<p>这里是一个最简单的例子：</p>
<pre><code class="language-js"><span class="hljs-comment">// user 具有对这个对象的引用</span>
<span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>
};</code></pre>
<p><img src="memory-user-john.svg" alt=""></p>
<p>这里的箭头描述了一个对象引用。全局变量 <code>&quot;user&quot;</code> 引用了对象 <code>{name：&quot;John&quot;}</code>（为简洁起见，我们称它为 John）。John 的 <code>&quot;name&quot;</code> 属性存储一个原始值，所以它被写在对象内部。</p>
<p>如果 <code>user</code> 的值被重写了，这个引用就没了：</p>
<pre><code class="language-js">user = <span class="hljs-literal">null</span>;</code></pre>
<p><img src="memory-user-john-lost.svg" alt=""></p>
<p>现在 John 变成不可达的了。因为没有引用了，就不能访问到它了。垃圾回收器会认为它是垃圾数据并进行回收，然后释放内存。</p>
<h2 id="两个引用">两个引用</h2>
<p>现在让我们想象下，我们把 <code>user</code> 的引用复制给 <code>admin</code>：</p>
<pre><code class="language-js"><span class="hljs-comment">// user 具有对这个对象的引用</span>
<span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>
};

*!*
<span class="hljs-keyword">let</span> admin = user;
*/!*</code></pre>
<p><img src="memory-user-john-admin.svg" alt=""></p>
<p>现在如果执行刚刚的那个操作：</p>
<pre><code class="language-js">user = <span class="hljs-literal">null</span>;</code></pre>
<p>……然后对象仍然可以被通过 <code>admin</code> 这个全局变量访问到，所以对象还在内存中。如果我们又重写了 <code>admin</code>，对象就会被删除。</p>
<h2 id="相互关联的对象">相互关联的对象</h2>
<p>现在来看一个更复杂的例子。这是个家庭：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">marry</span>(<span class="hljs-params">man, woman</span>) </span>{
  woman.husband = man;
  man.wife = woman;

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">father</span>: man,
    <span class="hljs-attr">mother</span>: woman
  }
}

<span class="hljs-keyword">let</span> family = marry({
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>
}, {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Ann&quot;</span>
});</code></pre>
<p><code>marry</code> 函数通过让两个对象相互引用使它们“结婚”了，并返回了一个包含这两个对象的新对象。</p>
<p>由此产生的内存结构：</p>
<p><img src="family.svg" alt=""></p>
<p>到目前为止，所有对象都是可达的。</p>
<p>现在让我们移除两个引用：</p>
<pre><code class="language-js"><span class="hljs-keyword">delete</span> family.father;
<span class="hljs-keyword">delete</span> family.mother.husband;</code></pre>
<p><img src="family-delete-refs.svg" alt=""></p>
<p>仅删除这两个引用中的一个是不够的，因为所有的对象仍然都是可达的。</p>
<p>但是，如果我们把这两个都删除，那么我们可以看到再也没有对 John 的引用了：</p>
<p><img src="family-no-father.svg" alt=""></p>
<p>对外引用不重要，只有传入引用才可以使对象可达。所以，John 现在是不可达的，并且将被从内存中删除，同时 John 的所有数据也将变得不可达。</p>
<p>经过垃圾回收：</p>
<p><img src="family-no-father-2.svg" alt=""></p>
<h2 id="无法到达的岛屿">无法到达的岛屿</h2>
<p>几个对象相互引用，但外部没有对其任意对象的引用，这些对象也可能是不可达的，并被从内存中删除。</p>
<p>源对象与上面相同。然后：</p>
<pre><code class="language-js">family = <span class="hljs-literal">null</span>;</code></pre>
<p>内存内部状态将变成：</p>
<p><img src="family-no-family.svg" alt=""></p>
<p>这个例子展示了可达性概念的重要性。</p>
<p>显而易见，John 和 Ann 仍然连着，都有传入的引用。但是，这样还不够。</p>
<p>前面说的 <code>&quot;family&quot;</code> 对象已经不再与根相连，没有了外部对其的引用，所以它变成了一座“孤岛”，并且将被从内存中删除。</p>
<h2 id="内部算法">内部算法</h2>
<p>垃圾回收的基本算法被称为 &quot;mark-and-sweep&quot;。</p>
<p>定期执行以下“垃圾回收”步骤：</p>
<ul>
<li>垃圾收集器找到所有的根，并“标记”（记住）它们。</li>
<li>然后它遍历并“标记”来自它们的所有引用。</li>
<li>然后它遍历标记的对象并标记 <strong>它们的</strong> 引用。所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象。</li>
<li>……如此操作，直到所有可达的（从根部）引用都被访问到。</li>
<li>没有被标记的对象都会被删除。</li>
</ul>
<p>例如，使我们的对象有如下的结构：</p>
<p><img src="garbage-collection-1.svg" alt=""></p>
<p>我们可以清楚地看到右侧有一个“无法到达的岛屿”。现在我们来看看“标记和清除”垃圾收集器如何处理它。</p>
<p>第一步标记所有的根：</p>
<p><img src="garbage-collection-2.svg" alt=""></p>
<p>然后它们的引用被标记了：</p>
<p><img src="garbage-collection-3.svg" alt=""></p>
<p>……如果还有引用的话，继续标记：</p>
<p><img src="garbage-collection-4.svg" alt=""></p>
<p>现在，无法通过这个过程访问到的对象被认为是不可达的，并且会被删除。</p>
<p><img src="garbage-collection-5.svg" alt=""></p>
<p>我们还可以将这个过程想象成从根溢出一个巨大的油漆桶，它流经所有引用并标记所有可到达的对象。然后移除未标记的。</p>
<p>这是垃圾收集工作的概念。JavaScript 引擎做了许多优化，使垃圾回收运行速度更快，并且不影响正常代码运行。</p>
<p>一些优化建议：</p>
<ul>
<li><strong>分代收集（Generational collection）</strong>—— 对象被分成两组：“新的”和“旧的”。许多对象出现，完成它们的工作并很快死去，它们可以很快被清理。那些长期存活的对象会变得“老旧”，而且被检查的频次也会减少。</li>
<li><strong>增量收集（Incremental collection）</strong>—— 如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟。所以引擎试图将垃圾收集工作分成几部分来做。然后将这几部分会逐一进行处理。这需要它们之间有额外的标记来追踪变化，但是这样会有许多微小的延迟而不是一个大的延迟。</li>
<li><strong>闲时收集（Idle-time collection）</strong>—— 垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。</li>
</ul>
<p>还有其他垃圾回收算法的优化和风格。尽管我想在这里描述它们，但我必须打住了，因为不同的引擎会有不同的调整和技巧。而且，更重要的是，随着引擎的发展，情况会发生变化，所以在没有真实需求的时候，“提前”学习这些内容是不值得的。当然，除非这是一个纯粹的利益关系。我在下面给你提供了一些相关链接。</p>
<h2 id="总结">总结</h2>
<p>主要需要掌握的内容：</p>
<ul>
<li>垃圾回收是自动完成的，我们不能强制执行或是阻止执行。</li>
<li>当对象是可达状态时，它一定是存在于内存中的。</li>
<li>被引用与可访问（从一个根）不同：一组相互连接的对象可能整体都不可达。</li>
</ul>
<p>现代引擎实现了垃圾回收的高级算法。</p>
<p>《The Garbage Collection Handbook: The Art of Automatic Memory Management》（R. Jones 等人著）这本书涵盖了其中一些内容。</p>
<p>如果你熟悉底层（low-level）编程，关于 V8 引擎垃圾回收器的更详细信息请参阅文章 <a href="http://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection">V8 之旅：垃圾回收</a>。</p>
<p><a href="http://v8project.blogspot.com/">V8 博客</a> 还不时发布关于内存管理变化的文章。当然，为了学习垃圾收集，你最好通过学习 V8 引擎内部知识来进行准备，并阅读一个名为 <a href="http://mrale.ph">Vyacheslav Egorov</a> 的 V8 引擎工程师的博客。我之所以说 “V8”，因为网上关于它的文章最丰富的。对于其他引擎，许多方法是相似的，但在垃圾收集上许多方面有所不同。</p>
<p>当你需要底层的优化时，对引擎有深入了解将很有帮助。在熟悉了这门编程语言之后，把熟悉引擎作为下一步计划是明智之选。</p>

      </fieldset>
      
      <fieldset id='_tSZvgG'>
      <legend>solution</legend>
      <p><strong>答案：一个错误。</strong></p>
<p>试一下：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeUser</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
    <span class="hljs-attr">ref</span>: <span class="hljs-built_in">this</span>
  };
};

<span class="hljs-keyword">let</span> user = makeUser();

alert( user.ref.name ); <span class="hljs-comment">// Error: Cannot read property &#x27;name&#x27; of undefined</span></code></pre>
<p>这是因为设置 <code>this</code> 的规则不考虑对象定义。只有调用那一刻才重要。</p>
<p>这里 <code>makeUser()</code> 中的 <code>this</code> 的值是 <code>undefined</code>，因为它是被作为函数调用的，而不是通过点符号被作为方法调用。</p>
<p><code>this</code> 的值是对于整个函数的，代码段和对象字面量对它都没有影响。</p>
<p>所以 <code>ref: this</code> 实际上取的是当前函数的 <code>this</code>。</p>
<p>我们可以重写这个函数，并返回和上面相同的值为 <code>undefined</code> 的 <code>this</code>：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeUser</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>; <span class="hljs-comment">// 这次这里没有对象字面量</span>
}

alert( makeUser().name ); <span class="hljs-comment">// Error: Cannot read property &#x27;name&#x27; of undefined</span></code></pre>
<p>我们可以看到 <code>alert( makeUser().name )</code> 的结果和前面那个例子中 <code>alert( user.ref.name )</code> 的结果相同。</p>
<p>这里有个反例：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeUser</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
*!*
    <span class="hljs-function"><span class="hljs-title">ref</span>(<span class="hljs-params"></span>)</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
    }
*/!*
  };
};

<span class="hljs-keyword">let</span> user = makeUser();

alert( user.ref().name ); <span class="hljs-comment">// John</span></code></pre>
<p>现在正常了，因为 <code>user.ref()</code> 是一个方法。<code>this</code> 的值为点符号 <code>.</code> 前的这个对象。</p>

      </fieldset>
      
      <fieldset id='_UxN7CQ'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="在对象字面量中使用-this">在对象字面量中使用 &quot;this&quot;</h1>
<p>这里 <code>makeUser</code> 函数返回了一个对象。</p>
<p>访问 <code>ref</code> 的结果是什么？为什么？</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeUser</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
    <span class="hljs-attr">ref</span>: <span class="hljs-built_in">this</span>
  };
};

<span class="hljs-keyword">let</span> user = makeUser();

alert( user.ref.name ); <span class="hljs-comment">// 结果是什么？</span></code></pre>

      </fieldset>
      
      <fieldset id='_vji5Ac'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-keyword">let</span> calculator = {
  <span class="hljs-function"><span class="hljs-title">sum</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.a + <span class="hljs-built_in">this</span>.b;
  },

  <span class="hljs-function"><span class="hljs-title">mul</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.a * <span class="hljs-built_in">this</span>.b;
  },

  <span class="hljs-function"><span class="hljs-title">read</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-built_in">this</span>.a = +prompt(<span class="hljs-string">&#x27;a?&#x27;</span>, <span class="hljs-number">0</span>);
    <span class="hljs-built_in">this</span>.b = +prompt(<span class="hljs-string">&#x27;b?&#x27;</span>, <span class="hljs-number">0</span>);
  }
};

calculator.read();
alert( calculator.sum() );
alert( calculator.mul() );</code></pre>

      </fieldset>
      
      <fieldset id='_SMgbSX'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="创建一个计算器">创建一个计算器</h1>
<p>创建一个有三个方法的 <code>calculator</code> 对象：</p>
<ul>
<li><code>read()</code> 提示输入两个值，并将其保存为对象属性。</li>
<li><code>sum()</code> 返回保存的值的和。</li>
<li><code>mul()</code> 将保存的值相乘并返回计算结果。</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">let</span> calculator = {
  <span class="hljs-comment">// ……你的代码……</span>
};

calculator.read();
alert( calculator.sum() );
alert( calculator.mul() );</code></pre>
<p>[demo]</p>

      </fieldset>
      
      <fieldset id='_OcuYzc'>
      <legend>solution</legend>
      <p>解决方案就是在每次调用后返回这个对象本身。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> ladder = {
  <span class="hljs-attr">step</span>: <span class="hljs-number">0</span>,
  <span class="hljs-function"><span class="hljs-title">up</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-built_in">this</span>.step++;
*!*
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
*/!*
  },
  <span class="hljs-function"><span class="hljs-title">down</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-built_in">this</span>.step--;
*!*
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
*/!*
  },
  <span class="hljs-function"><span class="hljs-title">showStep</span>(<span class="hljs-params"></span>)</span> {
    alert( <span class="hljs-built_in">this</span>.step );
*!*
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
*/!*
  }
}

ladder.up().up().down().up().down().showStep(); <span class="hljs-comment">// 1</span></code></pre>
<p>我们也可以每行一个调用。对于长链接它更具可读性：</p>
<pre><code class="language-js">ladder
  .up()
  .up()
  .down()
  .up()
  .down()
  .showStep(); <span class="hljs-comment">// 1</span></code></pre>

      </fieldset>
      
      <fieldset id='_RaHq67'>
      <legend>task</legend>
      <p>importance: 2</p>
<hr>
<h1 id="链式（调用）">链式（调用）</h1>
<p>有一个可以上下移动的 <code>ladder</code> 对象：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> ladder = {
  <span class="hljs-attr">step</span>: <span class="hljs-number">0</span>,
  <span class="hljs-function"><span class="hljs-title">up</span>(<span class="hljs-params"></span>)</span> { 
    <span class="hljs-built_in">this</span>.step++;
  },
  <span class="hljs-function"><span class="hljs-title">down</span>(<span class="hljs-params"></span>)</span> { 
    <span class="hljs-built_in">this</span>.step--;
  },
  <span class="hljs-attr">showStep</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// 显示当前的 step</span>
    alert( <span class="hljs-built_in">this</span>.step );
  }
};</code></pre>
<p>现在，如果我们要按顺序执行几次调用，可以这样做：</p>
<pre><code class="language-js">ladder.up();
ladder.up();
ladder.down();
ladder.showStep(); <span class="hljs-comment">// 1</span></code></pre>
<p>修改 <code>up</code>，<code>down</code> 和 <code>showStep</code> 的代码，让调用可以链接，就像这样：</p>
<pre><code class="language-js">ladder.up().up().down().showStep(); <span class="hljs-comment">// 1</span></code></pre>
<p>这种方法在 JavaScript 库中被广泛使用。</p>

      </fieldset>
      
      <fieldset id='_W901dW'>
      <legend>article</legend>
      <h1 id="对象方法，this">对象方法，&quot;this&quot;</h1>
<p>通常创建对象来表示真实世界中的实体，如用户和订单等：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>
};</code></pre>
<p>并且，在现实世界中，用户可以进行 <strong>操作</strong>：从购物车中挑选某物、登录和注销等。</p>
<p>在 JavaScript 中，行为（action）由属性中的函数来表示。</p>
<h2 id="方法示例">方法示例</h2>
<p>刚开始，我们来教 <code>user</code> 说 hello：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>
};

*!*
user.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-string">&quot;Hello!&quot;</span>);
};
*/!*

user.sayHi(); <span class="hljs-comment">// Hello!</span></code></pre>
<p>这里我们使用函数表达式创建了一个函数，并将其指定给对象的 <code>user.sayHi</code> 属性。</p>
<p>随后我们调用它。用户现在可以说话了！</p>
<p>作为对象属性的函数被称为 <strong>方法</strong>。</p>
<p>所以，在这我们得到了 <code>user</code> 对象的 <code>sayHi</code> 方法。</p>
<p>当然，我们也可以使用预先声明的函数作为方法，就像这样：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-comment">// ...</span>
};

*!*
<span class="hljs-comment">// 首先，声明函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-string">&quot;Hello!&quot;</span>);
};

<span class="hljs-comment">// 然后将其作为一个方法添加</span>
user.sayHi = sayHi;
*/!*

user.sayHi(); <span class="hljs-comment">// Hello!</span></code></pre>
<pre><code class="language-smart">当我们在代码中用对象表示实体时，就是所谓的 [面向对象编程](https://en.wikipedia.org/wiki/Object-oriented_programming)，简称为 &quot;OOP&quot;。

OOP 是一门大学问，本身就是一门有趣的科学。怎样选择合适的实体？如何组织它们之间的交互？这就是架构，有很多关于这方面的书，例如 E. Gamma、R. Helm、R. Johnson 和 J. Vissides 所著的《设计模式：可复用面向对象软件的基础》，G. Booch 所著的《面向对象分析与设计》等。</code></pre>
<h3 id="方法简写">方法简写</h3>
<p>在对象字面量中，有一种更短的（声明）方法的语法：</p>
<pre><code class="language-js"><span class="hljs-comment">// 这些对象作用一样</span>

user = {
  <span class="hljs-attr">sayHi</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    alert(<span class="hljs-string">&quot;Hello&quot;</span>);
  }
};

<span class="hljs-comment">// 方法简写看起来更好，对吧？</span>
<span class="hljs-keyword">let</span> user = {
*!*
  <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-comment">// 与 &quot;sayHi: function()&quot; 一样</span>
*/!*
    alert(<span class="hljs-string">&quot;Hello&quot;</span>);
  }
};</code></pre>
<p>如上所示，我们可以省略 <code>&quot;function&quot;</code>，只写 <code>sayHi()</code>。</p>
<p>说实话，这种表示法还是有些不同。在对象继承方面有一些细微的差别（稍后将会介绍），但目前它们并不重要。在几乎所有的情况下，较短的语法是首选的。</p>
<h2 id="方法中的-this">方法中的 &quot;this&quot;</h2>
<p>通常，对象方法需要访问对象中存储的信息才能完成其工作。</p>
<p>例如，<code>user.sayHi()</code> 中的代码可能需要用到 <code>user</code> 的 name 属性。</p>
<p><strong>为了访问该对象，方法中可以使用 <code>this</code> 关键字。</strong></p>
<p><code>this</code> 的值就是在点之前的这个对象，即调用该方法的对象。</p>
<p>举个例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,

  <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> {
*!*
    <span class="hljs-comment">// &quot;this&quot; 指的是“当前的对象”</span>
    alert(<span class="hljs-built_in">this</span>.name);
*/!*
  }

};

user.sayHi(); <span class="hljs-comment">// John</span></code></pre>
<p>在这里 <code>user.sayHi()</code> 执行过程中，<code>this</code> 的值是 <code>user</code>。</p>
<p>技术上讲，也可以在不使用 <code>this</code> 的情况下，通过外部变量名来引用它：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,

  <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> {
*!*
    alert(user.name); <span class="hljs-comment">// &quot;user&quot; 替代 &quot;this&quot;</span>
*/!*
  }

};</code></pre>
<p>……但这样的代码是不可靠的。如果我们决定将 <code>user</code> 复制给另一个变量，例如 <code>admin = user</code>，并赋另外的值给 <code>user</code>，那么它将访问到错误的对象。</p>
<p>下面这个示例证实了这一点：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,

  <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> {
*!*
    alert( user.name ); <span class="hljs-comment">// 导致错误</span>
*/!*
  }

};


<span class="hljs-keyword">let</span> admin = user;
user = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 重写让其更明显</span>

admin.sayHi(); <span class="hljs-comment">// 噢哟！在 sayHi() 使用了旧的 name 属性！报错！</span></code></pre>
<p>如果我们在 <code>alert</code> 中以 <code>this.name</code> 替换 <code>user.name</code>，那么代码就会正常运行。</p>
<h2 id="this-不受限制">&quot;this&quot; 不受限制</h2>
<p>在 JavaScript 中，<code>this</code> 关键字与其他大多数编程语言中的不同。JavaScript 中的 <code>this</code> 可以用于任何函数。</p>
<p>下面这样的代码没有语法错误：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>{
  alert( *!*<span class="hljs-built_in">this</span>*/!*.name );
}</code></pre>
<p><code>this</code> 的值是在代码运行时计算出来的，它取决于代码上下文。</p>
<p>例如，这里相同的函数被分配给两个不同的对象，在调用中有着不同的 &quot;this&quot; 值：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> };
<span class="hljs-keyword">let</span> admin = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Admin&quot;</span> };

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>{
  alert( <span class="hljs-built_in">this</span>.name );
}

*!*
<span class="hljs-comment">// 在两个对象中使用相同的函数</span>
user.f = sayHi;
admin.f = sayHi;
*/!*

<span class="hljs-comment">// 这两个调用有不同的 this 值</span>
<span class="hljs-comment">// 函数内部的 &quot;this&quot; 是“点符号前面”的那个对象</span>
user.f(); <span class="hljs-comment">// John（this == user）</span>
admin.f(); <span class="hljs-comment">// Admin（this == admin）</span>

admin[<span class="hljs-string">&#x27;f&#x27;</span>](); <span class="hljs-comment">// Admin（使用点符号或方括号语法来访问这个方法，都没有关系。）</span></code></pre>
<p>这个规则很简单：如果 <code>obj.f()</code> 被调用了，则 <code>this</code> 在 <code>f</code> 函数调用期间是 <code>obj</code>。所以在上面的例子中 this 先是 <code>user</code>，之后是 <code>admin</code>。</p>
<p>````smart header=&quot;在没有对象的情况下调用：<code>this == undefined</code>&quot;
我们甚至可以在没有对象的情况下调用函数：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-built_in">this</span>);
}

sayHi(); <span class="hljs-comment">// undefined</span></code></pre>
<p>在这种情况下，严格模式下的 <code>this</code> 值为 <code>undefined</code>。如果我们尝试访问 <code>this.name</code>，将会报错。</p>
<p>在非严格模式的情况下，<code>this</code> 将会是 <strong>全局对象</strong>（浏览器中的 <code>window</code>，我们稍后会在 <a href="info:global-object"></a> 一章中学习它）。这是一个历史行为，<code>&quot;use strict&quot;</code> 已经将其修复了。</p>
<p>通常这种调用是程序出错了。如果在一个函数内部有 <code>this</code>，那么通常意味着它是在对象上下文环境中被调用的。</p>
<pre><code>
```smart header=&quot;解除 `this` 绑定的后果&quot;
如果你经常使用其他的编程语言，那么你可能已经习惯了“绑定 `this`”的概念，即在对象中定义的方法总是有指向该对象的 `this`。

在 JavaScript 中，`this` 是“自由”的，它的值是在调用时计算出来的，它的值并不取决于方法声明的位置，而是取决于在“点符号前”的是什么对象。

在运行时对 `this` 求值的这个概念既有优点也有缺点。一方面，函数可以被重用于不同的对象。另一方面，更大的灵活性造成了更大的出错的可能。

这里我们的立场并不是要评判编程语言的这个设计是好是坏。而是要了解怎样使用它，如何趋利避害。
```

## 箭头函数没有自己的 &quot;this&quot;

箭头函数有些特别：它们没有自己的 `this`。如果我们在这样的函数中引用 `this`，`this` 值取决于外部“正常的”函数。

举个例子，这里的 `arrow()` 使用的 `this` 来自于外部的 `user.sayHi()` 方法：

```js run
let user = {
  firstName: &quot;Ilya&quot;,
  sayHi() {
    let arrow = () =&gt; alert(this.firstName);
    arrow();
  }
};

user.sayHi(); // Ilya
```

这是箭头函数的一个特性，当我们并不想要一个独立的 `this`，反而想从外部上下文中获取时，它很有用。在后面的 &lt;info:arrow-functions&gt; 一章中，我们将深入介绍箭头函数。


## 总结

- 存储在对象属性中的函数被称为“方法”。
- 方法允许对象进行像 `object.doSomething()` 这样的“操作”。
- 方法可以将对象引用为 `this`。

`this` 的值是在程序运行时得到的。
- 一个函数在声明时，可能就使用了 `this`，但是这个 `this` 只有在函数被调用时才会有值。
- 可以在对象之间复制函数。
- 以“方法”的语法调用函数时：`object.method()`，调用过程中的 `this` 值是 `object`。

请注意箭头函数有些特别：它们没有 `this`。在箭头函数内部访问到的 `this` 都是从外部获取的。</code></pre>

      </fieldset>
      
      <fieldset id='_p6Ra1E'>
      <legend>solution</legend>
      <p>是的，这是可以的。</p>
<p>如果一个函数返回一个对象，那么 <code>new</code> 返回那个对象而不是 <code>this</code>。</p>
<p>所以它们可以，例如，返回相同的外部定义的对象 <code>obj</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> obj = {};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> obj; }
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> obj; }

alert( <span class="hljs-keyword">new</span> A() == <span class="hljs-keyword">new</span> B() ); <span class="hljs-comment">// true</span></code></pre>

      </fieldset>
      
      <fieldset id='_3foPdB'>
      <legend>task</legend>
      <p>importance: 2</p>
<hr>
<h1 id="两个函数--一个对象">两个函数 — 一个对象</h1>
<p>是否可以创建像 <code>new A()==new B()</code> 这样的函数 <code>A</code> 和 <code>B</code>？</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>{ ... }
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span>(<span class="hljs-params"></span>) </span>{ ... }

<span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> A;
<span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> B;

alert( a == b ); <span class="hljs-comment">// true</span></code></pre>
<p>如果可以，请提供一个它们的代码示例。</p>

      </fieldset>
      
      <fieldset id='_FvWKXn'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Calculator</span>(<span class="hljs-params"></span>) </span>{

  <span class="hljs-built_in">this</span>.read = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">this</span>.a = +prompt(<span class="hljs-string">&#x27;a?&#x27;</span>, <span class="hljs-number">0</span>);
    <span class="hljs-built_in">this</span>.b = +prompt(<span class="hljs-string">&#x27;b?&#x27;</span>, <span class="hljs-number">0</span>);
  };

  <span class="hljs-built_in">this</span>.sum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.a + <span class="hljs-built_in">this</span>.b;
  };

  <span class="hljs-built_in">this</span>.mul = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.a * <span class="hljs-built_in">this</span>.b;
  };
}

<span class="hljs-keyword">let</span> calculator = <span class="hljs-keyword">new</span> Calculator();
calculator.read();

alert( <span class="hljs-string">&quot;Sum=&quot;</span> + calculator.sum() );
alert( <span class="hljs-string">&quot;Mul=&quot;</span> + calculator.mul() );</code></pre>

      </fieldset>
      
      <fieldset id='_KECRzy'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="创建-new-calculator">创建 new Calculator</h1>
<p>创建一个构造函数 <code>Calculator</code>，它创建的对象中有三个方法：</p>
<ul>
<li><code>read()</code> 使用 <code>prompt</code> 请求两个值并把它们记录在对象的属性中。</li>
<li><code>sum()</code> 返回这些属性的总和。</li>
<li><code>mul()</code> 返回这些属性的乘积。</li>
</ul>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> calculator = <span class="hljs-keyword">new</span> Calculator();
calculator.read();

alert( <span class="hljs-string">&quot;Sum=&quot;</span> + calculator.sum() );
alert( <span class="hljs-string">&quot;Mul=&quot;</span> + calculator.mul() );</code></pre>
<p>[demo]</p>

      </fieldset>
      
      <fieldset id='_s3bB3M'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Accumulator</span>(<span class="hljs-params">startingValue</span>) </span>{
  <span class="hljs-built_in">this</span>.value = startingValue;

  <span class="hljs-built_in">this</span>.read = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">this</span>.value += +prompt(<span class="hljs-string">&#x27;How much to add?&#x27;</span>, <span class="hljs-number">0</span>);
  };

}

<span class="hljs-keyword">let</span> accumulator = <span class="hljs-keyword">new</span> Accumulator(<span class="hljs-number">1</span>);
accumulator.read();
accumulator.read();
alert(accumulator.value);</code></pre>

      </fieldset>
      
      <fieldset id='_oueHyL'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="创建-new-accumulator">创建 new Accumulator</h1>
<p>创建一个构造函数 <code>Accumulator(startingValue)</code>。</p>
<p>它创建的对象应该：</p>
<ul>
<li>将“当前 value”存储在属性 <code>value</code> 中。起始值被设置到构造器 <code>startingValue</code> 的参数。</li>
<li><code>read()</code> 方法应该使用 <code>prompt</code> 来读取一个新的数字，并将其添加到 <code>value</code> 中。</li>
</ul>
<p>换句话说，<code>value</code> 属性是所有用户输入值与初始值 <code>startingValue</code> 的总和。</p>
<p>下面是示例代码：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> accumulator = <span class="hljs-keyword">new</span> Accumulator(<span class="hljs-number">1</span>); <span class="hljs-comment">// 初始值 1</span>

accumulator.read(); <span class="hljs-comment">// 添加用户输入的 value</span>
accumulator.read(); <span class="hljs-comment">// 添加用户输入的 value</span>

alert(accumulator.value); <span class="hljs-comment">// 显示这些值的总和</span></code></pre>
<p>[demo]</p>

      </fieldset>
      
      <fieldset id='_a4gEup'>
      <legend>article</legend>
      <h1 id="构造器和操作符-new">构造器和操作符 &quot;new&quot;</h1>
<p>常规的 <code>{...}</code> 语法允许创建一个对象。但是我们经常需要创建许多类似的对象，例如多个用户或菜单项等。</p>
<p>这可以使用构造函数和 <code>&quot;new&quot;</code> 操作符来实现。</p>
<h2 id="构造函数">构造函数</h2>
<p>构造函数在技术上是常规函数。不过有两个约定：</p>
<ol>
<li>它们的命名以大写字母开头。</li>
<li>它们只能由 <code>&quot;new&quot;</code> 操作符来执行。</li>
</ol>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-built_in">this</span>.name = name;
  <span class="hljs-built_in">this</span>.isAdmin = <span class="hljs-literal">false</span>;
}

*!*
<span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Jack&quot;</span>);
*/!*

alert(user.name); <span class="hljs-comment">// Jack</span>
alert(user.isAdmin); <span class="hljs-comment">// false</span></code></pre>
<p>当一个函数被使用 <code>new</code> 操作符执行时，它按照以下步骤：</p>
<ol>
<li>一个新的空对象被创建并分配给 <code>this</code>。</li>
<li>函数体执行。通常它会修改 <code>this</code>，为其添加新的属性。</li>
<li>返回 <code>this</code> 的值。</li>
</ol>
<p>换句话说，<code>new User(...)</code> 做的就是类似的事情：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params">name</span>) </span>{
*!*
  <span class="hljs-comment">// this = {};（隐式创建）</span>
*/!*

  <span class="hljs-comment">// 添加属性到 this</span>
  <span class="hljs-built_in">this</span>.name = name;
  <span class="hljs-built_in">this</span>.isAdmin = <span class="hljs-literal">false</span>;

*!*
  <span class="hljs-comment">// return this;（隐式返回）</span>
*/!*
}</code></pre>
<p>所以 <code>new User(&quot;Jack&quot;)</code> 的结果是相同的对象：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Jack&quot;</span>,
  <span class="hljs-attr">isAdmin</span>: <span class="hljs-literal">false</span>
};</code></pre>
<p>现在，如果我们想创建其他用户，我们可以调用 <code>new User(&quot;Ann&quot;)</code>，<code>new User(&quot;Alice&quot;)</code> 等。比每次都使用字面量创建要短得多，而且更易于阅读。</p>
<p>这是构造器的主要目的 —— 实现可重用的对象创建代码。</p>
<p>让我们再强调一遍 —— 从技术上讲，任何函数都可以用作构造器。即：任何函数都可以通过 <code>new</code> 来运行，它会执行上面的算法。“首字母大写”是一个共同的约定，以明确表示一个函数将被使用 <code>new</code> 来运行。</p>
<pre><code class="language-smart">如果我们有许多行用于创建单个复杂对象的代码，我们可以将它们封装在构造函数中，像这样：

```js
let user = new function() {
  this.name = &quot;John&quot;;
  this.isAdmin = false;

  // ……用于用户创建的其他代码
  // 也许是复杂的逻辑和语句
  // 局部变量等
};
```

构造器不能被再次调用，因为它不保存在任何地方，只是被创建和调用。因此，这个技巧旨在封装构建单个对象的代码，而无需将来重用。</code></pre>
<h2 id="构造器模式测试：newtarget">构造器模式测试：new.target</h2>
<pre><code class="language-smart">本节涉及的语法内容很少使用，除非你想了解所有内容，否则你可以直接跳过该语法。</code></pre>
<p>在一个函数内部，我们可以使用 <code>new.target</code> 属性来检查它是否被使用 <code>new</code> 进行调用了。</p>
<p>对于常规调用，它为空，对于使用 <code>new</code> 的调用，则等于该函数：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-keyword">new</span>.target);
}

<span class="hljs-comment">// 不带 &quot;new&quot;：</span>
*!*
User(); <span class="hljs-comment">// undefined</span>
*/!*

<span class="hljs-comment">// 带 &quot;new&quot;：</span>
*!*
<span class="hljs-keyword">new</span> User(); <span class="hljs-comment">// function User { ... }</span>
*/!*</code></pre>
<p>它可以被用在函数内部，来判断该函数是被通过 <code>new</code> 调用的“构造器模式”，还是没被通过 <code>new</code> 调用的“常规模式”。</p>
<p>我们也可以让 <code>new</code> 调用和常规调用做相同的工作，像这样：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">new</span>.target) { <span class="hljs-comment">// 如果你没有通过 new 运行我</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(name); <span class="hljs-comment">// ……我会给你添加 new</span>
  }

  <span class="hljs-built_in">this</span>.name = name;
}

<span class="hljs-keyword">let</span> john = User(<span class="hljs-string">&quot;John&quot;</span>); <span class="hljs-comment">// 将调用重定向到新用户</span>
alert(john.name); <span class="hljs-comment">// John</span></code></pre>
<p>这种方法有时被用在库中以使语法更加灵活。这样人们在调用函数时，无论是否使用了 <code>new</code>，程序都能工作。</p>
<p>不过，到处都使用它并不是一件好事，因为省略了 <code>new</code> 使得很难观察到代码中正在发生什么。而通过 <code>new</code> 我们都可以知道这创建了一个新对象。</p>
<h2 id="构造器的-return">构造器的 return</h2>
<p>通常，构造器没有 <code>return</code> 语句。它们的任务是将所有必要的东西写入 <code>this</code>，并自动转换为结果。</p>
<p>但是，如果这有一个 <code>return</code> 语句，那么规则就简单了：</p>
<ul>
<li>如果 <code>return</code> 返回的是一个对象，则返回这个对象，而不是 <code>this</code>。</li>
<li>如果 <code>return</code> 返回的是一个原始类型，则忽略。</li>
</ul>
<p>换句话说，带有对象的 <code>return</code> 返回该对象，在所有其他情况下返回 <code>this</code>。</p>
<p>例如，这里 <code>return</code> 通过返回一个对象覆盖 <code>this</code>：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BigUser</span>(<span class="hljs-params"></span>) </span>{

  <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&quot;John&quot;</span>;

  <span class="hljs-keyword">return</span> { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Godzilla&quot;</span> };  <span class="hljs-comment">// &lt;-- 返回这个对象</span>
}

alert( <span class="hljs-keyword">new</span> BigUser().name );  <span class="hljs-comment">// Godzilla，得到了那个对象</span></code></pre>
<p>这里有一个 <code>return</code> 为空的例子（或者我们可以在它之后放置一个原始类型，没有什么影响）：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SmallUser</span>(<span class="hljs-params"></span>) </span>{

  <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&quot;John&quot;</span>;

  <span class="hljs-keyword">return</span>; <span class="hljs-comment">// &lt;-- 返回 this</span>
}

alert( <span class="hljs-keyword">new</span> SmallUser().name );  <span class="hljs-comment">// John</span></code></pre>
<p>通常构造器没有 <code>return</code> 语句。这里我们主要为了完整性而提及返回对象的特殊行为。</p>
<pre><code class="language-smart">顺便说一下，如果没有参数，我们可以省略 `new` 后的括号：

```js
let user = new User; // &lt;-- 没有参数
// 等同于
let user = new User();
```

这里省略括号不被认为是一种“好风格”，但是规范允许使用该语法。</code></pre>
<h2 id="构造器中的方法">构造器中的方法</h2>
<p>使用构造函数来创建对象会带来很大的灵活性。构造函数可能有一些参数，这些参数定义了如何构造对象以及要放入什么。</p>
<p>当然，我们不仅可以将属性添加到 <code>this</code> 中，还可以添加方法。</p>
<p>例如，下面的 <code>new User(name)</code> 用给定的 <code>name</code> 和方法 <code>sayHi</code> 创建了一个对象：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-built_in">this</span>.name = name;

  <span class="hljs-built_in">this</span>.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    alert( <span class="hljs-string">&quot;My name is: &quot;</span> + <span class="hljs-built_in">this</span>.name );
  };
}

*!*
<span class="hljs-keyword">let</span> john = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;John&quot;</span>);

john.sayHi(); <span class="hljs-comment">// My name is: John</span>
*/!*

<span class="hljs-comment">/*
john = {
   name: &quot;John&quot;,
   sayHi: function() { ... }
}
*/</span></code></pre>
<p><a href="info:classes">类</a> 是用于创建复杂对象的一个更高级的语法，我们稍后会讲到。</p>
<h2 id="总结">总结</h2>
<ul>
<li>构造函数，或简称构造器，就是常规函数，但大家对于构造器有个共同的约定，就是其命名首字母要大写。</li>
<li>构造函数只能使用 <code>new</code> 来调用。这样的调用意味着在开始时创建了空的 <code>this</code>，并在最后返回填充了值的 <code>this</code>。</li>
</ul>
<p>我们可以使用构造函数来创建多个类似的对象。</p>
<p>JavaScript 为许多内置的对象提供了构造函数：比如日期 <code>Date</code>、集合 <code>Set</code> 以及其他我们计划学习的内容。</p>
<pre><code class="language-smart">在本章中，我们只介绍了关于对象和构造器的基础知识。它们对于我们在下一章中，学习更多关于数据类型和函数的相关知识非常重要。

在我们学习了那些之后，我们将回到对象，在 &lt;info:prototypes&gt; 和 &lt;info:classes&gt; 章节中深入介绍它们。</code></pre>

      </fieldset>
      
      <fieldset id='_srtEQq'>
      <legend>article</legend>
      <h1 id="可选链-">可选链 &quot;?.&quot;</h1>
<p>[recent browser=&quot;new&quot;]</p>
<p>可选链 <code>?.</code> 是一种访问嵌套对象属性的防错误方法。即使中间的属性不存在，也不会出现错误。</p>
<h2 id="问题">问题</h2>
<p>如果你才刚开始读此教程并学习 JavaScript，那可能还没接触到这个问题，但它却相当常见。</p>
<p>例如，我们有些用户会有地址信息，但有一少部分用户并没有提供相关信息。那么我们就不能安全地读取到 <code>user.address.street</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {}; <span class="hljs-comment">// 这个 user 恰巧没有 address</span>

alert(user.address.street); <span class="hljs-comment">// Error!</span></code></pre>
<p>或者，在 Web 开发中，我们想获取页面上某个元素的信息，但它可能不存在：</p>
<pre><code class="language-js"><span class="hljs-comment">// 如果 querySelector(...) 的结果为 null，则会报错</span>
<span class="hljs-keyword">let</span> html = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.my-element&#x27;</span>).innerHTML;</code></pre>
<p>在 JavaScript 这门语言中出现 <code>?.</code> 前，<code>&amp;&amp;</code> 运算符常被用来解决这个问题。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {}; <span class="hljs-comment">// user 没有 address</span>

alert( user &amp;&amp; user.address &amp;&amp; user.address.street ); <span class="hljs-comment">// undefined（不报错）</span></code></pre>
<p>依次对整条路径上的属性使用与运算进行判断，以确保所有节点是存在的，但是写起来很麻烦。</p>
<h2 id="可选链">可选链</h2>
<p>如果可选链 <code>?.</code> 前面部分是 <code>undefined</code> 或者 <code>null</code>，它会停止运算并返回 <code>undefined</code>。</p>
<p><strong>为了简明起见，在本文接下来的内容中，我们会说如果一个属性既不是 <code>null</code> 也不是 <code>undefined</code>，那么它就“存在”。</strong></p>
<p>下面这是一种安全地访问 <code>user.address.street</code> 的方式：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {}; <span class="hljs-comment">// user 没有 address</span>

alert( user?.address?.street ); <span class="hljs-comment">// undefined （不报错）</span></code></pre>
<p>以 <code>user?.address</code> 的方式来读取 <code>address</code> 是可行的，即使对象 <code>user</code> 不存在：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = <span class="hljs-literal">null</span>;

alert( user?.address ); <span class="hljs-comment">// undefined</span>
alert( user?.address.street ); <span class="hljs-comment">// undefined</span></code></pre>
<p>请注意：<code>?.</code> 语法使其前面的值成为可选值，但不会对其后面的起作用。</p>
<p>在上面的例子中，<code>user?.</code> 只允许 <code>user</code> 为 <code>null/undefined</code>。</p>
<p>另一方面，如果 <code>user</code> 存在，那么它必须具有 <code>user.address</code> 属性，否则 <code>user?.address.street</code> 在第二个点符号处会报错。</p>
<pre><code class="language-warn">我们应该只将 `?.` 使用在一些东西可以不存在的地方。

例如，如果根据我们的代码逻辑，`user` 对象必须存在，但 `address` 是可选的，那么 `user.address?.street` 会更好。

所以，如果 `user` 恰巧因为失误变为 undefined，我们会知道并修复这个失误。否则，代码中的 error 在不恰当的地方被消除了，这会导致调试更加困难。</code></pre>
<p>````warn header=&quot;<code>?.</code> 前的变量必须已声明&quot;
如果未声明变量 <code>user</code>，那么 <code>user?.anything</code> 会触发一个错误：</p>
<pre><code class="language-js"><span class="hljs-comment">// ReferenceError: user is not defined</span>
user?.address;</code></pre>
<p><code>?.</code> 前的变量必须已通过 <code>let/const/var user</code> 进行声明。可选链仅适用于已声明的变量。</p>
<pre><code>
## 短路效应

正如前面所说的，如果 `?.` 左边部分不存在，就会立即停止运算（“短路效应”）。

所以，如果后面有任何函数调用或者副作用，它们均不会执行：

```js run
let user = null;
let x = 0;

user?.sayHi(x++); // 没事发生

alert(x); // 0，值没有增加
```

## 其它情况：?.()，?.[]

可选链 `?.` 不是一个运算符，而是一个特殊的语法结构。它还可以与函数和方括号一起使用。

例如，将 `?.()` 用于调用一个可能不存在的函数。

在下面这段代码中，有些用户具有 `admin` 方法，而有些没有：

```js run
let user1 = {
  admin() {
    alert(&quot;I am admin&quot;);
  }
}

let user2 = {};

*!*
user1.admin?.(); // I am admin
user2.admin?.();
*/!*
```

在这两行代码中，我们首先使用点符号 `.` 来获取 `admin` 属性，因为用户对象一定存在，因此可以安全地读取它。

然后 `?.()` 会检查它左边的部分：如果 admin 函数存在，那么就调用运行它（对于 `user1`）。否则（对于 `user2`）运算停止，没有错误。

如果我们想使用方括号 `[]` 而不是点符号 `.` 来访问属性，语法 `?.[]` 也可以使用。跟前面的例子类似，它允许从一个可能不存在的对象上安全地读取属性。

```js run
let user1 = {
  firstName: &quot;John&quot;
};

let user2 = null; // 假设，我们不能授权此用户

let key = &quot;firstName&quot;;

alert( user1?.[key] ); // John
alert( user2?.[key] ); // undefined

alert( user1?.[key]?.something?.not?.existing); // undefined
```

此外，我们还可以将 `?.` 跟 `delete` 一起使用：

```js run
delete user?.name; // 如果 user 存在，则删除 user.name
```

```warn header=&quot;我们可以使用 `?.` 来安全地读取或删除，但不能写入&quot;
可选链 `?.` 不能用在赋值语句的左侧：

```js run
// 下面这段代码的想法是要写入 user.name，如果 user 存在的话

user?.name = &quot;John&quot;; // Error，不起作用
// because it evaluates to undefined = &quot;John&quot;
```

## 总结

可选链 `?.` 语法有三种形式：

1. `obj?.prop` —— 如果 `obj` 存在则返回 `obj.prop`，否则返回 `undefined`。
2. `obj?.[prop]` —— 如果 `obj` 存在则返回 `obj[prop]`，否则返回 `undefined`。
3. `obj?.method()` —— 如果 `obj` 存在则调用 `obj.method()`，否则返回 `undefined`。

正如我们所看到的，这些语法形式用起来都很简单直接。`?.` 检查左边部分是否为 `null/undefined`，如果不是则继续运算。

`?.` 链使我们能够安全地访问嵌套属性。

但是，我们应该谨慎地使用 `?.`，仅在当左边部分不存在也没问题的情况下使用为宜。

以保证在代码中有编程上的 error 出现时，也不会对我们隐藏。</code></pre>

      </fieldset>
      
      <fieldset id='_MFkHAv'>
      <legend>article</legend>
      <h1 id="symbol-类型">Symbol 类型</h1>
<p>根据规范，对象的属性键只能是字符串类型或者 Symbol 类型。不是 Number，也不是 Boolean，只有字符串或 Symbol 这两种类型。</p>
<p>到目前为止，我们只见过字符串。现在我们来看看 Symbol 能给我们带来什么好处。</p>
<h2 id="symbol">Symbol</h2>
<p>&quot;Symbol&quot; 值表示唯一的标识符。</p>
<p>可以使用 <code>Symbol()</code> 来创建这种类型的值：</p>
<pre><code class="language-js"><span class="hljs-comment">// id 是 symbol 的一个实例化对象</span>
<span class="hljs-keyword">let</span> id = <span class="hljs-built_in">Symbol</span>();</code></pre>
<p>创建时，我们可以给 Symbol 一个描述（也称为 Symbol 名），这在代码调试时非常有用：</p>
<pre><code class="language-js"><span class="hljs-comment">// id 是描述为 &quot;id&quot; 的 Symbol</span>
<span class="hljs-keyword">let</span> id = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);</code></pre>
<p>Symbol 保证是唯一的。即使我们创建了许多具有相同描述的 Symbol，它们的值也是不同。描述只是一个标签，不影响任何东西。</p>
<p>例如，这里有两个描述相同的 Symbol —— 它们不相等：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> id1 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);
<span class="hljs-keyword">let</span> id2 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);

*!*
alert(id1 == id2); <span class="hljs-comment">// false</span>
*/!*</code></pre>
<p>如果你熟悉 Ruby 或者其他有 &quot;Symbol&quot; 的语言 —— 别被误导。JavaScript 的 Symbol 是不同的。</p>
<pre><code class="language-warn">JavaScript 中的大多数值都支持字符串的隐式转换。例如，我们可以 `alert` 任何值，都可以生效。Symbol 比较特殊，它不会被自动转换。

例如，这个 `alert` 将会提示出错：

```js run
let id = Symbol(&quot;id&quot;);
*!*
alert(id); // 类型错误：无法将 Symbol 值转换为字符串。
*/!*
```

这是一种防止混乱的“语言保护”，因为字符串和 Symbol 有本质上的不同，不应该意外地将它们转换成另一个。

如果我们真的想显示一个 Symbol，我们需要在它上面调用 `.toString()`，如下所示：
```js run
let id = Symbol(&quot;id&quot;);
*!*
alert(id.toString()); // Symbol(id)，现在它有效了
*/!*
```

或者获取 `symbol.description` 属性，只显示描述（description）：
```js run
let id = Symbol(&quot;id&quot;);
*!*
alert(id.description); // id
*/!*
```
</code></pre>
<h2 id="隐藏属性">“隐藏”属性</h2>
<p>Symbol 允许我们创建对象的“隐藏”属性，代码的任何其他部分都不能意外访问或重写这些属性。</p>
<p>例如，如果我们使用的是属于第三方代码的 <code>user</code> 对象，我们想要给它们添加一些标识符。</p>
<p>我们可以给它们使用 Symbol 键：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = { <span class="hljs-comment">// 属于另一个代码</span>
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>
};

<span class="hljs-keyword">let</span> id = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);

user[id] = <span class="hljs-number">1</span>;

alert( user[id] ); <span class="hljs-comment">// 我们可以使用 Symbol 作为键来访问数据</span></code></pre>
<p>使用 <code>Symbol(&quot;id&quot;)</code> 作为键，比起用字符串 <code>&quot;id&quot;</code> 来有什么好处呢？</p>
<p>因为 <code>user</code> 对象属于其他的代码，那些代码也会使用这个对象，所以我们不应该在它上面直接添加任何字段，这样很不安全。但是你添加的 Symbol 属性不会被意外访问到，第三方代码根本不会看到它，所以使用 Symbol 基本上不会有问题。</p>
<p>另外，假设另一个脚本希望在 <code>user</code> 中有自己的标识符，以实现自己的目的。这可能是另一个 JavaScript 库，因此脚本之间完全不了解彼此。</p>
<p>然后该脚本可以创建自己的 <code>Symbol(&quot;id&quot;)</code>，像这样：</p>
<pre><code class="language-js"><span class="hljs-comment">// ...</span>
<span class="hljs-keyword">let</span> id = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);

user[id] = <span class="hljs-string">&quot;Their id value&quot;</span>;</code></pre>
<p>我们的标识符和它们的标识符之间不会有冲突，因为 Symbol 总是不同的，即使它们有相同的名字。</p>
<p>……但如果我们处于同样的目的，使用字符串 <code>&quot;id&quot;</code> 而不是用 symbol，那么 <strong>就会</strong> 出现冲突：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> };

<span class="hljs-comment">// 我们的脚本使用了 &quot;id&quot; 属性。</span>
user.id = <span class="hljs-string">&quot;Our id value&quot;</span>;

<span class="hljs-comment">// ……另一个脚本也想将 &quot;id&quot; 用于它的目的……     </span>

user.id = <span class="hljs-string">&quot;Their id value&quot;</span>
<span class="hljs-comment">// 砰！无意中被另一个脚本重写了 id！</span></code></pre>
<h3 id="字面量中的-symbol">字面量中的 Symbol</h3>
<p>如果我们要在对象字面量 <code>{...}</code> 中使用 Symbol，则需要使用方括号把它括起来。</p>
<p>就像这样：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> id = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);

<span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
*!*
  [id]: <span class="hljs-number">123</span> <span class="hljs-comment">// 而不是 &quot;id&quot;：123</span>
*/!*
};</code></pre>
<p>这是因为我们需要变量 <code>id</code> 的值作为键，而不是字符串 &quot;id&quot;。</p>
<h3 id="symbol-在-forin-中会被跳过">Symbol 在 for..in 中会被跳过</h3>
<p>Symbol 属性不参与 <code>for..in</code> 循环。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> id = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);
<span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,
  [id]: <span class="hljs-number">123</span>
};

*!*
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> user) alert(key); <span class="hljs-comment">// name, age (no symbols)</span>
*/!*

<span class="hljs-comment">// 使用 Symbol 任务直接访问</span>
alert( <span class="hljs-string">&quot;Direct: &quot;</span> + user[id] );</code></pre>
<p><code>Object.keys(user)</code> 也会忽略它们。这是一般“隐藏符号属性”原则的一部分。如果另一个脚本或库遍历我们的对象，它不会意外地访问到符号属性。</p>
<p>相反，<a href="mdn:js/Object/assign">Object.assign</a> 会同时复制字符串和 symbol 属性：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> id = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);
<span class="hljs-keyword">let</span> user = {
  [id]: <span class="hljs-number">123</span>
};

<span class="hljs-keyword">let</span> clone = <span class="hljs-built_in">Object</span>.assign({}, user);

alert( clone[id] ); <span class="hljs-comment">// 123</span></code></pre>
<p>这里并不矛盾，就是这样设计的。这里的想法是当我们克隆或者合并一个 object 时，通常希望 <strong>所有</strong> 属性被复制（包括像 <code>id</code> 这样的 Symbol）。</p>
<h2 id="全局-symbol">全局 symbol</h2>
<p>正如我们所看到的，通常所有的 Symbol 都是不同的，即使它们有相同的名字。但有时我们想要名字相同的 Symbol 具有相同的实体。例如，应用程序的不同部分想要访问的 Symbol <code>&quot;id&quot;</code> 指的是完全相同的属性。</p>
<p>为了实现这一点，这里有一个 <strong>全局 Symbol 注册表</strong>。我们可以在其中创建 Symbol 并在稍后访问它们，它可以确保每次访问相同名字的 Symbol 时，返回的都是相同的 Symbol。</p>
<p>要从注册表中读取（不存在则创建）Symbol，请使用 <code>Symbol.for(key)</code>。</p>
<p>该调用会检查全局注册表，如果有一个描述为 <code>key</code> 的 Symbol，则返回该 Symbol，否则将创建一个新 Symbol（<code>Symbol(key)</code>），并通过给定的 <code>key</code> 将其存储在注册表中。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-comment">// 从全局注册表中读取</span>
<span class="hljs-keyword">let</span> id = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">&quot;id&quot;</span>); <span class="hljs-comment">// 如果该 Symbol 不存在，则创建它</span>

<span class="hljs-comment">// 再次读取（可能是在代码中的另一个位置）</span>
<span class="hljs-keyword">let</span> idAgain = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">&quot;id&quot;</span>);

<span class="hljs-comment">// 相同的 Symbol</span>
alert( id === idAgain ); <span class="hljs-comment">// true</span></code></pre>
<p>注册表内的 Symbol 被称为 <strong>全局 Symbol</strong>。如果我们想要一个应用程序范围内的 Symbol，可以在代码中随处访问 —— 这就是它们的用途。</p>
<pre><code class="language-smart">在一些编程语言中，例如 Ruby，每个名字都有一个 Symbol。

正如我们所看到的，在 JavaScript 中，全局 Symbol 也是这样的。</code></pre>
<h3 id="symbolkeyfor">Symbol.keyFor</h3>
<p>对于全局 Symbol，不仅有 <code>Symbol.for(key)</code> 按名字返回一个 Symbol，还有一个反向调用：<code>Symbol.keyFor(sym)</code>，它的作用完全反过来：通过全局 Symbol 返回一个名字。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-comment">// 通过 name 获取 Symbol</span>
<span class="hljs-keyword">let</span> sym = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">&quot;name&quot;</span>);
<span class="hljs-keyword">let</span> sym2 = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">&quot;id&quot;</span>);

<span class="hljs-comment">// 通过 Symbol 获取 name</span>
alert( <span class="hljs-built_in">Symbol</span>.keyFor(sym) ); <span class="hljs-comment">// name</span>
alert( <span class="hljs-built_in">Symbol</span>.keyFor(sym2) ); <span class="hljs-comment">// id</span></code></pre>
<p><code>Symbol.keyFor</code> 内部使用全局 Symbol 注册表来查找 Symbol 的键。所以它不适用于非全局 Symbol。如果 Symbol 不是全局的，它将无法找到它并返回 <code>undefined</code>。</p>
<p>也就是说，任何 Symbol 都具有 <code>description</code> 属性。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> globalSymbol = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">&quot;name&quot;</span>);
<span class="hljs-keyword">let</span> localSymbol = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;name&quot;</span>);

alert( <span class="hljs-built_in">Symbol</span>.keyFor(globalSymbol) ); <span class="hljs-comment">// name，全局 Symbol</span>
alert( <span class="hljs-built_in">Symbol</span>.keyFor(localSymbol) ); <span class="hljs-comment">// undefined，非全局</span>

alert( localSymbol.description ); <span class="hljs-comment">// name</span></code></pre>
<h2 id="系统-symbol">系统 Symbol</h2>
<p>JavaScript 内部有很多“系统” Symbol，我们可以使用它们来微调对象的各个方面。 </p>
<p>它们都被列在了 <a href="https://tc39.github.io/ecma262/#sec-well-known-symbols">众所周知的 Symbol</a> 表的规范中：</p>
<ul>
<li><code>Symbol.hasInstance</code></li>
<li><code>Symbol.isConcatSpreadable</code></li>
<li><code>Symbol.iterator</code></li>
<li><code>Symbol.toPrimitive</code></li>
<li>……等等。</li>
</ul>
<p>例如，<code>Symbol.toPrimitive</code> 允许我们将对象描述为原始值转换。我们很快就会看到它的使用。</p>
<p>当我们研究相应的语言特征时，我们对其他的 Symbol 也会慢慢熟悉起来。</p>
<h2 id="总结">总结</h2>
<p><code>Symbol</code> 是唯一标识符的基本类型</p>
<p>Symbol 是使用带有可选描述（name）的 <code>Symbol()</code> 调用创建的。</p>
<p>Symbol 总是不同的值，即使它们有相同的名字。如果我们希望同名的 Symbol 相等，那么我们应该使用全局注册表：<code>Symbol.for(key)</code> 返回（如果需要的话则创建）一个以 <code>key</code> 作为名字的全局 Symbol。使用 <code>Symbol.for</code> 多次调用 <code>key</code> 相同的 Symbol 时，返回的就是同一个 Symbol。</p>
<p>Symbol 有两个主要的使用场景：</p>
<ol>
<li><p>“隐藏” 对象属性。
 如果我们想要向“属于”另一个脚本或者库的对象添加一个属性，我们可以创建一个 Symbol 并使用它作为属性的键。Symbol 属性不会出现在 <code>for..in</code> 中，因此它不会意外地被与其他属性一起处理。并且，它不会被直接访问，因为另一个脚本没有我们的 symbol。因此，该属性将受到保护，防止被意外使用或重写。</p>
<p> 因此我们可以使用 Symbol 属性“秘密地”将一些东西隐藏到我们需要的对象中，但其他地方看不到它。</p>
</li>
<li><p>JavaScript 使用了许多系统 Symbol，这些 Symbol 可以作为 <code>Symbol.*</code> 访问。我们可以使用它们来改变一些内置行为。例如，在本教程的后面部分，我们将使用 <code>Symbol.iterator</code> 来进行 <a href="info:iterable">迭代</a> 操作，使用 <code>Symbol.toPrimitive</code> 来设置 <a href="info:object-toprimitive">对象原始值的转换</a> 等等。</p>
</li>
</ol>
<p>从技术上说，Symbol 不是 100% 隐藏的。有一个内置方法 <a href="mdn:js/Object/getOwnPropertySymbols">Object.getOwnPropertySymbols(obj)</a> 允许我们获取所有的 Symbol。还有一个名为 <a href="mdn:js/Reflect/ownKeys">Reflect.ownKeys(obj)</a> 的方法可以返回一个对象的 <strong>所有</strong> 键，包括 Symbol。所以它们并不是真正的隐藏。但是大多数库、内置方法和语法结构都没有使用这些方法。</p>

      </fieldset>
      
      <fieldset id='_ERtFfa'>
      <legend>article</legend>
      <h1 id="对象--原始值转换">对象 — 原始值转换</h1>
<p>当对象相加 <code>obj1 + obj2</code>，相减 <code>obj1 - obj2</code>，或者使用 <code>alert(obj)</code> 打印时会发生什么？</p>
<p>在这种情况下，对象会被自动转换为原始值，然后执行操作。</p>
<p>在 <a href="info:type-conversions">info:type-conversions</a> 一章中，我们已经看到了数值，字符串和布尔转换的规则。但是我们没有讲对象的转换规则。现在我们已经掌握了方法（method）和 symbol 的相关知识，可以开始学习对象原始值转换了。</p>
<ol>
<li>所有的对象在布尔上下文（context）中均为 <code>true</code>。所以对于对象，不存在 to-boolean 转换，只有字符串和数值转换。</li>
<li>数值转换发生在对象相减或应用数学函数时。例如，<code>Date</code> 对象（将在 <a href="info:date">info:date</a> 一章中介绍）可以相减，<code>date1 - date2</code> 的结果是两个日期之间的差值。</li>
<li>至于字符串转换 —— 通常发生在我们像 <code>alert(obj)</code> 这样输出一个对象和类似的上下文中。</li>
</ol>
<h2 id="toprimitive">ToPrimitive</h2>
<p>我们可以使用特殊的对象方法，对字符串和数值转换进行微调。</p>
<p>下面是三个类型转换的变体，被称为 &quot;hint&quot;，在 <a href="https://tc39.github.io/ecma262/#sec-toprimitive">规范</a> 中有详细介绍（译注：当一个对象被用在需要原始值的上下文中时，例如，在 <code>alert</code> 或数学运算中，对象会被转换为原始值）：</p>
<p><code>&quot;string&quot;</code>
: 对象到字符串的转换，当我们对期望一个字符串的对象执行操作时，如 &quot;alert&quot;：</p>
<pre><code>```js
// 输出
alert(obj);

// 将对象作为属性键
anotherObj[obj] = 123;
```</code></pre>
<p><code>&quot;number&quot;</code>
: 对象到数字的转换，例如当我们进行数学运算时：</p>
<pre><code>```js
// 显式转换
let num = Number(obj);

// 数学运算（除了二进制加法）
let n = +obj; // 一元加法
let delta = date1 - date2;

// 小于/大于的比较
let greater = user1 &gt; user2;
```</code></pre>
<p><code>&quot;default&quot;</code>
: 在少数情况下发生，当运算符“不确定”期望值的类型时。</p>
<pre><code>例如，二进制加法 `+` 可用于字符串（连接），也可以用于数字（相加），所以字符串和数字这两种类型都可以。因此，当二元加法得到对象类型的参数时，它将依据 `&quot;default&quot;` hint 来对其进行转换。

此外，如果对象被用于与字符串、数字或 symbol 进行 `==` 比较，这时到底应该进行哪种转换也不是很明确，因此使用 `&quot;default&quot;` hint。

```js
// 二元加法使用默认 hint
let total = obj1 + obj2;

// obj == number 使用默认 hint
if (user == 1) { ... };
```

像 `&lt;` 和 `&gt;` 这样的小于/大于比较运算符，也可以同时用于字符串和数字。不过，它们使用 &quot;number&quot; hint，而不是 &quot;default&quot;。这是历史原因。

实际上，我们没有必要记住这些奇特的细节，除了一种情况（`Date` 对象，我们稍后会学到它）之外，所有内建对象都以和 `&quot;number&quot;` 相同的方式实现 `&quot;default&quot;` 转换。我们也可以这样做。</code></pre>
<p>```smart header=&quot;没有 <code>\&quot;boolean\&quot;</code> hint&quot;
请注意 —— 只有三种 hint。就这么简单。</p>
<p>没有 &quot;boolean&quot; hint（在布尔上下文中所有对象都是 <code>true</code>）或其他任何东西。如果我们将 <code>&quot;default&quot;</code> 和 <code>&quot;number&quot;</code> 视为相同，就像大多数内建函数一样，那么就只有两种转换了。</p>
<pre><code>
**为了进行转换，JavaScript 尝试查找并调用三个对象方法：**

1. 调用 `obj[Symbol.toPrimitive](hint)` —— 带有 symbol 键 `Symbol.toPrimitive`（系统 symbol）的方法，如果这个方法存在的话，
2. 否则，如果 hint 是 `&quot;string&quot;`
   —— 尝试 `obj.toString()` 和 `obj.valueOf()`，无论哪个存在。
3. 否则，如果 hint 是 `&quot;number&quot;` 或 `&quot;default&quot;`
   —— 尝试 `obj.valueOf()` 和 `obj.toString()`，无论哪个存在。

## Symbol.toPrimitive

我们从第一个方法开始。有一个名为 `Symbol.toPrimitive` 的内建 symbol，它被用来给转换方法命名，像这样：

```js
obj[Symbol.toPrimitive] = function(hint) {
  // 返回一个原始值
  // hint = &quot;string&quot;、&quot;number&quot; 和 &quot;default&quot; 中的一个
}</code></pre>
<p>例如，这里 <code>user</code> 对象实现了它：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">money</span>: <span class="hljs-number">1000</span>,

  [<span class="hljs-built_in">Symbol</span>.toPrimitive](hint) {
    alert(<span class="hljs-string">`hint: <span class="hljs-subst">${hint}</span>`</span>);
    <span class="hljs-keyword">return</span> hint == <span class="hljs-string">&quot;string&quot;</span> ? <span class="hljs-string">`{name: &quot;<span class="hljs-subst">${<span class="hljs-built_in">this</span>.name}</span>&quot;}`</span> : <span class="hljs-built_in">this</span>.money;
  }
};

<span class="hljs-comment">// 转换演示：</span>
alert(user); <span class="hljs-comment">// hint: string -&gt; {name: &quot;John&quot;}</span>
alert(+user); <span class="hljs-comment">// hint: number -&gt; 1000</span>
alert(user + <span class="hljs-number">500</span>); <span class="hljs-comment">// hint: default -&gt; 1500</span></code></pre>
<p>从代码中我们可以看到，根据转换的不同，<code>user</code> 变成一个自描述字符串或者一个金额。单个方法 <code>user[Symbol.toPrimitive]</code> 处理了所有的转换情况。</p>
<h2 id="tostringvalueof">toString/valueOf</h2>
<p>方法 <code>toString</code> 和 <code>valueOf</code> 来自上古时代。它们不是 symbol（那时候还没有 symbol 这个概念），而是“常规的”字符串命名的方法。它们提供了一种可选的“老派”的实现转换的方法。</p>
<p>如果没有 <code>Symbol.toPrimitive</code>，那么 JavaScript 将尝试找到它们，并且按照下面的顺序进行尝试：</p>
<ul>
<li>对于 &quot;string&quot; hint，<code>toString -&gt; valueOf</code>。</li>
<li>其他情况，<code>valueOf -&gt; toString</code>。</li>
</ul>
<p>这些方法必须返回一个原始值。如果 <code>toString</code> 或 <code>valueOf</code> 返回了一个对象，那么返回值会被忽略（和这里没有方法的时候相同）。</p>
<p>默认情况下，普通对象具有 <code>toString</code> 和 <code>valueOf</code> 方法：</p>
<ul>
<li><code>toString</code> 方法返回一个字符串 <code>&quot;[object Object]&quot;</code>。</li>
<li><code>valueOf</code> 方法返回对象自身。</li>
</ul>
<p>下面是一个示例：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>};

alert(user); <span class="hljs-comment">// [object Object]</span>
alert(user.valueOf() === user); <span class="hljs-comment">// true</span></code></pre>
<p>所以，如果我们尝试将一个对象当做字符串来使用，例如在 <code>alert</code> 中，那么在默认情况下我们会看到 <code>[object Object]</code>。</p>
<p>这里提到默认值 <code>valueOf</code> 只是为了完整起见，以避免混淆。正如你看到的，它返回对象本身，因此被忽略。别问我为什么，那是历史原因。所以我们可以假设它根本就不存在。</p>
<p>让我们实现一下这些方法。</p>
<p>例如，这里的 <code>user</code> 执行和前面提到的那个 <code>user</code> 一样的操作，使用 <code>toString</code> 和 <code>valueOf</code> 的组合（而不是 <code>Symbol.toPrimitive</code>）：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">money</span>: <span class="hljs-number">1000</span>,

  <span class="hljs-comment">// 对于 hint=&quot;string&quot;</span>
  <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`{name: &quot;<span class="hljs-subst">${<span class="hljs-built_in">this</span>.name}</span>&quot;}`</span>;
  },

  <span class="hljs-comment">// 对于 hint=&quot;number&quot; 或 &quot;default&quot;</span>
  <span class="hljs-function"><span class="hljs-title">valueOf</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.money;
  }

};

alert(user); <span class="hljs-comment">// toString -&gt; {name: &quot;John&quot;}</span>
alert(+user); <span class="hljs-comment">// valueOf -&gt; 1000</span>
alert(user + <span class="hljs-number">500</span>); <span class="hljs-comment">// valueOf -&gt; 1500</span></code></pre>
<p>我们可以看到，执行的动作和前面使用 <code>Symbol.toPrimitive</code> 的那个例子相同。</p>
<p>通常我们希望有一个“全能”的地方来处理所有原始转换。在这种情况下，我们可以只实现 <code>toString</code>，就像这样：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,

  <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;
  }
};

alert(user); <span class="hljs-comment">// toString -&gt; John</span>
alert(user + <span class="hljs-number">500</span>); <span class="hljs-comment">// toString -&gt; John500</span></code></pre>
<p>如果没有 <code>Symbol.toPrimitive</code> 和 <code>valueOf</code>，<code>toString</code> 将处理所有原始转换。</p>
<h2 id="返回类型">返回类型</h2>
<p>关于所有原始转换方法，有一个重要的点需要知道，就是它们不一定会返回 &quot;hint&quot; 的原始值。</p>
<p>没有限制 <code>toString()</code> 是否返回字符串，或 <code>Symbol.toPrimitive</code> 方法是否为 hint &quot;number&quot; 返回数字。</p>
<p>唯一强制性的事情是：这些方法必须返回一个原始值，而不是对象。</p>
<pre><code class="language-smart">由于历史原因，如果 `toString` 或 `valueOf` 返回一个对象，则不会出现 error，但是这种值会被忽略（就像这种方法根本不存在）。这是因为在 JavaScript 语言发展初期，没有很好的 &quot;error&quot; 的概念。

相反，`Symbol.toPrimitive` **必须** 返回一个原始值，否则就会出现 error。</code></pre>
<h2 id="进一步的转换">进一步的转换</h2>
<p>我们已经知道，许多运算符和函数执行类型转换，例如乘法 <code>*</code> 将操作数转换为数字。</p>
<p>如果我们将对象作为参数传递，则会出现两个阶段：</p>
<ol>
<li>对象被转换为原始值（通过前面我们描述的规则）。</li>
<li>如果生成的原始值的类型不正确，则继续进行转换。</li>
</ol>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> obj = {
  <span class="hljs-comment">// toString 在没有其他方法的情况下处理所有转换</span>
  <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;2&quot;</span>;
  }
};

alert(obj * <span class="hljs-number">2</span>); <span class="hljs-comment">// 4，对象被转换为原始值字符串 &quot;2&quot;，之后它被乘法转换为数字 2。</span></code></pre>
<ol>
<li>乘法 <code>obj * 2</code> 首先将对象转换为原始值（字符串 &quot;2&quot;）。</li>
<li>之后 <code>&quot;2&quot; * 2</code> 变为 <code>2 * 2</code>（字符串被转换为数字）。</li>
</ol>
<p>二元加法在同样的情况下会将其连接成字符串，因为它更愿意接受字符串：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> obj = {
  <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;2&quot;</span>;
  }
};

alert(obj + <span class="hljs-number">2</span>); <span class="hljs-comment">// 22（&quot;2&quot; + 2）被转换为原始值字符串 =&gt; 级联</span></code></pre>
<h2 id="总结">总结</h2>
<p>对象到原始值的转换，是由许多期望以原始值作为值的内建函数和运算符自动调用的。</p>
<p>这里有三种类型（hint）：</p>
<ul>
<li><code>&quot;string&quot;</code>（对于 <code>alert</code> 和其他需要字符串的操作）</li>
<li><code>&quot;number&quot;</code>（对于数学运算）</li>
<li><code>&quot;default&quot;</code>（少数运算符）</li>
</ul>
<p>规范明确描述了哪个运算符使用哪个 hint。很少有运算符“不知道期望什么”并使用 <code>&quot;default&quot;</code> hint。通常对于内建对象，<code>&quot;default&quot;</code> hint 的处理方式与 <code>&quot;number&quot;</code> 相同，因此在实践中，最后两个 hint 常常合并在一起。</p>
<p>转换算法是：</p>
<ol>
<li>调用 <code>obj[Symbol.toPrimitive](hint)</code> 如果这个方法存在，</li>
<li>否则，如果 hint 是 <code>&quot;string&quot;</code><ul>
<li>尝试 <code>obj.toString()</code> 和 <code>obj.valueOf()</code>，无论哪个存在。</li>
</ul>
</li>
<li>否则，如果 hint 是 <code>&quot;number&quot;</code> 或者 <code>&quot;default&quot;</code><ul>
<li>尝试 <code>obj.valueOf()</code> 和 <code>obj.toString()</code>，无论哪个存在。</li>
</ul>
</li>
</ol>
<p>在实践中，为了便于进行日志记录或调试，对于所有能够返回一种“可读性好”的对象的表达形式的转换，只实现以 <code>obj.toString()</code> 作为全能转换的方法就够了。</p>

      </fieldset>
      
      <fieldset id='_ebQK94'>
      <legend>solution</legend>
      <p>试试运行一下：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;Hello&quot;</span>;

str.test = <span class="hljs-number">5</span>; <span class="hljs-comment">// (*)</span>

alert(str.test); </code></pre>
<p>根据你是否开启了严格模式 <code>use strict</code>，会得到如下结果：</p>
<ol>
<li><code>undefined</code>（非严格模式）</li>
<li>报错（严格模式）。</li>
</ol>
<p>为什么？让我们看看在 <code>(*)</code> 那一行到底发生了什么：</p>
<ol>
<li>当访问 <code>str</code> 的属性时，一个“对象包装器”被创建了。</li>
<li>在严格模式下，向其写入内容会报错。</li>
<li>否则，将继续执行带有属性的操作，该对象将获得 <code>test</code> 属性，但是此后，“对象包装器”将消失，因此在最后一行，<code>str</code> 并没有该属性的踪迹。</li>
</ol>
<p><strong>这个例子清楚地表明，原始类型不是对象。</strong></p>
<p>它们不能存储额外的数据。</p>

      </fieldset>
      
      <fieldset id='_575DK8'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="我能添加一个字符串属性吗？">我能添加一个字符串属性吗？</h1>
<p>思考下面的代码：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;Hello&quot;</span>;

str.test = <span class="hljs-number">5</span>;

alert(str.test);</code></pre>
<p>你怎么想的呢，它会工作吗？会得到什么样的结果？</p>

      </fieldset>
      
      <fieldset id='_iWkwLF'>
      <legend>article</legend>
      <h1 id="原始类型的方法">原始类型的方法</h1>
<p>JavaScript 允许我们像使用对象一样使用原始类型（字符串，数字等）。JavaScript 还提供了这样的调用方法。我们很快就会学习它们，但是首先我们将了解它的工作原理，毕竟原始类型不是对象（在这里我们会分析地更加清楚）。</p>
<p>我们来看看原始类型和对象之间的关键区别。</p>
<p>一个原始值：</p>
<ul>
<li>是原始类型中的一种值。</li>
<li>在 JavaScript 中有 7 种原始类型：<code>string</code>，<code>number</code>，<code>bigint</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code> 和 <code>undefined</code>。</li>
</ul>
<p>一个对象：</p>
<ul>
<li>能够存储多个值作为属性。</li>
<li>可以使用大括号 <code>{}</code> 创建对象，例如：<code>{name: &quot;John&quot;, age: 30}</code>。JavaScript 中还有其他种类的对象，例如函数就是对象。</li>
</ul>
<p>关于对象的最好的事儿之一是，我们可以把一个函数作为对象的属性存储到对象中。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> john = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">sayHi</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    alert(<span class="hljs-string">&quot;Hi buddy!&quot;</span>);
  }
};

john.sayHi(); <span class="hljs-comment">// Hi buddy!</span></code></pre>
<p>所以我们在这里创建了一个包含 <code>sayHi</code> 方法的对象 <code>john</code>。</p>
<p>许多内建对象已经存在，例如那些处理日期、错误、HTML 元素等的内建对象。它们具有不同的属性和方法。</p>
<p>但是，这些特性（feature）都是有成本的！</p>
<p>对象比原始类型“更重”。它们需要额外的资源来支持运作。</p>
<h2 id="当作对象的原始类型">当作对象的原始类型</h2>
<p>以下是 JavaScript 创建者面临的悖论：</p>
<ul>
<li>人们可能想对诸如字符串或数字之类的原始类型执行很多操作。最好将它们作为方法来访问。</li>
<li>原始类型必须尽可能的简单轻量。</li>
</ul>
<p>而解决方案看起来多少有点尴尬，如下：</p>
<ol>
<li>原始类型仍然是原始的。与预期相同，提供单个值</li>
<li>JavaScript 允许访问字符串，数字，布尔值和 symbol 的方法和属性。</li>
<li>为了使它们起作用，创建了提供额外功能的特殊“对象包装器”，使用后即被销毁。</li>
</ol>
<p>“对象包装器”对于每种原始类型都是不同的，它们被称为 <code>String</code>、<code>Number</code>、<code>Boolean</code> 和 <code>Symbol</code>。因此，它们提供了不同的方法。</p>
<p>例如，字符串方法 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase">str.toUpperCase()</a> 返回一个大写化处理的字符串。</p>
<p>用法演示如下：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;Hello&quot;</span>;

alert( str.toUpperCase() ); <span class="hljs-comment">// HELLO</span></code></pre>
<p>很简单，对吧？以下是 <code>str.toUpperCase()</code> 中实际发生的情况：</p>
<ol>
<li>字符串 <code>str</code> 是一个原始值。因此，在访问其属性时，会创建一个包含字符串字面值的特殊对象，并且具有有用的方法，例如 <code>toUpperCase()</code>。</li>
<li>该方法运行并返回一个新的字符串（由 <code>alert</code> 显示）。</li>
<li>特殊对象被销毁，只留下原始值 <code>str</code>。</li>
</ol>
<p>所以原始类型可以提供方法，但它们依然是轻量级的。</p>
<p>JavaScript 引擎高度优化了这个过程。它甚至可能跳过创建额外的对象。但是它仍然必须遵守规范，并且表现得好像它创建了一样。</p>
<p>数字有其自己的方法，例如，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed">toFixed(n)</a> 将数字舍入到给定的精度：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> n = <span class="hljs-number">1.23456</span>;

alert( n.toFixed(<span class="hljs-number">2</span>) ); <span class="hljs-comment">// 1.23</span></code></pre>
<p>我们将在后面 <a href="info:number">info:number</a> 和 <a href="info:string">info:string</a> 章节中看到更多具体的方法。</p>
<p>````warn header=&quot;构造器 <code>String/Number/Boolean</code> 仅供内部使用&quot;
像 Java 这样的一些语言允许我们使用 <code>new Number(1)</code> 或 <code>new Boolean(false)</code> 等语法，明确地为原始类型创建“对象包装器”。</p>
<p>在 JavaScript 中，由于历史原因，这也是可以的，但极其 <strong>不推荐</strong>。因为这样会出问题。</p>
<p>例如：</p>
<pre><code class="language-js">alert( <span class="hljs-keyword">typeof</span> <span class="hljs-number">0</span> ); <span class="hljs-comment">// &quot;number&quot;</span>

alert( <span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">0</span>) ); <span class="hljs-comment">// &quot;object&quot;!</span></code></pre>
<p>对象在 <code>if</code> 中始终是 <code>true</code>，因此此处的 alert 将显示：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> zero = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">0</span>);

<span class="hljs-keyword">if</span> (zero) { <span class="hljs-comment">// zero 为 true，因为它是一个对象</span>
  alert( <span class="hljs-string">&quot;zero is truthy?!?&quot;</span> );
}</code></pre>
<p>另一方面，调用不带 <code>new</code>（关键字）的 <code>String/Number/Boolean</code> 函数是完全理智和有用的。它们将一个值转换为相应的类型：转成字符串、数字或布尔值（原始类型）。</p>
<p>例如，下面完全是有效的：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> num = <span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;123&quot;</span>); <span class="hljs-comment">// 将字符串转成数字</span></code></pre>
<pre><code>

````warn header=&quot;null/undefined 没有任何方法&quot;
特殊的原始类型 `null` 和 `undefined` 是例外。它们没有对应的“对象包装器”，也没有提供任何方法。从某种意义上说，它们是“最原始的”。

尝试访问这种值的属性会导致错误：

```js run
alert(null.test); // error</code></pre>
<h2 id="总结">总结</h2>
<ul>
<li>除 <code>null</code> 和 <code>undefined</code> 以外的原始类型都提供了许多有用的方法。我们后面的章节中学习这些内容。</li>
<li>从形式上讲，这些方法通过临时对象工作，但 JavaScript 引擎可以很好地调整，以在内部对其进行优化，因此调用它们并不需要太高的成本。</li>
</ul>

      </fieldset>
      
      <fieldset id='_ch3E1R'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-keyword">let</span> a = +prompt(<span class="hljs-string">&quot;The first number?&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);
<span class="hljs-keyword">let</span> b = +prompt(<span class="hljs-string">&quot;The second number?&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);

alert( a + b );</code></pre>
<p>注意在 <code>prompt</code> 前面的一元加号 <code>+</code>。它将立即把值转换成数字。</p>
<p>否则，<code>a</code> 和 <code>b</code> 将会是字符串，它们的总和将是它们的连接，即：<code>&quot;1&quot; + &quot;2&quot; = &quot;12&quot;</code>。</p>

      </fieldset>
      
      <fieldset id='_Ysu62C'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="来自访问者的数字的总和">来自访问者的数字的总和</h1>
<p>创建一个脚本，提示访问者输入两个数字，然后显示它们的总和。</p>
<p>[demo]</p>
<p>P.S. 有一个类型陷阱。</p>

      </fieldset>
      
      <fieldset id='_5Nx2zN'>
      <legend>solution</legend>
      <p>在内部，<code>6.35</code> 的小数部分是一个无限的二进制。在这种情况下，它的存储会造成精度损失。</p>
<p>让我们来看看：</p>
<pre><code class="language-js">alert( <span class="hljs-number">6.35</span>.toFixed(<span class="hljs-number">20</span>) ); <span class="hljs-comment">// 6.34999999999999964473</span></code></pre>
<p>精度损失可能会导致数字的增加和减小。在这种特殊的情况下，数字变小了一点，这就是它向下舍入的原因。</p>
<p>那么 <code>1.35</code> 会怎样呢？</p>
<pre><code class="language-js">alert( <span class="hljs-number">1.35</span>.toFixed(<span class="hljs-number">20</span>) ); <span class="hljs-comment">// 1.35000000000000008882</span></code></pre>
<p>在这里，精度损失使得这个数字稍微大了一些，因此其向上舍入。</p>
<p><strong>如果我们希望以正确的方式进行舍入，我们应该如何解决 <code>6.35</code> 的舍入问题呢？</strong></p>
<p>在进行舍入前，我们应该使其更接近整数：</p>
<pre><code class="language-js">alert( (<span class="hljs-number">6.35</span> * <span class="hljs-number">10</span>).toFixed(<span class="hljs-number">20</span>) ); <span class="hljs-comment">// 63.50000000000000000000</span></code></pre>
<p>请注意，<code>63.5</code> 完全没有精度损失。这是因为小数部分 <code>0.5</code> 实际上是 <code>1/2</code>。以 2 的整数次幂为分母的小数在二进制数字系统中可以被精确地表示，现在我们可以对它进行舍入：</p>
<pre><code class="language-js">alert( <span class="hljs-built_in">Math</span>.round(<span class="hljs-number">6.35</span> * <span class="hljs-number">10</span>) / <span class="hljs-number">10</span>); <span class="hljs-comment">// 6.35 -&gt; 63.5 -&gt; 64(rounded) -&gt; 6.4</span></code></pre>

      </fieldset>
      
      <fieldset id='_ro6Hz0'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="为什么-635tofixed1--63？">为什么 6.35.toFixed(1) == 6.3？</h1>
<p>根据文档，<code>Math.round</code> 和 <code>toFixed</code> 都将数字舍入到最接近的数字：<code>0..4</code> 会被舍去，而 <code>5..9</code> 会进一位。</p>
<p>例如：</p>
<pre><code class="language-js">alert( <span class="hljs-number">1.35</span>.toFixed(<span class="hljs-number">1</span>) ); <span class="hljs-comment">// 1.4</span></code></pre>
<p>在下面这个类似的示例中，为什么 <code>6.35</code> 被舍入为 <code>6.3</code> 而不是 <code>6.4</code>？</p>
<pre><code class="language-js">alert( <span class="hljs-number">6.35</span>.toFixed(<span class="hljs-number">1</span>) ); <span class="hljs-comment">// 6.3</span></code></pre>
<p>如何以正确的方式来对 <code>6.35</code> 进行舍入？</p>

      </fieldset>
      
      <fieldset id='_056BKQ'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readNumber</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> num;

  <span class="hljs-keyword">do</span> {
    num = prompt(<span class="hljs-string">&quot;Enter a number please?&quot;</span>, <span class="hljs-number">0</span>);
  } <span class="hljs-keyword">while</span> ( !<span class="hljs-built_in">isFinite</span>(num) );

  <span class="hljs-keyword">if</span> (num === <span class="hljs-literal">null</span> || num === <span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">return</span> +num;
}

alert(<span class="hljs-string">`Read: <span class="hljs-subst">${readNumber()}</span>`</span>);</code></pre>
<p>该解决方案有点复杂，因为我们需要处理 <code>null</code> 和空行。</p>
<p>所以，我们实际上接受输入，直到输入的是一个“常规数字”。<code>null</code>（取消）和空行都符合该条件，因为在数字形式中它们是 <code>0</code>。</p>
<p>在我们停止之后，我们需要专门处理 <code>null</code> 和空行（返回 <code>null</code>），因为将它们转换为数字将返回 <code>0</code>。</p>

      </fieldset>
      
      <fieldset id='_myebNQ'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="重复，直到输入的是一个数字">重复，直到输入的是一个数字</h1>
<p>创建一个函数 <code>readNumber</code>，它提示输入一个数字，直到访问者输入一个有效的数字为止。</p>
<p>结果值必须以数字形式返回。</p>
<p>访问者也可以通过输入空行或点击“取消”来停止该过程。在这种情况下，函数应该返回 <code>null</code>。</p>
<p>[demo]</p>

      </fieldset>
      
      <fieldset id='_zr8K0f'>
      <legend>solution</legend>
      <p>那是因为 <code>i</code> 永远不会等于 <code>10</code>。</p>
<p>运行下面这段代码来查看 <code>i</code> 的 <strong>实际</strong> 值：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">11</span>) {
  i += <span class="hljs-number">0.2</span>;
  <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">9.8</span> &amp;&amp; i &lt; <span class="hljs-number">10.2</span>) alert( i );
}</code></pre>
<p>它们中没有一个恰好是 <code>10</code>。</p>
<p>之所以发生这种情况，是因为对 <code>0.2</code> 这样的小数时进行加法运算时出现了精度损失。</p>
<p>结论：在处理小数时避免相等性检查。</p>

      </fieldset>
      
      <fieldset id='_SaZOD3'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="一个偶发的无限循环">一个偶发的无限循环</h1>
<p>这是一个无限循环。它永远不会结束。为什么？</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span> (i != <span class="hljs-number">10</span>) {
  i += <span class="hljs-number">0.2</span>;
}</code></pre>

      </fieldset>
      
      <fieldset id='_4EdSOZ'>
      <legend>solution</legend>
      <p>我们需要将区间 0..1 中的所有值“映射”为范围在 <code>min</code> 到 <code>max</code> 中的值。</p>
<p>这可以分两个阶段完成：</p>
<ol>
<li>如果我们将 0..1 的随机数乘以 <code>max-min</code>，则随机数的范围将从 0..1 增加到 <code>0..max-min</code>。</li>
<li>现在，如果我们将随机数与 <code>min</code> 相加，则随机数的范围将为 <code>min</code> 到 <code>max</code>。</li>
</ol>
<p>函数实现：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">random</span>(<span class="hljs-params">min, max</span>) </span>{
  <span class="hljs-keyword">return</span> min + <span class="hljs-built_in">Math</span>.random() * (max - min);
}

alert( random(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>) ); 
alert( random(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>) ); 
alert( random(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>) ); </code></pre>

      </fieldset>
      
      <fieldset id='_55ckhI'>
      <legend>task</legend>
      <p>importance: 2</p>
<hr>
<h1 id="从-min-到-max-的随机数">从 min 到 max 的随机数</h1>
<p>内建函数 <code>Math.random()</code> 会创建一个在 <code>0</code> 到 <code>1</code> 之间（不包括 <code>1</code>）的随机数。</p>
<p>编写一个 <code>random(min, max)</code> 函数，用以生成一个在 <code>min</code> 到 <code>max</code> 之间的随机浮点数（不包括 <code>max</code>)）。</p>
<p>运行示例：</p>
<pre><code class="language-js">alert( random(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>) ); <span class="hljs-comment">// 1.2345623452</span>
alert( random(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>) ); <span class="hljs-comment">// 3.7894332423</span>
alert( random(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>) ); <span class="hljs-comment">// 4.3435234525</span></code></pre>

      </fieldset>
      
      <fieldset id='_21Mli3'>
      <legend>solution</legend>
      <h1 id="简单但错误的解决方案">简单但错误的解决方案</h1>
<p>最简单但错误的解决方案是生成一个范围在 <code>min</code> 到 <code>max</code> 的值，并取对其进行四舍五入后的值：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randomInteger</span>(<span class="hljs-params">min, max</span>) </span>{
  <span class="hljs-keyword">let</span> rand = min + <span class="hljs-built_in">Math</span>.random() * (max - min); 
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.round(rand);
}

alert( randomInteger(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) );</code></pre>
<p>这个函数是能起作用的，但不正确。获得边缘值 <code>min</code> 和 <code>max</code> 的概率比其他值低两倍。</p>
<p>如果你将上面这个例子运行多次，你会很容易看到 <code>2</code> 出现的频率最高。</p>
<p>发生这种情况是因为 <code>Math.round()</code> 从范围 <code>1..3</code> 中获得随机数，并按如下所示进行四舍五入：</p>
<pre><code class="language-js">values <span class="hljs-keyword">from</span> <span class="hljs-number">1</span>    ... to <span class="hljs-number">1.4999999999</span>  become <span class="hljs-number">1</span>
values <span class="hljs-keyword">from</span> <span class="hljs-number">1.5</span>  ... to <span class="hljs-number">2.4999999999</span>  become <span class="hljs-number">2</span>
values <span class="hljs-keyword">from</span> <span class="hljs-number">2.5</span>  ... to <span class="hljs-number">2.9999999999</span>  become <span class="hljs-number">3</span></code></pre>
<p>现在我们可以清楚地看到 <code>1</code> 的值比 <code>2</code> 少两倍。和 <code>3</code> 一样。</p>
<h1 id="正确的解决方案">正确的解决方案</h1>
<p>这个题目有很多正确的解决方案。其中之一是调整取值范围的边界。为了确保相同的取值范围，我们可以生成从 0.5 到 3.5 的值，从而将所需的概率添加到取值范围的边界：</p>
<pre><code class="language-js">*!*
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randomInteger</span>(<span class="hljs-params">min, max</span>) </span>{
  <span class="hljs-comment">// 现在范围是从  (min-0.5) 到 (max+0.5)</span>
  <span class="hljs-keyword">let</span> rand = min - <span class="hljs-number">0.5</span> + <span class="hljs-built_in">Math</span>.random() * (max - min + <span class="hljs-number">1</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.round(rand);
}
*/!*

alert( randomInteger(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) );</code></pre>
<p>另一种方法是使用 <code>Math.floor</code> 来取范围从 <code>min</code> 到 <code>max+1</code> 的随机数：</p>
<pre><code class="language-js">*!*
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randomInteger</span>(<span class="hljs-params">min, max</span>) </span>{
  <span class="hljs-comment">// here rand is from min to (max+1)</span>
  <span class="hljs-keyword">let</span> rand = min + <span class="hljs-built_in">Math</span>.random() * (max + <span class="hljs-number">1</span> - min);
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.floor(rand);
}
*/!*

alert( randomInteger(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) );</code></pre>
<p>现在所有间隔都以这种方式映射：</p>
<pre><code class="language-js">values <span class="hljs-keyword">from</span> <span class="hljs-number">1</span>  ... to <span class="hljs-number">1.9999999999</span>  become <span class="hljs-number">1</span>
values <span class="hljs-keyword">from</span> <span class="hljs-number">2</span>  ... to <span class="hljs-number">2.9999999999</span>  become <span class="hljs-number">2</span>
values <span class="hljs-keyword">from</span> <span class="hljs-number">3</span>  ... to <span class="hljs-number">3.9999999999</span>  become <span class="hljs-number">3</span></code></pre>
<p>所有间隔的长度相同，从而使最终能够均匀分配。</p>

      </fieldset>
      
      <fieldset id='_bd9sJ8'>
      <legend>task</legend>
      <p>importance: 2</p>
<hr>
<h1 id="从-min-到-max-的随机整数">从 min 到 max 的随机整数</h1>
<p>创建一个函数 <code>randomInteger(min，max)</code>，该函数会生成一个范围在 <code>min</code> 到 <code>max</code> 中的随机整数，包括 <code>min</code> 和 <code>max</code>。</p>
<p>在 <code>min..max</code> 范围中的所有数字的出现概率必须相同。</p>
<p>运行示例：</p>
<pre><code class="language-js">alert( randomInteger(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>) ); <span class="hljs-comment">// 1</span>
alert( randomInteger(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>) ); <span class="hljs-comment">// 3</span>
alert( randomInteger(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>) ); <span class="hljs-comment">// 5</span></code></pre>
<p>你可以使用 <a href="info:task/random-min-max">上一个任务</a> 的解决方案作为基础。</p>

      </fieldset>
      
      <fieldset id='_ZAbqko'>
      <legend>article</legend>
      <h1 id="数字类型">数字类型</h1>
<p>在现代 JavaScript 中，数字（number）有两种类型：</p>
<ol>
<li><p>JavaScript 中的常规数字以 64 位的格式 <a href="https://en.wikipedia.org/wiki/IEEE_754-2008_revision">IEEE-754</a> 存储，也被称为“双精度浮点数”。这是我们大多数时候所使用的数字，我们将在本章中学习它们。</p>
</li>
<li><p>BigInt 数字，用于表示任意长度的整数。有时会需要它们，因为常规数字不能超过 <code>2<sup>53</sup></code> 或小于 <code>-2<sup>53</sup></code>。由于仅在少数特殊领域才会用到 BigInt，因此我们在特殊的章节 <a href="info:bigint">info:bigint</a> 中对其进行了介绍。</p>
</li>
</ol>
<p>所以，在这里我们将讨论常规数字类型。现在让我们开始学习吧。</p>
<h2 id="编写数字的更多方法">编写数字的更多方法</h2>
<p>想象一下，我们需要写 10 亿。显然的方法是：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> billion = <span class="hljs-number">1000000000</span>;</code></pre>
<p>但在现实生活中，我们通常避免写一长串零，因为它很容易打错。另外，我们很懒。我们通常会将 10 亿写成 <code>&quot;1bn&quot;</code>，或将 73 亿写成 <code>&quot;7.3bn&quot;</code>。对于大多数大的数字来说都是如此。</p>
<p>在 JavaScript 中，我们通过在数字后附加字母 &quot;e&quot;，并指定零的数量来缩短数字：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> billion = <span class="hljs-number">1e9</span>;  <span class="hljs-comment">// 10 亿，字面意思：数字 1 后面跟 9 个 0</span>

alert( <span class="hljs-number">7.3e9</span> );  <span class="hljs-comment">// 73 亿（7,300,000,000）</span></code></pre>
<p>换句话说，<code>&quot;e&quot;</code> 把数字乘以 <code>1</code> 后面跟着给定数量的 0 的数字。</p>
<pre><code class="language-js"><span class="hljs-number">1e3</span> = <span class="hljs-number">1</span> * <span class="hljs-number">1000</span>
<span class="hljs-number">1.23e6</span> = <span class="hljs-number">1.23</span> * <span class="hljs-number">1000000</span></code></pre>
<p>现在让我们写一些非常小的数字。例如，1 微秒（百万分之一秒）：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> ms = <span class="hljs-number">0.000001</span>;</code></pre>
<p>就像以前一样，可以使用 <code>&quot;e&quot;</code> 来完成。如果我们想避免显式地写零，我们可以这样写：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> ms = <span class="hljs-number">1e-6</span>; <span class="hljs-comment">// 1 的左边有 6 个 0</span></code></pre>
<p>如果我们数一下 <code>0.000001</code> 中的 0 的个数，是 6 个。所以自然是 <code>1e-6</code>。</p>
<p>换句话说，<code>e</code> 后面的负数表示除以 1 后面跟着给定数量的 0 的数字：</p>
<pre><code class="language-js"><span class="hljs-comment">// -3 除以 1 后面跟着 3 个 0 的数字</span>
<span class="hljs-number">1e-3</span> = <span class="hljs-number">1</span> / <span class="hljs-number">1000</span> (=<span class="hljs-number">0.001</span>)

<span class="hljs-comment">// -6 除以 1 后面跟着 6 个 0 的数字</span>
<span class="hljs-number">1.23e-6</span> = <span class="hljs-number">1.23</span> / <span class="hljs-number">1000000</span> (=<span class="hljs-number">0.00000123</span>)</code></pre>
<h3 id="十六进制，二进制和八进制数字">十六进制，二进制和八进制数字</h3>
<p><a href="https://en.wikipedia.org/wiki/Hexadecimal">十六进制</a> 数字在 JavaScript 中被广泛用于表示颜色，编码字符以及其他许多东西。所以自然地，有一种较短的写方法：<code>0x</code>，然后是数字。</p>
<p>例如：</p>
<pre><code class="language-js">alert( <span class="hljs-number">0xff</span> ); <span class="hljs-comment">// 255</span>
alert( <span class="hljs-number">0xFF</span> ); <span class="hljs-comment">// 255（一样，大小写没影响）</span></code></pre>
<p>二进制和八进制数字系统很少使用，但也支持使用 <code>0b</code> 和 <code>0o</code> 前缀：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">0b11111111</span>; <span class="hljs-comment">// 二进制形式的 255</span>
<span class="hljs-keyword">let</span> b = <span class="hljs-number">0o377</span>; <span class="hljs-comment">// 八进制形式的 255</span>

alert( a == b ); <span class="hljs-comment">// true，两边是相同的数字，都是 255</span></code></pre>
<p>只有这三种进制支持这种写法。对于其他进制，我们应该使用函数 <code>parseInt</code>（我们将在本章后面看到）。</p>
<h2 id="tostringbase">toString(base)</h2>
<p>方法 <code>num.toString(base)</code> 返回在给定 <code>base</code> 进制数字系统中 <code>num</code> 的字符串表示形式。</p>
<p>举个例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> num = <span class="hljs-number">255</span>;

alert( num.toString(<span class="hljs-number">16</span>) );  <span class="hljs-comment">// ff</span>
alert( num.toString(<span class="hljs-number">2</span>) );   <span class="hljs-comment">// 11111111</span></code></pre>
<p><code>base</code> 的范围可以从 <code>2</code> 到 <code>36</code>。默认情况下是 <code>10</code>。</p>
<p>常见的用例如下：</p>
<ul>
<li><p><strong>base=16</strong> 用于十六进制颜色，字符编码等，数字可以是 <code>0..9</code> 或 <code>A..F</code>。</p>
</li>
<li><p><strong>base=2</strong> 主要用于调试按位操作，数字可以是 <code>0</code> 或 <code>1</code>。</p>
</li>
<li><p><strong>base=36</strong> 是最大进制，数字可以是 <code>0..9</code> 或 <code>A..Z</code>。所有拉丁字母都被用于了表示数字。对于 <code>36</code> 进制来说，一个有趣且有用的例子是，当我们需要将一个较长的数字标识符转换成较短的时候，例如做一个短的 URL。可以简单地使用基数为 <code>36</code> 的数字系统表示：</p>
<pre><code class="language-js">alert( <span class="hljs-number">123456.</span>.toString(<span class="hljs-number">36</span>) ); <span class="hljs-comment">// 2n9c</span></code></pre>
</li>
</ul>
<pre><code class="language-warn">请注意 `123456..toString(36)` 中的两个点不是打错了。如果我们想直接在一个数字上调用一个方法，比如上面例子中的 `toString`，那么我们需要在它后面放置两个点 `..`。

如果我们放置一个点：`123456.toString(36)`，那么就会出现一个 error，因为 JavaScript 语法隐含了第一个点之后的部分为小数部分。如果我们再放一个点，那么 JavaScript 就知道小数部分为空，现在使用该方法。

也可以写成 `(123456).toString(36)`。</code></pre>
<h2 id="舍入">舍入</h2>
<p>舍入（rounding）是使用数字时最常用的操作之一。</p>
<p>这里有几个对数字进行舍入的内建函数：</p>
<p><code>Math.floor</code>
: 向下舍入：<code>3.1</code> 变成 <code>3</code>，<code>-1.1</code> 变成 <code>-2</code>。</p>
<p><code>Math.ceil</code>
: 向上舍入：<code>3.1</code> 变成 <code>4</code>，<code>-1.1</code> 变成 <code>-1</code>。</p>
<p><code>Math.round</code>
: 向最近的整数舍入：<code>3.1</code> 变成 <code>3</code>，<code>3.6</code> 变成 <code>4</code>，<code>-1.1</code> 变成 <code>-1</code>。</p>
<p><code>Math.trunc</code>（IE 浏览器不支持这个方法）
: 移除小数点后的所有内容而没有舍入：<code>3.1</code> 变成 <code>3</code>，<code>-1.1</code> 变成 <code>-1</code>。</p>
<p>这个是总结它们之间差异的表格：</p>
<table>
<thead>
<tr>
<th></th>
<th><code>Math.floor</code></th>
<th><code>Math.ceil</code></th>
<th><code>Math.round</code></th>
<th><code>Math.trunc</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>3.1</code></td>
<td><code>3</code></td>
<td><code>4</code></td>
<td><code>3</code></td>
<td><code>3</code></td>
</tr>
<tr>
<td><code>3.6</code></td>
<td><code>3</code></td>
<td><code>4</code></td>
<td><code>4</code></td>
<td><code>3</code></td>
</tr>
<tr>
<td><code>-1.1</code></td>
<td><code>-2</code></td>
<td><code>-1</code></td>
<td><code>-1</code></td>
<td><code>-1</code></td>
</tr>
<tr>
<td><code>-1.6</code></td>
<td><code>-2</code></td>
<td><code>-1</code></td>
<td><code>-2</code></td>
<td><code>-1</code></td>
</tr>
</tbody></table>
<p>这些函数涵盖了处理数字小数部分的所有可能方法。但是，如果我们想将数字舍入到小数点后 <code>n</code> 位，该怎么办？</p>
<p>例如，我们有 <code>1.2345</code>，并且想把它舍入到小数点后两位，仅得到 <code>1.23</code>。</p>
<p>有两种方式可以实现这个需求：</p>
<ol>
<li><p>乘除法</p>
<p> 例如，要将数字舍入到小数点后两位，我们可以将数字乘以 <code>100</code>（或更大的 10 的整数次幂），调用舍入函数，然后再将其除回。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> num = <span class="hljs-number">1.23456</span>;

alert( <span class="hljs-built_in">Math</span>.floor(num * <span class="hljs-number">100</span>) / <span class="hljs-number">100</span> ); <span class="hljs-comment">// 1.23456 -&gt; 123.456 -&gt; 123 -&gt; 1.23</span></code></pre>
</li>
<li><p>函数 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed">toFixed(n)</a> 将数字舍入到小数点后 <code>n</code> 位，并以字符串形式返回结果。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> num = <span class="hljs-number">12.34</span>;
alert( num.toFixed(<span class="hljs-number">1</span>) ); <span class="hljs-comment">// &quot;12.3&quot;</span></code></pre>
<p> 这会向上或向下舍入到最接近的值，类似于 <code>Math.round</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> num = <span class="hljs-number">12.36</span>;
alert( num.toFixed(<span class="hljs-number">1</span>) ); <span class="hljs-comment">// &quot;12.4&quot;</span></code></pre>
<p> 请注意 <code>toFixed</code> 的结果是一个字符串。如果小数部分比所需要的短，则在结尾添加零：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> num = <span class="hljs-number">12.34</span>;
alert( num.toFixed(<span class="hljs-number">5</span>) ); <span class="hljs-comment">// &quot;12.34000&quot;，在结尾添加了 0，以达到小数点后五位</span></code></pre>
<p> 我们可以使用一元加号或 <code>Number()</code> 调用，将其转换为数字：<code>+ num.toFixed(5)</code>。</p>
</li>
</ol>
<h2 id="不精确的计算">不精确的计算</h2>
<p>在内部，数字是以 64 位格式 <a href="http://en.wikipedia.org/wiki/IEEE_754-1985">IEEE-754</a> 表示的，所以正好有 64 位可以存储一个数字：其中 52 位被用于存储这些数字，其中 11 位用于存储小数点的位置（对于整数，它们为零），而 1 位用于符号。</p>
<p>如果一个数字太大，则会溢出 64 位存储，并可能会导致无穷大：</p>
<pre><code class="language-js">alert( <span class="hljs-number">1e500</span> ); <span class="hljs-comment">// Infinity</span></code></pre>
<p>这可能不那么明显，但经常会发生的是，精度的损失。</p>
<p>考虑下这个（falsy！）测试：</p>
<pre><code class="language-js">alert( <span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span> == <span class="hljs-number">0.3</span> ); <span class="hljs-comment">// *!*false*/!*</span></code></pre>
<p>没错，如果我们检查 <code>0.1</code> 和 <code>0.2</code> 的总和是否为 <code>0.3</code>，我们会得到 <code>false</code>。</p>
<p>奇了怪了！如果不是 <code>0.3</code>，那能是啥？</p>
<pre><code class="language-js">alert( <span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span> ); <span class="hljs-comment">// 0.30000000000000004</span></code></pre>
<p>哎哟！这个错误比不正确的比较的后果更严重。想象一下，你创建了一个电子购物网站，如果访问者将价格为 <code>¥ 0.10</code> 和 <code>¥ 0.20</code> 的商品放入了他的购物车。订单总额将是 <code>¥ 0.30000000000000004</code>。这会让任何人感到惊讶。</p>
<p>但为什么会这样呢？</p>
<p>一个数字以其二进制的形式存储在内存中，一个 1 和 0 的序列。但是在十进制数字系统中看起来很简单的 <code>0.1</code>，<code>0.2</code> 这样的小数，实际上在二进制形式中是无限循环小数。</p>
<p>换句话说，什么是 <code>0.1</code>？<code>0.1</code> 就是 <code>1</code> 除以 <code>10</code>，<code>1/10</code>，即十分之一。在十进制数字系统中，这样的数字表示起来很容易。将其与三分之一进行比较：<code>1/3</code>。三分之一变成了无限循环小数 <code>0.33333(3)</code>。</p>
<p>在十进制数字系统中，可以保证以 <code>10</code> 的整数次幂作为除数能够正常工作，但是以 <code>3</code> 作为除数则不能。也是同样的原因，在二进制数字系统中，可以保证以 <code>2</code> 的整数次幂作为除数时能够正常工作，但 <code>1/10</code> 就变成了一个无限循环的二进制小数。</p>
<p>使用二进制数字系统无法 <strong>精确</strong> 存储 <em>0.1</em> 或 <em>0.2</em>，就像没有办法将三分之一存储为十进制小数一样。</p>
<p>IEEE-754 数字格式通过将数字舍入到最接近的可能数字来解决此问题。这些舍入规则通常不允许我们看到“极小的精度损失”，但是它确实存在。</p>
<p>我们可以看到：</p>
<pre><code class="language-js">alert( <span class="hljs-number">0.1</span>.toFixed(<span class="hljs-number">20</span>) ); <span class="hljs-comment">// 0.10000000000000000555</span></code></pre>
<p>当我们对两个数字进行求和时，它们的“精度损失”会叠加起来。</p>
<p>这就是为什么 <code>0.1 + 0.2</code> 不等于 <code>0.3</code>。</p>
<pre><code class="language-smart">许多其他编程语言也存在同样的问题。

PHP，Java，C，Perl，Ruby 给出的也是完全相同的结果，因为它们基于的是相同的数字格式。</code></pre>
<p>我们能解决这个问题吗？当然，最可靠的方法是借助方法 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed">toFixed(n)</a> 对结果进行舍入：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> sum = <span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>;
alert( sum.toFixed(<span class="hljs-number">2</span>) ); <span class="hljs-comment">// 0.30</span></code></pre>
<p>请注意，<code>toFixed</code> 总是返回一个字符串。它确保小数点后有 2 位数字。如果我们有一个电子购物网站，并需要显示 <code>¥ 0.30</code>，这实际上很方便。对于其他情况，我们可以使用一元加号将其强制转换为一个数字：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> sum = <span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>;
alert( +sum.toFixed(<span class="hljs-number">2</span>) ); <span class="hljs-comment">// 0.3</span></code></pre>
<p>我们可以将数字临时乘以 100（或更大的数字），将其转换为整数，进行数学运算，然后再除回。当我们使用整数进行数学运算时，误差会有所减少，但仍然可以在除法中得到：</p>
<pre><code class="language-js">alert( (<span class="hljs-number">0.1</span> * <span class="hljs-number">10</span> + <span class="hljs-number">0.2</span> * <span class="hljs-number">10</span>) / <span class="hljs-number">10</span> ); <span class="hljs-comment">// 0.3</span>
alert( (<span class="hljs-number">0.28</span> * <span class="hljs-number">100</span> + <span class="hljs-number">0.14</span> * <span class="hljs-number">100</span>) / <span class="hljs-number">100</span>); <span class="hljs-comment">// 0.4200000000000001</span></code></pre>
<p>因此，乘/除法可以减少误差，但不能完全消除误差。</p>
<p>有时候我们可以尝试完全避免小数。例如，我们正在创建一个电子购物网站，那么我们可以用角而不是元来存储价格。但是，如果我们要打 30% 的折扣呢？实际上，完全避免小数处理几乎是不可能的。只需要在必要时剪掉其“尾巴”来对其进行舍入即可。</p>
<pre><code class="language-smart">尝试运行下面这段代码：

```js run
// Hello！我是一个会自我增加的数字！
alert( 9999999999999999 ); // 显示 10000000000000000
```

出现了同样的问题：精度损失。有 64 位来表示该数字，其中 52 位可用于存储数字，但这还不够。所以最不重要的数字就消失了。

JavaScript 不会在此类事件中触发 error。它会尽最大努力使数字符合所需的格式，但不幸的是，这种格式不够大到满足需求。</code></pre>
<pre><code class="language-smart">数字内部表示的另一个有趣结果是存在两个零：`0` 和 `-0`。

这是因为在存储时，使用一位来存储符号，因此对于包括零在内的任何数字，可以设置这一位或者不设置。

在大多数情况下，这种区别并不明显，因为运算符将它们视为相同的值。</code></pre>
<h2 id="测试：isfinite-和-isnan">测试：isFinite 和 isNaN</h2>
<p>还记得这两个特殊的数值吗？</p>
<ul>
<li><code>Infinity</code>（和 <code>-Infinity</code>）是一个特殊的数值，比任何数值都大（小）。</li>
<li><code>NaN</code> 代表一个 error。</li>
</ul>
<p>它们属于 <code>number</code> 类型，但不是“普通”数字，因此，这里有用于检查它们的特殊函数：</p>
<ul>
<li><p><code>isNaN(value)</code> 将其参数转换为数字，然后测试它是否为 <code>NaN</code>：</p>
<pre><code class="language-js">alert( <span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">NaN</span>) ); <span class="hljs-comment">// true</span>
alert( <span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&quot;str&quot;</span>) ); <span class="hljs-comment">// true</span></code></pre>
<p>  但是我们需要这个函数吗？我们不能只使用 <code>=== NaN</code> 比较吗？不好意思，这不行。值 &quot;NaN&quot; 是独一无二的，它不等于任何东西，包括它自身：</p>
<pre><code class="language-js">alert( <span class="hljs-literal">NaN</span> === <span class="hljs-literal">NaN</span> ); <span class="hljs-comment">// false</span></code></pre>
</li>
<li><p><code>isFinite(value)</code> 将其参数转换为数字，如果是常规数字，则返回 <code>true</code>，而不是 <code>NaN/Infinity/-Infinity</code>：</p>
<pre><code class="language-js">alert( <span class="hljs-built_in">isFinite</span>(<span class="hljs-string">&quot;15&quot;</span>) ); <span class="hljs-comment">// true</span>
alert( <span class="hljs-built_in">isFinite</span>(<span class="hljs-string">&quot;str&quot;</span>) ); <span class="hljs-comment">// false，因为是一个特殊的值：NaN</span>
alert( <span class="hljs-built_in">isFinite</span>(<span class="hljs-literal">Infinity</span>) ); <span class="hljs-comment">// false，因为是一个特殊的值：Infinity</span></code></pre>
</li>
</ul>
<p>有时 <code>isFinite</code> 被用于验证字符串值是否为常规数字：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> num = +prompt(<span class="hljs-string">&quot;Enter a number&quot;</span>, <span class="hljs-string">&#x27;&#x27;</span>);

<span class="hljs-comment">// 结果会是 true，除非你输入的是 Infinity、-Infinity 或不是数字</span>
alert( <span class="hljs-built_in">isFinite</span>(num) );</code></pre>
<p>请注意，在所有数字函数中，包括 <code>isFinite</code>，空字符串或仅有空格的字符串均被视为 <code>0</code>。</p>
<p>```smart header=&quot;与 <code>Object.is</code> 进行比较&quot;</p>
<p>有一个特殊的内建方法 <a href="mdn:js/Object/is"><code>Object.is</code></a>，它类似于 <code>===</code> 一样对值进行比较，但它对于两种边缘情况更可靠：</p>
<ol>
<li>它适用于 <code>NaN</code>：<code>Object.is（NaN，NaN）=== true</code>，这是件好事。</li>
<li>值 <code>0</code> 和 <code>-0</code> 是不同的：<code>Object.is（0，-0）=== false</code>，从技术上讲这是对的，因为在内部，数字的符号位可能会不同，即使其他所有位均为零。</li>
</ol>
<p>在所有其他情况下，<code>Object.is(a，b)</code> 与 <code>a === b</code> 相同。</p>
<p>这种比较方式经常被用在 JavaScript 规范中。当内部算法需要比较两个值是否完全相同时，它使用 <code>Object.is</code>（内部称为 <a href="https://tc39.github.io/ecma262/#sec-samevalue">SameValue</a>）。</p>
<pre><code>

## parseInt 和 parseFloat

使用加号 `+` 或 `Number()` 的数字转换是严格的。如果一个值不完全是一个数字，就会失败：

```js run
alert( +&quot;100px&quot; ); // NaN</code></pre>
<p>唯一的例外是字符串开头或结尾的空格，因为它们会被忽略。</p>
<p>但在现实生活中，我们经常会有带有单位的值，例如 CSS 中的 <code>&quot;100px&quot;</code> 或 <code>&quot;12pt&quot;</code>。并且，在很多国家，货币符号是紧随金额之后的，所以我们有 <code>&quot;19€&quot;</code>，并希望从中提取出一个数值。</p>
<p>这就是 <code>parseInt</code> 和 <code>parseFloat</code> 的作用。</p>
<p>它们可以从字符串中“读取”数字，直到无法读取为止。如果发生 error，则返回收集到的数字。函数 <code>parseInt</code> 返回一个整数，而 <code>parseFloat</code> 返回一个浮点数：</p>
<pre><code class="language-js">alert( <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;100px&#x27;</span>) ); <span class="hljs-comment">// 100</span>
alert( <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;12.5em&#x27;</span>) ); <span class="hljs-comment">// 12.5</span>

alert( <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;12.3&#x27;</span>) ); <span class="hljs-comment">// 12，只有整数部分被返回了</span>
alert( <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;12.3.4&#x27;</span>) ); <span class="hljs-comment">// 12.3，在第二个点出停止了读取</span></code></pre>
<p>某些情况下，<code>parseInt/parseFloat</code> 会返回 <code>NaN</code>。当没有数字可读时会发生这种情况：</p>
<pre><code class="language-js">alert( <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;a123&#x27;</span>) ); <span class="hljs-comment">// NaN，第一个符号停止了读取</span></code></pre>
<p>````smart header=&quot;parseInt(str, radix)<code>的第二个参数&quot;</code>parseInt()<code>函数具有可选的第二个参数。它指定了数字系统的基数，因此</code>parseInt` 还可以解析十六进制数字、二进制数字等的字符串：</p>
<pre><code class="language-js">alert( <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;0xff&#x27;</span>, <span class="hljs-number">16</span>) ); <span class="hljs-comment">// 255</span>
alert( <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;ff&#x27;</span>, <span class="hljs-number">16</span>) ); <span class="hljs-comment">// 255，没有 0x 仍然有效</span>

alert( <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;2n9c&#x27;</span>, <span class="hljs-number">36</span>) ); <span class="hljs-comment">// 123456</span></code></pre>
<pre><code>
## 其他数学函数

JavaScript 有一个内建的 [Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math) 对象，它包含了一个小型的数学函数和常量库。

几个例子：

`Math.random()`
: 返回一个从 0 到 1 的随机数（不包括 1）

    ```js run
    alert( Math.random() ); // 0.1234567894322
    alert( Math.random() ); // 0.5435252343232
    alert( Math.random() ); // ... (任何随机数)
    ```

`Math.max(a, b, c...)` / `Math.min(a, b, c...)`
: 从任意数量的参数中返回最大/最小值。

    ```js run
    alert( Math.max(3, 5, -10, 0, 1) ); // 5
    alert( Math.min(1, 2) ); // 1
    ```

`Math.pow(n, power)`
: 返回 `n` 的给定（power）次幂

    ```js run
    alert( Math.pow(2, 10) ); // 2 的 10 次幂 = 1024
    ```

`Math` 对象中还有更多函数和常量，包括三角函数，你可以在 [Math 函数文档](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math) 中找到这些内容。

## 总结

要写有很多零的数字：

- 将 `&quot;e&quot;` 和 0 的数量附加到数字后。就像：`123e6` 与 `123` 后面接 6 个 0 相同。
- `&quot;e&quot;` 后面的负数将使数字除以 1 后面接着给定数量的零的数字。例如 `123e-6` 表示 `0.000123`（`123` 的百万分之一）。

对于不同的数字系统：

- 可以直接在十六进制（`0x`），八进制（`0o`）和二进制（`0b`）系统中写入数字。
- `parseInt(str，base)` 将字符串 `str` 解析为在给定的 `base` 数字系统中的整数，`2 ≤ base ≤ 36`。
- `num.toString(base)` 将数字转换为在给定的 `base` 数字系统中的字符串。

要将 `12pt` 和 `100px` 之类的值转换为数字：

- 使用 `parseInt/parseFloat` 进行“软”转换，它从字符串中读取数字，然后返回在发生 error 前可以读取到的值。

小数：

- 使用 `Math.floor`，`Math.ceil`，`Math.trunc`，`Math.round` 或 `num.toFixed(precision)` 进行舍入。
- 请确保记住使用小数时会损失精度。

更多数学函数：

- 需要时请查看 [Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math) 对象。这个库很小，但是可以满足基本的需求。</code></pre>

      </fieldset>
      
      <fieldset id='_oqKgPL'>
      <legend>solution</legend>
      <p>我们不能“替换”第一个字符，因为在 JavaScript 中字符串是不可变的。</p>
<p>但是我们可以根据已有字符串创建一个首字母大写的新字符串：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> newStr = str[<span class="hljs-number">0</span>].toUpperCase() + str.slice(<span class="hljs-number">1</span>);</code></pre>
<p>这里存在一个小问题。如果 <code>str</code> 是空的，那么 <code>str[0]</code> 就是 <code>undefined</code>，但由于 <code>undefined</code> 并没有 <code>toUpperCase()</code> 方法，因此我们会得到一个错误。</p>
<p>存在如下两种变体：</p>
<ol>
<li>使用 <code>str.charAt(0)</code>，因为它总是会返回一个字符串（可能为空）。</li>
<li>为空字符添加测试。</li>
</ol>
<p>这是第二种变体：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ucFirst</span>(<span class="hljs-params">str</span>) </span>{
  <span class="hljs-keyword">if</span> (!str) <span class="hljs-keyword">return</span> str;

  <span class="hljs-keyword">return</span> str[<span class="hljs-number">0</span>].toUpperCase() + str.slice(<span class="hljs-number">1</span>);
}

alert( ucFirst(<span class="hljs-string">&quot;john&quot;</span>) ); <span class="hljs-comment">// John</span></code></pre>

      </fieldset>
      
      <fieldset id='_BoT3Iw'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="首字母大写">首字母大写</h1>
<p>写一个函数 <code>ucFirst(str)</code>，并返回首字母大写的字符串 <code>str</code>，例如：</p>
<pre><code class="language-js">ucFirst(<span class="hljs-string">&quot;john&quot;</span>) == <span class="hljs-string">&quot;John&quot;</span>;</code></pre>

      </fieldset>
      
      <fieldset id='_1e10QI'>
      <legend>solution</legend>
      <p>为了使搜索不区分大小写，我们将字符串改为小写，然后搜索：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkSpam</span>(<span class="hljs-params">str</span>) </span>{
  <span class="hljs-keyword">let</span> lowerStr = str.toLowerCase();

  <span class="hljs-keyword">return</span> lowerStr.includes(<span class="hljs-string">&#x27;viagra&#x27;</span>) || lowerStr.includes(<span class="hljs-string">&#x27;xxx&#x27;</span>);
}

alert( checkSpam(<span class="hljs-string">&#x27;buy ViAgRA now&#x27;</span>) );
alert( checkSpam(<span class="hljs-string">&#x27;free xxxxx&#x27;</span>) );
alert( checkSpam(<span class="hljs-string">&quot;innocent rabbit&quot;</span>) );</code></pre>

      </fieldset>
      
      <fieldset id='_yPpf6u'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="检查-spam">检查 spam</h1>
<p>写一个函数 <code>checkSpam(str)</code>，如果 <code>str</code> 包含 <code>viagra</code> 或 <code>XXX</code> 就返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p>函数必须不区分大小写：</p>
<pre><code class="language-js">checkSpam(<span class="hljs-string">&#x27;buy ViAgRA now&#x27;</span>) == <span class="hljs-literal">true</span>
checkSpam(<span class="hljs-string">&#x27;free xxxxx&#x27;</span>) == <span class="hljs-literal">true</span>
checkSpam(<span class="hljs-string">&quot;innocent rabbit&quot;</span>) == <span class="hljs-literal">false</span></code></pre>

      </fieldset>
      
      <fieldset id='_3eiQKg'>
      <legend>solution</legend>
      <p>最大长度必须是 <code>maxlength</code>，因此为了给省略号留空间我们需要缩短它。</p>
<p>请注意，省略号实际上有一个单独的 unicode 字符，而不是三个点。</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">truncate</span>(<span class="hljs-params">str, maxlength</span>) </span>{
  <span class="hljs-keyword">return</span> (str.length &gt; maxlength) ?
    str.slice(<span class="hljs-number">0</span>, maxlength - <span class="hljs-number">1</span>) + <span class="hljs-string">&#x27;…&#x27;</span> : str;
}</code></pre>

      </fieldset>
      
      <fieldset id='_38f5zn'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="截断文本">截断文本</h1>
<p>创建函数 <code>truncate(str, maxlength)</code> 来检查 <code>str</code> 的长度，如果超过 <code>maxlength</code> —— 应使用 <code>&quot;…&quot;</code> 来代替 <code>str</code> 的结尾部分，长度仍然等于 <code>maxlength</code>。</p>
<p>函数的结果应该是截断后的文本（如果需要的话）。</p>
<p>例如：</p>
<pre><code class="language-js">truncate(<span class="hljs-string">&quot;What I&#x27;d like to tell on this topic is:&quot;</span>, <span class="hljs-number">20</span>) = <span class="hljs-string">&quot;What I&#x27;d like to te…&quot;</span>

truncate(<span class="hljs-string">&quot;Hi everyone!&quot;</span>, <span class="hljs-number">20</span>) = <span class="hljs-string">&quot;Hi everyone!&quot;</span></code></pre>

      </fieldset>
      
      <fieldset id='_aZxWrz'>
      <legend>solution</legend>
      
      </fieldset>
      
      <fieldset id='_PNk38j'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="提取货币">提取货币</h1>
<p>我们有以 <code>&quot;$120&quot;</code> 这样的格式表示的花销。意味着：先是美元符号，然后才是数值。</p>
<p>创建函数 <code>extractCurrencyValue(str)</code> 从字符串中提取数值并返回。</p>
<p>例如：</p>
<pre><code class="language-js">alert( extractCurrencyValue(<span class="hljs-string">&#x27;$120&#x27;</span>) === <span class="hljs-number">120</span> ); <span class="hljs-comment">// true</span></code></pre>

      </fieldset>
      
      <fieldset id='_TvaBRN'>
      <legend>article</legend>
      <h1 id="字符串">字符串</h1>
<p>在 JavaScript 中，文本数据被以字符串形式存储，单个字符没有单独的类型。</p>
<p>字符串的内部格式始终是 <a href="https://en.wikipedia.org/wiki/UTF-16">UTF-16</a>，它不依赖于页面编码。</p>
<h2 id="引号（quotes）">引号（Quotes）</h2>
<p>让我们回忆一下引号的种类。</p>
<p>字符串可以包含在单引号、双引号或反引号中：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> single = <span class="hljs-string">&#x27;single-quoted&#x27;</span>;
<span class="hljs-keyword">let</span> double = <span class="hljs-string">&quot;double-quoted&quot;</span>;

<span class="hljs-keyword">let</span> backticks = <span class="hljs-string">`backticks`</span>;</code></pre>
<p>单引号和双引号基本相同。但是，反引号允许我们通过 <code>${…}</code> 将任何表达式嵌入到字符串中：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">return</span> a + b;
}

alert(<span class="hljs-string">`1 + 2 = <span class="hljs-subst">${sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)}</span>.`</span>); <span class="hljs-comment">// 1 + 2 = 3.</span></code></pre>
<p>使用反引号的另一个优点是它们允许字符串跨行：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> guestList = <span class="hljs-string">`Guests:
 * John
 * Pete
 * Mary
`</span>;

alert(guestList); <span class="hljs-comment">// 客人清单，多行</span></code></pre>
<p>看起来很自然，不是吗？但是单引号和双引号可不能这样做。</p>
<p>如果我们使用单引号或双引号来实现字符串跨行的话，则会出现错误：</p>
<pre><code class="language-js">let guestList = &quot;Guests: // Error: Unexpected token ILLEGAL
  * John&quot;;</code></pre>
<p>当不考虑多行字符串的需要时，单引号和双引号来自语言创建的古时代。反引号出现较晚，因此更通用。</p>
<p>反引号还允许我们在第一个反引号之前指定一个“模版函数”。语法是：<code>func&#96;string&#96;</code>。函数 <code>func</code> 被自动调用，接收字符串和嵌入式表达式，并处理它们。你可以在 <a href="mdn:/JavaScript/Reference/Template_literals#Tagged_template_literals">docs</a> 中阅读更多关于它们的信息。这叫做 &quot;tagged templates&quot;。此功能可以更轻松地将字符串包装到自定义模版或其他函数中，但这很少使用。</p>
<h2 id="特殊字符">特殊字符</h2>
<p>我们仍然可以通过使用“换行符（newline character）”，以支持使用单引号和双引号来创建跨行字符串。换行符写作 <code>\n</code>，用来表示换行：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> guestList = <span class="hljs-string">&quot;Guests:\n * John\n * Pete\n * Mary&quot;</span>;

alert(guestList); <span class="hljs-comment">// 一个多行的客人列表</span></code></pre>
<p>例如，这两行描述的是一样的，只是书写方式不同：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> str1 = <span class="hljs-string">&quot;Hello\nWorld&quot;</span>; <span class="hljs-comment">// 使用“换行符”创建的两行字符串</span>

<span class="hljs-comment">// 使用反引号和普通的换行创建的两行字符串</span>
<span class="hljs-keyword">let</span> str2 = <span class="hljs-string">`Hello
World`</span>;

alert(str1 == str2); <span class="hljs-comment">// true</span></code></pre>
<p>还有其他不常见的“特殊”字符。</p>
<p>这是完整列表：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>\n</code></td>
<td>换行</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>回车：不单独使用。Windows 文本文件使用两个字符 <code>\r\n</code> 的组合来表示换行。</td>
</tr>
<tr>
<td><code>\&#39;</code>, <code>\&quot;</code></td>
<td>引号</td>
</tr>
<tr>
<td><code>\\</code></td>
<td>反斜线</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>制表符</td>
</tr>
<tr>
<td><code>\b</code>, <code>\f</code>, <code>\v</code></td>
<td>退格，换页，垂直标签 —— 为了兼容性，现在已经不使用了。</td>
</tr>
<tr>
<td><code>\xXX</code></td>
<td>具有给定十六进制 Unicode <code>XX</code> 的 Unicode 字符，例如：<code>&#39;\x7A&#39;</code> 和 <code>&#39;z&#39;</code> 相同。</td>
</tr>
<tr>
<td><code>\uXXXX</code></td>
<td>以 UTF-16 编码的十六进制代码 <code>XXXX</code> 的 unicode 字符，例如 <code>\u00A9</code> —— 是版权符号 <code>©</code> 的 unicode。它必须正好是 4 个十六进制数字。</td>
</tr>
<tr>
<td><code>\u{X…XXXXXX}</code>（1 到 6 个十六进制字符）</td>
<td>具有给定 UTF-32 编码的 unicode 符号。一些罕见的字符用两个 unicode 符号编码，占用 4 个字节。这样我们就可以插入长代码了。</td>
</tr>
</tbody></table>
<p>unicode 示例：</p>
<pre><code class="language-js">alert( <span class="hljs-string">&quot;\u00A9&quot;</span> ); <span class="hljs-comment">// ©</span>
alert( <span class="hljs-string">&quot;\u{20331}&quot;</span> ); <span class="hljs-comment">// 佫，罕见的中国象形文字（长 unicode）</span>
alert( <span class="hljs-string">&quot;\u{1F60D}&quot;</span> ); <span class="hljs-comment">// 😍，笑脸符号（另一个长 unicode）</span></code></pre>
<p>所有的特殊字符都以反斜杠字符 <code>\</code> 开始。它也被称为“转义字符”。</p>
<p>如果我们想要在字符串中插入一个引号，我们也会使用它。</p>
<p>例如：</p>
<pre><code class="language-js">alert( <span class="hljs-string">&#x27;I*!*\&#x27;*/!*m the Walrus!&#x27;</span> ); <span class="hljs-comment">// *!*I&#x27;m*/!* the Walrus!</span></code></pre>
<p>正如你所看到的，我们必须在内部引号前加上反斜杠 <code>\&#39;</code>，否则它将表示字符串结束。</p>
<p>当然，只有与外部闭合引号相同的引号才需要转义。因此，作为一个更优雅的解决方案，我们可以改用双引号或者反引号：</p>
<pre><code class="language-js">alert( <span class="hljs-string">`I&#x27;m the Walrus!`</span> ); <span class="hljs-comment">// I&#x27;m the Walrus!</span></code></pre>
<p>注意反斜杠 <code>\</code> 在 JavaScript 中用于正确读取字符串，然后消失。内存中的字符串没有 <code>\</code>。你从上述示例中的 <code>alert</code> 可以清楚地看到这一点。</p>
<p>但是如果我们需要在字符串中显示一个实际的反斜杠 <code>\</code> 应该怎么做？</p>
<p>我们可以这样做，只需要将其书写两次 <code>\\</code>：</p>
<pre><code class="language-js">alert( <span class="hljs-string">`The backslash: \\`</span> ); <span class="hljs-comment">// The backslash: \</span></code></pre>
<h2 id="字符串长度">字符串长度</h2>
<p><code>length</code> 属性表示字符串长度：</p>
<pre><code class="language-js">alert( <span class="hljs-string">`My\n`</span>.length ); <span class="hljs-comment">// 3</span></code></pre>
<p>注意 <code>\n</code> 是一个单独的“特殊”字符，所以长度确实是 <code>3</code>。</p>
<p>```warn header=&quot;<code>length</code> 是一个属性&quot;
掌握其他编程语言的人，有时会错误地调用 <code>str.length()</code> 而不是 <code>str.length</code>。这是行不通的。</p>
<p>请注意 <code>str.length</code> 是一个数字属性，而不是函数。后面不需要添加括号。</p>
<pre><code>
## 访问字符

要获取在 `pos` 位置的一个字符，可以使用方括号 `[pos]` 或者调用 [str.charAt(pos)](mdn:js/String/charAt) 方法。第一个字符从零位置开始：

```js run
let str = `Hello`;

// 第一个字符
alert( str[0] ); // H
alert( str.charAt(0) ); // H

// 最后一个字符
alert( str[str.length - 1] ); // o</code></pre>
<p>方括号是获取字符的一种现代化方法，而 <code>charAt</code> 是历史原因才存在的。</p>
<p>它们之间的唯一区别是，如果没有找到字符，<code>[]</code> 返回 <code>undefined</code>，而 <code>charAt</code> 返回一个空字符串：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">`Hello`</span>;

alert( str[<span class="hljs-number">1000</span>] ); <span class="hljs-comment">// undefined</span>
alert( str.charAt(<span class="hljs-number">1000</span>) ); <span class="hljs-comment">// &#x27;&#x27;（空字符串）</span></code></pre>
<p>我们也可以使用 <code>for..of</code> 遍历字符：</p>
<pre><code class="language-js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> char <span class="hljs-keyword">of</span> <span class="hljs-string">&quot;Hello&quot;</span>) {
  alert(char); <span class="hljs-comment">// H,e,l,l,o（char 变为 &quot;H&quot;，然后是 &quot;e&quot;，然后是 &quot;l&quot; 等）</span>
}</code></pre>
<h2 id="字符串是不可变的">字符串是不可变的</h2>
<p>在 JavaScript 中，字符串不可更改。改变字符是不可能的。</p>
<p>我们证明一下为什么不可能：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;Hi&#x27;</span>;

str[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;h&#x27;</span>; <span class="hljs-comment">// error</span>
alert( str[<span class="hljs-number">0</span>] ); <span class="hljs-comment">// 无法运行</span></code></pre>
<p>通常的解决方法是创建一个新的字符串，并将其分配给 <code>str</code> 而不是以前的字符串。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;Hi&#x27;</span>;

str = <span class="hljs-string">&#x27;h&#x27;</span> + str[<span class="hljs-number">1</span>];  <span class="hljs-comment">// 替换字符串</span>

alert( str ); <span class="hljs-comment">// hi</span></code></pre>
<p>在接下来的章节，我们将看到更多相关示例。</p>
<h2 id="改变大小写">改变大小写</h2>
<p><a href="mdn:js/String/toLowerCase">toLowerCase()</a> 和 <a href="mdn:js/String/toUpperCase">toUpperCase()</a> 方法可以改变大小写：</p>
<pre><code class="language-js">alert( <span class="hljs-string">&#x27;Interface&#x27;</span>.toUpperCase() ); <span class="hljs-comment">// INTERFACE</span>
alert( <span class="hljs-string">&#x27;Interface&#x27;</span>.toLowerCase() ); <span class="hljs-comment">// interface</span></code></pre>
<p>或者我们想要使一个字符变成小写：</p>
<pre><code class="language-js">alert( <span class="hljs-string">&#x27;Interface&#x27;</span>[<span class="hljs-number">0</span>].toLowerCase() ); <span class="hljs-comment">// &#x27;i&#x27;</span></code></pre>
<h2 id="查找子字符串">查找子字符串</h2>
<p>在字符串中查找子字符串有很多种方法。</p>
<h3 id="strindexof">str.indexOf</h3>
<p>第一个方法是 <a href="mdn:js/String/indexOf">str.indexOf(substr, pos)</a>。</p>
<p>它从给定位置 <code>pos</code> 开始，在 <code>str</code> 中查找 <code>substr</code>，如果没有找到，则返回 <code>-1</code>，否则返回匹配成功的位置。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;Widget with id&#x27;</span>;

alert( str.indexOf(<span class="hljs-string">&#x27;Widget&#x27;</span>) ); <span class="hljs-comment">// 0，因为 &#x27;Widget&#x27; 一开始就被找到</span>
alert( str.indexOf(<span class="hljs-string">&#x27;widget&#x27;</span>) ); <span class="hljs-comment">// -1，没有找到，检索是大小写敏感的</span>

alert( str.indexOf(<span class="hljs-string">&quot;id&quot;</span>) ); <span class="hljs-comment">// 1，&quot;id&quot; 在位置 1 处（……idget 和 id）</span></code></pre>
<p>可选的第二个参数允许我们从给定的起始位置开始检索。</p>
<p>例如，<code>&quot;id&quot;</code> 第一次出现的位置是 <code>1</code>。查询下一个存在位置时，我们从 <code>2</code> 开始检索：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;Widget with id&#x27;</span>;

alert( str.indexOf(<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-number">2</span>) ) <span class="hljs-comment">// 12</span></code></pre>
<p>如果我们对所有存在位置都感兴趣，可以在一个循环中使用 <code>indexOf</code>。每一次新的调用都发生在上一匹配位置之后：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;As sly as a fox, as strong as an ox&#x27;</span>;

<span class="hljs-keyword">let</span> target = <span class="hljs-string">&#x27;as&#x27;</span>; <span class="hljs-comment">// 这是我们要查找的目标</span>

<span class="hljs-keyword">let</span> pos = <span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">let</span> foundPos = str.indexOf(target, pos);
  <span class="hljs-keyword">if</span> (foundPos == -<span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;

  alert( <span class="hljs-string">`Found at <span class="hljs-subst">${foundPos}</span>`</span> );
  pos = foundPos + <span class="hljs-number">1</span>; <span class="hljs-comment">// 继续从下一个位置查找</span>
}</code></pre>
<p>相同的算法可以简写：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;As sly as a fox, as strong as an ox&quot;</span>;
<span class="hljs-keyword">let</span> target = <span class="hljs-string">&quot;as&quot;</span>;

*!*
<span class="hljs-keyword">let</span> pos = -<span class="hljs-number">1</span>;
<span class="hljs-keyword">while</span> ((pos = str.indexOf(target, pos + <span class="hljs-number">1</span>)) != -<span class="hljs-number">1</span>) {
  alert( pos );
}
*/!*</code></pre>
<p>```smart header=&quot;<code>str.lastIndexOf(substr, pos)</code>&quot;
还有一个类似的方法 <a href="mdn:js/String/lastIndexOf">str.lastIndexOf(substr, position)</a>，它从字符串的末尾开始搜索到开头。</p>
<p>它会以相反的顺序列出这些事件。</p>
<pre><code>
在 `if` 测试中 `indexOf` 有一点不方便。我们不能像这样把它放在 `if` 中：

```js run
let str = &quot;Widget with id&quot;;

if (str.indexOf(&quot;Widget&quot;)) {
    alert(&quot;We found it&quot;); // 不工作！
}</code></pre>
<p>上述示例中的 <code>alert</code> 不会显示，因为 <code>str.indexOf(&quot;Widget&quot;)</code> 返回 <code>0</code>（意思是它在起始位置就查找到了匹配项）。是的，但是 <code>if</code> 认为 <code>0</code> 表示 <code>false</code>。</p>
<p>因此我们应该检查 <code>-1</code>，像这样：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;Widget with id&quot;</span>;

*!*
<span class="hljs-keyword">if</span> (str.indexOf(<span class="hljs-string">&quot;Widget&quot;</span>) != -<span class="hljs-number">1</span>) {
*/!*
    alert(<span class="hljs-string">&quot;We found it&quot;</span>); <span class="hljs-comment">// 现在工作了！</span>
}</code></pre>
<h4 id="按位（bitwise）not-技巧">按位（bitwise）NOT 技巧</h4>
<p>这里使用的一个老技巧是 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Bitwise_NOT">bitwise NOT</a> <code>~</code> 运算符。它将数字转换为 32-bit 整数（如果存在小数部分，则删除小数部分），然后对其二进制表示形式中的所有位均取反。</p>
<p>实际上，这意味着一件很简单的事儿：对于 32-bit 整数，<code>~n</code> 等于 <code>-(n+1)</code>。</p>
<p>例如：</p>
<pre><code class="language-js">alert( ~<span class="hljs-number">2</span> ); <span class="hljs-comment">// -3，和 -(2+1) 相同</span>
alert( ~<span class="hljs-number">1</span> ); <span class="hljs-comment">// -2，和 -(1+1) 相同</span>
alert( ~<span class="hljs-number">0</span> ); <span class="hljs-comment">// -1，和 -(0+1) 相同</span>
*!*
alert( ~-<span class="hljs-number">1</span> ); <span class="hljs-comment">// 0，和 -(-1+1) 相同</span>
*/!*</code></pre>
<p>正如我们看到这样，只有当 <code>n == -1</code> 时，<code>~n</code> 才为零（适用于任何 32-bit 带符号的整数 <code>n</code>）。</p>
<p>因此，仅当 <code>indexOf</code> 的结果不是 <code>-1</code> 时，检查 <code>if ( ~str.indexOf(&quot;...&quot;) )</code> 才为真。换句话说，当有匹配时。</p>
<p>人们用它来简写 <code>indexOf</code> 检查：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;Widget&quot;</span>;

<span class="hljs-keyword">if</span> (~str.indexOf(<span class="hljs-string">&quot;Widget&quot;</span>)) {
  alert( <span class="hljs-string">&#x27;Found it!&#x27;</span> ); <span class="hljs-comment">// 正常运行</span>
}</code></pre>
<p>通常不建议以非显而易见的方式使用语言特性，但这种特殊技巧在旧代码中仍被广泛使用，所以我们应该理解它。</p>
<p>只要记住：<code>if (~str.indexOf(...))</code> 读作 &quot;if found&quot;。</p>
<p>确切地说，由于 <code>~</code> 运算符将大数字截断为 32 位，因此存在给出 <code>0</code> 的其他数字，最小的数字是 <code>~4294967295=0</code>。这使得这种检查只有在字符串没有那么长的情况下才是正确的。</p>
<p>现在我们只会在旧的代码中看到这个技巧，因为现代 JavaScript 提供了 <code>.includes</code> 方法（见下文）。</p>
<h3 id="includes，startswith，endswith">includes，startsWith，endsWith</h3>
<p>更现代的方法 <a href="mdn:js/String/includes">str.includes(substr, pos)</a> 根据 <code>str</code> 中是否包含 <code>substr</code> 来返回 <code>true/false</code>。</p>
<p>如果我们需要检测匹配，但不需要它的位置，那么这是正确的选择：</p>
<pre><code class="language-js">alert( <span class="hljs-string">&quot;Widget with id&quot;</span>.includes(<span class="hljs-string">&quot;Widget&quot;</span>) ); <span class="hljs-comment">// true</span>

alert( <span class="hljs-string">&quot;Hello&quot;</span>.includes(<span class="hljs-string">&quot;Bye&quot;</span>) ); <span class="hljs-comment">// false</span></code></pre>
<p><code>str.includes</code> 的第二个可选参数是开始搜索的起始位置：</p>
<pre><code class="language-js">alert( <span class="hljs-string">&quot;Midget&quot;</span>.includes(<span class="hljs-string">&quot;id&quot;</span>) ); <span class="hljs-comment">// true</span>
alert( <span class="hljs-string">&quot;Midget&quot;</span>.includes(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-number">3</span>) ); <span class="hljs-comment">// false, 从位置 3 开始没有 &quot;id&quot;</span></code></pre>
<p>方法 <a href="mdn:js/String/startsWith">str.startsWith</a> 和 <a href="mdn:js/String/endsWith">str.endsWith</a> 的功能与其名称所表示的意思相同：</p>
<pre><code class="language-js">alert( <span class="hljs-string">&quot;Widget&quot;</span>.startsWith(<span class="hljs-string">&quot;Wid&quot;</span>) ); <span class="hljs-comment">// true，&quot;Widget&quot; 以 &quot;Wid&quot; 开始</span>
alert( <span class="hljs-string">&quot;Widget&quot;</span>.endsWith(<span class="hljs-string">&quot;get&quot;</span>) ); <span class="hljs-comment">// true，&quot;Widget&quot; 以 &quot;get&quot; 结束</span></code></pre>
<h2 id="获取子字符串">获取子字符串</h2>
<p>JavaScript 中有三种获取字符串的方法：<code>substring</code>、<code>substr</code> 和 <code>slice</code>。</p>
<p><code>str.slice(start [, end])</code>
: 返回字符串从 <code>start</code> 到（但不包括）<code>end</code> 的部分。</p>
<pre><code>例如：

```js run
let str = &quot;stringify&quot;;
alert( str.slice(0, 5) ); // &#x27;strin&#x27;，从 0 到 5 的子字符串（不包括 5）
alert( str.slice(0, 1) ); // &#x27;s&#x27;，从 0 到 1，但不包括 1，所以只有在 0 处的字符
```

如果没有第二个参数，`slice` 会一直运行到字符串末尾：

```js run
let str = &quot;st*!*ringify*/!*&quot;;
alert( str.slice(2) ); // 从第二个位置直到结束
```

`start/end` 也有可能是负值。它们的意思是起始位置从字符串结尾计算：

```js run
let str = &quot;strin*!*gif*/!*y&quot;;

// 从右边的第四个位置开始，在右边的第一个位置结束
alert( str.slice(-4, -1) ); // &#x27;gif&#x27;
```</code></pre>
<p><code>str.substring(start [, end])</code>
: 返回字符串在 <code>start</code> 和 <code>end</code> <strong>之间</strong> 的部分。</p>
<pre><code>这与 `slice` 几乎相同，但它允许 `start` 大于 `end`。

例如：

```js run
let str = &quot;st*!*ring*/!*ify&quot;;

// 这些对于 substring 是相同的
alert( str.substring(2, 6) ); // &quot;ring&quot;
alert( str.substring(6, 2) ); // &quot;ring&quot;

// ……但对 slice 是不同的：
alert( str.slice(2, 6) ); // &quot;ring&quot;（一样）
alert( str.slice(6, 2) ); // &quot;&quot;（空字符串）

```

不支持负参数（不像 slice），它们被视为 `0`。</code></pre>
<p><code>str.substr(start [, length])</code>
: 返回字符串从 <code>start</code> 开始的给定 <code>length</code> 的部分。</p>
<pre><code>与以前的方法相比，这个允许我们指定 `length` 而不是结束位置：

```js run
let str = &quot;st*!*ring*/!*ify&quot;;
alert( str.substr(2, 4) ); // &#x27;ring&#x27;，从位置 2 开始，获取 4 个字符
```

第一个参数可能是负数，从结尾算起：

```js run
let str = &quot;strin*!*gi*/!*fy&quot;;
alert( str.substr(-4, 2) ); // &#x27;gi&#x27;，从第 4 位获取 2 个字符
```</code></pre>
<p>我们回顾一下这些方法，以免混淆：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>选择方式……</th>
<th>负值参数</th>
</tr>
</thead>
<tbody><tr>
<td><code>slice(start, end)</code></td>
<td>从 <code>start</code> 到 <code>end</code>（不含 <code>end</code>）</td>
<td>允许</td>
</tr>
<tr>
<td><code>substring(start, end)</code></td>
<td><code>start</code> 与 <code>end</code> 之间（包括 <code>start</code>，但不包括 <code>end</code>）</td>
<td>负值代表 <code>0</code></td>
</tr>
<tr>
<td><code>substr(start, length)</code></td>
<td>从 <code>start</code> 开始获取长为 <code>length</code> 的字符串</td>
<td>允许 <code>start</code> 为负数</td>
</tr>
</tbody></table>
<pre><code class="language-smart">它们可以完成这项工作。形式上，`substr` 有一个小缺点：它不是在 JavaScript 核心规范中描述的，而是在附录 B 中，它涵盖了主要由于历史原因而存在的仅浏览器特性。因此，非浏览器环境可能无法支持它。但实际上它在任何地方都有效。

相较于其他两个变体，`slice` 稍微灵活一些，它允许以负值作为参数并且写法更简短。因此仅仅记住这三种方法中的 `slice` 就足够了。</code></pre>
<h2 id="比较字符串">比较字符串</h2>
<p>正如我们从 <a href="info:comparison">info:comparison</a> 一章中了解到的，字符串按字母顺序逐字比较。</p>
<p>不过，也有一些奇怪的地方。</p>
<ol>
<li><p>小写字母总是大于大写字母：</p>
<pre><code class="language-js">alert( <span class="hljs-string">&#x27;a&#x27;</span> &gt; <span class="hljs-string">&#x27;Z&#x27;</span> ); <span class="hljs-comment">// true</span></code></pre>
</li>
<li><p>带变音符号的字母存在“乱序”的情况：</p>
<pre><code class="language-js">alert( <span class="hljs-string">&#x27;Österreich&#x27;</span> &gt; <span class="hljs-string">&#x27;Zealand&#x27;</span> ); <span class="hljs-comment">// true</span></code></pre>
<p> 如果我们对这些国家名进行排序，可能会导致奇怪的结果。通常，人们会期望 <code>Zealand</code> 在名单中的 <code>Österreich</code> 之后出现。</p>
</li>
</ol>
<p>为了明白发生了什么，我们回顾一下在 JavaScript 中字符串的内部表示。</p>
<p>所有的字符串都使用 <a href="https://en.wikipedia.org/wiki/UTF-16">UTF-16</a> 编码。即：每个字符都有对应的数字代码。有特殊的方法可以获取代码表示的字符，以及字符对应的代码。</p>
<p><code>str.codePointAt(pos)</code>
: 返回在 <code>pos</code> 位置的字符代码 :</p>
<pre><code>```js run
// 不同的字母有不同的代码
alert( &quot;z&quot;.codePointAt(0) ); // 122
alert( &quot;Z&quot;.codePointAt(0) ); // 90
```</code></pre>
<p><code>String.fromCodePoint(code)</code>
: 通过数字 <code>code</code> 创建字符</p>
<pre><code>```js run
alert( String.fromCodePoint(90) ); // Z
```

我们还可以用 `\u` 后跟十六进制代码，通过这些代码添加 unicode 字符：

```js run
// 在十六进制系统中 90 为 5a
alert( &#x27;\u005a&#x27; ); // Z
```</code></pre>
<p>现在我们看一下代码为 <code>65..220</code> 的字符（拉丁字母和一些额外的字符），方法是创建一个字符串：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;&#x27;</span>;

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">65</span>; i &lt;= <span class="hljs-number">220</span>; i++) {
  str += <span class="hljs-built_in">String</span>.fromCodePoint(i);
}
alert( str );
<span class="hljs-comment">// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~</span>
<span class="hljs-comment">// ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ</span></code></pre>
<p>看到没？先是大写字符，然后是一些特殊字符，然后是小写字符，而 <code>Ö</code> 几乎是最后输出。</p>
<p>现在很明显为什么 <code>a &gt; Z</code>。</p>
<p>字符通过数字代码进行比较。越大的代码意味着字符越大。<code>a</code>（97）的代码大于 <code>Z</code>（90）的代码。</p>
<ul>
<li>所有小写字母追随在大写字母之后，因为它们的代码更大。</li>
<li>一些像 <code>Ö</code> 的字母与主要字母表不同。这里，它的代码比任何从 <code>a</code> 到 <code>z</code> 的代码都要大。</li>
</ul>
<h3 id="正确的比较">正确的比较</h3>
<p>执行字符串比较的“正确”算法比看起来更复杂，因为不同语言的字母都不相同。</p>
<p>因此浏览器需要知道要比较的语言。</p>
<p>幸运的是，所有现代浏览器（IE10- 需要额外的库 <a href="https://github.com/andyearnshaw/Intl.js/">Intl.JS</a>) 都支持国际化标准 <a href="http://www.ecma-international.org/ecma-402/1.0/ECMA-402.pdf">ECMA-402</a>。</p>
<p>它提供了一种特殊的方法来比较不同语言的字符串，遵循它们的规则。</p>
<p>调用 <a href="mdn:js/String/localeCompare">str.localeCompare(str2)</a> 会根据语言规则返回一个整数，这个整数能表明 <code>str</code> 是否在 <code>str2</code> 前，后或者等于它：</p>
<ul>
<li>如果 <code>str</code> 小于 <code>str2</code> 则返回负数。</li>
<li>如果 <code>str</code> 大于 <code>str2</code> 则返回正数。</li>
<li>如果它们相等则返回 <code>0</code>。</li>
</ul>
<p>例如：</p>
<pre><code class="language-js">alert( <span class="hljs-string">&#x27;Österreich&#x27;</span>.localeCompare(<span class="hljs-string">&#x27;Zealand&#x27;</span>) ); <span class="hljs-comment">// -1</span></code></pre>
<p>这个方法实际上在 <a href="mdn:js/String/localeCompare">文档</a> 中指定了两个额外的参数，这两个参数允许它指定语言（默认语言从环境中获取，字符顺序视语言不同而不同）并设置诸如区别大小之类的附加规则，或应该将 <code>&quot;a&quot;</code> 和 <code>&quot;á&quot;</code> 看作相等情况等。</p>
<h2 id="内部，unicode">内部，Unicode</h2>
<pre><code class="language-warn">这部分会深入字符串内部。如果你计划处理 emoji、罕见的数学或象形文字或其他罕见的符号，这些知识会对你有用。

如果你不打算支持它们，你可以跳过这一部分。</code></pre>
<h3 id="代理对">代理对</h3>
<p>所有常用的字符都是一个 2 字节的代码。大多数欧洲语言，数字甚至大多数象形文字中的字母都有 2 字节的表示形式。</p>
<p>但 2 字节只允许 65536 个组合，这对于表示每个可能的符号是不够的。所以稀有的符号被称为“代理对”的一对 2 字节的符号编码。</p>
<p>这些符号的长度是 <code>2</code>：</p>
<pre><code class="language-js">alert( <span class="hljs-string">&#x27;𝒳&#x27;</span>.length ); <span class="hljs-comment">// 2，大写数学符号 X</span>
alert( <span class="hljs-string">&#x27;😂&#x27;</span>.length ); <span class="hljs-comment">// 2，笑哭表情</span>
alert( <span class="hljs-string">&#x27;𩷶&#x27;</span>.length ); <span class="hljs-comment">// 2，罕见的中国象形文字</span></code></pre>
<p>注意，代理对在 JavaScript 被创建时并不存在，因此无法被编程语言正确处理！</p>
<p>我们实际上在上面的每个字符串中都有一个符号，但 <code>length</code> 显示长度为 <code>2</code>。</p>
<p><code>String.fromCodePoint</code> 和 <code>str.codePointAt</code> 是几种处理代理对的少数方法。它们最近才出现在编程语言中。在它们之前，只有 <a href="mdn:js/String/fromCharCode">String.fromCharCode</a> 和 <a href="mdn:js/String/charCodeAt">str.charCodeAt</a>。这些方法实际上与 <code>fromCodePoint/codePointAt</code> 相同，但是不适用于代理对。</p>
<p>获取符号可能会非常麻烦，因为代理对被认为是两个字符：</p>
<pre><code class="language-js">alert( <span class="hljs-string">&#x27;𝒳&#x27;</span>[<span class="hljs-number">0</span>] ); <span class="hljs-comment">// 奇怪的符号……</span>
alert( <span class="hljs-string">&#x27;𝒳&#x27;</span>[<span class="hljs-number">1</span>] ); <span class="hljs-comment">// ……代理对的一块</span></code></pre>
<p>请注意，代理对的各部分没有任何意义。因此，上述示例中的 alert 显示的实际上是垃圾信息。</p>
<p>技术角度来说，代理对也是可以通过它们的代码检测到的：如果一个字符的代码在 <code>0xd800..0xdbff</code> 范围内，那么它是代理对的第一部分。下一个字符（第二部分）必须在 <code>0xdc00..0xdfff</code> 范围中。这些范围是按照标准专门为代理对保留的。</p>
<p>在上述示例中：</p>
<pre><code class="language-js"><span class="hljs-comment">// charCodeAt 不理解代理对，所以它给出了代理对的代码</span>

alert( <span class="hljs-string">&#x27;𝒳&#x27;</span>.charCodeAt(<span class="hljs-number">0</span>).toString(<span class="hljs-number">16</span>) ); <span class="hljs-comment">// d835，在 0xd800 和 0xdbff 之间</span>
alert( <span class="hljs-string">&#x27;𝒳&#x27;</span>.charCodeAt(<span class="hljs-number">1</span>).toString(<span class="hljs-number">16</span>) ); <span class="hljs-comment">// dcb3, 在 0xdc00 和 0xdfff 之间</span></code></pre>
<p>本章节后面的 <a href="info:iterable">info:iterable</a> 章节中，你可以找到更多处理代理对的方法。可能也专门的库，这里没有什么足够好的建议了。</p>
<h3 id="变音符号与规范化">变音符号与规范化</h3>
<p>在许多语言中，都有一些由基本字符组成的符号，在其上方/下方有一个标记。</p>
<p>例如，字母 <code>a</code> 可以是 <code>àáâäãåā</code> 的基本字符。最常见的“复合”字符在 UTF-16 表中都有自己的代码。但不是全部，因为可能的组合太多。</p>
<p>为了支持任意组合，UTF-16 允许我们使用多个 unicode 字符：基本字符紧跟“装饰”它的一个或多个“标记”字符。</p>
<p>例如，如果我们 <code>S</code> 后跟有特殊的 &quot;dot above&quot; 字符（代码 <code>\u0307</code>），则显示 Ṡ。</p>
<pre><code class="language-js">alert( <span class="hljs-string">&#x27;S\u0307&#x27;</span> ); <span class="hljs-comment">// Ṡ</span></code></pre>
<p>如果我们需要在字母上方（或下方）添加额外的标记 —— 没问题，只需要添加必要的标记字符即可。</p>
<p>例如，如果我们追加一个字符 &quot;dot below&quot;（代码 <code>\u0323</code>），那么我们将得到“S 上面和下面都有点”的字符：<code>Ṩ</code>。</p>
<p>例如：</p>
<pre><code class="language-js">alert( <span class="hljs-string">&#x27;S\u0307\u0323&#x27;</span> ); <span class="hljs-comment">// Ṩ</span></code></pre>
<p>这在提供良好灵活性的同时，也存在一个有趣的问题：两个视觉上看起来相同的字符，可以用不同的 unicode 组合表示。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> s1 = <span class="hljs-string">&#x27;S\u0307\u0323&#x27;</span>; <span class="hljs-comment">// Ṩ，S + 上点 + 下点</span>
<span class="hljs-keyword">let</span> s2 = <span class="hljs-string">&#x27;S\u0323\u0307&#x27;</span>; <span class="hljs-comment">// Ṩ，S + 下点 + 上点</span>

alert( <span class="hljs-string">`s1: <span class="hljs-subst">${s1}</span>, s2: <span class="hljs-subst">${s2}</span>`</span> );

alert( s1 == s2 ); <span class="hljs-comment">// false，尽管字符看起来相同（?!）</span></code></pre>
<p>为了解决这个问题，有一个 “unicode 规范化”算法，它将每个字符串都转化成单个“通用”格式。</p>
<p>它由 <a href="mdn:js/String/normalize">str.normalize()</a> 实现。</p>
<pre><code class="language-js">alert( <span class="hljs-string">&quot;S\u0307\u0323&quot;</span>.normalize() == <span class="hljs-string">&quot;S\u0323\u0307&quot;</span>.normalize() ); <span class="hljs-comment">// true</span></code></pre>
<p>有趣的是，在实际情况下，<code>normalize()</code> 实际上将一个由 3 个字符组成的序列合并为一个：<code>\u1e68</code>（S 有两个点）。</p>
<pre><code class="language-js">alert( <span class="hljs-string">&quot;S\u0307\u0323&quot;</span>.normalize().length ); <span class="hljs-comment">// 1</span>

alert( <span class="hljs-string">&quot;S\u0307\u0323&quot;</span>.normalize() == <span class="hljs-string">&quot;\u1e68&quot;</span> ); <span class="hljs-comment">// true</span></code></pre>
<p>事实上，情况并非总是如此，因为符号 <code>Ṩ</code> 是“常用”的，所以 UTF-16 创建者把它包含在主表中并给它了对应的代码。</p>
<p>如果你想了解更多关于规范化规则和变体的信息 —— 它们在 Unicode 标准附录中有详细描述：<a href="http://www.unicode.org/reports/tr15/">Unicode 规范化形式</a>，但对于大多数实际目的来说，本文的内容就已经足够了。</p>
<h2 id="总结">总结</h2>
<ul>
<li>有 3 种类型的引号。反引号允许字符串跨越多行并可以使用 <code>${…}</code> 在字符串中嵌入表达式。</li>
<li>JavaScript 中的字符串使用的是 UTF-16 编码。</li>
<li>我们可以使用像 <code>\n</code> 这样的特殊字符或通过使用 <code>\u...</code> 来操作它们的 unicode 进行字符插入。 </li>
<li>获取字符时，使用 <code>[]</code>。</li>
<li>获取子字符串，使用 <code>slice</code> 或 <code>substring</code>。</li>
<li>字符串的大/小写转换，使用：<code>toLowerCase/toUpperCase</code>。</li>
<li>查找子字符串时，使用 <code>indexOf</code> 或 <code>includes/startsWith/endsWith</code> 进行简单检查。</li>
<li>根据语言比较字符串时使用 <code>localeCompare</code>，否则将按字符代码进行比较。</li>
</ul>
<p>还有其他几种有用的字符串方法：</p>
<ul>
<li><code>str.trim()</code> —— 删除字符串前后的空格 (&quot;trims&quot;)。</li>
<li><code>str.repeat(n)</code> —— 重复字符串 <code>n</code> 次。</li>
<li>……更多内容细节请参见 <a href="mdn:js/String">手册</a>。</li>
</ul>
<p>字符串还具有使用正则表达式进行搜索/替换的方法。但这个话题很大，因此我们将在本教程中单独的 <a href="info:regular-expressions">info:regular-expressions</a> 章节中进行讨论。</p>

      </fieldset>
      
      <fieldset id='_HqSH6k'>
      <legend>solution</legend>
      <p>结果是 <code>4</code>:</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">&quot;Apples&quot;</span>, <span class="hljs-string">&quot;Pear&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>];

<span class="hljs-keyword">let</span> shoppingCart = fruits;

shoppingCart.push(<span class="hljs-string">&quot;Banana&quot;</span>);

*!*
alert( fruits.length ); <span class="hljs-comment">// 4</span>
*/!*</code></pre>
<p>这是因为数组是对象。所以 <code>shoppingCart</code> 和 <code>fruits</code> 是同一数组的引用。</p>

      </fieldset>
      
      <fieldset id='_ScunOp'>
      <legend>task</legend>
      <p>importance: 3</p>
<hr>
<h1 id="数组被拷贝了吗">数组被拷贝了吗?</h1>
<p>下面的代码将会显示什么？</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">&quot;Apples&quot;</span>, <span class="hljs-string">&quot;Pear&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>];

<span class="hljs-comment">// 在“副本”里 push 了一个新的值</span>
<span class="hljs-keyword">let</span> shoppingCart = fruits;
shoppingCart.push(<span class="hljs-string">&quot;Banana&quot;</span>);

<span class="hljs-comment">// fruits 里面是什么？</span>
alert( fruits.length ); <span class="hljs-comment">// ?</span></code></pre>

      </fieldset>
      
      <fieldset id='_EHyJQk'>
      <legend>solution</legend>
      <h1 id="慢的解决方案">慢的解决方案</h1>
<p>我们可以计算所有可能的子集的和。</p>
<p>最简单的方法就是获取每个元素然后计算从它开始所有子数组的和。</p>
<p>以 <code>[-1, 2, 3, -9, 11]</code> 为例：</p>
<pre><code class="language-js"><span class="hljs-comment">// 从 -1 开始：</span>
-<span class="hljs-number">1</span>
-<span class="hljs-number">1</span> + <span class="hljs-number">2</span>
-<span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span>
-<span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> + (-<span class="hljs-number">9</span>)
-<span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> + (-<span class="hljs-number">9</span>) + <span class="hljs-number">11</span>

<span class="hljs-comment">// 从 2 开始：</span>
<span class="hljs-number">2</span>
<span class="hljs-number">2</span> + <span class="hljs-number">3</span>
<span class="hljs-number">2</span> + <span class="hljs-number">3</span> + (-<span class="hljs-number">9</span>)
<span class="hljs-number">2</span> + <span class="hljs-number">3</span> + (-<span class="hljs-number">9</span>) + <span class="hljs-number">11</span>

<span class="hljs-comment">// 从 3 开始：</span>
<span class="hljs-number">3</span>
<span class="hljs-number">3</span> + (-<span class="hljs-number">9</span>)
<span class="hljs-number">3</span> + (-<span class="hljs-number">9</span>) + <span class="hljs-number">11</span>

<span class="hljs-comment">// 从 -9 开始：</span>
-<span class="hljs-number">9</span>
-<span class="hljs-number">9</span> + <span class="hljs-number">11</span>

<span class="hljs-comment">// 从 -11 开始：</span>
-<span class="hljs-number">11</span></code></pre>
<p>这样写出来的代码实际上是一个嵌套循环：外部循环遍历数组所有元素，内部循环计算从当前元素开始的所有子数组各自的和。</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMaxSubSum</span>(<span class="hljs-params">arr</span>) </span>{
  <span class="hljs-keyword">let</span> maxSum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 如果没有取到任何元素，就返回 0</span>

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
    <span class="hljs-keyword">let</span> sumFixedStart = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i; j &lt; arr.length; j++) {
      sumFixedStart += arr[j];
      maxSum = <span class="hljs-built_in">Math</span>.max(maxSum, sumFixedStart);
    }
  }

  <span class="hljs-keyword">return</span> maxSum;
}

alert( getMaxSubSum([-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">9</span>]) ); <span class="hljs-comment">// 5</span>
alert( getMaxSubSum([-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">9</span>, <span class="hljs-number">11</span>]) ); <span class="hljs-comment">// 11</span>
alert( getMaxSubSum([-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]) ); <span class="hljs-comment">// 3</span>
alert( getMaxSubSum([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) ); <span class="hljs-comment">// 6</span>
alert( getMaxSubSum([<span class="hljs-number">100</span>, -<span class="hljs-number">9</span>, <span class="hljs-number">2</span>, -<span class="hljs-number">3</span>, <span class="hljs-number">5</span>]) ); <span class="hljs-comment">// 100</span></code></pre>
<p>该方案的时间复杂度是 <a href="https://en.wikipedia.org/wiki/Big_O_notation">O(n<sup>2</sup>)</a>。也就是说，如果我们把数组大小增加 2 倍，那么算法的运行时间将会延长4倍。</p>
<p>对于大型数组（1000，10000 或者更多项）这种算法会导致严重的时间消耗。</p>
<h1 id="快的解决方案">快的解决方案</h1>
<p>让我们遍历数组，将当前局部元素的和保存在变量 <code>s</code> 中。如果 <code>s</code> 在某一点变成负数了，就重新分配 <code>s=0</code>。所有 <code>s</code> 中的最大值就是答案。</p>
<p>如果文字描述不太好理解，就直接看下面的代码吧，真的很短：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMaxSubSum</span>(<span class="hljs-params">arr</span>) </span>{
  <span class="hljs-keyword">let</span> maxSum = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> partialSum = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> arr) { <span class="hljs-comment">// arr 中的每个 item</span>
    partialSum += item; <span class="hljs-comment">// 将其加到 partialSum</span>
    maxSum = <span class="hljs-built_in">Math</span>.max(maxSum, partialSum); <span class="hljs-comment">// 记住最大值</span>
    <span class="hljs-keyword">if</span> (partialSum &lt; <span class="hljs-number">0</span>) partialSum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 如果是负数就置为 0</span>
  }

  <span class="hljs-keyword">return</span> maxSum;
}

alert( getMaxSubSum([-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">9</span>]) ); <span class="hljs-comment">// 5</span>
alert( getMaxSubSum([-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">9</span>, <span class="hljs-number">11</span>]) ); <span class="hljs-comment">// 11</span>
alert( getMaxSubSum([-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]) ); <span class="hljs-comment">// 3</span>
alert( getMaxSubSum([<span class="hljs-number">100</span>, -<span class="hljs-number">9</span>, <span class="hljs-number">2</span>, -<span class="hljs-number">3</span>, <span class="hljs-number">5</span>]) ); <span class="hljs-comment">// 100</span>
alert( getMaxSubSum([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) ); <span class="hljs-comment">// 6</span>
alert( getMaxSubSum([-<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>, -<span class="hljs-number">3</span>]) ); <span class="hljs-comment">// 0</span></code></pre>
<p>该算法只需要遍历 1 轮数组，所以时间复杂度是 O(n)。</p>
<p>你也可以在这获取更多该算法的细节信息：<a href="http://en.wikipedia.org/wiki/Maximum_subarray_problem">最大子数组问题</a>。如果还是不明白，那就调试上面的例子，观察它是怎样工作的，说得再多也没有自己去调试好使。</p>

      </fieldset>
      
      <fieldset id='_ka0jLN'>
      <legend>task</legend>
      <p>importance: 2</p>
<hr>
<h1 id="最大子数组">最大子数组</h1>
<p>输入是以数字组成的数组，例如 <code>arr = [1, -2, 3, 4, -9, 6]</code>.</p>
<p>任务是：找出所有项的和最大的 <code>arr</code> 数组的连续子数组。</p>
<p>写出函数 <code>getMaxSubSum(arr)</code>，用其找出并返回最大和。</p>
<p>例如：</p>
<pre><code class="language-js">getMaxSubSum([-<span class="hljs-number">1</span>, *!*<span class="hljs-number">2</span>, <span class="hljs-number">3</span>*/!*, -<span class="hljs-number">9</span>]) == <span class="hljs-number">5</span>（高亮项的加和）
getMaxSubSum([*!*<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>*/!*, -<span class="hljs-number">9</span>]) == <span class="hljs-number">6</span>
getMaxSubSum([-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">9</span>, *!*<span class="hljs-number">11</span>*/!*]) == <span class="hljs-number">11</span>
getMaxSubSum([-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, *!*<span class="hljs-number">1</span>, <span class="hljs-number">2</span>*/!*]) == <span class="hljs-number">3</span>
getMaxSubSum([*!*<span class="hljs-number">100</span>*/!*, -<span class="hljs-number">9</span>, <span class="hljs-number">2</span>, -<span class="hljs-number">3</span>, <span class="hljs-number">5</span>]) == <span class="hljs-number">100</span>
getMaxSubSum([*!*<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>*/!*]) == <span class="hljs-number">6</span>（所有项的和）</code></pre>
<p>如果所有项都是负数，那就一个项也不取（子数组是空的），所以返回的是 0：</p>
<pre><code class="language-js">getMaxSubSum([-<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>, -<span class="hljs-number">3</span>]) = <span class="hljs-number">0</span></code></pre>
<p>请尝试想出一个快速的解决方案：复杂度可以是 <a href="https://en.wikipedia.org/wiki/Big_O_notation">O(n<sup>2</sup>)</a>，有能力达到 O(n) 则更好。</p>

      </fieldset>
      
      <fieldset id='_2rXJxT'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-keyword">let</span> styles = [<span class="hljs-string">&quot;Jazz&quot;</span>, <span class="hljs-string">&quot;Blues&quot;</span>];
styles.push(<span class="hljs-string">&quot;Rock-n-Roll&quot;</span>);
styles[<span class="hljs-built_in">Math</span>.floor((styles.length - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>)] = <span class="hljs-string">&quot;Classics&quot;</span>;
alert( styles.shift() );
styles.unshift(<span class="hljs-string">&quot;Rap&quot;</span>, <span class="hljs-string">&quot;Reggae&quot;</span>);</code></pre>

      </fieldset>
      
      <fieldset id='_g37DdH'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="数组操作。">数组操作。</h1>
<p>我们试试下面的 5 个数组操作。</p>
<ol>
<li>创建一个数组 <code>styles</code>，里面存储有 &quot;Jazz&quot; 和 &quot;Blues&quot;。</li>
<li>将 &quot;Rock-n-Roll&quot; 从数组末端添加进去。</li>
<li>用 &quot;Classics&quot; 替换掉数组最中间的元素。查找数组最中间的元素的代码应该适用于任何奇数长度的数组。</li>
<li>去掉数组的第一个值并显示它。</li>
<li>在数组前面添加 <code>Rap</code> 和 <code>Reggae</code>。</li>
</ol>
<p>过程中的数组：</p>
<pre><code class="language-js">Jazz, Blues
Jazz, Bues, Rock-n-Roll
Jazz, Classics, Rock-n-Roll
Classics, Rock-n-Roll
Rap, Reggae, Classics, Rock-n-Roll</code></pre>

      </fieldset>
      
      <fieldset id='_sU3YsI'>
      <legend>solution</legend>
      <p><code>arr[2]()</code> 调用从句法来看可以类比于 <code>obj[method]()</code>，与 <code>obj</code> 对应的是 <code>arr</code>，与 <code>method</code> 对应的是 <code>2</code>。</p>
<p>所以调用 <code>arr[2]</code> 函数也就是调用对象函数。自然地，它接收 <code>this</code> 引用的对象 <code>arr</code> 然后输出该数组：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>];

arr.push(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  alert( <span class="hljs-built_in">this</span> );
})

arr[<span class="hljs-number">2</span>](); <span class="hljs-comment">// a,b,function(){...}</span></code></pre>
<p>该数组有 3 项：最开始有两个，后来添加进来一个函数。</p>

      </fieldset>
      
      <fieldset id='_ewrx2I'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="在数组上下文调用">在数组上下文调用</h1>
<p>结果是什么？为什么？</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>];

arr.push(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  alert( <span class="hljs-built_in">this</span> );
})

arr[<span class="hljs-number">2</span>](); <span class="hljs-comment">// ?</span></code></pre>

      </fieldset>
      
      <fieldset id='_EVjoWf'>
      <legend>solution</legend>
      <p>请注意这个解决方案的细微但是很重要的细节。我们没有在 <code>prompt</code> 后立即把 <code>value</code> 转换成数字，因为在执行 <code>value = +value</code> 之后，就没办法区分出空字符串（中断标志）和数字 0（合法输入）了，所以要放到后面再处理。</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sumInput</span>(<span class="hljs-params"></span>) </span>{

  <span class="hljs-keyword">let</span> numbers = [];

  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {

    <span class="hljs-keyword">let</span> value = prompt(<span class="hljs-string">&quot;A number please?&quot;</span>, <span class="hljs-number">0</span>);

    <span class="hljs-comment">// 应该结束了吗？</span>
    <span class="hljs-keyword">if</span> (value === <span class="hljs-string">&quot;&quot;</span> || value === <span class="hljs-literal">null</span> || !<span class="hljs-built_in">isFinite</span>(value)) <span class="hljs-keyword">break</span>;

    numbers.push(+value);
  }

  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> number <span class="hljs-keyword">of</span> numbers) {
    sum += number;
  }
  <span class="hljs-keyword">return</span> sum;
}

alert( sumInput() ); </code></pre>

      </fieldset>
      
      <fieldset id='_lJO3al'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="输入数字求和">输入数字求和</h1>
<p>写出函数 <code>sumInput()</code>，要求如下：</p>
<ul>
<li>使用 <code>prompt</code> 向用户索要值，并存在数组中。</li>
<li>当用户输入了非数字、空字符串或者点击“取消”按钮的时候，问询结束。</li>
<li>计算并返回数组所有项之和。</li>
</ul>
<p>P.S. <code>0</code> 是有效的数字，不要因为是 0 就停止问询。</p>
<p>[demo]</p>

      </fieldset>
      
      <fieldset id='_95HHqF'>
      <legend>article</legend>
      <h1 id="数组">数组</h1>
<p>对象允许存储键值集合，这很好。</p>
<p>但很多时候我们发现还需要 <strong>有序集合</strong>，里面的元素都是按顺序排列的。例如，我们可能需要存储一些列表，比如用户、商品以及 HTML 元素等。</p>
<p>这里使用对象就不是很方便了，因为对象不能提供能够管理元素顺序的方法。我们不能在已有的元素“之间”插入一个新的属性。这种场景下对象就不太适用了。</p>
<p>这时一个特殊的数据结构数组（<code>Array</code>）就派上用场了，它能存储有序的集合。</p>
<h2 id="声明">声明</h2>
<p>创建一个空数组有两种语法：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();
<span class="hljs-keyword">let</span> arr = [];</code></pre>
<p>绝大多数情况下使用的都是第二种语法。我们可以在方括号中添加初始元素：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Plum&quot;</span>];</code></pre>
<p>数组元素从 0 开始编号。</p>
<p>我们可以通过方括号中的数字获取元素：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Plum&quot;</span>];

alert( fruits[<span class="hljs-number">0</span>] ); <span class="hljs-comment">// Apple</span>
alert( fruits[<span class="hljs-number">1</span>] ); <span class="hljs-comment">// Orange</span>
alert( fruits[<span class="hljs-number">2</span>] ); <span class="hljs-comment">// Plum</span></code></pre>
<p>可以替换元素：</p>
<pre><code class="language-js">fruits[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;Pear&#x27;</span>; <span class="hljs-comment">// 现在变成了 [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Pear&quot;]</span></code></pre>
<p>……或者向数组新加一个元素：</p>
<pre><code class="language-js">fruits[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;Lemon&#x27;</span>; <span class="hljs-comment">// 现在变成 [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Lemon&quot;]</span></code></pre>
<p><code>length</code> 属性的值是数组中元素的总个数：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Plum&quot;</span>];

alert( fruits.length ); <span class="hljs-comment">// 3</span></code></pre>
<p>也可以用 <code>alert</code> 来显示整个数组。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Plum&quot;</span>];

alert( fruits ); <span class="hljs-comment">// Apple,Orange,Plum</span></code></pre>
<p>数组可以存储任何类型的元素。</p>
<p>例如:</p>
<pre><code class="language-js"><span class="hljs-comment">// 混合值</span>
<span class="hljs-keyword">let</span> arr = [ <span class="hljs-string">&#x27;Apple&#x27;</span>, { <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> }, <span class="hljs-literal">true</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ alert(<span class="hljs-string">&#x27;hello&#x27;</span>); } ];

<span class="hljs-comment">// 获取索引为 1 的对象然后显示它的 name</span>
alert( arr[<span class="hljs-number">1</span>].name ); <span class="hljs-comment">// John</span>

<span class="hljs-comment">// 获取索引为 3 的函数并执行</span>
arr[<span class="hljs-number">3</span>](); <span class="hljs-comment">// hello</span></code></pre>
<pre><code class="language-smart">数组就像对象一样，可以以逗号结尾：
```js 
let fruits = [
  &quot;Apple&quot;, 
  &quot;Orange&quot;, 
  &quot;Plum&quot;*!*,*/!*
];
```

因为每一行都是相似的，所以这种以“逗号结尾”的方式使得插入/移除项变得更加简单。</code></pre>
<h2 id="poppush-shiftunshift-方法">pop/push, shift/unshift 方法</h2>
<p><a href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type)">队列（queue）</a>是最常见的使用数组的方法之一。在计算机科学中，这表示支持两个操作的一个有序元素的集合：</p>
<ul>
<li><code>push</code> 在末端添加一个元素.</li>
<li><code>shift</code> 取出队列首端的一个元素，整个队列往前移，这样原先排第二的元素现在排在了第一。</li>
</ul>
<p><img src="queue.svg" alt=""></p>
<p>这两种操作数组都支持。</p>
<p>队列的应用在实践中经常会碰到。例如需要在屏幕上显示消息队列。</p>
<p>数组还有另一个用例，就是数据结构 <a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">栈</a>。</p>
<p>它支持两种操作：</p>
<ul>
<li><code>push</code> 在末端添加一个元素.</li>
<li><code>pop</code> 从末端取出一个元素.</li>
</ul>
<p>所以新元素的添加和取出都是从“末端”开始的。</p>
<p>栈通常被被形容成一叠卡片：要么在最上面添加卡片，要么从最上面拿走卡片：</p>
<p><img src="stack.svg" alt=""></p>
<p>对于栈来说，最后放进去的内容是最先接收的，也叫做 LIFO（Last-In-First-Out），即后进先出法则。而与队列相对应的叫做 FIFO（First-In-First-Out），即先进先出。</p>
<p>JavaScript 中的数组既可以用作队列，也可以用作栈。它们允许你从首端/末端来添加/删除元素。</p>
<p>这在计算机科学中，允许这样的操作的数据结构被称为 <a href="https://en.wikipedia.org/wiki/Double-ended_queue">双端队列（deque）</a>。</p>
<p><strong>作用于数组末端的方法：</strong></p>
<p><code>pop</code>
: 取出并返回数组的最后一个元素：</p>
<pre><code>```js run
let fruits = [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Pear&quot;];

alert( fruits.pop() ); // 移除 &quot;Pear&quot; 然后 alert 显示出来

alert( fruits ); // Apple, Orange
```</code></pre>
<p><code>push</code>
: 在数组末端添加元素：</p>
<pre><code>```js run
let fruits = [&quot;Apple&quot;, &quot;Orange&quot;];

fruits.push(&quot;Pear&quot;);

alert( fruits ); // Apple, Orange, Pear
```

调用 `fruits.push(...)` 与 `fruits[fruits.length] = ...` 是一样的。</code></pre>
<p><strong>作用于数组首端的方法：</strong></p>
<p><code>shift</code>
: 取出数组的第一个元素并返回它：</p>
<pre><code>```js run
let fruits = [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Pear&quot;];

alert( fruits.shift() ); // 移除 Apple 然后 alert 显示出来

alert( fruits ); // Orange, Pear
```</code></pre>
<p><code>unshift</code>
: 在数组的首端添加元素：</p>
<pre><code>```js run
let fruits = [&quot;Orange&quot;, &quot;Pear&quot;];

fruits.unshift(&#x27;Apple&#x27;);

alert( fruits ); // Apple, Orange, Pear
```</code></pre>
<p><code>push</code> 和 <code>unshift</code> 方法都可以一次添加多个元素：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">&quot;Apple&quot;</span>];

fruits.push(<span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Peach&quot;</span>);
fruits.unshift(<span class="hljs-string">&quot;Pineapple&quot;</span>, <span class="hljs-string">&quot;Lemon&quot;</span>);

<span class="hljs-comment">// [&quot;Pineapple&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Orange&quot;, &quot;Peach&quot;]</span>
alert( fruits );</code></pre>
<h2 id="内部">内部</h2>
<p>数组是一种特殊的对象。使用方括号来访问属性 <code>arr[0]</code> 实际上是来自于对象的语法。它其实与 <code>obj[key]</code> 相同，其中 <code>arr</code> 是对象，而数字用作键（key）。</p>
<p>它们扩展了对象，提供了特殊的方法来处理有序的数据集合以及 <code>length</code> 属性。但从本质上讲，它仍然是一个对象。</p>
<p>记住，在 JavaScript 中只有 7 种基本类型。数组是一个对象，因此其行为也像一个对象。</p>
<p>例如，它是通过引用来复制的：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">&quot;Banana&quot;</span>]

<span class="hljs-keyword">let</span> arr = fruits; <span class="hljs-comment">// 通过引用复制 (两个变量引用的是相同的数组)</span>

alert( arr === fruits ); <span class="hljs-comment">// true</span>

arr.push(<span class="hljs-string">&quot;Pear&quot;</span>); <span class="hljs-comment">// 通过引用修改数组</span>

alert( fruits ); <span class="hljs-comment">// Banana, Pear — 现在有 2 项了</span></code></pre>
<p>……但是数组真正特殊的是它们的内部实现。JavaScript 引擎尝试把这些元素一个接一个地存储在连续的内存区域，就像本章的插图显示的一样，而且还有一些其它的优化，以使数组运行得非常快。</p>
<p>但是，如果我们不像“有序集合”那样使用数组，而是像常规对象那样使用数组，这些就都不生效了。</p>
<p>例如，从技术上讲，我们可以这样做:</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> fruits = []; <span class="hljs-comment">// 创建一个数组</span>

fruits[<span class="hljs-number">99999</span>] = <span class="hljs-number">5</span>; <span class="hljs-comment">// 分配索引远大于数组长度的属性</span>

fruits.age = <span class="hljs-number">25</span>; <span class="hljs-comment">// 创建一个具有任意名称的属性</span></code></pre>
<p>这是可以的，因为数组是基于对象的。我们可以给它们添加任何属性。</p>
<p>但是 Javascript 引擎会发现，我们在像使用常规对象一样使用数组，那么针对数组的优化就不再适用了，然后对应的优化就会被关闭，这些优化所带来的优势也就荡然无存了。</p>
<p>数组误用的几种方式:</p>
<ul>
<li>添加一个非数字的属性，比如 <code>arr.test = 5</code>。</li>
<li>制造空洞，比如：添加 <code>arr[0]</code>，然后添加 <code>arr[1000]</code> (它们中间什么都没有)。</li>
<li>以倒序填充数组，比如 <code>arr[1000]</code>，<code>arr[999]</code> 等等。</li>
</ul>
<p>请将数组视为作用于 <strong>有序数据</strong> 的特殊结构。它们为此提供了特殊的方法。数组在 JavaScript 引擎内部是经过特殊调整的，使得更好地作用于连续的有序数据，所以请以正确的方式使用数组。如果你需要任意键值，那很有可能实际上你需要的是常规对象 <code>{}</code>。</p>
<h2 id="性能">性能</h2>
<p><code>push/pop</code> 方法运行的比较快，而 <code>shift/unshift</code> 比较慢。</p>
<p><img src="array-speed.svg" alt=""></p>
<p>为什么作用于数组的末端会比首端快呢？让我们看看在执行期间都发生了什么：</p>
<pre><code class="language-js">fruits.shift(); <span class="hljs-comment">// 从首端取出一个元素</span></code></pre>
<p>只获取并移除数字 <code>0</code> 对应的元素是不够的。其它元素也需要被重新编号。</p>
<p><code>shift</code> 操作必须做三件事:</p>
<ol>
<li>移除索引为 <code>0</code> 的元素。</li>
<li>把所有的元素向左移动，把索引 <code>1</code> 改成 <code>0</code>，<code>2</code> 改成 <code>1</code> 以此类推，对其重新编号。</li>
<li>更新 <code>length</code> 属性。</li>
</ol>
<p><img src="array-shift.svg" alt=""></p>
<p><strong>数组里的元素越多，移动它们就要花越多的时间，也就意味着越多的内存操作。</strong></p>
<p><code>unshift</code> 也是一样：为了在数组的首端添加元素，我们首先需要将现有的元素向右移动，增加它们的索引值。</p>
<p>那 <code>push/pop</code> 是什么样的呢？它们不需要移动任何东西。如果从末端移除一个元素，<code>pop</code> 方法只需要清理索引值并缩短 <code>length</code> 就可以了。</p>
<p><code>pop</code> 操作的行为：</p>
<pre><code class="language-js">fruits.pop(); <span class="hljs-comment">// 从末端取走一个元素</span></code></pre>
<p><img src="array-pop.svg" alt=""></p>
<p><strong><code>pop</code> 方法不需要移动任何东西，因为其它元素都保留了各自的索引。这就是为什么 <code>pop</code> 会特别快。</strong></p>
<p><code>push</code> 方法也是一样的。</p>
<h2 id="循环">循环</h2>
<p>遍历数组最古老的方式就是 <code>for</code> 循环：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Pear&quot;</span>];

*!*
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
*/!*
  alert( arr[i] );
}</code></pre>
<p>但对于数组来说还有另一种循环方式，<code>for..of</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Plum&quot;</span>];

<span class="hljs-comment">// 遍历数组元素</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> fruit <span class="hljs-keyword">of</span> fruits) {
  alert( fruit ); 
}</code></pre>
<p><code>for..of</code> 不能获取当前元素的索引，只是获取元素值，但大多数情况是够用的。而且这样写更短。</p>
<p>技术上来讲，因为数组也是对象，所以使用 <code>for..in</code> 也是可以的：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Pear&quot;</span>];

*!*
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> arr) {
*/!*
  alert( arr[key] ); <span class="hljs-comment">// Apple, Orange, Pear</span>
}</code></pre>
<p>但这其实是一个很不好的想法。会有一些潜在问题存在：</p>
<ol>
<li><p><code>for..in</code> 循环会遍历 <strong>所有属性</strong>，不仅仅是这些数字属性。</p>
<p> 在浏览器和其它环境中有一种称为“类数组”的对象，它们 <strong>看似是数组</strong>。也就是说，它们有 <code>length</code> 和索引属性，但是也可能有其它的非数字的属性和方法，这通常是我们不需要的。<code>for..in</code> 循环会把它们都列出来。所以如果我们需要处理类数组对象，这些“额外”的属性就会存在问题。</p>
</li>
<li><p><code>for..in</code> 循环适用于普通对象，并且做了对应的优化。但是不适用于数组，因此速度要慢 10-100 倍。当然即使是这样也依然非常快。只有在遇到瓶颈时可能会有问题。但是我们仍然应该了解这其中的不同。</p>
</li>
</ol>
<p>通常来说，我们不应该用 <code>for..in</code> 来处理数组。</p>
<h2 id="关于-length">关于 &quot;length&quot;</h2>
<p>当我们修改数组的时候，<code>length</code> 属性会自动更新。准确来说，它实际上不是数组里元素的个数，而是最大的数字索引值加一。</p>
<p>例如，一个数组只有一个元素，但是这个元素的索引值很大，那么这个数组的 <code>length</code> 也会很大：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> fruits = [];
fruits[<span class="hljs-number">123</span>] = <span class="hljs-string">&quot;Apple&quot;</span>;

alert( fruits.length ); <span class="hljs-comment">// 124</span></code></pre>
<p>要知道的是我们通常不会这样使用数组。</p>
<p><code>length</code> 属性的另一个有意思的点是它是可写的。</p>
<p>如果我们手动增加它，则不会发生任何有趣的事儿。但是如果我们减少它，数组就会被截断。该过程是不可逆的，下面是例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];

arr.length = <span class="hljs-number">2</span>; <span class="hljs-comment">// 截断到只剩 2 个元素</span>
alert( arr ); <span class="hljs-comment">// [1, 2]</span>

arr.length = <span class="hljs-number">5</span>; <span class="hljs-comment">// 又把 length 加回来</span>
alert( arr[<span class="hljs-number">3</span>] ); <span class="hljs-comment">// undefined：被截断的那些数值并没有回来</span></code></pre>
<p>所以，清空数组最简单的方法就是：<code>arr.length = 0;</code>。</p>
<h2 id="new-array-new-array">new Array() [#new-array]</h2>
<p>这是创建数组的另一种语法：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = *!*<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>*/!*(<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Pear&quot;</span>, <span class="hljs-string">&quot;etc&quot;</span>);</code></pre>
<p>它很少被使用，因为方括号 <code>[]</code> 更短更简洁。而且这种语法还存在一些诡异的特性。</p>
<p>如果使用单个参数（即数字）调用 <code>new Array</code>，那么它会创建一个 <strong>指定了长度，却没有任何项</strong> 的数组。</p>
<p>让我们看看如何搬起石头砸自己的脚:</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 会创建一个 [2] 的数组吗？</span>

alert( arr[<span class="hljs-number">0</span>] ); <span class="hljs-comment">// undefined！没有元素。</span>

alert( arr.length ); <span class="hljs-comment">// length 2</span></code></pre>
<p>在上面的代码中，<code>new Array(number)</code> 创建的数组的所有元素都是 <code>undefined</code>。</p>
<p>为了避免这种乌龙事件，我们通常都是使用方括号的，除非我们清楚地知道自己正在做什么。</p>
<h2 id="多维数组">多维数组</h2>
<p>数组里的项也可以是数组。我们可以将其用于多维数组，例如存储矩阵：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> matrix = [
  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],
  [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>],
  [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]
];

alert( matrix[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] ); <span class="hljs-comment">// 最中间的那个数</span></code></pre>
<h2 id="tostring">toString</h2>
<p>数组有自己的 <code>toString</code> 方法的实现，会返回以逗号隔开的元素列表。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];

alert( arr ); <span class="hljs-comment">// 1,2,3</span>
alert( <span class="hljs-built_in">String</span>(arr) === <span class="hljs-string">&#x27;1,2,3&#x27;</span> ); <span class="hljs-comment">// true</span></code></pre>
<p>此外，我们试试运行一下这个：</p>
<pre><code class="language-js">alert( [] + <span class="hljs-number">1</span> ); <span class="hljs-comment">// &quot;1&quot;</span>
alert( [<span class="hljs-number">1</span>] + <span class="hljs-number">1</span> ); <span class="hljs-comment">// &quot;11&quot;</span>
alert( [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] + <span class="hljs-number">1</span> ); <span class="hljs-comment">// &quot;1,21&quot;</span></code></pre>
<p>数组没有 <code>Symbol.toPrimitive</code>，也没有 <code>valueOf</code>，它们只能执行 <code>toString</code> 进行转换，所以这里 <code>[]</code> 就变成了一个空字符串，<code>[1]</code> 变成了 <code>&quot;1&quot;</code>，<code>[1,2]</code> 变成了 <code>&quot;1,2&quot;</code>。</p>
<p>当 <code>&quot;+&quot;</code> 运算符把一些项加到字符串后面时，加号后面的项也会被转换成字符串，所以下一步就会是这样：</p>
<pre><code class="language-js">alert( <span class="hljs-string">&quot;&quot;</span> + <span class="hljs-number">1</span> ); <span class="hljs-comment">// &quot;1&quot;</span>
alert( <span class="hljs-string">&quot;1&quot;</span> + <span class="hljs-number">1</span> ); <span class="hljs-comment">// &quot;11&quot;</span>
alert( <span class="hljs-string">&quot;1,2&quot;</span> + <span class="hljs-number">1</span> ); <span class="hljs-comment">// &quot;1,21&quot;</span></code></pre>
<h2 id="总结">总结</h2>
<p>数组是一种特殊的对象，适用于存储和管理有序的数据项。</p>
<ul>
<li><p>声明:</p>
<pre><code class="language-js"><span class="hljs-comment">// 方括号 (常见用法)</span>
<span class="hljs-keyword">let</span> arr = [item1, item2...];

<span class="hljs-comment">// new Array (极其少见)</span>
<span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(item1, item2...);</code></pre>
<p>  调用 <code>new Array(number)</code> 会创建一个给定长度的数组，但不含有任何项。</p>
</li>
<li><p><code>length</code> 属性是数组的长度，准确地说，它是数组最后一个数字索引值加一。它由数组方法自动调整。</p>
</li>
<li><p>如果我们手动缩短 <code>length</code>，那么数组就会被截断。</p>
</li>
</ul>
<p>我们可以通过下列操作以双端队列的方式使用数组：</p>
<ul>
<li><code>push(...items)</code> 在末端添加 <code>items</code> 项。</li>
<li><code>pop()</code> 从末端移除并返回该元素。</li>
<li><code>shift()</code> 从首端移除并返回该元素。</li>
<li><code>unshift(...items)</code> 从首端添加 <code>items</code> 项。</li>
</ul>
<p>遍历数组的元素：</p>
<ul>
<li><code>for (let i=0; i&lt;arr.length; i++)</code> — 运行得最快，可兼容旧版本浏览器。</li>
<li><code>for (let item of arr)</code> — 现代语法，只能访问 items。</li>
<li><code>for (let i in arr)</code> — 永远不要用这个。</li>
</ul>
<p>在下一章节 <a href="info:array-methods">info:array-methods</a> 中，我们会继续学习数组，学习更多添加、移除、提取元素和数组排序的方法。 </p>

      </fieldset>
      
      <fieldset id='_pu2Jlt'>
      <legend>solution</legend>
      
      </fieldset>
      
      <fieldset id='_qSgukq'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="将-border-left-width-转换成-borderleftwidth">将 border-left-width 转换成 borderLeftWidth</h1>
<p>编写函数 <code>camelize(str)</code> 将诸如 &quot;my-short-string&quot; 之类的由短划线分隔的单词变成骆驼式的 &quot;myShortString&quot;。</p>
<p>即：删除所有短横线，并将短横线后的每一个单词的首字母变为大写。</p>
<p>示例：</p>
<pre><code class="language-js">camelize(<span class="hljs-string">&quot;background-color&quot;</span>) == <span class="hljs-string">&#x27;backgroundColor&#x27;</span>;
camelize(<span class="hljs-string">&quot;list-style-image&quot;</span>) == <span class="hljs-string">&#x27;listStyleImage&#x27;</span>;
camelize(<span class="hljs-string">&quot;-webkit-transition&quot;</span>) == <span class="hljs-string">&#x27;WebkitTransition&#x27;</span>;</code></pre>
<p>提示：使用 <code>split</code> 将字符串拆分成数组，对其进行转换之后再 <code>join</code> 回来。</p>

      </fieldset>
      
      <fieldset id='_WeLsAh'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAverageAge</span>(<span class="hljs-params">users</span>) </span>{
  <span class="hljs-keyword">return</span> users.reduce(<span class="hljs-function">(<span class="hljs-params">prev, user</span>) =&gt;</span> prev + user.age, <span class="hljs-number">0</span>) / users.length;
}

<span class="hljs-keyword">let</span> john = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> };
<span class="hljs-keyword">let</span> pete = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Pete&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> };
<span class="hljs-keyword">let</span> mary = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Mary&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">29</span> };

<span class="hljs-keyword">let</span> arr = [ john, pete, mary ];

alert( getAverageAge(arr) ); <span class="hljs-comment">// 28</span></code></pre>

      </fieldset>
      
      <fieldset id='_Jpodvl'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="获取平均年龄">获取平均年龄</h1>
<p>编写 <code>getAverageAge(users)</code> 函数，该函数获取一个具有 <code>age</code> 属性的对象数组，并返回平均年龄。</p>
<p>平均值的计算公式是 <code>(age1 + age2 + ... + ageN) / N</code>。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> john = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> };
<span class="hljs-keyword">let</span> pete = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Pete&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> };
<span class="hljs-keyword">let</span> mary = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Mary&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">29</span> };

<span class="hljs-keyword">let</span> arr = [ john, pete, mary ];

alert( getAverageAge(arr) ); <span class="hljs-comment">// (25 + 30 + 29) / 3 = 28</span></code></pre>

      </fieldset>
      
      <fieldset id='_v4YvPl'>
      <legend>solution</legend>
      <p>让我们先遍历数字：</p>
<ul>
<li>对于每个元素，我们将检查结果数组是否已经有该元素。</li>
<li>如果有，则忽略，否则将其添加到结果中。</li>
</ul>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>{
  <span class="hljs-keyword">let</span> result = [];

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> str <span class="hljs-keyword">of</span> arr) {
    <span class="hljs-keyword">if</span> (!result.includes(str)) {
      result.push(str);
    }
  }

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-keyword">let</span> strings = [<span class="hljs-string">&quot;Hare&quot;</span>, <span class="hljs-string">&quot;Krishna&quot;</span>, <span class="hljs-string">&quot;Hare&quot;</span>, <span class="hljs-string">&quot;Krishna&quot;</span>,
  <span class="hljs-string">&quot;Krishna&quot;</span>, <span class="hljs-string">&quot;Krishna&quot;</span>, <span class="hljs-string">&quot;Hare&quot;</span>, <span class="hljs-string">&quot;Hare&quot;</span>, <span class="hljs-string">&quot;:-O&quot;</span>
];

alert( unique(strings) ); <span class="hljs-comment">// Hare, Krishna, :-O</span></code></pre>
<p>代码有效，但其中存在潜在的性能问题。</p>
<p>方法 <code>result.includes(str)</code> 在内部遍历数组 <code>result</code>，并将每个元素与 <code>str</code> 进行比较以找到匹配项。</p>
<p>所以如果 <code>result</code> 中有 <code>100</code> 个元素，并且没有任何一项与 <code>str</code> 匹配，那么它将遍历整个 <code>result</code> 并进行 <code>100</code> 次比较。如果 <code>result</code> 很大，比如 <code>10000</code>，那么就会有 <code>10000</code> 次的比较。</p>
<p>这本身并不是问题，因为 JavaScript 引擎速度非常快，所以遍历一个有 <code>10000</code> 个元素的数组只需要几微秒。</p>
<p>但是我们在 <code>for </code>循环中对 <code>arr</code> 的每个元素都进行了一次检测。</p>
<p>因此，如果 <code>arr.length</code> 是 <code>10000</code>，我们会有 <code>10000 * 10000</code> = 1 亿次的比较。那真的太多了。</p>
<p>所以该解决方案仅适用于小型数组。</p>
<p>进一步，在后面的 <a href="info:map-set">info:map-set</a> 一章中，我们将看到如何对该方法进行优化。</p>

      </fieldset>
      
      <fieldset id='_peghiL'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="数组去重">数组去重</h1>
<p><code>arr</code> 是一个数组。</p>
<p>创建一个函数 <code>unique(arr)</code>，返回去除重复元素后的数组 <code>arr</code>。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>{
  <span class="hljs-comment">/* your code */</span>
}

<span class="hljs-keyword">let</span> strings = [<span class="hljs-string">&quot;Hare&quot;</span>, <span class="hljs-string">&quot;Krishna&quot;</span>, <span class="hljs-string">&quot;Hare&quot;</span>, <span class="hljs-string">&quot;Krishna&quot;</span>,
  <span class="hljs-string">&quot;Krishna&quot;</span>, <span class="hljs-string">&quot;Krishna&quot;</span>, <span class="hljs-string">&quot;Hare&quot;</span>, <span class="hljs-string">&quot;Hare&quot;</span>, <span class="hljs-string">&quot;:-O&quot;</span>
];

alert( unique(strings) ); <span class="hljs-comment">// Hare, Krishna, :-O</span></code></pre>

      </fieldset>
      
      <fieldset id='_PVdz7Q'>
      <legend>solution</legend>
      
      </fieldset>
      
      <fieldset id='_UFheiM'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="从数组创建键（值）对象">从数组创建键（值）对象</h1>
<p>假设我们收到了一个用户数组，形式为：<code>{id:..., name:..., age... }</code>。</p>
<p>创建一个函数 <code>groupById(arr)</code> 从该数组创建对象，以 <code>id</code> 为键（key），数组项为值。</p>
<p>例如:</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> users = [
  {<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;john&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John Smith&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>},
  {<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;ann&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Ann Smith&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">24</span>},
  {<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;pete&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Pete Peterson&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">31</span>},
];

<span class="hljs-keyword">let</span> usersById = groupById(users);

<span class="hljs-comment">/*
// 调用函数后，我们应该得到：

usersById = {
  john: {id: &#x27;john&#x27;, name: &quot;John Smith&quot;, age: 20},
  ann: {id: &#x27;ann&#x27;, name: &quot;Ann Smith&quot;, age: 24},
  pete: {id: &#x27;pete&#x27;, name: &quot;Pete Peterson&quot;, age: 31},
}
*/</span></code></pre>
<p>处理服务端数据时，这个函数很有用。</p>
<p>在这个任务里我们假设 <code>id</code> 是唯一的。没有两个具有相同 <code>id</code> 的数组项。</p>
<p>请在解决方案中使用数组的 <code>.reduce</code> 方法。</p>

      </fieldset>
      
      <fieldset id='_9w47Up'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filterRange</span>(<span class="hljs-params">arr, a, b</span>) </span>{
  <span class="hljs-comment">// 在表达式周围添加了括号，以提高可读性</span>
  <span class="hljs-keyword">return</span> arr.filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> (a &lt;= item &amp;&amp; item &lt;= b));
}

<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>];

<span class="hljs-keyword">let</span> filtered = filterRange(arr, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>);

alert( filtered ); <span class="hljs-comment">// 3,1（匹配的值）</span>

alert( arr ); <span class="hljs-comment">// 5,3,8,1（未经改动的数组中的值）</span></code></pre>

      </fieldset>
      
      <fieldset id='_NoiGzU'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="过滤范围">过滤范围</h1>
<p>写一个函数 <code>filterRange(arr, a, b)</code>，该函数获取一个数组 <code>arr</code>，在其中查找数值大小在 <code>a</code> 和 <code>b</code> 之间的元素，并返回它们的数组。</p>
<p>该函数不应该修改原数组。它应该返回新的数组。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>];

<span class="hljs-keyword">let</span> filtered = filterRange(arr, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>); 

alert( filtered ); <span class="hljs-comment">// 3,1（匹配值）</span>

alert( arr ); <span class="hljs-comment">// 5,3,8,1（未修改）</span></code></pre>

      </fieldset>
      
      <fieldset id='_nLVmR4'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filterRangeInPlace</span>(<span class="hljs-params">arr, a, b</span>) </span>{

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
    <span class="hljs-keyword">let</span> val = arr[i];

    <span class="hljs-comment">// 如果超出范围，则删除</span>
    <span class="hljs-keyword">if</span> (val &lt; a || val &gt; b) {
      arr.splice(i, <span class="hljs-number">1</span>);
      i--;
    }
  }

}

<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>];

filterRangeInPlace(arr, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 删除 1 到 4 范围之外的值</span>

alert( arr ); <span class="hljs-comment">// [3, 1]</span></code></pre>

      </fieldset>
      
      <fieldset id='_qQ9EaY'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="原位（in-place）过滤范围">原位（in place）过滤范围</h1>
<p>写一个函数 <code>filterRangeInPlace(arr, a, b)</code>，该函数获取一个数组 <code>arr</code>，并删除其中介于 <code>a</code> 和 <code>b</code> 区间以外的所有值。检查：<code>a ≤ arr[i] ≤ b</code>。</p>
<p>该函数应该只修改数组。它不应该返回任何东西。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>];

filterRangeInPlace(arr, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 删除了范围在 1 到 4 之外的所有值</span>

alert( arr ); <span class="hljs-comment">// [3, 1]</span></code></pre>

      </fieldset>
      
      <fieldset id='_EBwdoV'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">10</span>, <span class="hljs-number">8</span>];

arr.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a);

alert( arr );</code></pre>

      </fieldset>
      
      <fieldset id='_0dA63x'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="降序排列">降序排列</h1>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">10</span>, <span class="hljs-number">8</span>];

<span class="hljs-comment">// ……你的代码以降序对其进行排序</span>

alert( arr ); <span class="hljs-comment">// 8, 5, 2, 1, -10</span></code></pre>

      </fieldset>
      
      <fieldset id='_hI3C1q'>
      <legend>solution</legend>
      <p>我们可以使用 <code>slice()</code> 来创建一个副本并对其进行排序：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copySorted</span>(<span class="hljs-params">arr</span>) </span>{
  <span class="hljs-keyword">return</span> arr.slice().sort();
}

<span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;HTML&quot;</span>, <span class="hljs-string">&quot;JavaScript&quot;</span>, <span class="hljs-string">&quot;CSS&quot;</span>];

*!*
<span class="hljs-keyword">let</span> sorted = copySorted(arr);
*/!*

alert( sorted );
alert( arr );</code></pre>

      </fieldset>
      
      <fieldset id='_7PhXBe'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="复制和排序数组">复制和排序数组</h1>
<p>我们有一个字符串数组 <code>arr</code>。我们希望有一个排序过的副本，但保持 <code>arr</code> 不变。</p>
<p>创建一个函数 <code>copySorted(arr)</code> 返回这样一个副本。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;HTML&quot;</span>, <span class="hljs-string">&quot;JavaScript&quot;</span>, <span class="hljs-string">&quot;CSS&quot;</span>];

<span class="hljs-keyword">let</span> sorted = copySorted(arr);

alert( sorted ); <span class="hljs-comment">// CSS, HTML, JavaScript</span>
alert( arr ); <span class="hljs-comment">// HTML, JavaScript, CSS (no changes)</span></code></pre>

      </fieldset>
      
      <fieldset id='_OYgmyP'>
      <legend>solution</legend>
      <pre><code class="language-js">
<span class="hljs-keyword">let</span> john = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> };
<span class="hljs-keyword">let</span> pete = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Pete&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> };
<span class="hljs-keyword">let</span> mary = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Mary&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">28</span> };

<span class="hljs-keyword">let</span> users = [ john, pete, mary ];

<span class="hljs-keyword">let</span> names = users.map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.name);

alert( names ); <span class="hljs-comment">// John, Pete, Mary</span></code></pre>

      </fieldset>
      
      <fieldset id='_VTwNMS'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="映射到-names">映射到 names</h1>
<p>你有一个 <code>user</code> 对象数组，每个对象都有 <code>user.name</code>。编写将其转换为 names 数组的代码。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> john = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> };
<span class="hljs-keyword">let</span> pete = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Pete&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> };
<span class="hljs-keyword">let</span> mary = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Mary&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">28</span> };

<span class="hljs-keyword">let</span> users = [ john, pete, mary ];

<span class="hljs-keyword">let</span> names = <span class="hljs-comment">/* ... your code */</span>

alert( names ); <span class="hljs-comment">// John, Pete, Mary</span></code></pre>

      </fieldset>
      
      <fieldset id='_LTeAPh'>
      <legend>solution</legend>
      <ul>
<li>请注意方法的存储方式。它们只是被添加到 <code>this.methods</code> 属性中。</li>
<li>所有检测和数字转换都通过 <code>calculate</code> 方法完成。将来可能会扩展它以支持更复杂的表达式。</li>
</ul>

      </fieldset>
      
      <fieldset id='_QCJcfL'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="创建一个可扩展的-calculator">创建一个可扩展的 calculator</h1>
<p>创建一个构造函数 <code>Calculator</code>，以创建“可扩展”的 calculator 对象。</p>
<p>该任务由两部分组成。</p>
<ol>
<li><p>首先，实现 <code>calculate(str)</code> 方法，该方法接受像 <code>&quot;1 + 2&quot;</code> 这样格式为“数字 运算符 数字”（以空格分隔）的字符串，并返回结果。该方法需要能够理解加号 <code>+</code> 和减号 <code>-</code>。</p>
<p> 用法示例：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> calc = <span class="hljs-keyword">new</span> Calculator;

alert( calc.calculate(<span class="hljs-string">&quot;3 + 7&quot;</span>) ); <span class="hljs-comment">// 10</span></code></pre>
</li>
<li><p>然后添加方法 <code>addMethod(name, func)</code>，该方法教 calculator 进行新操作。它需要运算符 <code>name</code> 和实现它的双参数函数 <code>func(a,b)</code>。</p>
<p> 例如，我们添加乘法 <code>*</code>，除法 <code>/</code> 和求幂 <code>**</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> powerCalc = <span class="hljs-keyword">new</span> Calculator;
powerCalc.addMethod(<span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a * b);
powerCalc.addMethod(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a / b);
powerCalc.addMethod(<span class="hljs-string">&quot;**&quot;</span>, <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a ** b);

<span class="hljs-keyword">let</span> result = powerCalc.calculate(<span class="hljs-string">&quot;2 ** 3&quot;</span>);
alert( result ); <span class="hljs-comment">// 8</span></code></pre>
</li>
</ol>
<ul>
<li>此任务中没有括号或复杂的表达式。</li>
<li>数字和运算符之间只有一个空格。</li>
<li>你可以自行选择是否添加错误处理功能。</li>
</ul>

      </fieldset>
      
      <fieldset id='_4b0Fgh'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-keyword">let</span> john = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-attr">surname</span>: <span class="hljs-string">&quot;Smith&quot;</span>, <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> };
<span class="hljs-keyword">let</span> pete = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Pete&quot;</span>, <span class="hljs-attr">surname</span>: <span class="hljs-string">&quot;Hunt&quot;</span>, <span class="hljs-attr">id</span>: <span class="hljs-number">2</span> };
<span class="hljs-keyword">let</span> mary = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Mary&quot;</span>, <span class="hljs-attr">surname</span>: <span class="hljs-string">&quot;Key&quot;</span>, <span class="hljs-attr">id</span>: <span class="hljs-number">3</span> };

<span class="hljs-keyword">let</span> users = [ john, pete, mary ];

*!*
<span class="hljs-keyword">let</span> usersMapped = users.map(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> ({
  <span class="hljs-attr">fullName</span>: <span class="hljs-string">`<span class="hljs-subst">${user.name}</span> <span class="hljs-subst">${user.surname}</span>`</span>,
  <span class="hljs-attr">id</span>: user.id
}));
*/!*

<span class="hljs-comment">/*
usersMapped = [
  { fullName: &quot;John Smith&quot;, id: 1 },
  { fullName: &quot;Pete Hunt&quot;, id: 2 },
  { fullName: &quot;Mary Key&quot;, id: 3 }
]
*/</span>

alert( usersMapped[<span class="hljs-number">0</span>].id ); <span class="hljs-comment">// 1</span>
alert( usersMapped[<span class="hljs-number">0</span>].fullName ); <span class="hljs-comment">// John Smith</span></code></pre>
<p>请注意，在箭头函数中，我们需要使用额外的括号。 </p>
<p>我们不能这样写：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> usersMapped = users.map(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> *!*{*/!*
  fullName: <span class="hljs-string">`<span class="hljs-subst">${user.name}</span> <span class="hljs-subst">${user.surname}</span>`</span>,
  <span class="hljs-attr">id</span>: user.id
});</code></pre>
<p>我们记得，有两种箭头函数的写法：直接返回值 <code>value =&gt; expr</code> 和带主体的 <code>value =&gt; {...}</code>。</p>
<p>JavaScript 在这里会把 <code>{</code> 视为函数体的开始，而不是对象的开始。解决方法是将它们包装在普通括号 <code>()</code> 中：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> usersMapped = users.map(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> *!*({*/!*
  fullName: <span class="hljs-string">`<span class="hljs-subst">${user.name}</span> <span class="hljs-subst">${user.surname}</span>`</span>,
  <span class="hljs-attr">id</span>: user.id
}));</code></pre>
<p>这样就可以了。</p>

      </fieldset>
      
      <fieldset id='_XiKmhc'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="映射到对象">映射到对象</h1>
<p>你有一个 <code>user</code> 对象数组，每个对象都有 <code>name</code>，<code>surname</code> 和 <code>id</code>。</p>
<p>编写代码以该数组为基础，创建另一个具有 <code>id</code> 和 <code>fullName</code> 的对象数组，其中 <code>fullName</code> 由 <code>name</code> 和 <code>surname</code> 生成。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> john = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-attr">surname</span>: <span class="hljs-string">&quot;Smith&quot;</span>, <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> };
<span class="hljs-keyword">let</span> pete = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Pete&quot;</span>, <span class="hljs-attr">surname</span>: <span class="hljs-string">&quot;Hunt&quot;</span>, <span class="hljs-attr">id</span>: <span class="hljs-number">2</span> };
<span class="hljs-keyword">let</span> mary = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Mary&quot;</span>, <span class="hljs-attr">surname</span>: <span class="hljs-string">&quot;Key&quot;</span>, <span class="hljs-attr">id</span>: <span class="hljs-number">3</span> };

<span class="hljs-keyword">let</span> users = [ john, pete, mary ];

*!*
<span class="hljs-keyword">let</span> usersMapped = <span class="hljs-comment">/* ... your code ... */</span>
*/!*

<span class="hljs-comment">/*
usersMapped = [
  { fullName: &quot;John Smith&quot;, id: 1 },
  { fullName: &quot;Pete Hunt&quot;, id: 2 },
  { fullName: &quot;Mary Key&quot;, id: 3 }
]
*/</span>

alert( usersMapped[<span class="hljs-number">0</span>].id ) <span class="hljs-comment">// 1</span>
alert( usersMapped[<span class="hljs-number">0</span>].fullName ) <span class="hljs-comment">// John Smith</span></code></pre>
<p>所以，实际上你需要将一个对象数组映射到另一个对象数组。在这儿尝试使用箭头函数 <code>=&gt;</code> 来编写。</p>

      </fieldset>
      
      <fieldset id='_xRkvJs'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sortByAge</span>(<span class="hljs-params">arr</span>) </span>{
  arr.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.age &gt; b.age ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>);
}

<span class="hljs-keyword">let</span> john = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> };
<span class="hljs-keyword">let</span> pete = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Pete&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> };
<span class="hljs-keyword">let</span> mary = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Mary&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">28</span> };

<span class="hljs-keyword">let</span> arr = [ pete, john, mary ];

sortByAge(arr);

<span class="hljs-comment">// 排序后的数组为：[john, mary, pete]</span>
alert(arr[<span class="hljs-number">0</span>].name); <span class="hljs-comment">// John</span>
alert(arr[<span class="hljs-number">1</span>].name); <span class="hljs-comment">// Mary</span>
alert(arr[<span class="hljs-number">2</span>].name); <span class="hljs-comment">// Pete</span></code></pre>
<p>译注：解决方案的代码还可以更短一些</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sortByAge</span>(<span class="hljs-params">arr</span>) </span>{
  arr.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.age - b.age);
}</code></pre>
<p>因为 <code>sort()</code> 方法的语法为 <code>arr.sort([compareFunction])</code>，如果没有指明 <code>compareFunction</code>，那么元素会被按照转换为的字符串的诸个字符的 Unicode 编码进行排序，如果指明了 <code>compareFunction</code>，那么数组会按照调用该函数的返回值排序。即 <code>a</code> 和 <code>b</code> 是两个将要被比较的元素：</p>
<ul>
<li>如果 <code>compareFunction(a, b)</code> 小于 <code>0</code>，那么 <code>a</code> 会被排列到 <code>b</code> 之前；</li>
<li>如果 <code>compareFunction(a, b)</code> 等于 <code>0</code>，那么 <code>a</code> 和 <code>b</code> 的相对位置不变。备注：ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）；</li>
<li>如果 <code>compareFunction(a, b)</code> 大于 <code>0</code>，那么 <code>b</code> 会被排列到 <code>a</code> 之前。</li>
</ul>
<p>因此，升序排列的函数可以简写为：<code>(a, b) =&gt; a.age - b.age</code>。</p>

      </fieldset>
      
      <fieldset id='_nOsOvN'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="按年龄对用户排序">按年龄对用户排序</h1>
<p>编写函数 <code>sortByAge(users)</code> 获得对象数组的 <code>age</code> 属性，并根据 <code>age</code> 对这些对象数组进行排序。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> john = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> };
<span class="hljs-keyword">let</span> pete = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Pete&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> };
<span class="hljs-keyword">let</span> mary = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Mary&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">28</span> };

<span class="hljs-keyword">let</span> arr = [ pete, john, mary ];

sortByAge(arr);

<span class="hljs-comment">// now: [john, mary, pete]</span>
alert(arr[<span class="hljs-number">0</span>].name); <span class="hljs-comment">// John</span>
alert(arr[<span class="hljs-number">1</span>].name); <span class="hljs-comment">// Mary</span>
alert(arr[<span class="hljs-number">2</span>].name); <span class="hljs-comment">// Pete</span></code></pre>

      </fieldset>
      
      <fieldset id='_Zg2Z5F'>
      <legend>solution</legend>
      <p>简单的解决方案可以是：</p>
<pre><code class="language-js">*!*
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shuffle</span>(<span class="hljs-params">array</span>) </span>{
  array.sort(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">Math</span>.random() - <span class="hljs-number">0.5</span>);
}
*/!*

<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
shuffle(arr);
alert(arr);</code></pre>
<p>这样是可以的，因为 <code>Math.random() - 0.5</code> 是一个可能是正数或负数的随机数，因此排序函数会随机地对数组中的元素进行重新排序。</p>
<p>但是，由于排序函数并非旨在以这种方式使用，因此并非所有的排列都具有相同的概率。</p>
<p>例如，请考虑下面的代码。它运行 100 万次 <code>shuffle</code> 并计算所有可能结果的出现次数：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shuffle</span>(<span class="hljs-params">array</span>) </span>{
  array.sort(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">Math</span>.random() - <span class="hljs-number">0.5</span>);
}

<span class="hljs-comment">// 所有可能排列的出现次数</span>
<span class="hljs-keyword">let</span> count = {
  <span class="hljs-string">&#x27;123&#x27;</span>: <span class="hljs-number">0</span>,
  <span class="hljs-string">&#x27;132&#x27;</span>: <span class="hljs-number">0</span>,
  <span class="hljs-string">&#x27;213&#x27;</span>: <span class="hljs-number">0</span>,
  <span class="hljs-string">&#x27;231&#x27;</span>: <span class="hljs-number">0</span>,
  <span class="hljs-string">&#x27;321&#x27;</span>: <span class="hljs-number">0</span>,
  <span class="hljs-string">&#x27;312&#x27;</span>: <span class="hljs-number">0</span>
};

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++) {
  <span class="hljs-keyword">let</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
  shuffle(array);
  count[array.join(<span class="hljs-string">&#x27;&#x27;</span>)]++;
}

<span class="hljs-comment">// 显示所有可能排列的出现次数</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> count) {
  alert(<span class="hljs-string">`<span class="hljs-subst">${key}</span>: <span class="hljs-subst">${count[key]}</span>`</span>);
}</code></pre>
<p>示例结果（取决于 Javascript 引擎）：</p>
<pre><code class="language-js"><span class="hljs-number">123</span>: <span class="hljs-number">250706</span>
<span class="hljs-number">132</span>: <span class="hljs-number">124425</span>
<span class="hljs-number">213</span>: <span class="hljs-number">249618</span>
<span class="hljs-number">231</span>: <span class="hljs-number">124880</span>
<span class="hljs-number">312</span>: <span class="hljs-number">125148</span>
<span class="hljs-number">321</span>: <span class="hljs-number">125223</span></code></pre>
<p>我们可以清楚地看到这种倾斜：<code>123</code> 和 <code>213</code> 的出现频率比其他情况高得多。</p>
<p>使用不同的 JavaScript 引擎运行这个示例代码得到的结果可能会有所不同，但是我们已经可以看到这种方法是不可靠的。</p>
<p>为什么它不起作用？一般来说，<code>sort</code> 是一个“黑匣子”：我们将一个数组和一个比较函数放入其中，并期望其对数组进行排序。但是由于比较的完全随机性，这个黑匣子疯了，它发疯地确切程度取决于引擎中的具体实现方法。</p>
<p>还有其他很好的方法可以完成这项任务。例如，有一个很棒的算法叫作 <a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">Fisher-Yates shuffle</a>。其思路是：逆向遍历数组，并将每个元素与其前面的随机的一个元素互换位置：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shuffle</span>(<span class="hljs-params">array</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = array.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) {
    <span class="hljs-keyword">let</span> j = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * (i + <span class="hljs-number">1</span>)); <span class="hljs-comment">// 从 0 到 i 的随机索引</span>

    <span class="hljs-comment">// 交换元素 array[i] 和 array[j]</span>
    <span class="hljs-comment">// 我们使用“解构分配（destructuring assignment）”语法来实现它</span>
    <span class="hljs-comment">// 你将在后面的章节中找到有关该语法的更多详细信息</span>
    <span class="hljs-comment">// 可以写成：</span>
    <span class="hljs-comment">// let t = array[i]; array[i] = array[j]; array[j] = t</span>
    [array[i], array[j]] = [array[j], array[i]];
  }
}</code></pre>
<p>让我们以相同的方式测试一下：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shuffle</span>(<span class="hljs-params">array</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = array.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) {
    <span class="hljs-keyword">let</span> j = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * (i + <span class="hljs-number">1</span>));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

<span class="hljs-comment">// 所有可能排列的出现次数</span>
<span class="hljs-keyword">let</span> count = {
  <span class="hljs-string">&#x27;123&#x27;</span>: <span class="hljs-number">0</span>,
  <span class="hljs-string">&#x27;132&#x27;</span>: <span class="hljs-number">0</span>,
  <span class="hljs-string">&#x27;213&#x27;</span>: <span class="hljs-number">0</span>,
  <span class="hljs-string">&#x27;231&#x27;</span>: <span class="hljs-number">0</span>,
  <span class="hljs-string">&#x27;321&#x27;</span>: <span class="hljs-number">0</span>,
  <span class="hljs-string">&#x27;312&#x27;</span>: <span class="hljs-number">0</span>
};

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++) {
  <span class="hljs-keyword">let</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
  shuffle(array);
  count[array.join(<span class="hljs-string">&#x27;&#x27;</span>)]++;
}

<span class="hljs-comment">// 显示所有可能排列的出现次数</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> count) {
  alert(<span class="hljs-string">`<span class="hljs-subst">${key}</span>: <span class="hljs-subst">${count[key]}</span>`</span>);
}</code></pre>
<p>示例输出：</p>
<pre><code class="language-js"><span class="hljs-number">123</span>: <span class="hljs-number">166693</span>
<span class="hljs-number">132</span>: <span class="hljs-number">166647</span>
<span class="hljs-number">213</span>: <span class="hljs-number">166628</span>
<span class="hljs-number">231</span>: <span class="hljs-number">167517</span>
<span class="hljs-number">312</span>: <span class="hljs-number">166199</span>
<span class="hljs-number">321</span>: <span class="hljs-number">166316</span></code></pre>
<p>现在看起来不错：所有排列都以相同的概率出现。</p>
<p>另外，在性能方面，Fisher — Yates 算法要好得多，没有“排序”开销。</p>

      </fieldset>
      
      <fieldset id='_pVYTWz'>
      <legend>task</legend>
      <p>importance: 3</p>
<hr>
<h1 id="随机排列数组">随机排列数组</h1>
<p>编写函数 <code>shuffle(array)</code> 来随机排列数组的元素。</p>
<p>多次运行 <code>shuffle</code> 可能导致元素顺序的不同。例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];

shuffle(arr);
<span class="hljs-comment">// arr = [3, 2, 1]</span>

shuffle(arr);
<span class="hljs-comment">// arr = [2, 1, 3]</span>

shuffle(arr);
<span class="hljs-comment">// arr = [3, 1, 2]</span>
<span class="hljs-comment">// ...</span></code></pre>
<p>所有元素顺序应该具有相等的概率。例如，可以将 <code>[1,2,3]</code> 重新排序为 <code>[1,2,3]</code> 或 <code>[1,3,2]</code> 或 <code>[3,1,2]</code> 等，每种情况的概率相等。</p>

      </fieldset>
      
      <fieldset id='_WWn86V'>
      <legend>article</legend>
      <h1 id="数组方法">数组方法</h1>
<p>数组提供的方法有很多。为了方便起见，在本章中，我们将按组讲解。</p>
<h2 id="添加移除数组元素">添加/移除数组元素</h2>
<p>我们已经学了从数组的首端或尾端添加和删除元素的方法：</p>
<ul>
<li><code>arr.push(...items)</code> —— 从尾端添加元素，</li>
<li><code>arr.pop()</code> —— 从尾端提取元素，</li>
<li><code>arr.shift()</code> —— 从首端提取元素，</li>
<li><code>arr.unshift(...items)</code> —— 从首端添加元素。</li>
</ul>
<p>这里还有其他几种方法。</p>
<h3 id="splice">splice</h3>
<p>如何从数组中删除元素？</p>
<p>数组是对象，所以我们可以尝试使用 <code>delete</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;I&quot;</span>, <span class="hljs-string">&quot;go&quot;</span>, <span class="hljs-string">&quot;home&quot;</span>];

<span class="hljs-keyword">delete</span> arr[<span class="hljs-number">1</span>]; <span class="hljs-comment">// remove &quot;go&quot;</span>

alert( arr[<span class="hljs-number">1</span>] ); <span class="hljs-comment">// undefined</span>

<span class="hljs-comment">// now arr = [&quot;I&quot;,  , &quot;home&quot;];</span>
alert( arr.length ); <span class="hljs-comment">// 3</span></code></pre>
<p>元素被删除了，但数组仍然有 3 个元素，我们可以看到 <code>arr.length == 3</code>。</p>
<p>这很正常，因为 <code>delete obj.key</code> 是通过 <code>key</code> 来移除对应的值。对于对象来说是可以的。但是对于数组来说，我们通常希望剩下的元素能够移动并占据被释放的位置。我们希望得到一个更短的数组。</p>
<p>所以应该使用特殊的方法。</p>
<p><a href="mdn:js/Array/splice">arr.splice(str)</a> 方法可以说是处理数组的瑞士军刀。它可以做所有事情：添加，删除和插入元素。</p>
<p>语法是：</p>
<pre><code class="language-js">arr.splice(index[, deleteCount, elem1, ..., elemN])</code></pre>
<p>从 <code>index</code> 开始：删除 <code>deleteCount</code> 个元素并在当前位置插入 <code>elem1, ..., elemN</code>。最后返回已删除元素的数组。</p>
<p>通过例子我们可以很容易地掌握这个方法。</p>
<p>让我们从删除开始：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;I&quot;</span>, <span class="hljs-string">&quot;study&quot;</span>, <span class="hljs-string">&quot;JavaScript&quot;</span>];

*!*
arr.splice(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 从索引 1 开始删除 1 个元素</span>
*/!*

alert( arr ); <span class="hljs-comment">// [&quot;I&quot;, &quot;JavaScript&quot;]</span></code></pre>
<p>简单，对吧？从索引 <code>1</code> 开始删除 <code>1</code> 个元素。</p>
<p>在下一个例子中，我们删除了 3 个元素，并用另外两个元素替换它们：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [*!*<span class="hljs-string">&quot;I&quot;</span>, <span class="hljs-string">&quot;study&quot;</span>, <span class="hljs-string">&quot;JavaScript&quot;</span>,*/!* <span class="hljs-string">&quot;right&quot;</span>, <span class="hljs-string">&quot;now&quot;</span>];

<span class="hljs-comment">// remove 3 first elements and replace them with another</span>
arr.splice(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;Let&#x27;s&quot;</span>, <span class="hljs-string">&quot;dance&quot;</span>);

alert( arr ) <span class="hljs-comment">// now [*!*&quot;Let&#x27;s&quot;, &quot;dance&quot;*/!*, &quot;right&quot;, &quot;now&quot;]</span></code></pre>
<p>在这里我们可以看到 <code>splice</code> 返回了已删除元素的数组：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [*!*<span class="hljs-string">&quot;I&quot;</span>, <span class="hljs-string">&quot;study&quot;</span>,*/!* <span class="hljs-string">&quot;JavaScript&quot;</span>, <span class="hljs-string">&quot;right&quot;</span>, <span class="hljs-string">&quot;now&quot;</span>];

<span class="hljs-comment">// 删除前两个元素</span>
<span class="hljs-keyword">let</span> removed = arr.splice(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);

alert( removed ); <span class="hljs-comment">// &quot;I&quot;, &quot;study&quot; &lt;-- 被从数组中删除了的元素</span></code></pre>
<p>我们可以将 <code>deleteCount</code> 设置为 <code>0</code>，<code>splice</code> 方法就能够插入元素而不用删除任何元素：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;I&quot;</span>, <span class="hljs-string">&quot;study&quot;</span>, <span class="hljs-string">&quot;JavaScript&quot;</span>];

<span class="hljs-comment">// 从索引 2 开始</span>
<span class="hljs-comment">// 删除 0 个元素</span>
<span class="hljs-comment">// 然后插入 &quot;complex&quot; 和 &quot;language&quot;</span>
arr.splice(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;complex&quot;</span>, <span class="hljs-string">&quot;language&quot;</span>);

alert( arr ); <span class="hljs-comment">// &quot;I&quot;, &quot;study&quot;, &quot;complex&quot;, &quot;language&quot;, &quot;JavaScript&quot;</span></code></pre>
<pre><code class="language-smart">在这里和其他数组方法中，负向索引都是被允许的。它们从数组末尾计算位置，如下所示：

```js run
let arr = [1, 2, 5];

// 从索引 -1（尾端前一位）
// 删除 0 个元素，
// 然后插入 3 和 4
arr.splice(-1, 0, 3, 4);

alert( arr ); // 1,2,3,4,5
```</code></pre>
<h3 id="slice">slice</h3>
<p><a href="mdn:js/Array/slice">arr.slice</a> 方法比 <code>arr.splice</code> 简单得多。</p>
<p>语法是：</p>
<pre><code class="language-js">arr.slice([start], [end])</code></pre>
<p>它会返回一个新数组，将所有从索引 <code>start</code> 到 <code>end</code>（不包括 <code>end</code>）的数组项复制到一个新的数组。<code>start</code> 和 <code>end</code> 都可以是负数，在这种情况下，从末尾计算索引。</p>
<p>它和字符串的 <code>str.slice</code> 方法有点像，就是把子字符串替换成子数组。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;t&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;s&quot;</span>, <span class="hljs-string">&quot;t&quot;</span>];

alert( arr.slice(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) ); <span class="hljs-comment">// e,s（复制从位置 1 到位置 3 的元素）</span>

alert( arr.slice(-<span class="hljs-number">2</span>) ); <span class="hljs-comment">// s,t（复制从位置 -2 到尾端的元素）</span></code></pre>
<p>我们也可以不带参数地调用它：<code>arr.slice()</code> 会创建一个 <code>arr</code> 的副本。其通常用于获取副本，以进行不影响原始数组的进一步转换。</p>
<h3 id="concat">concat</h3>
<p><a href="mdn:js/Array/concat">arr.concat</a> 创建一个新数组，其中包含来自于其他数组和其他项的值。</p>
<p>语法：</p>
<pre><code class="language-js">arr.concat(arg1, arg2...)</code></pre>
<p>它接受任意数量的参数 —— 数组或值都可以。</p>
<p>结果是一个包含来自于 <code>arr</code>，然后是 <code>arg1</code>，<code>arg2</code> 的元素的新数组。</p>
<p>如果参数 <code>argN</code> 是一个数组，那么其中的所有元素都会被复制。否则，将复制参数本身。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];

<span class="hljs-comment">// create an array from: arr and [3,4]</span>
alert( arr.concat([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]) ); <span class="hljs-comment">// 1,2,3,4</span>

<span class="hljs-comment">// create an array from: arr and [3,4] and [5,6]</span>
alert( arr.concat([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]) ); <span class="hljs-comment">// 1,2,3,4,5,6</span>

<span class="hljs-comment">// create an array from: arr and [3,4], then add values 5 and 6</span>
alert( arr.concat([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-number">5</span>, <span class="hljs-number">6</span>) ); <span class="hljs-comment">// 1,2,3,4,5,6</span></code></pre>
<p>通常，它只复制数组中的元素。其他对象，即使它们看起来像数组一样，但仍然会被作为一个整体添加：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];

<span class="hljs-keyword">let</span> arrayLike = {
  <span class="hljs-number">0</span>: <span class="hljs-string">&quot;something&quot;</span>,
  <span class="hljs-attr">length</span>: <span class="hljs-number">1</span>
};

alert( arr.concat(arrayLike) ); <span class="hljs-comment">// 1,2,[object Object]</span></code></pre>
<p>……但是，如果类似数组的对象具有 <code>Symbol.isConcatSpreadable</code> 属性，那么它就会被 <code>concat</code> 当作一个数组来处理：此对象中的元素将被添加：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];

<span class="hljs-keyword">let</span> arrayLike = {
  <span class="hljs-number">0</span>: <span class="hljs-string">&quot;something&quot;</span>,
  <span class="hljs-number">1</span>: <span class="hljs-string">&quot;else&quot;</span>,
*!*
  [<span class="hljs-built_in">Symbol</span>.isConcatSpreadable]: <span class="hljs-literal">true</span>,
*/!*
  length: <span class="hljs-number">2</span>
};

alert( arr.concat(arrayLike) ); <span class="hljs-comment">// 1,2,something,else</span></code></pre>
<h2 id="遍历：foreach">遍历：forEach</h2>
<p><a href="mdn:js/Array/forEach">arr.forEach</a> 方法允许为数组的每个元素都运行一个函数。</p>
<p>语法：</p>
<pre><code class="language-js">arr.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, array</span>) </span>{
  <span class="hljs-comment">// ... do something with item</span>
});</code></pre>
<p>例如，下面这个程序显示了数组的每个元素：</p>
<pre><code class="language-js"><span class="hljs-comment">// 对每个元素调用 alert</span>
[<span class="hljs-string">&quot;Bilbo&quot;</span>, <span class="hljs-string">&quot;Gandalf&quot;</span>, <span class="hljs-string">&quot;Nazgul&quot;</span>].forEach(alert);</code></pre>
<p>而这段代码更详细地介绍了它们在目标数组中的位置：</p>
<pre><code class="language-js">[<span class="hljs-string">&quot;Bilbo&quot;</span>, <span class="hljs-string">&quot;Gandalf&quot;</span>, <span class="hljs-string">&quot;Nazgul&quot;</span>].forEach(<span class="hljs-function">(<span class="hljs-params">item, index, array</span>) =&gt;</span> {
  alert(<span class="hljs-string">`<span class="hljs-subst">${item}</span> is at index <span class="hljs-subst">${index}</span> in <span class="hljs-subst">${array}</span>`</span>);
});</code></pre>
<p>该函数的结果（如果它有返回）会被抛弃和忽略。</p>
<h2 id="在数组中搜索">在数组中搜索</h2>
<p>现在，让我们介绍在数组中进行搜索的方法。</p>
<h3 id="indexoflastindexof-和-includes">indexOf/lastIndexOf 和 includes</h3>
<p><a href="mdn:js/Array/indexOf">arr.indexOf</a>、<a href="mdn:js/Array/lastIndexOf">arr.lastIndexOf</a> 和 <a href="mdn:js/Array/includes">arr.includes</a> 方法与字符串操作具有相同的语法，并且作用基本上也与字符串的方法相同，只不过这里是对数组元素而不是字符进行操作：</p>
<ul>
<li><code>arr.indexOf(item, from)</code> 从索引 <code>from</code> 开始搜索 <code>item</code>，如果找到则返回索引，否则返回 <code>-1</code>。</li>
<li><code>arr.lastIndexOf(item, from)</code> —— 和上面相同，只是从右向左搜索。</li>
<li><code>arr.includes(item, from)</code> —— 从索引 <code>from</code> 开始搜索 <code>item</code>，如果找到则返回 <code>true</code>（译注：如果没找到，则返回 <code>false</code>）。</li>
</ul>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>];

alert( arr.indexOf(<span class="hljs-number">0</span>) ); <span class="hljs-comment">// 1</span>
alert( arr.indexOf(<span class="hljs-literal">false</span>) ); <span class="hljs-comment">// 2</span>
alert( arr.indexOf(<span class="hljs-literal">null</span>) ); <span class="hljs-comment">// -1</span>

alert( arr.includes(<span class="hljs-number">1</span>) ); <span class="hljs-comment">// true</span></code></pre>
<p>请注意，这些方法使用的是严格相等 <code>===</code> 比较。所以如果我们搜索 <code>false</code>，会精确到的确是 <code>false</code> 而不是数字 <code>0</code>。</p>
<p>如果我们想检查是否包含某个元素，并且不想知道确切的索引，那么 <code>arr.includes</code> 是首选。</p>
<p>此外，<code>includes</code> 的一个非常小的差别是它能正确处理<code>NaN</code>，而不像 <code>indexOf/lastIndexOf</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-literal">NaN</span>];
alert( arr.indexOf(<span class="hljs-literal">NaN</span>) ); <span class="hljs-comment">// -1（应该为 0，但是严格相等 === equality 对 NaN 无效）</span>
alert( arr.includes(<span class="hljs-literal">NaN</span>) );<span class="hljs-comment">// true（这个结果是对的）</span></code></pre>
<h3 id="find-和-findindex">find 和 findIndex</h3>
<p>想象一下，我们有一个对象数组。我们如何找到具有特定条件的对象？</p>
<p>这时可以用 <a href="mdn:js/Array/find">arr.find</a> 方法。</p>
<p>语法如下：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> result = arr.find(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, array</span>) </span>{
  <span class="hljs-comment">// 如果返回 true，则返回 item 并停止迭代</span>
  <span class="hljs-comment">// 对于 falsy 则返回 undefined</span>
});</code></pre>
<p>依次对数组中的每个元素调用该函数：</p>
<ul>
<li><code>item</code> 是元素。</li>
<li><code>index</code> 是它的索引。</li>
<li><code>array</code> 是数组本身。</li>
</ul>
<p>如果它返回 <code>true</code>，则搜索停止，并返回 <code>item</code>。如果没有搜索到，则返回 <code>undefined</code>。</p>
<p>例如，我们有一个存储用户的数组，每个用户都有 <code>id</code> 和 <code>name</code> 字段。让我们找到 <code>id == 1</code> 的那个用户：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> users = [
  {<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>},
  {<span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Pete&quot;</span>},
  {<span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Mary&quot;</span>}
];

<span class="hljs-keyword">let</span> user = users.find(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.id == <span class="hljs-number">1</span>);

alert(user.name); <span class="hljs-comment">// John</span></code></pre>
<p>在现实生活中，对象数组是很常见的，所以 <code>find</code> 方法非常有用。</p>
<p>注意在这个例子中，我们传给了 <code>find</code> 一个单参数函数 <code>item =&gt; item.id == 1</code>。这很典型，并且 <code>find</code> 方法的其他参数很少使用。</p>
<p><a href="mdn:js/Array/findIndex">arr.findIndex</a> 方法（与 <code>arr.find</code> 方法）基本上是一样的，但它返回找到元素的索引，而不是元素本身。并且在未找到任何内容时返回 <code>-1</code>。</p>
<h3 id="filter">filter</h3>
<p><code>find</code> 方法搜索的是使函数返回 <code>true</code> 的第一个（单个）元素。</p>
<p>如果需要匹配的有很多，我们可以使用 <a href="mdn:js/Array/filter">arr.filter(fn)</a>。</p>
<p>语法与 <code>find</code> 大致相同，但是 <code>filter</code> 返回的是所有匹配元素组成的数组：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> results = arr.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, array</span>) </span>{
  <span class="hljs-comment">// 如果 true item 被 push 到 results，迭代继续</span>
  <span class="hljs-comment">// 如果什么都没找到，则返回空数组</span>
});</code></pre>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> users = [
  {<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>},
  {<span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Pete&quot;</span>},
  {<span class="hljs-attr">id</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Mary&quot;</span>}
];

<span class="hljs-comment">// 返回前两个用户的数组</span>
<span class="hljs-keyword">let</span> someUsers = users.filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.id &lt; <span class="hljs-number">3</span>);

alert(someUsers.length); <span class="hljs-comment">// 2</span></code></pre>
<h2 id="转换数组">转换数组</h2>
<p>让我们继续学习进行数组转换和重新排序的方法。</p>
<h3 id="map">map</h3>
<p><a href="mdn:js/Array/map">arr.map</a> 方法是最有用和经常使用的方法之一。</p>
<p>它对数组的每个元素都调用函数，并返回结果数组。</p>
<p>语法：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> result = arr.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, array</span>) </span>{
  <span class="hljs-comment">// 返回新值而不是当前元素</span>
})</code></pre>
<p>例如，在这里我们将每个元素转换为它的字符串长度：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> lengths = [<span class="hljs-string">&quot;Bilbo&quot;</span>, <span class="hljs-string">&quot;Gandalf&quot;</span>, <span class="hljs-string">&quot;Nazgul&quot;</span>].map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.length);
alert(lengths); <span class="hljs-comment">// 5,7,6</span></code></pre>
<h3 id="sortfn">sort(fn)</h3>
<p><a href="mdn:js/Array/sort">arr.sort</a> 方法对数组进行 <strong>原位（in-place）</strong> 排序，更改元素的顺序。(译注：原位是指在此数组内，而非生成一个新数组。)</p>
<p>它还返回排序后的数组，但是返回值通常会被忽略，因为修改了 <code>arr</code> 本身。</p>
<p>语法：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">15</span> ];

<span class="hljs-comment">// 该方法重新排列 arr 的内容</span>
arr.sort();

alert( arr );  <span class="hljs-comment">// *!*1, 15, 2*/!*</span></code></pre>
<p>你有没有注意到结果有什么奇怪的地方？</p>
<p>顺序变成了 <code>1, 15, 2</code>。不对，但为什么呢？</p>
<p><strong>这些元素默认情况下被按字符串进行排序。</strong></p>
<p>从字面上看，所有元素都被转换为字符串，然后进行比较。对于字符串，按照词典顺序进行排序，实际上应该是 <code>&quot;2&quot; &gt; &quot;15&quot;</code>。</p>
<p>要使用我们自己的排序顺序，我们需要提供一个函数作为 <code>arr.sort()</code> 的参数。</p>
<p>该函数应该比较两个任意值并返回：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compare</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">if</span> (a &gt; b) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 如果第一个值比第二个值大</span>
  <span class="hljs-keyword">if</span> (a == b) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 如果两个值相等</span>
  <span class="hljs-keyword">if</span> (a &lt; b) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 如果第一个值比第二个值小</span>
}</code></pre>
<p>例如，按数字进行排序：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compareNumeric</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">if</span> (a &gt; b) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  <span class="hljs-keyword">if</span> (a == b) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">if</span> (a &lt; b) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
}

<span class="hljs-keyword">let</span> arr = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">15</span> ];

*!*
arr.sort(compareNumeric);
*/!*

alert(arr);  <span class="hljs-comment">// *!*1, 2, 15*/!*</span></code></pre>
<p>现在结果符合预期了。</p>
<p>我们思考一下这儿发生了什么。<code>arr</code> 可以是由任何内容组成的数组，对吗？它可能包含数字、字符串、对象或其他任何内容。我们有一组 <strong>一些元素</strong>。要对其进行排序，我们需要一个 <strong>排序函数</strong> 来确认如何比较这些元素。默认是按字符串进行排序的。</p>
<p><code>arr.sort(fn)</code> 方法实现了通用的排序算法。我们不需要关心它的内部工作原理（大多数情况下都是经过 <a href="https://en.wikipedia.org/wiki/Quicksort">快速排序</a> 算法优化的）。它将遍历数组，使用提供的函数比较其元素并对其重新排序，我们所需要的就是提供执行比较的函数 <code>fn</code>。</p>
<p>顺便说一句，如果我们想知道要比较哪些元素 —— 那么什么都不会阻止 alert 它们：</p>
<pre><code class="language-js">[<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>, <span class="hljs-number">15</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>].sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>{
  alert( a + <span class="hljs-string">&quot; &lt;&gt; &quot;</span> + b );
});</code></pre>
<p>该算法可以在此过程中，将一个元素与多个其他元素进行比较，但是它会尝试进行尽可能少的比较。</p>
<pre><code class="language-smart">实际上，比较函数只需要返回一个正数表示“大于”，一个负数表示“小于”。

通过这个原理我们可以编写更短的函数：

```js run
let arr = [ 1, 2, 15 ];

arr.sort(function(a, b) { return a - b; });

alert(arr);  // *!*1, 2, 15*/!*
```</code></pre>
<pre><code class="language-smart">你还记得 [箭头函数](info:arrow-functions-basics) 吗？这里使用箭头函数会更加简洁：

```js
arr.sort( (a, b) =&gt; a - b );
```

这与上面更长的版本完全相同。</code></pre>
<p>````smart header=&quot;使用 <code>localeCompare</code> for strings&quot;
你记得 <a href="info:string#correct-comparisons">字符串比较</a> 算法吗？默认情况下，它通过字母的代码比较字母。</p>
<p>对于许多字母，最好使用 <code>str.localeCompare</code> 方法正确地对字母进行排序，例如 <code>Ö</code>。</p>
<p>例如，让我们用德语对几个国家/地区进行排序：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> countries = [<span class="hljs-string">&#x27;Österreich&#x27;</span>, <span class="hljs-string">&#x27;Andorra&#x27;</span>, <span class="hljs-string">&#x27;Vietnam&#x27;</span>];

alert( countries.sort( <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a &gt; b ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>) ); <span class="hljs-comment">// Andorra, Vietnam, Österreich（错的）</span>

alert( countries.sort( <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.localeCompare(b) ) ); <span class="hljs-comment">// Andorra,Österreich,Vietnam（对的！）</span></code></pre>
<pre><code>
### reverse

[arr.reverse](mdn:js/Array/reverse) 方法用于颠倒 `arr` 中元素的顺序。

例如：

```js run
let arr = [1, 2, 3, 4, 5];
arr.reverse();

alert( arr ); // 5,4,3,2,1
```

它也会返回颠倒后的数组 `arr`。

### split 和 join

举一个现实生活场景的例子。我们正在编写一个消息应用程序，并且该人员输入以逗号分隔的接收者列表：`John, Pete, Mary`。但对我们来说，名字数组比单个字符串舒适得多。怎么做才能获得这样的数组呢？

[str.split(delim)](mdn:js/String/split) 方法可以做到。它通过给定的分隔符 `delim` 将字符串分割成一个数组。

在下面的例子中，我们用“逗号后跟着一个空格”作为分隔符：

```js run
let names = &#x27;Bilbo, Gandalf, Nazgul&#x27;;

let arr = names.split(&#x27;, &#x27;);

for (let name of arr) {
  alert( `A message to ${name}.` ); // A message to Bilbo（和其他名字）
}
```

`split` 方法有一个可选的第二个数字参数 —— 对数组长度的限制。如果提供了，那么额外的元素会被忽略。但实际上它很少使用：

```js run
let arr = &#x27;Bilbo, Gandalf, Nazgul, Saruman&#x27;.split(&#x27;, &#x27;, 2);

alert(arr); // Bilbo, Gandalf
```

````smart header=&quot;拆分为字母&quot;
调用带有空参数 `s` 的 `split(s)`，会将字符串拆分为字母数组：

```js run
let str = &quot;test&quot;;

alert( str.split(&#x27;&#x27;) ); // t,e,s,t
```</code></pre>
<p><a href="mdn:js/Array/join">arr.join(glue)</a> 与 <code>split</code> 相反。它会在它们之间创建一串由 <code>glue</code> 粘合的 <code>arr</code> 项。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;Bilbo&#x27;</span>, <span class="hljs-string">&#x27;Gandalf&#x27;</span>, <span class="hljs-string">&#x27;Nazgul&#x27;</span>];

<span class="hljs-keyword">let</span> str = arr.join(<span class="hljs-string">&#x27;;&#x27;</span>); <span class="hljs-comment">// 使用分号 ; 将数组粘合成字符串</span>

alert( str ); <span class="hljs-comment">// Bilbo;Gandalf;Nazgul</span></code></pre>
<h3 id="reducereduceright">reduce/reduceRight</h3>
<p>当我们需要遍历一个数组时 —— 我们可以使用 <code>forEach</code>，<code>for</code> 或 <code>for..of</code>。</p>
<p>当我们需要遍历并返回每个元素的数据时 —— 我们可以使用 <code>map</code>。</p>
<p><a href="mdn:js/Array/reduce">arr.reduce</a> 方法和 <a href="mdn:js/Array/reduceRight">arr.reduceRight</a> 方法和上面的种类差不多，但稍微复杂一点。它们用于根据数组计算单个值。</p>
<p>语法是：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> value = arr.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">accumulator, item, index, array</span>) </span>{
  <span class="hljs-comment">// ...</span>
}, [initial]);</code></pre>
<p>该函数一个接一个地应用于所有数组元素，并将其结果“搬运（carry on）”到下一个调用。</p>
<p>参数：</p>
<ul>
<li><code>accumulator</code> —— 是上一个函数调用的结果，第一次等于  <code>initial</code>（如果提供了 <code>initial</code> 的话）。</li>
<li><code>item</code> —— 当前的数组元素。</li>
<li><code>index</code> —— 当前索引。</li>
<li><code>arr</code> —— 数组本身。</li>
</ul>
<p>应用函数时，上一个函数调用的结果将作为第一个参数传递给下一个函数。</p>
<p>因此，第一个参数本质上是累加器，用于存储所有先前执行的组合结果。最后，它成为 <code>reduce</code> 的结果。</p>
<p>听起来复杂吗？</p>
<p>掌握这个知识点的最简单的方法就是通过示例。</p>
<p>在这里，我们通过一行代码得到一个数组的总和：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];

<span class="hljs-keyword">let</span> result = arr.reduce(<span class="hljs-function">(<span class="hljs-params">sum, current</span>) =&gt;</span> sum + current, <span class="hljs-number">0</span>);

alert(result); <span class="hljs-comment">// 15</span></code></pre>
<p>传递给 <code>reduce</code> 的函数仅使用了 2 个参数，通常这就足够了。</p>
<p>让我们看看细节，到底发生了什么。</p>
<ol>
<li>在第一次运行时，<code>sum</code> 的值为初始值 <code>initial</code>（<code>reduce</code> 的最后一个参数），等于 0，<code>current</code> 是第一个数组元素，等于 <code>1</code>。所以函数运行的结果是 <code>1</code>。</li>
<li>在第二次运行时，<code>sum = 1</code>，我们将第二个数组元素（<code>2</code>）与其相加并返回。</li>
<li>在第三次运行中，<code>sum = 3</code>，我们继续把下一个元素与其相加，以此类推……</li>
</ol>
<p>计算流程：</p>
<p><img src="reduce.svg" alt=""></p>
<p>或者以表格的形式表示，每一行代表的是对下一个数组元素的函数调用：</p>
<table>
<thead>
<tr>
<th></th>
<th><code>sum</code></th>
<th><code>current</code></th>
<th><code>result</code></th>
</tr>
</thead>
<tbody><tr>
<td>第 1 次调用</td>
<td><code>0</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
</tr>
<tr>
<td>第 2 次调用</td>
<td><code>1</code></td>
<td><code>2</code></td>
<td><code>3</code></td>
</tr>
<tr>
<td>第 3 次调用</td>
<td><code>3</code></td>
<td><code>3</code></td>
<td><code>6</code></td>
</tr>
<tr>
<td>第 4 次调用</td>
<td><code>6</code></td>
<td><code>4</code></td>
<td><code>10</code></td>
</tr>
<tr>
<td>第 5 次调用</td>
<td><code>10</code></td>
<td><code>5</code></td>
<td><code>15</code></td>
</tr>
</tbody></table>
<p>在这里，我们可以清楚地看到上一个调用的结果如何成为下一个调用的第一个参数。</p>
<p>我们也可以省略初始值：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];

<span class="hljs-comment">// 删除 reduce 的初始值（没有 0）</span>
<span class="hljs-keyword">let</span> result = arr.reduce(<span class="hljs-function">(<span class="hljs-params">sum, current</span>) =&gt;</span> sum + current);

alert( result ); <span class="hljs-comment">// 15</span></code></pre>
<p>结果是一样的。这是因为如果没有初始值，那么 <code>reduce</code> 会将数组的第一个元素作为初始值，并从第二个元素开始迭代。</p>
<p>计算表与上面相同，只是去掉第一行。</p>
<p>但是这种使用需要非常小心。如果数组为空，那么在没有初始值的情况下调用 <code>reduce</code> 会导致错误。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [];

<span class="hljs-comment">// Error: Reduce of empty array with no initial value</span>
<span class="hljs-comment">// 如果初始值存在，则 reduce 将为空 arr 返回它（即这个初始值）。</span>
arr.reduce(<span class="hljs-function">(<span class="hljs-params">sum, current</span>) =&gt;</span> sum + current);</code></pre>
<p>所以建议始终指定初始值。</p>
<p><a href="mdn:js/Array/reduceRight">arr.reduceRight</a> 和 <a href="mdn:js/Array/reduce">arr.reduce</a> 方法的功能一样，只是遍历为从右到左。</p>
<h2 id="arrayisarray">Array.isArray</h2>
<p>数组是基于对象的，不构成单独的语言类型。</p>
<p>所以 <code>typeof</code> 不能帮助从数组中区分出普通对象：</p>
<pre><code class="language-js">alert(<span class="hljs-keyword">typeof</span> {}); <span class="hljs-comment">// object</span>
alert(<span class="hljs-keyword">typeof</span> []); <span class="hljs-comment">// same</span></code></pre>
<p>……但是数组经常被使用，因此有一种特殊的方法用于判断：<a href="mdn:js/Array/isArray">Array.isArray(value)</a>。如果 <code>value</code> 是一个数组，则返回 <code>true</code>；否则返回 <code>false</code>。</p>
<pre><code class="language-js">alert(<span class="hljs-built_in">Array</span>.isArray({})); <span class="hljs-comment">// false</span>

alert(<span class="hljs-built_in">Array</span>.isArray([])); <span class="hljs-comment">// true</span></code></pre>
<h2 id="大多数方法都支持-thisarg">大多数方法都支持 &quot;thisArg&quot;</h2>
<p>几乎所有调用函数的数组方法 —— 比如 <code>find</code>，<code>filter</code>，<code>map</code>，除了 <code>sort</code> 是一个特例，都接受一个可选的附加参数 <code>thisArg</code>。</p>
<p>上面的部分中没有解释该参数，因为该参数很少使用。但是为了完整性，我们需要讲讲它。</p>
<p>以下是这些方法的完整语法：</p>
<pre><code class="language-js">arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
<span class="hljs-comment">// ...</span>
<span class="hljs-comment">// thisArg 是可选的最后一个参数</span></code></pre>
<p><code>thisArg</code> 参数的值在 <code>func</code> 中变为 <code>this</code>。</p>
<p>例如，在这里我们使用 <code>army</code> 对象方法作为过滤器，<code>thisArg</code> 用于传递上下文（passes the context）：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> army = {
  <span class="hljs-attr">minAge</span>: <span class="hljs-number">18</span>,
  <span class="hljs-attr">maxAge</span>: <span class="hljs-number">27</span>,
  <span class="hljs-function"><span class="hljs-title">canJoin</span>(<span class="hljs-params">user</span>)</span> {
    <span class="hljs-keyword">return</span> user.age &gt;= <span class="hljs-built_in">this</span>.minAge &amp;&amp; user.age &lt; <span class="hljs-built_in">this</span>.maxAge;
  }
};

<span class="hljs-keyword">let</span> users = [
  {<span class="hljs-attr">age</span>: <span class="hljs-number">16</span>},
  {<span class="hljs-attr">age</span>: <span class="hljs-number">20</span>},
  {<span class="hljs-attr">age</span>: <span class="hljs-number">23</span>},
  {<span class="hljs-attr">age</span>: <span class="hljs-number">30</span>}
];

*!*
<span class="hljs-comment">// 找到 army.canJoin 返回 true 的 user</span>
<span class="hljs-keyword">let</span> soldiers = users.filter(army.canJoin, army);
*/!*

alert(soldiers.length); <span class="hljs-comment">// 2</span>
alert(soldiers[<span class="hljs-number">0</span>].age); <span class="hljs-comment">// 20</span>
alert(soldiers[<span class="hljs-number">1</span>].age); <span class="hljs-comment">// 23</span></code></pre>
<p>如果在上面的示例中我们使用了 <code>users.filter(army.canJoin)</code>，那么 <code>army.canJoin</code> 将被作为独立函数调用，并且这时 <code>this=undefined</code>，从而会导致即时错误。</p>
<p>可以用 <code>users.filter(user =&gt; army.canJoin(user))</code> 替换对 <code>users.filter(army.canJoin, army)</code> 的调用。前者的使用频率更高，因为对于大多数人来说，它更容易理解。</p>
<h2 id="总结">总结</h2>
<p>数组方法备忘单：</p>
<ul>
<li><p>添加/删除元素：</p>
<ul>
<li><code>push(...items)</code> —— 向尾端添加元素，</li>
<li><code>pop()</code> —— 从尾端提取一个元素，</li>
<li><code>shift()</code> —— 从首端提取一个元素，</li>
<li><code>unshift(...items)</code> —— 向首端添加元素，</li>
<li><code>splice(pos, deleteCount, ...items)</code> —— 从 <code>pos</code> 开始删除 <code>deleteCount</code> 个元素，并插入 <code>items</code>。</li>
<li><code>slice(start, end)</code> —— 创建一个新数组，将从位置 <code>start</code> 到位置 <code>end</code>（但不包括 <code>end</code>）的元素复制进去。</li>
<li><code>concat(...items)</code> —— 返回一个新数组：复制当前数组的所有元素，并向其中添加 <code>items</code>。如果 <code>items</code> 中的任意一项是一个数组，那么就取其元素。</li>
</ul>
</li>
<li><p>搜索元素：</p>
<ul>
<li><code>indexOf/lastIndexOf(item, pos)</code> ——  从位置 <code>pos</code> 开始搜索 <code>item</code>，搜索到则返回该项的索引，否则返回 <code>-1</code>。</li>
<li><code>includes(value)</code> —— 如果数组有 <code>value</code>，则返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li><code>find/filter(func)</code> —— 通过 <code>func</code> 过滤元素，返回使 <code>func</code> 返回 <code>true</code> 的第一个值/所有值。 </li>
<li><code>findIndex</code> 和 <code>find</code> 类似，但返回索引而不是值。</li>
</ul>
</li>
<li><p>遍历元素：</p>
<ul>
<li><code>forEach(func)</code> —— 对每个元素都调用 <code>func</code>，不返回任何内容。</li>
</ul>
</li>
<li><p>转换数组：</p>
<ul>
<li><code>map(func)</code> —— 根据对每个元素调用 <code>func</code> 的结果创建一个新数组。</li>
<li><code>sort(func)</code> —— 对数组进行原位（in-place）排序，然后返回它。</li>
<li><code>reverse()</code> —— 原位（in-place）反转数组，然后返回它。</li>
<li><code>split/join</code> —— 将字符串转换为数组并返回。</li>
<li><code>reduce(func, initial)</code> —— 通过对每个元素调用 <code>func</code> 计算数组上的单个值，并在调用之间传递中间结果。</li>
</ul>
</li>
<li><p>其他：</p>
<ul>
<li><code>Array.isArray(arr)</code> 检查 <code>arr</code> 是否是一个数组。</li>
</ul>
</li>
</ul>
<p>请注意，<code>sort</code>，<code>reverse</code> 和 <code>splice</code> 方法修改的是数组本身。</p>
<p>这些是最常用的方法，它们覆盖 99％ 的用例。但是还有其他几个：</p>
<ul>
<li><p><a href="mdn:js/Array/some">arr.some(fn)</a>/<a href="mdn:js/Array/every">arr.every(fn)</a> 检查数组。</p>
<p>与 <code>map</code> 类似，对数组的每个元素调用函数 <code>fn</code>。如果任何/所有结果为 <code>true</code>，则返回 <code>true</code>，否则返回 <code>false</code>。</p>
</li>
<li><p><a href="mdn:js/Array/fill">arr.fill(value, start, end)</a> —— 从索引 <code>start</code> 到 <code>end</code>，用重复的 <code>value</code> 填充数组。</p>
</li>
<li><p><a href="mdn:js/Array/copyWithin">arr.copyWithin(target, start, end)</a> —— 将从位置 <code>start</code> 到 <code>end</code> 的所有元素复制到 <strong>自身</strong> 的 <code>target</code> 位置（覆盖现有元素）。</p>
</li>
</ul>
<p>有关完整列表，请参阅 <a href="mdn:js/Array">手册</a>。</p>
<p>乍看起来，似乎有很多方法，很难记住。但实际上这比看起来要容易得多。</p>
<p>浏览这个备忘单，以了解这些方法。然后解决本章中的习题来进行练习，以便让你有数组方法的使用经验。</p>
<p>然后，每当你需要对数组进行某些操作，而又不知道怎么做的时候，请回到这儿，查看这个备忘单，然后找到正确的方法。示例将帮助你正确编写它。用不了多久，你就自然而然地记住这些方法了，根本不需要你死记硬背。</p>

      </fieldset>
      
      <fieldset id='_lShotT'>
      <legend>article</legend>
      <h1 id="iterable-object（可迭代对象）">Iterable object（可迭代对象）</h1>
<p><strong>可迭代（Iterable）</strong> 对象是数组的泛化。这个概念是说任何对象都可以被定制为可在 <code>for..of</code> 循环中使用的对象。</p>
<p>数组是可迭代的。但不仅仅是数组。很多其他内建对象也都是可迭代的。例如字符串也是可迭代的。</p>
<p>如果从技术上讲，对象不是数组，而是表示某物的集合（列表，集合），<code>for..of</code> 是一个能够遍历它的很好的语法，因此，让我们来看看如何使其发挥作用。</p>
<h2 id="symboliterator">Symbol.iterator</h2>
<p>通过自己创建一个对象，我们就可以轻松地掌握可迭代的概念。</p>
<p>例如，我们有一个对象，它并不是数组，但是看上去很适合使用 <code>for..of</code> 循环。</p>
<p>比如一个 <code>range</code> 对象，它代表了一个数字区间：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> range = {
  <span class="hljs-attr">from</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">to</span>: <span class="hljs-number">5</span>
};

<span class="hljs-comment">// 我们希望 for..of 这样运行：</span>
<span class="hljs-comment">// for(let num of range) ... num=1,2,3,4,5</span></code></pre>
<p>为了让 <code>range</code> 对象可迭代（也就让 <code>for..of</code> 可以运行）我们需要为对象添加一个名为 <code>Symbol.iterator</code> 的方法（一个专门用于使对象可迭代的内置 symbol）。</p>
<ol>
<li>当 <code>for..of</code> 循环启动时，它会调用这个方法（如果没找到，就会报错）。这个方法必须返回一个 <strong>迭代器（iterator）</strong> —— 一个有 <code>next</code> 方法的对象。</li>
<li>从此开始，<code>for..of</code> <strong>仅适用于这个被返回的对象</strong>。</li>
<li>当 <code>for..of</code> 循环希望取得下一个数值，它就调用这个对象的 <code>next()</code> 方法。</li>
<li><code>next()</code> 方法返回的结果的格式必须是 <code>{done: Boolean, value: any}</code>，当 <code>done=true</code> 时，表示迭代结束，否则 <code>value</code> 是下一个值。</li>
</ol>
<p>这是带有注释的 <code>range</code> 的完整实现：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> range = {
  <span class="hljs-attr">from</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">to</span>: <span class="hljs-number">5</span>
};

<span class="hljs-comment">// 1. for..of 调用首先会调用这个：</span>
range[<span class="hljs-built_in">Symbol</span>.iterator] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{

  <span class="hljs-comment">// ……它返回迭代器对象（iterator object）：</span>
  <span class="hljs-comment">// 2. 接下来，for..of 仅与此迭代器一起工作，要求它提供下一个值</span>
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">current</span>: <span class="hljs-built_in">this</span>.from,
    <span class="hljs-attr">last</span>: <span class="hljs-built_in">this</span>.to,      

    <span class="hljs-comment">// 3. next() 在 for..of 的每一轮循环迭代中被调用</span>
    <span class="hljs-function"><span class="hljs-title">next</span>(<span class="hljs-params"></span>)</span> {
      <span class="hljs-comment">// 4. 它将会返回 {done:.., value :...} 格式的对象</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.current &lt;= <span class="hljs-built_in">this</span>.last) {
        <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: <span class="hljs-built_in">this</span>.current++ };
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> };
      }
    }
  };
};

<span class="hljs-comment">// 现在它可以运行了！</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> range) {
  alert(num); <span class="hljs-comment">// 1, 然后是 2, 3, 4, 5</span>
}</code></pre>
<p>请注意可迭代对象的核心功能：关注点分离。</p>
<ul>
<li><code>range</code> 自身没有 <code>next()</code> 方法。</li>
<li>相反，是通过调用 <code>range[Symbol.iterator]()</code> 创建了另一个对象，即所谓的“迭代器”对象，并且它的 <code>next</code> 会为迭代生成值。</li>
</ul>
<p>因此，迭代器对象和与其进行迭代的对象是分开的。</p>
<p>从技术上说，我们可以将它们合并，并使用 <code>range</code> 自身作为迭代器来简化代码。</p>
<p>就像这样：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> range = {
  <span class="hljs-attr">from</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">to</span>: <span class="hljs-number">5</span>,

  [<span class="hljs-built_in">Symbol</span>.iterator]() {
    <span class="hljs-built_in">this</span>.current = <span class="hljs-built_in">this</span>.from;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;
  },

  <span class="hljs-function"><span class="hljs-title">next</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.current &lt;= <span class="hljs-built_in">this</span>.to) {
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: <span class="hljs-built_in">this</span>.current++ };
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> };
    }
  }
};

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> range) {
  alert(num); <span class="hljs-comment">// 1, 然后是 2, 3, 4, 5</span>
}</code></pre>
<p>现在 <code>range[Symbol.iterator]()</code> 返回的是 <code>range</code> 对象自身：它包括了必需的 <code>next()</code> 方法，并通过 <code>this.current</code> 记忆了当前的迭代进程。这样更短，对吗？是的。有时这样也可以。</p>
<p>但缺点是，现在不可能同时在对象上运行两个 <code>for..of</code> 循环了：它们将共享迭代状态，因为只有一个迭代器，即对象本身。但是两个并行的 <code>for..of</code> 是很罕见的，即使在异步情况下。</p>
<pre><code class="language-smart">无穷迭代器也是可能的。例如，将 `range` 设置为 `range.to = Infinity`，这时 `range` 则成为了无穷迭代器。或者我们可以创建一个可迭代对象，它生成一个无穷伪随机数序列。也是可能的。

`next` 没有什么限制，它可以返回越来越多的值，这是正常的。

当然，迭代这种对象的 `for..of` 循环将不会停止。但是我们可以通过使用 `break` 来停止它。</code></pre>
<h2 id="字符串是可迭代的">字符串是可迭代的</h2>
<p>数组和字符串是使用最广泛的内建可迭代对象。</p>
<p>对于一个字符串，<code>for..of</code> 遍历它的每个字符：</p>
<pre><code class="language-js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> char <span class="hljs-keyword">of</span> <span class="hljs-string">&quot;test&quot;</span>) {
  <span class="hljs-comment">// 触发 4 次，每个字符一次</span>
  alert( char ); <span class="hljs-comment">// t, then e, then s, then t</span>
}</code></pre>
<p>对于代理对（surrogate pairs），它也能正常工作！（译注：这里的代理对也就指的是 UTF-16 的扩展字符）</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;𝒳😂&#x27;</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> char <span class="hljs-keyword">of</span> str) {
    alert( char ); <span class="hljs-comment">// 𝒳，然后是 😂</span>
}</code></pre>
<h2 id="显式调用迭代器">显式调用迭代器</h2>
<p>为了更深层地了解底层知识，让我们来看看如何显式地使用迭代器。</p>
<p>我们将会采用与 <code>for..of</code> 完全相同的方式遍历字符串，但使用的是直接调用。这段代码创建了一个字符串迭代器，并“手动”从中获取值。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;Hello&quot;</span>;

<span class="hljs-comment">// 和 for..of 做相同的事</span>
<span class="hljs-comment">// for (let char of str) alert(char);</span>

*!*
<span class="hljs-keyword">let</span> iterator = str[<span class="hljs-built_in">Symbol</span>.iterator]();
*/!*

<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">let</span> result = iterator.next();
  <span class="hljs-keyword">if</span> (result.done) <span class="hljs-keyword">break</span>;
  alert(result.value); <span class="hljs-comment">// 一个接一个地输出字符</span>
}</code></pre>
<p>很少需要我们这样做，但是比 <code>for..of</code> 给了我们更多的控制权。例如，我们可以拆分迭代过程：迭代一部分，然后停止，做一些其他处理，然后再恢复迭代。</p>
<h2 id="可迭代（iterable）和类数组（array-like）-array-like">可迭代（iterable）和类数组（array-like） [#array-like]</h2>
<p>有两个看起来很相似，但又有很大不同的正式术语。请你确保正确地掌握它们，以免造成混淆。</p>
<ul>
<li><strong>Iterable</strong> 如上所述，是实现了 <code>Symbol.iterator</code> 方法的对象。</li>
<li><strong>Array-like</strong> 是有索引和 <code>length</code> 属性的对象，所以它们看起来很像数组。</li>
</ul>
<p>当我们将 JavaScript 用于编写在浏览器或其他环境中的实际任务时，我们可能会遇到可迭代对象或类数组对象，或两者兼有。</p>
<p>例如，字符串即是可迭代的（<code>for..of</code> 对它们有效），又是类数组的（它们有数值索引和 <code>length</code> 属性）。</p>
<p>但是一个可迭代对象也许不是类数组对象。反之亦然，类数组对象可能不可迭代。</p>
<p>例如，上面例子中的 <code>range</code> 是可迭代的，但并非类数组对象，因为它没有索引属性，也没有 <code>length</code> 属性。</p>
<p>下面这个对象则是类数组的，但是不可迭代：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arrayLike = { <span class="hljs-comment">// 有索引和 length 属性 =&gt; 类数组对象</span>
  <span class="hljs-number">0</span>: <span class="hljs-string">&quot;Hello&quot;</span>,
  <span class="hljs-number">1</span>: <span class="hljs-string">&quot;World&quot;</span>,
  <span class="hljs-attr">length</span>: <span class="hljs-number">2</span>
};

*!*
<span class="hljs-comment">// Error (no Symbol.iterator)</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> arrayLike) {}
*/!*</code></pre>
<p>可迭代对象和类数组对象通常都 <strong>不是数组</strong>，它们没有 <code>push</code> 和 <code>pop</code> 等方法。如果我们有一个这样的对象，并想像数组那样操作它，那就非常不方便。例如，我们想使用数组方法操作 <code>range</code>，应该如何实现呢？</p>
<h2 id="arrayfrom">Array.from</h2>
<p>有一个全局方法 <a href="mdn:js/Array/from">Array.from</a> 可以接受一个可迭代或类数组的值，并从中获取一个“真正的”数组。然后我们就可以对其调用数组方法了。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arrayLike = {
  <span class="hljs-number">0</span>: <span class="hljs-string">&quot;Hello&quot;</span>,
  <span class="hljs-number">1</span>: <span class="hljs-string">&quot;World&quot;</span>,
  <span class="hljs-attr">length</span>: <span class="hljs-number">2</span>
};

*!*
<span class="hljs-keyword">let</span> arr = <span class="hljs-built_in">Array</span>.from(arrayLike); <span class="hljs-comment">// (*)</span>
*/!*
alert(arr.pop()); <span class="hljs-comment">// World（pop 方法有效）</span></code></pre>
<p>在 <code>(*)</code> 行的 <code>Array.from</code> 方法接受对象，检查它是一个可迭代对象或类数组对象，然后创建一个新数组，并将该对象的所有元素复制到这个新数组。</p>
<p>如果是可迭代对象，也是同样：</p>
<pre><code class="language-js"><span class="hljs-comment">// 假设 range 来自上文的例子中</span>
<span class="hljs-keyword">let</span> arr = <span class="hljs-built_in">Array</span>.from(range);
alert(arr); <span class="hljs-comment">// 1,2,3,4,5 （数组的 toString 转化方法生效）</span></code></pre>
<p><code>Array.from</code> 的完整语法允许我们提供一个可选的“映射（mapping）”函数：</p>
<pre><code class="language-js"><span class="hljs-built_in">Array</span>.from(obj[, mapFn, thisArg])</code></pre>
<p>可选的第二个参数 <code>mapFn</code> 可以是一个函数，该函数会在对象中的元素被添加到数组前，被应用于每个元素，此外 <code>thisArg</code> 允许我们为该函数设置 <code>this</code>。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-comment">// 假设 range 来自上文例子中</span>

<span class="hljs-comment">// 求每个数的平方</span>
<span class="hljs-keyword">let</span> arr = <span class="hljs-built_in">Array</span>.from(range, <span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num * num);

alert(arr); <span class="hljs-comment">// 1,4,9,16,25</span></code></pre>
<p>现在我们用 <code>Array.from</code> 将一个字符串转换为单个字符的数组：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;𝒳😂&#x27;</span>;

<span class="hljs-comment">// 将 str 拆分为字符数组</span>
<span class="hljs-keyword">let</span> chars = <span class="hljs-built_in">Array</span>.from(str);

alert(chars[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 𝒳</span>
alert(chars[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 😂</span>
alert(chars.length); <span class="hljs-comment">// 2</span></code></pre>
<p>与 <code>str.split</code> 方法不同，它依赖于字符串的可迭代特性。因此，就像 <code>for..of</code> 一样，可以正确地处理代理对（surrogate pair）。（译注：代理对也就是 UTF-16 扩展字符。）</p>
<p>技术上来讲，它和下面这段代码做的是相同的事：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;𝒳😂&#x27;</span>;

<span class="hljs-keyword">let</span> chars = []; <span class="hljs-comment">// Array.from 内部执行相同的循环</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> char <span class="hljs-keyword">of</span> str) {
  chars.push(char);
}

alert(chars);</code></pre>
<p>……但 <code>Array.from</code> 精简很多。</p>
<p>我们甚至可以基于 <code>Array.from</code> 创建代理感知（surrogate-aware）的<code>slice</code> 方法（译注：也就是能够处理 UTF-16 扩展字符的 <code>slice</code> 方法）：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">slice</span>(<span class="hljs-params">str, start, end</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(str).slice(start, end).join(<span class="hljs-string">&#x27;&#x27;</span>);
}

<span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;𝒳😂𩷶&#x27;</span>;

alert( slice(str, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>) ); <span class="hljs-comment">// 😂𩷶</span>

<span class="hljs-comment">// 原生方法不支持识别代理对（译注：UTF-16 扩展字符）</span>
alert( str.slice(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) ); <span class="hljs-comment">// 乱码（两个不同 UTF-16 扩展字符碎片拼接的结果）</span></code></pre>
<h2 id="总结">总结</h2>
<p>可以应用 <code>for..of</code> 的对象被称为 <strong>可迭代的</strong>。</p>
<ul>
<li>技术上来说，可迭代对象必须实现 <code>Symbol.iterator</code> 方法。<ul>
<li><code>obj[Symbol.iterator]</code> 的结果被称为 <strong>迭代器（iterator）</strong>。由它处理进一步的迭代过程。</li>
<li>一个迭代器必须有 <code>next()</code> 方法，它返回一个 <code>{done: Boolean, value: any}</code> 对象，这里 <code>done:true</code> 表明迭代结束，否则 <code>value</code> 就是下一个值。</li>
</ul>
</li>
<li><code>Symbol.iterator</code> 方法会被 <code>for..of</code> 自动调用，但我们也可以直接调用它。</li>
<li>内置的可迭代对象例如字符串和数组，都实现了 <code>Symbol.iterator</code>。</li>
<li>字符串迭代器能够识别代理对（surrogate pair）。（译注：代理对也就是 UTF-16 扩展字符。）</li>
</ul>
<p>有索引属性和 <code>length</code> 属性的对象被称为 <strong>类数组对象</strong>。这种对象可能还具有其他属性和方法，但是没有数组的内建方法。</p>
<p>如果我们仔细研究一下规范 —— 就会发现大多数内建方法都假设它们需要处理的是可迭代对象或者类数组对象，而不是“真正的”数组，因为这样抽象度更高。</p>
<p><code>Array.from(obj[, mapFn, thisArg])</code> 将可迭代对象或类数组对象 <code>obj</code> 转化为真正的数组 <code>Array</code>，然后我们就可以对它应用数组的方法。可选参数 <code>mapFn</code> 和 <code>thisArg</code> 允许我们将函数应用到每个元素。</p>

      </fieldset>
      
      <fieldset id='_rSdQHA'>
      <legend>solution</legend>
      
      </fieldset>
      
      <fieldset id='_7sVnqv'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="过滤数组中的唯一元素">过滤数组中的唯一元素</h1>
<p>定义 <code>arr</code> 为一个数组。</p>
<p>创建一个函数 <code>unique(arr)</code>，该函数返回一个由 <code>arr</code> 中所有唯一元素所组成的数组。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>{
  <span class="hljs-comment">/* 你的代码 */</span>
}

<span class="hljs-keyword">let</span> values = [<span class="hljs-string">&quot;Hare&quot;</span>, <span class="hljs-string">&quot;Krishna&quot;</span>, <span class="hljs-string">&quot;Hare&quot;</span>, <span class="hljs-string">&quot;Krishna&quot;</span>,
  <span class="hljs-string">&quot;Krishna&quot;</span>, <span class="hljs-string">&quot;Krishna&quot;</span>, <span class="hljs-string">&quot;Hare&quot;</span>, <span class="hljs-string">&quot;Hare&quot;</span>, <span class="hljs-string">&quot;:-O&quot;</span>
];

alert( unique(values) ); <span class="hljs-comment">// Hare, Krishna, :-O</span></code></pre>
<p>P.S. 这里用到了 string 类型，但其实可以是任何类型的值。</p>
<p>P.S. 使用 <code>Set</code> 来存储唯一值。</p>

      </fieldset>
      
      <fieldset id='_wIg0O0'>
      <legend>solution</legend>
      <p>为了找到所有字谜（anagram），让我们把每个单词打散为字母并进行排序。当字母被排序后，所有的字谜就都一样了。</p>
<p>例如：</p>
<pre><code>nap, pan -&gt; anp
ear, era, are -&gt; aer
cheaters, hectares, teachers -&gt; aceehrst
...</code></pre>
<p>我们将使用进行字母排序后的单词的变体（variant）作为 map 的键，每个键仅对应存储一个值：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">aclean</span>(<span class="hljs-params">arr</span>) </span>{
  <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> word <span class="hljs-keyword">of</span> arr) {
    <span class="hljs-comment">// 将单词 split 成字母，对字母进行排序，之后再 join 回来</span>
*!*
    <span class="hljs-keyword">let</span> sorted = word.toLowerCase().split(<span class="hljs-string">&#x27;&#x27;</span>).sort().join(<span class="hljs-string">&#x27;&#x27;</span>); <span class="hljs-comment">// (*)</span>
*/!*
    map.set(sorted, word);
  }

  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(map.values());
}

<span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;nap&quot;</span>, <span class="hljs-string">&quot;teachers&quot;</span>, <span class="hljs-string">&quot;cheaters&quot;</span>, <span class="hljs-string">&quot;PAN&quot;</span>, <span class="hljs-string">&quot;ear&quot;</span>, <span class="hljs-string">&quot;era&quot;</span>, <span class="hljs-string">&quot;hectares&quot;</span>];

alert( aclean(arr) );</code></pre>
<p>字母排序在 <code>(*)</code> 行以链式调用的方式完成。</p>
<p>为了方便，我们把它分解为多行：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> sorted = word <span class="hljs-comment">// PAN</span>
  .toLowerCase() <span class="hljs-comment">// pan</span>
  .split(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// [&#x27;p&#x27;,&#x27;a&#x27;,&#x27;n&#x27;]</span>
  .sort() <span class="hljs-comment">// [&#x27;a&#x27;,&#x27;n&#x27;,&#x27;p&#x27;]</span>
  .join(<span class="hljs-string">&#x27;&#x27;</span>); <span class="hljs-comment">// anp</span></code></pre>
<p>两个不同的单词 <code>&#39;PAN&#39;</code> 和 <code>&#39;nap&#39;</code> 得到了同样的字母排序形式 <code>&#39;anp&#39;</code>。</p>
<p>下一行是将单词放入 map：</p>
<pre><code class="language-js">map.set(sorted, word);</code></pre>
<p>如果我们再次遇到相同字母排序形式的单词，那么它将会覆盖 map 中有相同键的前一个值。因此，每个字母形式（译注：排序后的）最多只有一个单词。（译注：并且是每个字母形式中最靠后的那个值）</p>
<p>最后，<code>Array.from(map.values())</code> 将 map 的值迭代（我们不需要结果的键）为数组形式，并返回这个数组。</p>
<p>在这里，我们也可以使用普通对象（plain object）而不用 <code>Map</code>，因为键就是字符串。</p>
<p>下面是解决方案：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">aclean</span>(<span class="hljs-params">arr</span>) </span>{
  <span class="hljs-keyword">let</span> obj = {};

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
    <span class="hljs-keyword">let</span> sorted = arr[i].toLowerCase().split(<span class="hljs-string">&quot;&quot;</span>).sort().join(<span class="hljs-string">&quot;&quot;</span>);
    obj[sorted] = arr[i];
  }

  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.values(obj);
}

<span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;nap&quot;</span>, <span class="hljs-string">&quot;teachers&quot;</span>, <span class="hljs-string">&quot;cheaters&quot;</span>, <span class="hljs-string">&quot;PAN&quot;</span>, <span class="hljs-string">&quot;ear&quot;</span>, <span class="hljs-string">&quot;era&quot;</span>, <span class="hljs-string">&quot;hectares&quot;</span>];

alert( aclean(arr) );</code></pre>

      </fieldset>
      
      <fieldset id='_9AzfDt'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="过滤字谜（anagrams）">过滤字谜（anagrams）</h1>
<p><a href="https://en.wikipedia.org/wiki/Anagram">Anagrams</a> 是具有相同数量相同字母但是顺序不同的单词。</p>
<p>例如：</p>
<pre><code>nap - pan
ear - are - era
cheaters - hectares - teachers</code></pre>
<p>写一个函数 <code>aclean(arr)</code>，它返回被清除了字谜（anagrams）的数组。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;nap&quot;</span>, <span class="hljs-string">&quot;teachers&quot;</span>, <span class="hljs-string">&quot;cheaters&quot;</span>, <span class="hljs-string">&quot;PAN&quot;</span>, <span class="hljs-string">&quot;ear&quot;</span>, <span class="hljs-string">&quot;era&quot;</span>, <span class="hljs-string">&quot;hectares&quot;</span>];

alert( aclean(arr) ); <span class="hljs-comment">// &quot;nap,teachers,ear&quot; or &quot;PAN,cheaters,era&quot;</span></code></pre>
<p>对于所有的字谜（anagram）组，都应该保留其中一个词，但保留的具体是哪一个并不重要。</p>

      </fieldset>
      
      <fieldset id='_aM2aKA'>
      <legend>solution</legend>
      <p>这是因为 <code>map.keys()</code> 返回的是可迭代对象而非数组。</p>
<p>我们可以使用方法 <code>Array.from</code> 来将它转换为数组：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

map.set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;John&quot;</span>);

*!*
<span class="hljs-keyword">let</span> keys = <span class="hljs-built_in">Array</span>.from(map.keys());
*/!*

keys.push(<span class="hljs-string">&quot;more&quot;</span>);

alert(keys); <span class="hljs-comment">// name, more</span></code></pre>

      </fieldset>
      
      <fieldset id='_qPaJBb'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="迭代键">迭代键</h1>
<p>我们期望使用 <code>map.keys()</code> 得到一个数组，然后使用特定的方法例如 <code>.push</code> 等，对其进行处理。</p>
<p>但是运行不了：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

map.set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;John&quot;</span>);

<span class="hljs-keyword">let</span> keys = map.keys();

*!*
<span class="hljs-comment">// Error: keys.push is not a function</span>
keys.push(<span class="hljs-string">&quot;more&quot;</span>);
*/!*</code></pre>
<p>为什么？我们应该如何修改代码让 <code>keys.push</code> 工作？</p>

      </fieldset>
      
      <fieldset id='_sVAIhu'>
      <legend>article</legend>
      <h1 id="map-and-set（映射和集合）">Map and Set（映射和集合）</h1>
<p>我们已经了解了以下复杂的数据结构：</p>
<ul>
<li>存储带键的数据（keyed）集合的对象。</li>
<li>存储有序集合的数组。</li>
</ul>
<p>但这还不足以应对现实情况。这就是为什么存在 <code>Map</code> 和 <code>Set</code>。</p>
<h2 id="map">Map</h2>
<p><a href="mdn:js/Map">Map</a> 是一个带键的数据项的集合，就像一个 <code>Object</code> 一样。 但是它们最大的差别是 <code>Map</code> 允许任何类型的键（key）。</p>
<p>它的方法和属性如下：</p>
<ul>
<li><code>new Map()</code> —— 创建 map。</li>
<li><code>map.set(key, value)</code> —— 根据键存储值。</li>
<li><code>map.get(key)</code> —— 根据键来返回值，如果 <code>map</code> 中不存在对应的 <code>key</code>，则返回 <code>undefined</code>。</li>
<li><code>map.has(key)</code> —— 如果 <code>key</code> 存在则返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li><code>map.delete(key)</code> —— 删除指定键的值。</li>
<li><code>map.clear()</code> —— 清空 map。</li>
<li><code>map.size</code> —— 返回当前元素个数。</li>
</ul>
<p>举个例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

map.set(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;str1&#x27;</span>);   <span class="hljs-comment">// 字符串键</span>
map.set(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;num1&#x27;</span>);     <span class="hljs-comment">// 数字键</span>
map.set(<span class="hljs-literal">true</span>, <span class="hljs-string">&#x27;bool1&#x27;</span>); <span class="hljs-comment">// 布尔值键</span>

<span class="hljs-comment">// 还记得普通的 Object 吗? 它会将键转化为字符串</span>
<span class="hljs-comment">// Map 则会保留键的类型，所以下面这两个结果不同：</span>
alert( map.get(<span class="hljs-number">1</span>)   ); <span class="hljs-comment">// &#x27;num1&#x27;</span>
alert( map.get(<span class="hljs-string">&#x27;1&#x27;</span>) ); <span class="hljs-comment">// &#x27;str1&#x27;</span>

alert( map.size ); <span class="hljs-comment">// 3</span></code></pre>
<p>如我们所见，与对象不同，键不会被转换成字符串。键可以是任何类型。</p>
<p>```smart header=&quot;<code>map[key]</code> 不是使用 <code>Map</code> 的正确方式&quot;
虽然 <code>map[key]</code> 也有效，例如我们可以设置 <code>map[key] = 2</code>，这样会将 <code>map</code> 视为 JavaScript 的 plain object，因此它暗含了所有相应的限制（没有对象键等）。</p>
<p>所以我们应该使用 <code>map</code> 方法：<code>set</code> 和 <code>get</code> 等。</p>
<pre><code>
**Map 还可以使用对象作为键。**

例如：

```js run
let john = { name: &quot;John&quot; };

// 存储每个用户的来访次数
let visitsCountMap = new Map();

// john 是 Map 中的键
visitsCountMap.set(john, 123);

alert( visitsCountMap.get(john) ); // 123</code></pre>
<p>使用对象作为键是 <code>Map</code> 最值得注意和重要的功能之一。对于字符串键，<code>Object</code>（普通对象）也能正常使用，但对于对象键则不行。</p>
<p>我们来尝试一下：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> john = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> };

<span class="hljs-keyword">let</span> visitsCountObj = {}; <span class="hljs-comment">// 尝试使用对象</span>

visitsCountObj[john] = <span class="hljs-number">123</span>; <span class="hljs-comment">// 尝试将 john 对象作为键</span>

*!*
<span class="hljs-comment">// 是写成了这样!</span>
alert( visitsCountObj[<span class="hljs-string">&quot;[object Object]&quot;</span>] ); <span class="hljs-comment">// 123</span>
*/!*</code></pre>
<p>因为 <code>visitsCountObj</code> 是一个对象，它会将所有的键如 <code>john</code> 转换为字符串，所以我们得到字符串键 <code>&quot;[object Object]&quot;</code>。这显然不是我们想要的结果。</p>
<p>```smart header=&quot;<code>Map</code> 是怎么比较键的？&quot;
<code>Map</code> 使用 <a href="https://tc39.github.io/ecma262/#sec-samevaluezero">SameValueZero</a> 算法来比较键是否相等。它和严格等于 <code>===</code> 差不多，但区别是 <code>NaN</code> 被看成是等于 <code>NaN</code>。所以 <code>NaN</code> 也可以被用作键。</p>
<p>这个算法不能被改变或者自定义。</p>
<pre><code>
````smart header=&quot;链式调用&quot;
每一次 `map.set` 调用都会返回 map 本身，所以我们可以进行“链式”调用：

```js
map.set(&#x27;1&#x27;, &#x27;str1&#x27;)
  .set(1, &#x27;num1&#x27;)
  .set(true, &#x27;bool1&#x27;);</code></pre>
<pre><code>

## Map 迭代

如果要在 `map` 里使用循环，可以使用以下三个方法：

- `map.keys()` —— 遍历并返回所有的键（returns an iterable for keys），
- `map.values()` —— 遍历并返回所有的值（returns an iterable for values），
- `map.entries()` —— 遍历并返回所有的实体（returns an iterable for entries）`[key, value]`，`for..of` 在默认情况下使用的就是这个。

例如：

```js run
let recipeMap = new Map([
  [&#x27;cucumber&#x27;, 500],
  [&#x27;tomatoes&#x27;, 350],
  [&#x27;onion&#x27;,    50]
]);

// 遍历所有的键（vegetables）
for (let vegetable of recipeMap.keys()) {
  alert(vegetable); // cucumber, tomatoes, onion
}

// 遍历所有的值（amounts）
for (let amount of recipeMap.values()) {
  alert(amount); // 500, 350, 50
}

// 遍历所有的实体 [key, value]
for (let entry of recipeMap) { // 与 recipeMap.entries() 相同
  alert(entry); // cucumber,500 (and so on)
}
```

```smart header=&quot;使用插入顺序&quot;
迭代的顺序与插入值的顺序相同。与普通的 `Object` 不同，`Map` 保留了此顺序。
```

除此之外，`Map` 有内置的 `forEach` 方法，与 `Array` 类似：

```js
// 对每个键值对 (key, value) 运行 forEach 函数
recipeMap.forEach( (value, key, map) =&gt; {
  alert(`${key}: ${value}`); // cucumber: 500 etc
});
```

## Object.entries：从对象创建 Map

当创建一个 `Map` 后，我们可以传入一个带有键值对的数组（或其它可迭代对象）来进行初始化，如下所示：

```js run
// 键值对 [key, value] 数组
let map = new Map([
  [&#x27;1&#x27;,  &#x27;str1&#x27;],
  [1,    &#x27;num1&#x27;],
  [true, &#x27;bool1&#x27;]
]);

alert( map.get(&#x27;1&#x27;) ); // str1
```

如果我们想从一个已有的普通对象（plain object）来创建一个 `Map`，那么我们可以使用内建方法 [Object.entries(obj)](mdn:js/Object/entries)，该返回对象的键/值对数组，该数组格式完全按照 `Map` 所需的格式。

所以可以像下面这样从一个对象创建一个 Map：

```js run
let obj = {
  name: &quot;John&quot;,
  age: 30
};

*!*
let map = new Map(Object.entries(obj));
*/!*

alert( map.get(&#x27;name&#x27;) ); // John
```

这里，`Object.entries` 返回键/值对数组：`[ [&quot;name&quot;,&quot;John&quot;], [&quot;age&quot;, 30] ]`。这就是 `Map` 所需要的格式。


## Object.fromEntries：从 Map 创建对象

我们刚刚已经学习了如何使用 `Object.entries(obj)` 从普通对象（plain object）创建 `Map`。

`Object.fromEntries` 方法的作用是相反的：给定一个具有 `[key, value]` 键值对的数组，它会根据给定数组创建一个对象：

```js run
let prices = Object.fromEntries([
  [&#x27;banana&#x27;, 1],
  [&#x27;orange&#x27;, 2],
  [&#x27;meat&#x27;, 4]
]);

// 现在 prices = { banana: 1, orange: 2, meat: 4 }

alert(prices.orange); // 2
```

我们可以使用 `Object.fromEntries` 从 `Map` 得到一个普通对象（plain object）。

例如，我们在 `Map` 中存储了一些数据，但是我们需要把这些数据传给需要普通对象（plain object）的第三方代码。

我们来开始：

```js run
let map = new Map();
map.set(&#x27;banana&#x27;, 1);
map.set(&#x27;orange&#x27;, 2);
map.set(&#x27;meat&#x27;, 4);

*!*
let obj = Object.fromEntries(map.entries()); // 创建一个普通对象（plain object）(*)
*/!*

// 完成了！
// obj = { banana: 1, orange: 2, meat: 4 }

alert(obj.orange); // 2
```

调用 `map.entries()` 将返回一个可迭代的键/值对，这刚好是 `Object.fromEntries` 所需要的格式。

我们可以把带 `(*)` 这一行写得更短：
```js
let obj = Object.fromEntries(map); // 省掉 .entries()
```

上面的代码作用也是一样的，因为 `Object.fromEntries` 期望得到一个可迭代对象作为参数，而不一定是数组。并且 `map` 的标准迭代会返回跟 `map.entries()` 一样的键/值对。因此，我们可以获得一个普通对象（plain object），其键/值对与 `map` 相同。

## Set

`Set` 是一个特殊的类型集合 —— “值的集合”（没有键），它的每一个值只能出现一次。

它的主要方法如下：

- `new Set(iterable)` —— 创建一个 `set`，如果提供了一个 `iterable` 对象（通常是数组），将会从数组里面复制值到 `set` 中。
- `set.add(value)` —— 添加一个值，返回 set 本身
- `set.delete(value)` —— 删除值，如果 `value` 在这个方法调用的时候存在则返回 `true` ，否则返回 `false`。
- `set.has(value)` —— 如果 `value` 在 set 中，返回 `true`，否则返回 `false`。
- `set.clear()` —— 清空 set。
- `set.size` —— 返回元素个数。

它的主要特点是，重复使用同一个值调用 `set.add(value)` 并不会发生什么改变。这就是 `Set` 里面的每一个值只出现一次的原因。

例如，我们有客人来访，我们想记住他们每一个人。但是已经来访过的客人再次来访，不应造成重复记录。每个访客必须只被“计数”一次。

`Set` 可以帮助我们解决这个问题：

```js run
let set = new Set();

let john = { name: &quot;John&quot; };
let pete = { name: &quot;Pete&quot; };
let mary = { name: &quot;Mary&quot; };

// visits，一些访客来访好几次
set.add(john);
set.add(pete);
set.add(mary);
set.add(john);
set.add(mary);

// set 只保留不重复的值
alert( set.size ); // 3

for (let user of set) {
  alert(user.name); // John（然后 Pete 和 Mary）
}
```

`Set` 的替代方法可以是一个用户数组，用 [arr.find](mdn:js/Array/find) 在每次插入值时检查是否重复。但是这样性能会很差，因为这个方法会遍历整个数组来检查每个元素。`Set` 内部对唯一性检查进行了更好的优化。

##  Set 迭代（iteration）

我们可以使用 `for..of` 或 `forEach` 来遍历 Set：

```js run
let set = new Set([&quot;oranges&quot;, &quot;apples&quot;, &quot;bananas&quot;]);

for (let value of set) alert(value);

// 与 forEach 相同：
set.forEach((value, valueAgain, set) =&gt; {
  alert(value);
});
```

注意一件有趣的事儿。`forEach` 的回调函数有三个参数：一个 `value`，然后是 **同一个值** `valueAgain`，最后是目标对象。没错，同一个值在参数里出现了两次。

`forEach` 的回调函数有三个参数，是为了与 `Map` 兼容。当然，这看起来确实有些奇怪。但是这对在特定情况下轻松地用 `Set` 代替 `Map` 很有帮助，反之亦然。

`Map` 中用于迭代的方法在 `Set` 中也同样支持：

- `set.keys()` —— 遍历并返回所有的值（returns an iterable object for values），
- `set.values()` —— 与 `set.keys()` 作用相同，这是为了兼容 `Map`，
- `set.entries()` —— 遍历并返回所有的实体（returns an iterable object for entries）`[value, value]`，它的存在也是为了兼容 `Map`。

## 总结

`Map` —— 是一个带键的数据项的集合。

方法和属性如下：

- `new Map([iterable])` —— 创建 map，可选择带有 `[key,value]` 对的 `iterable`（例如数组）来进行初始化。
- `map.set(key, value)` —— 根据键存储值。
- `map.get(key)` —— 根据键来返回值，如果 `map` 中不存在对应的 `key`，则返回 `undefined`。
- `map.has(key)` —— 如果 `key` 存在则返回 `true`，否则返回 `false`。
- `map.delete(key)` —— 删除指定键的值。
- `map.clear()` —— 清空 map 。
- `map.size` —— 返回当前元素个数。

与普通对象 `Object` 的不同点：

- 任何键、对象都可以作为键。
- 有其他的便捷方法，如 `size` 属性。

`Set` —— 是一组唯一值的集合。

方法和属性：

- `new Set([iterable])` —— 创建 set，可选择带有 `iterable`（例如数组）来进行初始化。
- `set.add(value)` —— 添加一个值（如果 `value` 存在则不做任何修改），返回 set 本身。
- `set.delete(value)` —— 删除值，如果 `value` 在这个方法调用的时候存在则返回 `true` ，否则返回 `false`。
- `set.has(value)` —— 如果 `value` 在 set 中，返回 `true`，否则返回 `false`。
- `set.clear()` —— 清空 set。
- `set.size` —— 元素的个数。

在 `Map` 和 `Set` 中迭代总是按照值插入的顺序进行的，所以我们不能说这些集合是无序的，但是我们不能对元素进行重新排序，也不能直接按其编号来获取元素。</code></pre>

      </fieldset>
      
      <fieldset id='_RSTeFy'>
      <legend>solution</legend>
      <p>让我们将已读消息存储在 <code>WeakSet</code> 中：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> messages = [
  {<span class="hljs-attr">text</span>: <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-attr">from</span>: <span class="hljs-string">&quot;John&quot;</span>},
  {<span class="hljs-attr">text</span>: <span class="hljs-string">&quot;How goes?&quot;</span>, <span class="hljs-attr">from</span>: <span class="hljs-string">&quot;John&quot;</span>},
  {<span class="hljs-attr">text</span>: <span class="hljs-string">&quot;See you soon&quot;</span>, <span class="hljs-attr">from</span>: <span class="hljs-string">&quot;Alice&quot;</span>}
];

<span class="hljs-keyword">let</span> readMessages = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakSet</span>();

<span class="hljs-comment">// 两个消息已读</span>
readMessages.add(messages[<span class="hljs-number">0</span>]);
readMessages.add(messages[<span class="hljs-number">1</span>]);
<span class="hljs-comment">// readMessages 包含两个元素</span>

<span class="hljs-comment">// ……让我们再读一遍第一条消息！</span>
readMessages.add(messages[<span class="hljs-number">0</span>]);
<span class="hljs-comment">// readMessages 仍然有两个不重复的元素</span>

<span class="hljs-comment">// 回答：message[0] 已读？</span>
alert(<span class="hljs-string">&quot;Read message 0: &quot;</span> + readMessages.has(messages[<span class="hljs-number">0</span>])); <span class="hljs-comment">// true</span>

messages.shift();
<span class="hljs-comment">// 现在 readMessages 有一个元素（技术上来讲，内存可能稍后才会被清理）</span></code></pre>
<p><code>WeakSet</code> 允许存储一系列的消息，并且很容易就能检查它是否包含某个消息。</p>
<p>它会自动清理自身。代价是，我们不能对它进行迭代，也不能直接从中获取“所有已读消息”。但是，我们可以通过遍历所有消息，然后找出存在于 set 的那些消息来完成这个功能。</p>
<p>另一种不同的解决方案可以是，在读取消息后向消息添加诸如 <code>message.isRead=true</code> 之类的属性。由于 <code>messages</code> 对象是由另一个代码管理的，因此通常不建议这样做，但是我们可以使用 symbol 属性来避免冲突。</p>
<p>像这样：</p>
<pre><code class="language-js"><span class="hljs-comment">// symbol 属性仅对于我们的代码是已知的</span>
<span class="hljs-keyword">let</span> isRead = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;isRead&quot;</span>);
messages[<span class="hljs-number">0</span>][isRead] = <span class="hljs-literal">true</span>;</code></pre>
<p>现在，第三方代码可能看不到我们的额外属性。</p>
<p>尽管 symbol 可以降低出现问题的可能性，但从架构的角度来看，还是使用 <code>WeakSet</code> 更好。</p>

      </fieldset>
      
      <fieldset id='_osamvA'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="存储-unread-标识">存储 &quot;unread&quot; 标识</h1>
<p>这里有一个 messages 数组：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> messages = [
  {<span class="hljs-attr">text</span>: <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-attr">from</span>: <span class="hljs-string">&quot;John&quot;</span>},
  {<span class="hljs-attr">text</span>: <span class="hljs-string">&quot;How goes?&quot;</span>, <span class="hljs-attr">from</span>: <span class="hljs-string">&quot;John&quot;</span>},
  {<span class="hljs-attr">text</span>: <span class="hljs-string">&quot;See you soon&quot;</span>, <span class="hljs-attr">from</span>: <span class="hljs-string">&quot;Alice&quot;</span>}
];</code></pre>
<p>你的代码可以访问它，但是 message 是由其他人的代码管理的。该代码会定期添加新消息，删除旧消息，但是你不知道这些操作确切的发生时间。</p>
<p>现在，你应该使用什么数据结构来保存关于消息“是否已读”的信息？该结构必须很适合对给定的 message 对象给出“它读了吗？”的答案。</p>
<p>P.S. 当一个消息被从 <code>messages</code> 中删除后，它应该也从你的数据结构中消失。</p>
<p>P.S. 我们不能修改 message 对象，例如向其添加我们的属性。因为它们是由其他人的代码管理的，我们修改该数据可能会导致不好的后果。</p>

      </fieldset>
      
      <fieldset id='_qLao1a'>
      <legend>solution</legend>
      <p>我们可以使用 <code>WeakMap</code> 保存日期：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> messages = [
  {<span class="hljs-attr">text</span>: <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-attr">from</span>: <span class="hljs-string">&quot;John&quot;</span>},
  {<span class="hljs-attr">text</span>: <span class="hljs-string">&quot;How goes?&quot;</span>, <span class="hljs-attr">from</span>: <span class="hljs-string">&quot;John&quot;</span>},
  {<span class="hljs-attr">text</span>: <span class="hljs-string">&quot;See you soon&quot;</span>, <span class="hljs-attr">from</span>: <span class="hljs-string">&quot;Alice&quot;</span>}
];

<span class="hljs-keyword">let</span> readMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();

readMap.set(messages[<span class="hljs-number">0</span>], <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2017</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>));
<span class="hljs-comment">// 我们稍后将学习 Date 对象</span></code></pre>

      </fieldset>
      
      <fieldset id='_QBgti6'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="保存阅读日期">保存阅读日期</h1>
<p>这儿有一个和 <a href="info:task/recipients-read">上一个任务</a> 类似的 <code>messages</code> 数组。场景也相似。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> messages = [
  {<span class="hljs-attr">text</span>: <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-attr">from</span>: <span class="hljs-string">&quot;John&quot;</span>},
  {<span class="hljs-attr">text</span>: <span class="hljs-string">&quot;How goes?&quot;</span>, <span class="hljs-attr">from</span>: <span class="hljs-string">&quot;John&quot;</span>},
  {<span class="hljs-attr">text</span>: <span class="hljs-string">&quot;See you soon&quot;</span>, <span class="hljs-attr">from</span>: <span class="hljs-string">&quot;Alice&quot;</span>}
];</code></pre>
<p>现在的问题是：你建议采用什么数据结构来保存信息：“消息是什么时候被阅读的？”。</p>
<p>在前一个任务中我们只需要保存“是/否”。现在我们需要保存日期，并且它应该在消息被垃圾回收时也被从内存中清除。</p>
<p>P.S. 日期可以存储为内建的 <code>Date</code> 类的对象，稍后我们将进行介绍。</p>

      </fieldset>
      
      <fieldset id='_TfakZG'>
      <legend>article</legend>
      <h1 id="weakmap-and-weakset（弱映射和弱集合）">WeakMap and WeakSet（弱映射和弱集合）</h1>
<p>我们从前面的 <a href="info:garbage-collection">info:garbage-collection</a> 章节中知道，JavaScript 引擎在值可访问（并可能被使用）时将其存储在内存中。</p>
<p>例如:</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> john = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> };

<span class="hljs-comment">// 该对象能被访问，john 是它的引用</span>

<span class="hljs-comment">// 覆盖引用</span>
john = <span class="hljs-literal">null</span>;

*!*
<span class="hljs-comment">// 该对象将会被从内存中清除</span>
*/!*</code></pre>
<p>通常，当对象、数组这类数据结构在内存中时，它们的子元素，如对象的属性、数组的元素都是可以访问的。</p>
<p>例如，如果把一个对象放入到数组中，那么只要这个数组存在，那么这个对象也就存在，即使没有其他对该对象的引用。</p>
<p>就像这样:</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> john = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> };

<span class="hljs-keyword">let</span> array = [ john ];

john = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 覆盖引用</span>

*!*
<span class="hljs-comment">// john 被存储在数组里, 所以它不会被垃圾回收机制回收</span>
<span class="hljs-comment">// 我们可以通过 array[0] 来获取它</span>
*/!*</code></pre>
<p>类似的，如果我们使用对象作为常规 <code>Map</code> 的键，那么当 <code>Map</code> 存在时，该对象也将存在。它会占用内存，并且应该不会被（垃圾回收机制）回收。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> john = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> };

<span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
map.set(john, <span class="hljs-string">&quot;...&quot;</span>);

john = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 覆盖引用</span>

*!*
<span class="hljs-comment">// john 被存储在 map 中，</span>
<span class="hljs-comment">// 我们可以使用 map.keys() 来获取它</span>
*/!*</code></pre>
<p><code>WeakMap</code> 在这方面有着根本上的不同。它不会阻止垃圾回收机制对作为键的对象（key object）的回收。</p>
<p>让我们通过例子来看看这指的到底是什么。</p>
<h2 id="weakmap">WeakMap</h2>
<p><code>WeakMap</code> 和 <code>Map</code> 的第一个不同点就是，<code>WeakMap</code> 的键必须是对象，不能是原始值：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> weakMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();

<span class="hljs-keyword">let</span> obj = {};

weakMap.set(obj, <span class="hljs-string">&quot;ok&quot;</span>); <span class="hljs-comment">// 正常工作（以对象作为键）</span>

*!*
<span class="hljs-comment">// 不能使用字符串作为键</span>
weakMap.set(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;Whoops&quot;</span>); <span class="hljs-comment">// Error，因为 &quot;test&quot; 不是一个对象</span>
*/!*</code></pre>
<p>现在，如果我们在 weakMap 中使用一个对象作为键，并且没有其他对这个对象的引用 —— 该对象将会被从内存（和map）中自动清除。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> john = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> };

<span class="hljs-keyword">let</span> weakMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();
weakMap.set(john, <span class="hljs-string">&quot;...&quot;</span>);

john = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 覆盖引用</span>

<span class="hljs-comment">// john 被从内存中删除了！</span></code></pre>
<p>与上面常规的 <code>Map</code> 的例子相比，现在如果 <code>john</code> 仅仅是作为 <code>WeakMap</code> 的键而存在 —— 它将会被从 map（和内存）中自动删除。</p>
<p><code>WeakMap</code> 不支持迭代以及 <code>keys()</code>，<code>values()</code> 和 <code>entries()</code> 方法。所以没有办法获取 <code>WeakMap</code> 的所有键或值。</p>
<p><code>WeakMap</code> 只有以下的方法：</p>
<ul>
<li><code>weakMap.get(key)</code></li>
<li><code>weakMap.set(key, value)</code></li>
<li><code>weakMap.delete(key)</code></li>
<li><code>weakMap.has(key)</code></li>
</ul>
<p>为什么会有这种限制呢？这是技术的原因。如果一个对象丢失了其它所有引用（就像上面示例中的 <code>john</code>），那么它就会被垃圾回收机制自动回收。但是在从技术的角度并不能准确知道 <strong>何时会被回收</strong>。</p>
<p>这些都是由 JavaScript 引擎决定的。JavaScript 引擎可能会选择立即执行内存清理，如果现在正在发生很多删除操作，那么 JavaScript 引擎可能就会选择等一等，稍后再进行内存清理。因此，从技术上讲，<code>WeakMap</code> 的当前元素的数量是未知的。JavaScript 引擎可能清理了其中的垃圾，可能没清理，也可能清理了一部分。因此，暂不支持访问 <code>WeakMap</code> 的所有键/值的方法。</p>
<p>那么，在哪里我们会需要这样的数据结构呢？</p>
<h2 id="使用案例：额外的数据">使用案例：额外的数据</h2>
<p><code>WeakMap</code> 的主要应用场景是 <strong>额外数据的存储</strong>。</p>
<p>假如我们正在处理一个“属于”另一个代码的一个对象，也可能是第三方库，并想存储一些与之相关的数据，那么这些数据就应该与这个对象共存亡 —— 这时候 <code>WeakMap</code> 正是我们所需要的利器。</p>
<p>我们将这些数据放到 <code>WeakMap</code> 中，并使用该对象作为这些数据的键，那么当该对象被垃圾回收机制回收后，这些数据也会被自动清除。</p>
<pre><code class="language-js">weakMap.set(john, <span class="hljs-string">&quot;secret documents&quot;</span>);
<span class="hljs-comment">// 如果 john 消失，secret documents 将会被自动清除</span></code></pre>
<p>让我们来看一个例子。</p>
<p>例如，我们有用于处理用户访问计数的代码。收集到的信息被存储在 map 中：一个用户对象作为键，其访问次数为值。当一个用户离开时（该用户对象将被垃圾回收机制回收），这时我们就不再需要他的访问次数了。</p>
<p>下面是一个使用 <code>Map</code> 的计数函数的例子：</p>
<pre><code class="language-js"><span class="hljs-comment">// 📁 visitsCount.js</span>
<span class="hljs-keyword">let</span> visitsCountMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(); <span class="hljs-comment">// map: user =&gt; visits count</span>

<span class="hljs-comment">// 递增用户来访次数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countUser</span>(<span class="hljs-params">user</span>) </span>{
  <span class="hljs-keyword">let</span> count = visitsCountMap.get(user) || <span class="hljs-number">0</span>;
  visitsCountMap.set(user, count + <span class="hljs-number">1</span>);
}</code></pre>
<p>下面是其他部分的代码，可能是使用它的其它代码：</p>
<pre><code class="language-js"><span class="hljs-comment">// 📁 main.js</span>
<span class="hljs-keyword">let</span> john = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> };

countUser(john); <span class="hljs-comment">// count his visits</span>

<span class="hljs-comment">// 不久之后，john 离开了</span>
john = <span class="hljs-literal">null</span>;</code></pre>
<p>现在 <code>john</code> 这个对象应该被垃圾回收，但他仍在内存中，因为它是 <code>visitsCountMap</code> 中的一个键。</p>
<p>当我们移除用户时，我们需要清理 <code>visitsCountMap</code>，否则它将在内存中无限增大。在复杂的架构中，这种清理会成为一项繁重的任务。</p>
<p>我们可以通过使用 <code>WeakMap</code> 来避免这样的问题：</p>
<pre><code class="language-js"><span class="hljs-comment">// 📁 visitsCount.js</span>
<span class="hljs-keyword">let</span> visitsCountMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>(); <span class="hljs-comment">// weakmap: user =&gt; visits count</span>

<span class="hljs-comment">// 递增用户来访次数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countUser</span>(<span class="hljs-params">user</span>) </span>{
  <span class="hljs-keyword">let</span> count = visitsCountMap.get(user) || <span class="hljs-number">0</span>;
  visitsCountMap.set(user, count + <span class="hljs-number">1</span>);
}</code></pre>
<p>现在我们不需要去清理 <code>visitsCountMap</code> 了。当 <code>john</code> 对象变成不可访问时，即便它是 <code>WeakMap</code> 里的一个键，它也会连同它作为 <code>WeakMap</code> 里的键所对应的信息一同被从内存中删除。</p>
<h2 id="使用案例：缓存">使用案例：缓存</h2>
<p>另外一个普遍的例子是缓存：当一个函数的结果需要被记住（“缓存”），这样在后续的对同一个对象的调用时，就可以重用这个被缓存的结果。</p>
<p>我们可以使用 <code>Map</code> 来存储结果，就像这样：</p>
<pre><code class="language-js"><span class="hljs-comment">// 📁 cache.js</span>
<span class="hljs-keyword">let</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

<span class="hljs-comment">// 计算并记住结果</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">process</span>(<span class="hljs-params">obj</span>) </span>{
  <span class="hljs-keyword">if</span> (!cache.has(obj)) {
    <span class="hljs-keyword">let</span> result = <span class="hljs-comment">/* calculations of the result for */</span> obj;

    cache.set(obj, result);
  }

  <span class="hljs-keyword">return</span> cache.get(obj);
}

*!*
<span class="hljs-comment">// 现在我们在其它文件中使用 process()</span>
*/!*

<span class="hljs-comment">// 📁 main.js</span>
<span class="hljs-keyword">let</span> obj = {<span class="hljs-comment">/* 假设我们有个对象 */</span>};

<span class="hljs-keyword">let</span> result1 = process(obj); <span class="hljs-comment">// 计算完成</span>

<span class="hljs-comment">// ……稍后，来自代码的另外一个地方……</span>
<span class="hljs-keyword">let</span> result2 = process(obj); <span class="hljs-comment">// 取自缓存的被记忆的结果</span>

<span class="hljs-comment">// ……稍后，我们不再需要这个对象时：</span>
obj = <span class="hljs-literal">null</span>;

alert(cache.size); <span class="hljs-comment">// 1（啊！该对象依然在 cache 中，并占据着内存！）</span></code></pre>
<p>对于多次调用同一个对象，它只需在第一次调用时计算出结果，之后的调用可以直接从 <code>cache</code> 中获取。这样做的缺点是，当我们不再需要这个对象的时候需要清理 <code>cache</code>。</p>
<p>如果我们用 <code>WeakMap</code> 替代 <code>Map</code>，这个问题便会消失：当对象被垃圾回收时，对应的缓存的结果也会被自动地从内存中清除。</p>
<pre><code class="language-js"><span class="hljs-comment">// 📁 cache.js</span>
*!*
<span class="hljs-keyword">let</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();
*/!*

<span class="hljs-comment">// 计算并记结果</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">process</span>(<span class="hljs-params">obj</span>) </span>{
  <span class="hljs-keyword">if</span> (!cache.has(obj)) {
    <span class="hljs-keyword">let</span> result = <span class="hljs-comment">/* calculate the result for */</span> obj;

    cache.set(obj, result);
  }

  <span class="hljs-keyword">return</span> cache.get(obj);
}

<span class="hljs-comment">// 📁 main.js</span>
<span class="hljs-keyword">let</span> obj = {<span class="hljs-comment">/* some object */</span>};

<span class="hljs-keyword">let</span> result1 = process(obj);
<span class="hljs-keyword">let</span> result2 = process(obj);

<span class="hljs-comment">// ……稍后，我们不再需要这个对象时：</span>
obj = <span class="hljs-literal">null</span>;

<span class="hljs-comment">// 无法获取 cache.size，因为它是一个 WeakMap，</span>
<span class="hljs-comment">// 要么是 0，或即将变为 0</span>
<span class="hljs-comment">// 当 obj 被垃圾回收，缓存的数据也会被清除</span></code></pre>
<h2 id="weakset">WeakSet</h2>
<p><code>WeakSet</code> 的表现类似：</p>
<ul>
<li>与 <code>Set</code> 类似，但是我们只能向 <code>WeakSet</code> 添加对象（而不能是原始值）。</li>
<li>对象只有在其它某个（些）地方能被访问的时候，才能留在 set 中。</li>
<li>跟 <code>Set</code> 一样，<code>WeakSet</code> 支持 <code>add</code>，<code>has</code> 和 <code>delete</code> 方法，但不支持 <code>size</code> 和 <code>keys()</code>，并且不可迭代。</li>
</ul>
<p>变“弱（weak）”的同时，它也可以作为额外的存储空间。但并非针对任意数据，而是针对“是/否”的事实。<code>WeakSet</code> 的元素可能代表着有关该对象的某些信息。</p>
<p>例如，我们可以将用户添加到 <code>WeakSet</code> 中，以追踪访问过我们网站的用户：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> visitedSet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakSet</span>();

<span class="hljs-keyword">let</span> john = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> };
<span class="hljs-keyword">let</span> pete = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Pete&quot;</span> };
<span class="hljs-keyword">let</span> mary = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Mary&quot;</span> };

visitedSet.add(john); <span class="hljs-comment">// John 访问了我们</span>
visitedSet.add(pete); <span class="hljs-comment">// 然后是 Pete</span>
visitedSet.add(john); <span class="hljs-comment">// John 再次访问</span>

<span class="hljs-comment">// visitedSet 现在有两个用户了</span>

<span class="hljs-comment">// 检查 John 是否来访过？</span>
alert(visitedSet.has(john)); <span class="hljs-comment">// true</span>

<span class="hljs-comment">// 检查 Mary 是否来访过？</span>
alert(visitedSet.has(mary)); <span class="hljs-comment">// false</span>

john = <span class="hljs-literal">null</span>;

<span class="hljs-comment">// visitedSet 将被自动清理</span></code></pre>
<p><code>WeakMap</code> 和 <code>WeakSet</code> 最明显的局限性就是不能迭代，并且无法获取所有当前内容。那样可能会造成不便，但是并不会阻止 <code>WeakMap/WeakSet</code> 完成其主要工作 — 成为在其它地方管理/存储“额外”的对象数据。</p>
<h2 id="总结">总结</h2>
<p><code>WeakMap</code> 是类似于 <code>Map</code> 的集合，它仅允许对象作为键，并且一旦通过其他方式无法访问它们，便会将它们与其关联值一同删除。</p>
<p><code>WeakSet</code> 是类似于 <code>Set</code> 的集合，它仅存储对象，并且一旦通过其他方式无法访问它们，便会将其删除。</p>
<p>它们都不支持引用所有键或其计数的方法和属性。仅允许单个操作。</p>
<p><code>WeakMap</code> 和 <code>WeakSet</code> 被用作“主要”对象存储之外的“辅助”数据结构。一旦将对象从主存储器中删除，如果该对象仅被用作 <code>WeakMap</code> 或 <code>WeakSet</code> 的键，那么它将被自动清除。</p>

      </fieldset>
      
      <fieldset id='_N4tnjK'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sumSalaries</span>(<span class="hljs-params">salaries</span>) </span>{

  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> salary <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.values(salaries)) {
    sum += salary;
  }

  <span class="hljs-keyword">return</span> sum; <span class="hljs-comment">// 650</span>
}

<span class="hljs-keyword">let</span> salaries = {
  <span class="hljs-string">&quot;John&quot;</span>: <span class="hljs-number">100</span>,
  <span class="hljs-string">&quot;Pete&quot;</span>: <span class="hljs-number">300</span>,
  <span class="hljs-string">&quot;Mary&quot;</span>: <span class="hljs-number">250</span>
};

alert( sumSalaries(salaries) ); <span class="hljs-comment">// 650</span></code></pre>
<p>还有另外一种可选方案，即使用 <code>Object.values</code> 和 <code>reduce</code> 来求和：</p>
<pre><code class="language-js"><span class="hljs-comment">// 使用 reduce 方法遍历 salaries 数组</span>
<span class="hljs-comment">// 把它们加起来</span>
<span class="hljs-comment">// 返回最终结果</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sumSalaries</span>(<span class="hljs-params">salaries</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.values(salaries).reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b, <span class="hljs-number">0</span>) <span class="hljs-comment">// 650</span>
}</code></pre>

      </fieldset>
      
      <fieldset id='_DdV2GF'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="属性求和">属性求和</h1>
<p>有一个带有任意数量薪水的 <code>salaries</code> 对象。</p>
<p>编写函数 <code>sumSalaries(salaries)</code>，该函数使用 <code>Object.values</code> 和 <code>for..of</code> 循环返回所有薪水的总和。</p>
<p>如果 <code>salaries</code> 是空对象，那么结果必须是 <code>0</code>。</p>
<p>举个例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> salaries = {
  <span class="hljs-string">&quot;John&quot;</span>: <span class="hljs-number">100</span>,
  <span class="hljs-string">&quot;Pete&quot;</span>: <span class="hljs-number">300</span>,
  <span class="hljs-string">&quot;Mary&quot;</span>: <span class="hljs-number">250</span>
};

alert( sumSalaries(salaries) ); <span class="hljs-comment">// 650</span></code></pre>

      </fieldset>
      
      <fieldset id='_ecuGXI'>
      <legend>solution</legend>
      
      </fieldset>
      
      <fieldset id='_npvTbI'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="计算属性数量">计算属性数量</h1>
<p>写一个函数 <code>count(obj)</code>，该函数返回对象中的属性的数量：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>
};

alert( count(user) ); <span class="hljs-comment">// 2</span></code></pre>
<p>试着使代码尽可能简短。</p>
<p>P.S. 忽略 Symbol 类型属性，只计算“常规”属性。</p>

      </fieldset>
      
      <fieldset id='_6yhlfW'>
      <legend>article</legend>
      <h1 id="objectkeys，values，entries">Object.keys，values，entries</h1>
<p>对各个数据结构的学习至此告一段落，下面让我们讨论一下如何迭代它们。</p>
<p>在前面的章节中，我们认识了 <code>map.keys()</code>，<code>map.values()</code> 和 <code>map.entries()</code> 方法。</p>
<p>这些方法是通用的，有一个共同的约定来将它们用于各种数据结构。如果我们创建一个我们自己的数据结构，我们也应该实现这些方法。</p>
<p>它们支持：</p>
<ul>
<li><code>Map</code></li>
<li><code>Set</code></li>
<li><code>Array</code></li>
</ul>
<p>普通对象也支持类似的方法，但是语法上有一些不同。</p>
<h2 id="objectkeys，values，entries-1">Object.keys，values，entries</h2>
<p>对于普通对象，下列这些方法是可用的：</p>
<ul>
<li><a href="mdn:js/Object/keys">Object.keys(obj)</a> —— 返回一个包含该对象所有的键的数组。</li>
<li><a href="mdn:js/Object/values">Object.values(obj)</a> —— 返回一个包含该对象所有的值的数组。</li>
<li><a href="mdn:js/Object/entries">Object.entries(obj)</a> —— 返回一个包含该对象所有 [key, value] 键值对的数组。</li>
</ul>
<p>……但是请注意区别（比如说跟 map 的区别）：</p>
<table>
<thead>
<tr>
<th></th>
<th>Map</th>
<th>Object</th>
</tr>
</thead>
<tbody><tr>
<td>调用语法</td>
<td><code>map.keys()</code></td>
<td><code>Object.keys(obj)</code>，而不是 <code>obj.keys()</code></td>
</tr>
<tr>
<td>返回值</td>
<td>可迭代项</td>
<td>“真正的”数组</td>
</tr>
</tbody></table>
<p>第一个区别是，对于对象我们使用的调用语法是 <code>Object.keys(obj)</code>，而不是 <code>obj.keys()</code>。</p>
<p>为什么会这样？主要原因是灵活性。请记住，在 JavaScript 中，对象是所有复杂结构的基础。因此，我们可能有一个自己创建的对象，比如 <code>data</code>，并实现了它自己的 <code>data.values()</code> 方法。同时，我们依然可以对它调用 <code>Object.values(data)</code> 方法。</p>
<p>第二个区别是 <code>Object.*</code> 方法返回的是“真正的”数组对象，而不只是一个可迭代项。这主要是历史原因。</p>
<p>举个例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>
};</code></pre>
<ul>
<li><code>Object.keys(user) = [&quot;name&quot;, &quot;age&quot;]</code></li>
<li><code>Object.values(user) = [&quot;John&quot;, 30]</code></li>
<li><code>Object.entries(user) = [ [&quot;name&quot;,&quot;John&quot;], [&quot;age&quot;,30] ]</code></li>
</ul>
<p>这里有一个使用 <code>Object.values</code> 来遍历属性值的例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>
};

<span class="hljs-comment">// 遍历所有的值</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.values(user)) {
  alert(value); <span class="hljs-comment">// John, then 30</span>
}</code></pre>
<pre><code class="language-warn">就像 `for..in` 循环一样，这些方法会忽略使用 `Symbol(...)` 作为键的属性。

通常这很方便。但是，如果我们也想要 Symbol 类型的键，那么这儿有一个单独的方法 [Object.getOwnPropertySymbols](mdn:js/Object/getOwnPropertySymbols)，它会返回一个只包含 Symbol 类型的键的数组。另外，还有一种方法 [Reflect.ownKeys(obj)](mdn:js/Reflect/ownKeys)，它会返回 **所有** 键。</code></pre>
<h2 id="转换对象">转换对象</h2>
<p>对象缺少数组存在的许多方法，例如 <code>map</code> 和 <code>filter</code> 等。</p>
<p>如果我们想应用它们，那么我们可以使用 <code>Object.entries</code>，然后使用 <code>Object.fromEntries</code>：</p>
<ol>
<li>使用 <code>Object.entries(obj)</code> 从 <code>obj</code> 获取由键/值对组成的数组。</li>
<li>对该数组使用数组方法，例如 <code>map</code>。</li>
<li>对结果数组使用 <code>Object.fromEntries(array)</code> 方法，将结果转回成对象。</li>
</ol>
<p>例如，我们有一个带有价格的对象，并想将它们加倍：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> prices = {
  <span class="hljs-attr">banana</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">orange</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">meat</span>: <span class="hljs-number">4</span>,
};

*!*
<span class="hljs-keyword">let</span> doublePrices = <span class="hljs-built_in">Object</span>.fromEntries(
  <span class="hljs-comment">// 转换为数组，之后使用 map 方法，然后通过 fromEntries 再转回到对象</span>
  <span class="hljs-built_in">Object</span>.entries(prices).map(<span class="hljs-function">(<span class="hljs-params">[key, value]</span>) =&gt;</span> [key, value * <span class="hljs-number">2</span>])
);
*/!*

alert(doublePrices.meat); <span class="hljs-comment">// 8</span></code></pre>
<p>乍一看，可能看起来很困难，但是使用一次或两次后，就很容易理解了。我们可以通过这种方式建立强大的转换链。</p>

      </fieldset>
      
      <fieldset id='_0VISCH'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">years</span>: <span class="hljs-number">30</span>
};

<span class="hljs-keyword">let</span> {name, <span class="hljs-attr">years</span>: age, isAdmin = <span class="hljs-literal">false</span>} = user;

alert( name ); <span class="hljs-comment">// John</span>
alert( age ); <span class="hljs-comment">// 30</span>
alert( isAdmin ); <span class="hljs-comment">// false</span></code></pre>

      </fieldset>
      
      <fieldset id='_Vf45Rq'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="解构赋值">解构赋值</h1>
<p>我们有一个对象：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">years</span>: <span class="hljs-number">30</span>
};</code></pre>
<p>写一个解构赋值语句使得：</p>
<ul>
<li><code>name</code> 属性赋值给变量 <code>name</code>。</li>
<li><code>years</code> 属性赋值给变量 <code>age</code>。</li>
<li><code>isAdmin</code> 属性赋值给变量 <code>isAdmin</code>（如果属性缺失则取默认值 false）。</li>
</ul>
<p>下面是赋值完成后的值的情况：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-attr">years</span>: <span class="hljs-number">30</span> };

<span class="hljs-comment">// 等号左侧是你的代码</span>
<span class="hljs-comment">// ... = user</span>

alert( name ); <span class="hljs-comment">// John</span>
alert( age ); <span class="hljs-comment">// 30</span>
alert( isAdmin ); <span class="hljs-comment">// false</span></code></pre>

      </fieldset>
      
      <fieldset id='_4paCxP'>
      <legend>solution</legend>
      
      </fieldset>
      
      <fieldset id='_vxlF9g'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="最高薪资">最高薪资</h1>
<p>这儿有一个 <code>salaries</code> 对象：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> salaries = {
  <span class="hljs-string">&quot;John&quot;</span>: <span class="hljs-number">100</span>,
  <span class="hljs-string">&quot;Pete&quot;</span>: <span class="hljs-number">300</span>,
  <span class="hljs-string">&quot;Mary&quot;</span>: <span class="hljs-number">250</span>
};</code></pre>
<p>新建一个函数 <code>topSalary(salaries)</code>，返回收入最高的人的姓名。</p>
<ul>
<li>如果 <code>salaries</code> 是空的，函数应该返回 <code>null</code>。</li>
<li>如果有多个收入最高的人，返回其中任意一个即可。</li>
</ul>
<p>P.S. 使用 <code>Object.entries</code> 和解构语法来遍历键/值对。</p>

      </fieldset>
      
      <fieldset id='_OzdPvT'>
      <legend>article</legend>
      <h1 id="解构赋值">解构赋值</h1>
<p>JavaScript 中最常用的两种数据结构是 <code>Object</code> 和 <code>Array</code>。</p>
<p>对象让我们能够创建通过键来存储数据项的单个实体，数组则让我们能够将数据收集到一个有序的集合中。</p>
<p>但是，当我们把它们传递给函数时，它可能不需要一个整体的对象/数组，而是需要单个块。</p>
<p><strong>解构赋值</strong> 是一种特殊的语法，它使我们可以将数组或对象“拆包”为到一系列变量中，因为有时候使用变量更加方便。解构操作对那些具有很多参数和默认值等的函数也很奏效。</p>
<h2 id="数组解构">数组解构</h2>
<p>下面是一个将数组解构到变量中的例子：</p>
<pre><code class="language-js"><span class="hljs-comment">// 我们有一个存放了名字和姓氏的数组</span>
<span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;Ilya&quot;</span>, <span class="hljs-string">&quot;Kantor&quot;</span>]

*!*
<span class="hljs-comment">// 解构赋值</span>
<span class="hljs-comment">// sets firstName = arr[0]</span>
<span class="hljs-comment">// and surname = arr[1]</span>
<span class="hljs-keyword">let</span> [firstName, surname] = arr;
*/!*

alert(firstName); <span class="hljs-comment">// Ilya</span>
alert(surname);  <span class="hljs-comment">// Kantor</span></code></pre>
<p>现在我们就可以针对这些变量进行操作，而不是针对原来的数组元素。</p>
<p>当与 <code>split</code> 函数（或其他返回值是数组的函数）结合使用时，看起来就更优雅了：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> [firstName, surname] = <span class="hljs-string">&quot;Ilya Kantor&quot;</span>.split(<span class="hljs-string">&#x27; &#x27;</span>);</code></pre>
<pre><code class="language-smart">这种语法叫做“解构赋值”，因为它通过将结构中的各元素复制到变量中来达到“解构”的目的。但数组本身是没有被修改的。

这只是下面这些代码的更精简的写法而已：
```js
// let [firstName, surname] = arr;
let firstName = arr[0];
let surname = arr[1];
```</code></pre>
<pre><code class="language-smart">数组中不想要的元素也可以通过添加额外的逗号来把它丢弃：

```js run
*!*
// 不需要第二个元素
let [firstName, , title] = [&quot;Julius&quot;, &quot;Caesar&quot;, &quot;Consul&quot;, &quot;of the Roman Republic&quot;];
*/!*

alert( title ); // Consul
```

在上面的代码中，数组的第二个元素被跳过了，第三个元素被赋值给了 `title` 变量，数组中剩下的元素也都被跳过了（因为在这没有对应给它们的变量）。</code></pre>
<pre><code class="language-smart">
……实际上，我们可以将其与任何可迭代对象一起使用，而不仅限于数组：

```js
let [a, b, c] = &quot;abc&quot;; // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
let [one, two, three] = new Set([1, 2, 3]);
```
</code></pre>
<pre><code class="language-smart">
我们可以在等号左侧使用任何“可以被赋值的”东西。

例如，一个对象的属性：
```js run
let user = {};
[user.name, user.surname] = &quot;Ilya Kantor&quot;.split(&#x27; &#x27;);

alert(user.name); // Ilya
```
</code></pre>
<pre><code class="language-smart">
在前面的章节中我们已经见过了 [Object.entries(obj)](mdn:js/Object/entries) 方法。

我们可以将 .entries() 方法与解构语法一同使用，来遍历一个对象的“键—值”对：

```js run
let user = {
  name: &quot;John&quot;,
  age: 30
};

// 循环遍历键—值对
*!*
for (let [key, value] of Object.entries(user)) {
*/!*
  alert(`${key}:${value}`); // name:John, then age:30
}
```

……对于 map 对象也类似：

```js run
let user = new Map();
user.set(&quot;name&quot;, &quot;John&quot;);
user.set(&quot;age&quot;, &quot;30&quot;);

*!*
for (let [key, value] of user) {
*/!*
  alert(`${key}:${value}`); // name:John, then age:30
}
```</code></pre>
<pre><code class="language-smart">一个用于交换变量值的典型技巧：

```js run
let guest = &quot;Jane&quot;;
let admin = &quot;Pete&quot;;

// 交换值：让 guest=Pete, admin=Jane
[guest, admin] = [admin, guest];

alert(`${guest} ${admin}`); // Pete Jane（成功交换！）</code></pre>
<p>这里我们创建了一个由两个变量组成的临时数组，并且立即以交换了的顺序对其进行了解构。</p>
<p>我们可以用这种方式交换两个以上的变量。</p>
<h3 id="剩余的-">剩余的 &#39;...&#39;</h3>
<p>如果我们不只是要获得第一个值，还要将后续的所有元素都收集起来 — 我们可以使用三个点 <code>&quot;...&quot;</code> 来再加一个参数来接收“剩余的”元素：</p>
<pre><code class="language-js">let [name1, name2, *!*...rest*/!*] = [&quot;Julius&quot;, &quot;Caesar&quot;, *!*&quot;Consul&quot;, &quot;of the Roman Republic&quot;*/!*];

alert(name1); // Julius
alert(name2); // Caesar

*!*
// 请注意，`rest` 的类型是数组
alert(rest[0]); // Consul
alert(rest[1]); // of the Roman Republic
alert(rest.length); // 2
*/!*</code></pre>
<p><code>rest</code> 的值就是数组中剩下的元素组成的数组。不一定要使用变量名 <code>rest</code>，我们也可以使用其他的变量名，只要确保它前面有三个点，并且在解构赋值的最后一个参数位置上就行了。</p>
<h3 id="默认值">默认值</h3>
<p>如果赋值语句中，变量的数量多于数组中实际元素的数量，赋值不会报错。未赋值的变量被认为是 <code>undefined</code>：</p>
<pre><code class="language-js">*!*
<span class="hljs-keyword">let</span> [firstName, surname] = [];
*/!*

alert(firstName); <span class="hljs-comment">// undefined</span>
alert(surname); <span class="hljs-comment">// undefined</span></code></pre>
<p>如果我们想要一个“默认”值给未赋值的变量，我们可以使用 <code>=</code> 来提供：</p>
<pre><code class="language-js">*!*
<span class="hljs-comment">// 默认值</span>
<span class="hljs-keyword">let</span> [name = <span class="hljs-string">&quot;Guest&quot;</span>, surname = <span class="hljs-string">&quot;Anonymous&quot;</span>] = [<span class="hljs-string">&quot;Julius&quot;</span>];
*/!*

alert(name);    <span class="hljs-comment">// Julius（来自数组的值）</span>
alert(surname); <span class="hljs-comment">// Anonymous（默认值被使用了）</span></code></pre>
<p>默认值可以是更加复杂的表达式甚至可以是函数调用，这些表达式或函数只会在这个变量未被赋值的时候才会被计算。</p>
<p>举个例子，我们使用了 <code>prompt</code> 函数来提供两个默认值，但它只会在未被赋值的那个变量上进行调用：</p>
<pre><code class="language-js"><span class="hljs-comment">// 只会提示输入姓氏</span>
<span class="hljs-keyword">let</span> [name = prompt(<span class="hljs-string">&#x27;name?&#x27;</span>), surname = prompt(<span class="hljs-string">&#x27;surname?&#x27;</span>)] = [<span class="hljs-string">&quot;Julius&quot;</span>];

alert(name);    <span class="hljs-comment">// Julius（来自数组）</span>
alert(surname); <span class="hljs-comment">// 你输入的值</span></code></pre>
<h2 id="对象解构">对象解构</h2>
<p>解构赋值同样适用于对象。</p>
<p>基本语法是：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> {var1, var2} = {<span class="hljs-attr">var1</span>:…, <span class="hljs-attr">var2</span>:…}</code></pre>
<p>在等号右侧有一个已经存在的对象，我们想把它拆开到变量中。等号左侧包含了对象相应属性的一个“模式（pattern）”。在简单的情况下，等号左侧的就是 <code>{...}</code> 中的变量名列表。</p>
<p>举个例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> options = {
  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Menu&quot;</span>,
  <span class="hljs-attr">width</span>: <span class="hljs-number">100</span>,
  <span class="hljs-attr">height</span>: <span class="hljs-number">200</span>
};

*!*
<span class="hljs-keyword">let</span> {title, width, height} = options;
*/!*

alert(title);  <span class="hljs-comment">// Menu</span>
alert(width);  <span class="hljs-comment">// 100</span>
alert(height); <span class="hljs-comment">// 200</span></code></pre>
<p>属性 <code>options.title</code>、<code>options.width</code> 和 <code>options.height</code> 值被赋给了对应的变量。变量的顺序并不重要，下面这个代码也奏效：</p>
<pre><code class="language-js"><span class="hljs-comment">// 改变 let {...} 中元素的顺序</span>
<span class="hljs-keyword">let</span> {height, width, title} = { <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Menu&quot;</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">200</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">100</span> }</code></pre>
<p>等号左侧的模式（pattern）可以更加复杂，并且指定了属性和变量之间的映射关系。</p>
<p>如果我们想把一个属性赋值给另一个名字的变量，比如把 <code>options.width</code> 属性赋值给变量 <code>w</code>，那么我们可以使用冒号来指定：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> options = {
  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Menu&quot;</span>,
  <span class="hljs-attr">width</span>: <span class="hljs-number">100</span>,
  <span class="hljs-attr">height</span>: <span class="hljs-number">200</span>
};

*!*
<span class="hljs-comment">// { sourceProperty: targetVariable }</span>
<span class="hljs-keyword">let</span> {<span class="hljs-attr">width</span>: w, <span class="hljs-attr">height</span>: h, title} = options;
*/!*

<span class="hljs-comment">// width -&gt; w</span>
<span class="hljs-comment">// height -&gt; h</span>
<span class="hljs-comment">// title -&gt; title</span>

alert(title);  <span class="hljs-comment">// Menu</span>
alert(w);      <span class="hljs-comment">// 100</span>
alert(h);      <span class="hljs-comment">// 200</span></code></pre>
<p>冒号表示“什么值：赋值给谁”。上面的例子中，属性 <code>width</code> 被赋值给了 <code>w</code>，属性 <code>height</code> 被赋值给了 <code>h</code>，属性 <code>title</code> 被赋值给了同名变量。</p>
<p>对于可能缺失的属性，我们可以使用 <code>&quot;=&quot;</code> 设置默认值，如下所示：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> options = {
  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Menu&quot;</span>
};

*!*
<span class="hljs-keyword">let</span> {width = <span class="hljs-number">100</span>, height = <span class="hljs-number">200</span>, title} = options;
*/!*

alert(title);  <span class="hljs-comment">// Menu</span>
alert(width);  <span class="hljs-comment">// 100</span>
alert(height); <span class="hljs-comment">// 200</span></code></pre>
<p>就像数组或函数参数一样，默认值可以是任意表达式甚至可以是函数调用。它们只会在未提供对应的值时才会被计算/调用。</p>
<p>在下面的代码中，<code>prompt</code> 提示输入 <code>width</code> 值，但不会提示输入 <code>title</code> 值：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> options = {
  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Menu&quot;</span>
};

*!*
<span class="hljs-keyword">let</span> {width = prompt(<span class="hljs-string">&quot;width?&quot;</span>), title = prompt(<span class="hljs-string">&quot;title?&quot;</span>)} = options;
*/!*

alert(title);  <span class="hljs-comment">// Menu</span>
alert(width);  <span class="hljs-comment">//（无论 prompt 的结果是什么）</span></code></pre>
<p>我们还可以将冒号和等号结合起来：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> options = {
  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Menu&quot;</span>
};

*!*
<span class="hljs-keyword">let</span> {<span class="hljs-attr">width</span>: w = <span class="hljs-number">100</span>, <span class="hljs-attr">height</span>: h = <span class="hljs-number">200</span>, title} = options;
*/!*

alert(title);  <span class="hljs-comment">// Menu</span>
alert(w);      <span class="hljs-comment">// 100</span>
alert(h);      <span class="hljs-comment">// 200</span></code></pre>
<p>如果我们有一个具有很多属性的复杂对象，那么我们可以只提取所需的内容：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> options = {
  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Menu&quot;</span>,
  <span class="hljs-attr">width</span>: <span class="hljs-number">100</span>,
  <span class="hljs-attr">height</span>: <span class="hljs-number">200</span>
};

<span class="hljs-comment">// 仅提取 title 作为变量</span>
<span class="hljs-keyword">let</span> { title } = options;

alert(title); <span class="hljs-comment">// Menu</span></code></pre>
<h3 id="剩余模式（pattern）">剩余模式（pattern）&quot;...&quot;</h3>
<p>如果对象拥有的属性数量比我们提供的变量数量还多，该怎么办？我们可以只取其中的某一些属性，然后把“剩余的”赋值到其他地方吗？</p>
<p>我们可以使用剩余模式（pattern），就像我们对数组那样。一些较旧的浏览器不支持此功能（例如，使用 Babel 对其进行填充），但可以在现代浏览器中使用。</p>
<p>看起来就像这样：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> options = {
  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Menu&quot;</span>,
  <span class="hljs-attr">height</span>: <span class="hljs-number">200</span>,
  <span class="hljs-attr">width</span>: <span class="hljs-number">100</span>
};

*!*
<span class="hljs-comment">// title = 名为 title 的属性</span>
<span class="hljs-comment">// rest = 存有剩余属性的对象</span>
<span class="hljs-keyword">let</span> {title, ...rest} = options;
*/!*

<span class="hljs-comment">// 现在 title=&quot;Menu&quot;, rest={height: 200, width: 100}</span>
alert(rest.height);  <span class="hljs-comment">// 200</span>
alert(rest.width);   <span class="hljs-comment">// 100</span></code></pre>
<p>````smart header=&quot;不使用 <code>let</code> 时的陷阱&quot;
在上面的示例中，变量都是在赋值中通过正确方式声明的：<code>let {…} = {…}</code>。当然，我们也可以使用已有的变量，而不用 <code>let</code>，但这里有一个陷阱。</p>
<p>以下代码无法正常运行：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> title, width, height;

<span class="hljs-comment">// 这一行发生了错误</span>
{title, width, height} = {<span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Menu&quot;</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">200</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">100</span>};</code></pre>
<p>问题在于 JavaScript 把主代码流（即不在其他表达式中）的 <code>{...}</code> 当做一个代码块。这样的代码块可以用于对语句分组，如下所示：</p>
<pre><code class="language-js">{
  <span class="hljs-comment">// 一个代码块</span>
  <span class="hljs-keyword">let</span> message = <span class="hljs-string">&quot;Hello&quot;</span>;
  <span class="hljs-comment">// ...</span>
  alert( message );
}</code></pre>
<p>因此，这里 JavaScript 假定我们有一个代码块，这就是报错的原因。我们需要解构它。</p>
<p>为了告诉 JavaScript 这不是一个代码块，我们可以把整个赋值表达式用括号 <code>(...)</code> 包起来：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> title, width, height;

<span class="hljs-comment">// 现在就可以了</span>
*!*(*<span class="hljs-regexp">/!*{title, width, height} = {title: &quot;Menu&quot;, width: 200, height: 100}*!*)*/</span>!*;

alert( title ); <span class="hljs-comment">// Menu</span></code></pre>
<pre><code>
## 嵌套解构

如果一个对象或数组嵌套了其他的对象和数组，我们可以在等号左侧使用更复杂的模式（pattern）来提取更深层的数据。

在下面的代码中，`options` 的属性 `size` 是另一个对象，属性 `items` 是另一个数组。赋值语句中等号左侧的模式（pattern）具有相同的结构以从中提取值：

```js run
let options = {
  size: {
    width: 100,
    height: 200
  },
  items: [&quot;Cake&quot;, &quot;Donut&quot;],
  extra: true   
};

// 为了清晰起见，解构赋值语句被写成多行的形式
let {
  size: { // 把 size 赋值到这里
    width,
    height
  },
  items: [item1, item2], // 把 items 赋值到这里
  title = &quot;Menu&quot; // 在对象中不存在（使用默认值）
} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
alert(item1);  // Cake
alert(item2);  // Donut
```

对象 `options` 的所有属性，除了 `extra` 属性在等号左侧不存在，都被赋值给了对应的变量：

![](destructuring-complex.svg)

最终，我们得到了 `width`、`height`、`item1`、`item2` 和具有默认值的 `title` 变量。

注意，`size` 和 `items` 没有对应的变量，因为我们取的是它们的内容。

## 智能函数参数

有时，一个函数有很多参数，其中大部分的参数都是可选的。对用户界面来说更是如此。想象一个创建菜单的函数。它可能具有宽度参数，高度参数，标题参数和项目列表等。

下面是实现这种函数的一个很不好的写法：

```js
function showMenu(title = &quot;Untitled&quot;, width = 200, height = 100, items = []) {
  // ...
}
```

在实际开发中存在一个问题就是你怎么记得住这么多参数的顺序。通常集成开发环境工具（IDE）会尽力帮助我们，特别是当代码有良好的文档注释的时候，但是…… 另一个问题就是，当大部分的参数采用默认值就好的情况下，怎么调用这个函数。

难道像这样？

```js
// 在采用默认值就可以的位置设置 undefined
showMenu(&quot;My Menu&quot;, undefined, undefined, [&quot;Item1&quot;, &quot;Item2&quot;])
```

这太难看了。而且，当我们处理更多参数的时候可读性会变得很差。

解构赋值语法前来救援！

我们可以把所有参数当作一个对象来传递，然后函数马上把这个对象解构成多个变量：

```js run
// 我们传递一个对象给函数
let options = {
  title: &quot;My menu&quot;,
  items: [&quot;Item1&quot;, &quot;Item2&quot;]
};

// ……然后函数马上把对象展开成变量
function showMenu(*!*{title = &quot;Untitled&quot;, width = 200, height = 100, items = []}*/!*) {
  // title, items – 提取于 options，
  // width, height – 使用默认值
  alert( `${title} ${width} ${height}` ); // My Menu 200 100
  alert( items ); // Item1, Item2
}

showMenu(options);
```

我们同样可以使用带有嵌套对象和冒号映射的更加复杂的解构：

```js run
let options = {
  title: &quot;My menu&quot;,
  items: [&quot;Item1&quot;, &quot;Item2&quot;]
};

*!*
function showMenu({
  title = &quot;Untitled&quot;,
  width: w = 100,  // width goes to w
  height: h = 200, // height goes to h
  items: [item1, item2] // items first element goes to item1, second to item2
}) {
*/!*
  alert( `${title} ${w} ${h}` ); // My Menu 100 200
  alert( item1 ); // Item1
  alert( item2 ); // Item2
}

showMenu(options);
```

完整语法和解构赋值是一样的：
```js
function({
  incomingProperty: varName = defaultValue
  ...
})
```

对于参数对象，属性 `incomingProperty` 对应的变量是 `varName`，默认值是 `defaultValue`。

请注意，这种解构假定了 `showMenu()` 函数确实存在参数。如果我们想让所有的参数都使用默认值，那我们应该传递一个空对象：

```js
showMenu({}); // 不错，所有值都取默认值

showMenu(); // 这样会导致错误
```

我们可以通过指定空对象 `{}` 为整个参数对象的默认值来解决这个问题：

```js run
function showMenu({ title = &quot;Menu&quot;, width = 100, height = 200 }*!* = {}*/!*) {
  alert( `${title} ${width} ${height}` );
}

showMenu(); // Menu 100 200
```

在上面的代码中，整个参数对象的默认是 `{}`，因此总会有内容可以用来解构。

## 总结

- 解构赋值可以立即将一个对象或数组映射到多个变量上。
- 解构对象的完整语法：
    ```js
    let {prop : varName = default, ...rest} = object
    ```

    这表示属性 `prop` 会被赋值给变量 `varName`，如果没有这个属性的话，就会使用默认值 `default`。

    没有对应映射的对象属性会被复制到 `rest` 对象。

- 解构数组的完整语法：

    ```js
    let [item1 = default, item2, ...rest] = array
    ```

    数组的第一个元素被赋值给 `item1`，第二个元素被赋值给 `item2`，剩下的所有元素被复制到另一个数组 `rest`。

- 从嵌套数组/对象中提取数据也是可以的，此时等号左侧必须和等号右侧有相同的结构。</code></pre>

      </fieldset>
      
      <fieldset id='_fpxAL7'>
      <legend>solution</legend>
      <p><code>new Date</code> 构造函数默认使用本地时区。所以唯一需要牢记的就是月份从 0 开始计数。</p>
<p>所以二月对应的数值是 1。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2012</span>, <span class="hljs-number">1</span>, <span class="hljs-number">20</span>, <span class="hljs-number">3</span>, <span class="hljs-number">12</span>);
alert( d );</code></pre>

      </fieldset>
      
      <fieldset id='_xoMleN'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="创建日期">创建日期</h1>
<p>创建一个 <code>Date</code> 对象，日期是：Feb 20, 2012, 3:12am。时区是当地时区。</p>
<p>使用 <code>alert</code> 显示结果。</p>

      </fieldset>
      
      <fieldset id='_6Vvi4K'>
      <legend>solution</legend>
      <p><code>date.getDay()</code> 方法返回从星期日开始的星期数。</p>
<p>我们创建一个关于星期的数组，这样我们就可以通过编号获取正确的日期名称：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getWeekDay</span>(<span class="hljs-params">date</span>) </span>{
  <span class="hljs-keyword">let</span> days = [<span class="hljs-string">&#x27;SU&#x27;</span>, <span class="hljs-string">&#x27;MO&#x27;</span>, <span class="hljs-string">&#x27;TU&#x27;</span>, <span class="hljs-string">&#x27;WE&#x27;</span>, <span class="hljs-string">&#x27;TH&#x27;</span>, <span class="hljs-string">&#x27;FR&#x27;</span>, <span class="hljs-string">&#x27;SA&#x27;</span>];

  <span class="hljs-keyword">return</span> days[date.getDay()];
}

<span class="hljs-keyword">let</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2014</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 3 Jan 2014</span>
alert( getWeekDay(date) ); <span class="hljs-comment">// FR</span></code></pre>

      </fieldset>
      
      <fieldset id='_QJYUhN'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="显示星期数">显示星期数</h1>
<p>编写一个函数 <code>getWeekDay(date)</code> 以短格式来显示一个日期的星期数：&#39;MO&#39;，&#39;TU&#39;，&#39;WE&#39;，&#39;TH&#39;，&#39;FR&#39;，&#39;SA&#39;，&#39;SU&#39;。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2012</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);  <span class="hljs-comment">// 3 Jan 2012</span>
alert( getWeekDay(date) );        <span class="hljs-comment">// 应该输出 &quot;TU&quot;</span></code></pre>

      </fieldset>
      
      <fieldset id='_bymX7j'>
      <legend>solution</legend>
      
      </fieldset>
      
      <fieldset id='_ZsbdG4'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="欧洲的星期表示方法">欧洲的星期表示方法</h1>
<p>欧洲国家的星期计算是从星期一（数字 1）开始的，然后是星期二（数字 2），直到星期日（数字 7）。编写一个函数 <code>getLocalDay(date)</code>，并返回日期的欧洲式星期数。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2012</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);  <span class="hljs-comment">// 3 Jan 2012</span>
alert( getLocalDay(date) );       <span class="hljs-comment">// 星期二，应该显示 2</span></code></pre>

      </fieldset>
      
      <fieldset id='_3444am'>
      <legend>solution</legend>
      <p>思路很简单：从 <code>date</code> 中减去给定的天数：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDateAgo</span>(<span class="hljs-params">date, days</span>) </span>{
  date.setDate(date.getDate() - days);
  <span class="hljs-keyword">return</span> date.getDate();
}</code></pre>
<p>……但是函数不能修改 <code>date</code>。这一点很重要，因为我们提供日期的外部代码不希望它被修改。</p>
<p>要实现这一点，我们可以复制这个日期，就像这样：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDateAgo</span>(<span class="hljs-params">date, days</span>) </span>{
  <span class="hljs-keyword">let</span> dateCopy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(date);

  dateCopy.setDate(date.getDate() - days);
  <span class="hljs-keyword">return</span> dateCopy.getDate();
}

<span class="hljs-keyword">let</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2015</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>);

alert( getDateAgo(date, <span class="hljs-number">1</span>) ); <span class="hljs-comment">// 1, (1 Jan 2015)</span>
alert( getDateAgo(date, <span class="hljs-number">2</span>) ); <span class="hljs-comment">// 31, (31 Dec 2014)</span>
alert( getDateAgo(date, <span class="hljs-number">365</span>) ); <span class="hljs-comment">// 2, (2 Jan 2014)</span></code></pre>

      </fieldset>
      
      <fieldset id='_4sv6UC'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="许多天之前是哪个月几号？">许多天之前是哪个月几号？</h1>
<p>写一个函数 <code>getDateAgo(date, days)</code>，返回特定日期 <code>date</code> 往前 <code>days</code> 天是哪个月的哪一天。</p>
<p>例如，假设今天是 20 号，那么 <code>getDateAgo(new Date(), 1)</code> 的结果应该是 19 号，<code>getDateAgo(new Date(), 2)</code> 的结果应该是 18 号。</p>
<p>跨月、年也应该是正确输出：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2015</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>);

alert( getDateAgo(date, <span class="hljs-number">1</span>) ); <span class="hljs-comment">// 1, (1 Jan 2015)</span>
alert( getDateAgo(date, <span class="hljs-number">2</span>) ); <span class="hljs-comment">// 31, (31 Dec 2014)</span>
alert( getDateAgo(date, <span class="hljs-number">365</span>) ); <span class="hljs-comment">// 2, (2 Jan 2014)</span></code></pre>
<p>P.S. 函数不应该修改给定的 <code>date</code> 值。</p>

      </fieldset>
      
      <fieldset id='_s84qXp'>
      <legend>solution</legend>
      <p>让我们使用下个月创建日期，但将零作为天数（day）传递：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLastDayOfMonth</span>(<span class="hljs-params">year, month</span>) </span>{
  <span class="hljs-keyword">let</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(year, month + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> date.getDate();
}

alert( getLastDayOfMonth(<span class="hljs-number">2012</span>, <span class="hljs-number">0</span>) ); <span class="hljs-comment">// 31</span>
alert( getLastDayOfMonth(<span class="hljs-number">2012</span>, <span class="hljs-number">1</span>) ); <span class="hljs-comment">// 29</span>
alert( getLastDayOfMonth(<span class="hljs-number">2013</span>, <span class="hljs-number">1</span>) ); <span class="hljs-comment">// 28</span></code></pre>
<p>通常，日期从 1 开始，但从技术上讲，我们可以传递任何数字，日期会自动进行调整。因此，当我们传递 0 时，它的意思是“一个月的第一天的前一天”，换句话说：“上个月的最后一天”。</p>

      </fieldset>
      
      <fieldset id='_mFzmM8'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="某月的最后一天？">某月的最后一天？</h1>
<p>写一个函数 <code>getLastDayOfMonth(year, month)</code> 返回 month 月的最后一天。有时候是 30，有时是 31，甚至在二月的时候会是 28/29。</p>
<p>参数：</p>
<ul>
<li><code>year</code> —— 四位数的年份，比如 2012。</li>
<li><code>month</code> —— 月份，从 0 到 11。</li>
</ul>
<p>举个例子，<code>getLastDayOfMonth(2012, 1) = 29</code>（闰年，二月）</p>

      </fieldset>
      
      <fieldset id='_84NVWm'>
      <legend>solution</legend>
      <p>为获取秒数，我们可以使用今天的日期和 00:00:00 这个时间创建一个日期，然后使用当前时间减去该时间。</p>
<p>不同之处在于，从今天之初开始算起的时间是以毫秒计算的，我们应该将其处以 1000，进而得到秒数：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSecondsToday</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();

  <span class="hljs-comment">// 使用当前的 day/month/year 创建一个对象</span>
  <span class="hljs-keyword">let</span> today = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(now.getFullYear(), now.getMonth(), now.getDate());

  <span class="hljs-keyword">let</span> diff = now - today; <span class="hljs-comment">// ms difference</span>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.round(diff / <span class="hljs-number">1000</span>); <span class="hljs-comment">// make seconds</span>
}

alert( getSecondsToday() );</code></pre>
<p>另一种解决方法是获取 hours/minutes/seconds，然后把它们转换为秒数：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSecondsToday</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
  <span class="hljs-keyword">return</span> d.getHours() * <span class="hljs-number">3600</span> + d.getMinutes() * <span class="hljs-number">60</span> + d.getSeconds();
};

alert( getSecondsToday() );</code></pre>

      </fieldset>
      
      <fieldset id='_TKAjIo'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="今天过去了多少秒？">今天过去了多少秒？</h1>
<p>写一个函数 <code>getSecondsToday()</code>，返回今天已经过去了多少秒？</p>
<p>例如：如果现在是 <code>10:00 am</code>，并且没有夏令时转换，那么：</p>
<pre><code class="language-js">getSecondsToday() == <span class="hljs-number">36000</span> <span class="hljs-comment">// (3600 * 10)</span></code></pre>
<p>该函数应该在任意一天都能正确运行。那意味着，它不应具有“今天”的硬编码值。</p>

      </fieldset>
      
      <fieldset id='_UgXS28'>
      <legend>solution</legend>
      <p>为获取距离明天的毫秒数，我们可以用“明天 00:00:00”这个日期减去当前的日期。</p>
<p>首先我们生成“明天”，然后对其进行减法操作：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSecondsToTomorrow</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();

  <span class="hljs-comment">// tomorrow date</span>
  <span class="hljs-keyword">let</span> tomorrow = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(now.getFullYear(), now.getMonth(), *!*now.getDate()+<span class="hljs-number">1</span>*/!*);

  <span class="hljs-keyword">let</span> diff = tomorrow - now; <span class="hljs-comment">// difference in ms</span>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.round(diff / <span class="hljs-number">1000</span>); <span class="hljs-comment">// convert to seconds</span>
}</code></pre>
<p>另一种解法：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSecondsToTomorrow</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
  <span class="hljs-keyword">let</span> hour = now.getHours();
  <span class="hljs-keyword">let</span> minutes = now.getMinutes();
  <span class="hljs-keyword">let</span> seconds = now.getSeconds();
  <span class="hljs-keyword">let</span> totalSecondsToday = (hour * <span class="hljs-number">60</span> + minutes) * <span class="hljs-number">60</span> + seconds;
  <span class="hljs-keyword">let</span> totalSecondsInADay = <span class="hljs-number">86400</span>;

  <span class="hljs-keyword">return</span> totalSecondsInADay - totalSecondsToday;
}</code></pre>
<p>请注意，很多国家有夏令时（DST），因此他们的一天可能有 23 小时或者 25 小时。我们对这些天数要区别对待。</p>

      </fieldset>
      
      <fieldset id='_IEEDoP'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="距离明天还有多少秒？">距离明天还有多少秒？</h1>
<p>写一个函数 <code>getSecondsToTomorrow()</code>，返回距离明天的秒数。</p>
<p>例如，现在是 <code>23:00</code>，那么：</p>
<pre><code class="language-js">getSecondsToTomorrow() == <span class="hljs-number">3600</span></code></pre>
<p>P.S. 该函数应该在任意一天都能正确运行。那意味着，它不应具有“今天”的硬编码值。</p>

      </fieldset>
      
      <fieldset id='_JiAZcC'>
      <legend>solution</legend>
      <p>为了获取 <code>date</code> 距离当前时间的间隔 —— 我们将两个日期相减。</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatDate</span>(<span class="hljs-params">date</span>) </span>{
  <span class="hljs-keyword">let</span> diff = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() - date; <span class="hljs-comment">// 以毫秒表示的差值</span>

  <span class="hljs-keyword">if</span> (diff &lt; <span class="hljs-number">1000</span>) { <span class="hljs-comment">// 少于 1 秒</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;right now&#x27;</span>;
  }

  <span class="hljs-keyword">let</span> sec = <span class="hljs-built_in">Math</span>.floor(diff / <span class="hljs-number">1000</span>); <span class="hljs-comment">// 将 diff 转换为秒</span>

  <span class="hljs-keyword">if</span> (sec &lt; <span class="hljs-number">60</span>) {
    <span class="hljs-keyword">return</span> sec + <span class="hljs-string">&#x27; sec. ago&#x27;</span>;
  }

  <span class="hljs-keyword">let</span> min = <span class="hljs-built_in">Math</span>.floor(diff / <span class="hljs-number">60000</span>); <span class="hljs-comment">// 将 diff 转换为分钟</span>
  <span class="hljs-keyword">if</span> (min &lt; <span class="hljs-number">60</span>) {
    <span class="hljs-keyword">return</span> min + <span class="hljs-string">&#x27; min. ago&#x27;</span>;
  }

  <span class="hljs-comment">// 格式化 date</span>
  <span class="hljs-comment">// 将前置 0 加到一位数 day/month/hours/minutes 前</span>
  <span class="hljs-keyword">let</span> d = date;
  d = [
    <span class="hljs-string">&#x27;0&#x27;</span> + d.getDate(),
    <span class="hljs-string">&#x27;0&#x27;</span> + (d.getMonth() + <span class="hljs-number">1</span>),
    <span class="hljs-string">&#x27;&#x27;</span> + d.getFullYear(),
    <span class="hljs-string">&#x27;0&#x27;</span> + d.getHours(),
    <span class="hljs-string">&#x27;0&#x27;</span> + d.getMinutes()
  ].map(<span class="hljs-function"><span class="hljs-params">component</span> =&gt;</span> component.slice(-<span class="hljs-number">2</span>)); <span class="hljs-comment">// 得到每个组件的后两位</span>

  <span class="hljs-comment">// 将时间信息和日期组合在一起</span>
 <span class="hljs-keyword">return</span> d.slice(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>).join(<span class="hljs-string">&#x27;.&#x27;</span>) + <span class="hljs-string">&#x27; &#x27;</span> + d.slice(<span class="hljs-number">3</span>).join(<span class="hljs-string">&#x27;:&#x27;</span>);
}

alert( formatDate(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span> - <span class="hljs-number">1</span>)) ); <span class="hljs-comment">// &quot;right now&quot;</span>

alert( formatDate(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span> - <span class="hljs-number">30</span> * <span class="hljs-number">1000</span>)) ); <span class="hljs-comment">// &quot;30 sec. ago&quot;</span>

alert( formatDate(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span> - <span class="hljs-number">5</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>)) ); <span class="hljs-comment">// &quot;5 min. ago&quot;</span>

<span class="hljs-comment">// 昨天的日期如：31.12.2016 20:00</span>
alert( formatDate(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span> - <span class="hljs-number">86400</span> * <span class="hljs-number">1000</span>)) );</code></pre>
<p>另一种解法：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatDate</span>(<span class="hljs-params">date</span>) </span>{
  <span class="hljs-keyword">let</span> dayOfMonth = date.getDate();
  <span class="hljs-keyword">let</span> month = date.getMonth() + <span class="hljs-number">1</span>;
  <span class="hljs-keyword">let</span> year = date.getFullYear();
  <span class="hljs-keyword">let</span> hour = date.getHours();
  <span class="hljs-keyword">let</span> minutes = date.getMinutes();
  <span class="hljs-keyword">let</span> diffMs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() - date;
  <span class="hljs-keyword">let</span> diffSec = <span class="hljs-built_in">Math</span>.round(diffMs / <span class="hljs-number">1000</span>);
  <span class="hljs-keyword">let</span> diffMin = diffSec / <span class="hljs-number">60</span>;
  <span class="hljs-keyword">let</span> diffHour = diffMin / <span class="hljs-number">60</span>;

  <span class="hljs-comment">// 格式化</span>
  year = year.toString().slice(-<span class="hljs-number">2</span>);
  month = month &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">&#x27;0&#x27;</span> + month : month;
  dayOfMonth = dayOfMonth &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">&#x27;0&#x27;</span> + dayOfMonth : dayOfMonth;
  hour = hour &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">&#x27;0&#x27;</span> + hour : hour;
  minutes = minutes &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">&#x27;0&#x27;</span> + minutes : minutes;

  <span class="hljs-keyword">if</span> (diffSec &lt; <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;right now&#x27;</span>;  
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (diffMin &lt; <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${diffSec}</span> sec. ago`</span>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (diffHour &lt; <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${diffMin}</span> min. ago`</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${dayOfMonth}</span>.<span class="hljs-subst">${month}</span>.<span class="hljs-subst">${year}</span> <span class="hljs-subst">${hour}</span>:<span class="hljs-subst">${minutes}</span>`</span>
  }
}</code></pre>

      </fieldset>
      
      <fieldset id='_KPIzAq'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="格式化相对日期">格式化相对日期</h1>
<p>写一个函数 <code>formatDate(date)</code>，能够对 <code>date</code> 进行如下格式化：</p>
<ul>
<li>如果 <code>date</code> 距离现在不到 1 秒，输出 <code>&quot;right now&quot;</code>。</li>
<li>否则，如果 <code>date</code> 距离现在不到 1 分钟，输出 <code>&quot;n sec. ago&quot;</code>。</li>
<li>否则，如果不到 1 小时，输出 <code>&quot;m min. ago&quot;</code>。</li>
<li>否则，以 <code>&quot;DD.MM.YY HH:mm&quot;</code> 格式输出完整日期。即：<code>&quot;day.month.year hours:minutes&quot;</code>，全部以两位数格式表示，例如：<code>31.12.16 10:00</code>。</li>
</ul>
<p>举个例子：</p>
<pre><code class="language-js">alert( formatDate(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span> - <span class="hljs-number">1</span>)) ); <span class="hljs-comment">// &quot;right now&quot;</span>

alert( formatDate(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span> - <span class="hljs-number">30</span> * <span class="hljs-number">1000</span>)) ); <span class="hljs-comment">// &quot;30 sec. ago&quot;</span>

alert( formatDate(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span> - <span class="hljs-number">5</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>)) ); <span class="hljs-comment">// &quot;5 min. ago&quot;</span>

<span class="hljs-comment">// 昨天的日期，例如 31.12.16 20:00</span>
alert( formatDate(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span> - <span class="hljs-number">86400</span> * <span class="hljs-number">1000</span>)) );</code></pre>

      </fieldset>
      
      <fieldset id='_Gz90Gh'>
      <legend>article</legend>
      <h1 id="日期和时间">日期和时间</h1>
<p>让我一起学习一个新的内建对象：<a href="mdn:js/Date">日期（Date）</a>。该对象存储日期和时间，并提供了日期/时间的管理方法。</p>
<p>例如，我们可以使用它来存储创建/修改时间，或者用来测量时间，再或者仅用来打印当前时间。</p>
<h2 id="创建">创建</h2>
<p>创建一个新的 <code>Date</code> 对象，只需要调用 <code>new Date()</code>，在调用时可以带有下面这些参数之一：</p>
<p><code>new Date()</code>
: 不带参数 —— 创建一个表示当前日期和时间的 <code>Date</code> 对象：</p>
<pre><code>```js run
let now = new Date();
alert( now ); // 显示当前的日期/时间
```</code></pre>
<p><code>new Date(milliseconds)</code>
: 创建一个 <code>Date</code> 对象，其时间等于 1970-01-01 00:00:00 UTC+0 再过一毫秒（1/1000 秒）。</p>
<pre><code>```js run
// 0 表示 01.01.1970 UTC+0
let Jan01_1970 = new Date(0);
alert( Jan01_1970 );

// 现在增加 24 小时，得到 02.01.1970 UTC+0
let Jan02_1970 = new Date(24 * 3600 * 1000);
alert( Jan02_1970 );
```

传入的整数参数代表的是自 1970-01-01 00:00:00 以来经过的毫秒数，该整数被称为 **时间戳**。

这是一种日期的轻量级数字表示形式。我们通常使用 `new Date(timestamp)` 通过时间戳来创建日期，并可以使用 `date.getTime()` 将现有的 `Date` 对象转化为时间戳（下文会讲到）。

在 01.01.1970 之前的日期带有负的时间戳，例如：
```js run
// 31 Dec 1969
let Dec31_1969 = new Date(-24 * 3600 * 1000);
alert( Dec31_1969 );
```</code></pre>
<p><code>new Date(datestring)</code>
: 如果只有一个参数，并且是字符串，那么它会被自动解析。该算法与 <code>Date.parse</code> 所使用的算法相同，我们将在下文中进行介绍。</p>
<pre><code>```js run
let date = new Date(&quot;2017-01-26&quot;);
alert(date);
// 该时间未被设定，因此被假定为格林尼治标准时间（GMT）的午夜（midnight）
// 并会根据你运行代码时的时区进行调整
// 因此，结果可能是
// Thu Jan 26 2017 11:00:00 GMT+1100 (Australian Eastern Daylight Time)
// 或
// Wed Jan 25 2017 16:00:00 GMT-0800 (Pacific Standard Time)
```</code></pre>
<p><code>new Date(year, month, date, hours, minutes, seconds, ms)</code>
: 使用当前时区中的给定组件创建日期。只有前两个参数是必须的。</p>
<pre><code>- `year` 必须是四位数：`2013` 是合法的，`98` 是不合法的。
- `month` 计数从 `0`（一月）开始，到 `11`（十二月）结束。
- `date` 是当月的具体某一天，如果缺失，则为默认值 `1`。
- 如果 `hours/minutes/seconds/ms` 缺失，则均为默认值 `0`。

例如：

```js
new Date(2011, 0, 1, 0, 0, 0, 0); // 1 Jan 2011, 00:00:00
new Date(2011, 0, 1); // 同样，时分秒等均为默认值 0
```

时间度量最小精确到 1 毫秒（1/1000 秒）：

```js run
let date = new Date(2011, 0, 1, 2, 3, 4, 567);
alert( date ); // 1.01.2011, 02:03:04.567
```</code></pre>
<h2 id="访问日期组件">访问日期组件</h2>
<p>从 <code>Date</code> 对象中访问年、月等信息有多种方式：</p>
<p><a href="mdn:js/Date/getFullYear">getFullYear()</a>
: 获取年份（4 位数）</p>
<p><a href="mdn:js/Date/getMonth">getMonth()</a>
: 获取月份，<strong>从 0 到 11</strong>。</p>
<p><a href="mdn:js/Date/getDate">getDate()</a>
: 获取当月的具体日期，从 1 到 31，这个方法名称可能看起来有些令人疑惑。</p>
<p><a href="mdn:js/Date/getHours">getHours()</a>，<a href="mdn:js/Date/getMinutes">getMinutes()</a>，<a href="mdn:js/Date/getSeconds">getSeconds()</a>，<a href="mdn:js/Date/getMilliseconds">getMilliseconds()</a>
: 获取相应的时间组件。</p>
<p>```warn header=&quot;不是 <code>getYear()</code>，而是 <code>getFullYear()</code>&quot;
很多 JavaScript 引擎都实现了一个非标准化的方法 <code>getYear()</code>。不推荐使用这个方法。它有时候可能会返回 2 位的年份信息。永远都不要使用它。要获取年份就使用 <code>getFullYear()</code>。</p>
<pre><code>
另外，我们还可以获取一周中的第几天：

[getDay()](mdn:js/Date/getDay)
: 获取一周中的第几天，从 `0`（星期日）到 `6`（星期六）。第一天始终是星期日，在某些国家可能不是这样的习惯，但是这不能被改变。

**以上的所有方法返回的组件都是基于当地时区的。**

当然，也有与当地时区的 UTC 对应项，它们会返回基于 UTC+0 时区的日、月、年等：[getUTCFullYear()](mdn:js/Date/getUTCFullYear)，[getUTCMonth()](mdn:js/Date/getUTCMonth)，[getUTCDay()](mdn:js/Date/getUTCDay)。只需要在 `&quot;get&quot;` 之后插入 `&quot;UTC&quot;` 即可。

如果你当地时区相对于 UTC 有偏移，那么下面代码会显示不同的小时数：

```js run
//  当前日期
let date = new Date();

// 当地时区的小时数
alert( date.getHours() );

// 在 UTC+0 时区的小时数（非夏令时的伦敦时间）
alert( date.getUTCHours() );</code></pre>
<p>除了上述给定的方法，还有两个没有 UTC 变体的特殊方法：</p>
<p><a href="mdn:js/Date/getTime">getTime()</a>
: 返回日期的时间戳 —— 从 1970-1-1 00:00:00 UTC+0 开始到现在所经过的毫秒数。</p>
<p><a href="mdn:js/Date/getTimezoneOffset">getTimezoneOffset()</a>
: 返回 UTC 与本地时区之间的时差，以分钟为单位：</p>
<pre><code>```js run
// 如果你在时区 UTC-1，输出 60
// 如果你在时区 UTC+3，输出 -180
alert( new Date().getTimezoneOffset() );

```</code></pre>
<h2 id="设置日期组件">设置日期组件</h2>
<p>下列方法可以设置日期/时间组件：</p>
<ul>
<li><a href="mdn:js/Date/setFullYear"><code>setFullYear(year, [month], [date])</code></a></li>
<li><a href="mdn:js/Date/setMonth"><code>setMonth(month, [date])</code></a></li>
<li><a href="mdn:js/Date/setDate"><code>setDate(date)</code></a></li>
<li><a href="mdn:js/Date/setHours"><code>setHours(hour, [min], [sec], [ms])</code></a></li>
<li><a href="mdn:js/Date/setMinutes"><code>setMinutes(min, [sec], [ms])</code></a></li>
<li><a href="mdn:js/Date/setSeconds"><code>setSeconds(sec, [ms])</code></a></li>
<li><a href="mdn:js/Date/setMilliseconds"><code>setMilliseconds(ms)</code></a></li>
<li><a href="mdn:js/Date/setTime"><code>setTime(milliseconds)</code></a>（使用自 1970-01-01 00:00:00 UTC+0 以来的毫秒数来设置整个日期）</li>
</ul>
<p>以上方法除了 <code>setTime()</code> 都有 UTC 变体，例如：<code>setUTCHours()</code>。</p>
<p>我们可以看到，有些方法可以一次性设置多个组件，比如 <code>setHours</code>。未提及的组件不会被修改。</p>
<p>举个例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> today = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();

today.setHours(<span class="hljs-number">0</span>);
alert(today); <span class="hljs-comment">// 日期依然是今天，但是小时数被改为了 0</span>

today.setHours(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
alert(today); <span class="hljs-comment">// 日期依然是今天，时间为 00:00:00。</span></code></pre>
<h2 id="自动校准（autocorrection）">自动校准（Autocorrection）</h2>
<p><strong>自动校准</strong> 是 <code>Date</code> 对象的一个非常方便的特性。我们可以设置超范围的数值，它会自动校准。</p>
<p>举个例子：</p>
<pre><code class="language-js">let date = new Date(2013, 0, *!*32*/!*); // 32 Jan 2013 ?!?
alert(date); // ……是 1st Feb 2013!</code></pre>
<p>超出范围的日期组件将会被自动分配。</p>
<p>假设我们要在日期 &quot;28 Feb 2016&quot; 上加 2 天。结果可能是 &quot;2 Mar&quot; 或 &quot;1 Mar&quot;，因为存在闰年。但是我们不需要去考虑这些，只需要直接加 2 天，剩下的 <code>Date</code> 对象会帮我们处理：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2016</span>, <span class="hljs-number">1</span>, <span class="hljs-number">28</span>);
*!*
date.setDate(date.getDate() + <span class="hljs-number">2</span>);
*/!*

alert( date ); <span class="hljs-comment">// 1 Mar 2016</span></code></pre>
<p>这个特性经常被用来获取给定时间段后的日期。例如，我们想获取“现在 70 秒后”的日期：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
date.setSeconds(date.getSeconds() + <span class="hljs-number">70</span>);

alert( date ); <span class="hljs-comment">// 显示正确的日期信息</span></code></pre>
<p>我们还可以设置 0 甚至可以设置负值。例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2016</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 2016 年 1 月 2 日</span>

date.setDate(<span class="hljs-number">1</span>); <span class="hljs-comment">// 设置为当月的第一天</span>
alert( date );

date.setDate(<span class="hljs-number">0</span>); <span class="hljs-comment">// 天数最小可以设置为 1，所以这里设置的是上一月的最后一天</span>
alert( date ); <span class="hljs-comment">// 31 Dec 2015</span></code></pre>
<h2 id="日期转化为数字，日期差值">日期转化为数字，日期差值</h2>
<p>当 <code>Date</code> 对象被转化为数字时，得到的是对应的时间戳，与使用 <code>date.getTime()</code> 的结果相同：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
alert(+date); <span class="hljs-comment">// 以毫秒为单位的数值，与使用 date.getTime() 的结果相同</span></code></pre>
<p>有一个重要的副作用：日期可以相减，相减的结果是以毫秒为单位时间差。</p>
<p>这个作用可以用于时间测量：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> start = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(); <span class="hljs-comment">// 开始测量时间</span>

<span class="hljs-comment">// do the job</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) {
  <span class="hljs-keyword">let</span> doSomething = i * i * i;
}

<span class="hljs-keyword">let</span> end = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(); <span class="hljs-comment">// 结束测量时间</span>

alert( <span class="hljs-string">`The loop took <span class="hljs-subst">${end - start}</span> ms`</span> );</code></pre>
<h2 id="datenow">Date.now()</h2>
<p>如果我们仅仅想要测量时间间隔，我们不需要 <code>Date</code> 对象。</p>
<p>有一个特殊的方法 <code>Date.now()</code>，它会返回当前的时间戳。</p>
<p>它相当于 <code>new Date().getTime()</code>，但它不会创建中间的 <code>Date</code> 对象。因此它更快，而且不会对垃圾处理造成额外的压力。</p>
<p>这种方法很多时候因为方便，又或是因性能方面的考虑而被采用，例如使用 JavaScript 编写游戏或其他的特殊应用场景。</p>
<p>因此这样做可能会更好：</p>
<pre><code class="language-js">*!*
<span class="hljs-keyword">let</span> start = <span class="hljs-built_in">Date</span>.now(); <span class="hljs-comment">// 从 1 Jan 1970 至今的时间戳</span>
*/!*

<span class="hljs-comment">// do the job</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) {
  <span class="hljs-keyword">let</span> doSomething = i * i * i;
}

*!*
<span class="hljs-keyword">let</span> end = <span class="hljs-built_in">Date</span>.now(); <span class="hljs-comment">// 完成</span>
*/!*

alert( <span class="hljs-string">`The loop took <span class="hljs-subst">${end - start}</span> ms`</span> ); <span class="hljs-comment">// 相减的是时间戳，而不是日期</span></code></pre>
<h2 id="度量（benchmarking）">度量（Benchmarking）</h2>
<p>如果我们想要为一个很耗 CPU 性能的函数提供一个可靠的度量（benchmark），我们应该小心一点。</p>
<p>例如，我们想判断两个计算日期差值的函数：哪个更快？</p>
<p>这种性能测量通常称为“度量（benchmark）”。</p>
<pre><code class="language-js"><span class="hljs-comment">// 我们有 date1 和 date2，哪个函数会更快地返回两者的时间差？</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">diffSubtract</span>(<span class="hljs-params">date1, date2</span>) </span>{
  <span class="hljs-keyword">return</span> date2 - date1;
}

<span class="hljs-comment">// or</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">diffGetTime</span>(<span class="hljs-params">date1, date2</span>) </span>{
  <span class="hljs-keyword">return</span> date2.getTime() - date1.getTime();
}</code></pre>
<p>这两个函数做的事情完全相同，但是其中一个函数使用显性的 <code>date.getTime()</code> 来获取毫秒形式的日期，另一个则依赖于“日期 — 数字”的转换。它们的结果是一样的。</p>
<p>那么，哪个更快呢？</p>
<p>首先想到的方法可能是连续运行它们很多次，并计算时间差。就我们的例子而言，函数非常简单，所以我们必须执行至少 100000 次。</p>
<p>让我们开始测量：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">diffSubtract</span>(<span class="hljs-params">date1, date2</span>) </span>{
  <span class="hljs-keyword">return</span> date2 - date1;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">diffGetTime</span>(<span class="hljs-params">date1, date2</span>) </span>{
  <span class="hljs-keyword">return</span> date2.getTime() - date1.getTime();
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bench</span>(<span class="hljs-params">f</span>) </span>{
  <span class="hljs-keyword">let</span> date1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">let</span> date2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();

  <span class="hljs-keyword">let</span> start = <span class="hljs-built_in">Date</span>.now();
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) f(date1, date2);
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Date</span>.now() - start;
}

alert( <span class="hljs-string">&#x27;Time of diffSubtract: &#x27;</span> + bench(diffSubtract) + <span class="hljs-string">&#x27;ms&#x27;</span> );
alert( <span class="hljs-string">&#x27;Time of diffGetTime: &#x27;</span> + bench(diffGetTime) + <span class="hljs-string">&#x27;ms&#x27;</span> );</code></pre>
<p>哇！使用 <code>getTime()</code> 这种方式快得多！原因是它没有类型转化，这样对引擎优化来说更加简单。</p>
<p>好，我们得到了结论，但是这并不是一个很好的度量的例子。</p>
<p>想象一下当运行 <code>bench(diffSubtract)</code> 的同时，CPU 还在并行处理其他事务，并且这也会占用资源。然而，运行 <code>bench(diffGetTime)</code> 的时候，并行处理的事务完成了。</p>
<p>这是对于现代多进程操作系统来说的一个非常真实的场景。</p>
<p>结果就是，第一个函数相比于第二个函数，缺少 CPU 资源。这可能导致错误的结论。</p>
<p><strong>为了得到更加可靠的度量，整个度量测试包应该重新运行多次。</strong></p>
<p>例如，像下面的代码这样：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">diffSubtract</span>(<span class="hljs-params">date1, date2</span>) </span>{
  <span class="hljs-keyword">return</span> date2 - date1;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">diffGetTime</span>(<span class="hljs-params">date1, date2</span>) </span>{
  <span class="hljs-keyword">return</span> date2.getTime() - date1.getTime();
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bench</span>(<span class="hljs-params">f</span>) </span>{
  <span class="hljs-keyword">let</span> date1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">let</span> date2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();

  <span class="hljs-keyword">let</span> start = <span class="hljs-built_in">Date</span>.now();
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) f(date1, date2);
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Date</span>.now() - start;
}

<span class="hljs-keyword">let</span> time1 = <span class="hljs-number">0</span>;
<span class="hljs-keyword">let</span> time2 = <span class="hljs-number">0</span>;

*!*
<span class="hljs-comment">// 交替运行 bench(upperSlice) 和 bench(upperLoop) 各 10 次</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}
*/!*

alert( <span class="hljs-string">&#x27;Total time for diffSubtract: &#x27;</span> + time1 );
alert( <span class="hljs-string">&#x27;Total time for diffGetTime: &#x27;</span> + time2 );</code></pre>
<p>现代的 JavaScript 引擎的先进优化策略只对执行很多次的 &quot;hot code&quot; 有效（对于执行很少次数的代码没有必要优化）。因此，在上面的例子中，第一次执行的优化程度不高。我们可能需要增加一个升温步骤：</p>
<pre><code class="language-js"><span class="hljs-comment">// 在主循环中增加“升温”环节</span>
bench(diffSubtract);
bench(diffGetTime);

<span class="hljs-comment">// 开始度量</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}</code></pre>
<pre><code class="language-warn">现代的 JavaScript 引擎执行了很多优化。与“正常使用”相比，它们可能会改变“人为测试”的结果，特别是在我们对很细微的东西进行度量测试时，例如 operator 的工作方式或内建函数。因此，如果你想好好了解一下性能，请学习 JavaScript 引擎的工作原理。在那之后，你可能再也不需要微度量了。

关于 V8 引擎的大量文章，可以在 &lt;http://mrale.ph&gt; 找到。</code></pre>
<h2 id="对一个字符串使用-dateparse">对一个字符串使用 Date.parse</h2>
<p><a href="mdn:js/Date/parse">Date.parse(str)</a> 方法可以从一个字符串中读取日期。</p>
<p>字符串的格式应该为：<code>YYYY-MM-DDTHH:mm:ss.sssZ</code>，其中：</p>
<ul>
<li><code>YYYY-MM-DD</code> —— 日期：年-月-日。</li>
<li>字符 <code>&quot;T&quot;</code> 是一个分隔符。</li>
<li><code>HH:mm:ss.sss</code> —— 时间：小时，分钟，秒，毫秒。</li>
<li>可选字符 <code>&#39;Z&#39;</code> 为 <code>+-hh:mm</code> 格式的时区。单个字符 <code>Z</code> 代表 UTC+0 时区。</li>
</ul>
<p>简短形式也是可以的，比如 <code>YYYY-MM-DD</code> 或 <code>YYYY-MM</code>，甚至可以是 <code>YYYY</code>。</p>
<p><code>Date.parse(str)</code> 调用会解析给定格式的字符串，并返回时间戳（自 1970-01-01 00:00:00 起所经过的毫秒数）。如果给定字符串的格式不正确，则返回 <code>NaN</code>。</p>
<p>举个例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> ms = <span class="hljs-built_in">Date</span>.parse(<span class="hljs-string">&#x27;2012-01-26T13:51:50.417-07:00&#x27;</span>);

alert(ms); <span class="hljs-comment">// 1327611110417  (时间戳)</span></code></pre>
<p>我们可以通过时间戳来立即创建一个 <code>new Date</code> 对象：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>( <span class="hljs-built_in">Date</span>.parse(<span class="hljs-string">&#x27;2012-01-26T13:51:50.417-07:00&#x27;</span>) );

alert(date);  </code></pre>
<h2 id="总结">总结</h2>
<ul>
<li>在 JavaScript 中，日期和时间使用 <a href="mdn:js/Date">Date</a> 对象来表示。我们不能只创建日期，或者只创建时间，<code>Date</code> 对象总是同时创建两者。</li>
<li>月份从 0 开始计数（对，一月是 0）。</li>
<li>一周中的某一天 <code>getDay()</code> 同样从 0 开始计算（0 代表星期日）。</li>
<li>当设置了超出范围的组件时，<code>Date</code> 会进行自我校准。这一点对于日/月/小时的加减很有用。</li>
<li>日期可以相减，得到的是以毫秒表示的两者的差值。因为当 <code>Date</code> 被转换为数字时，<code>Date</code> 对象会被转换为时间戳。</li>
<li>使用 <code>Date.now()</code> 可以更快地获取当前时间的时间戳。</li>
</ul>
<p>和其他系统不同，JavaScript 中时间戳以毫秒为单位，而不是秒。</p>
<p>有时我们需要更加精准的时间度量。JavaScript 自身并没有测量微秒的方法（百万分之一秒），但大多数运行环境会提供。例如：浏览器有 <a href="mdn:api/Performance/now">performance.now()</a> 方法来给出从页面加载开始的以毫秒为单位的微秒数（精确到毫秒的小数点后三位）：</p>
<pre><code class="language-js">alert(<span class="hljs-string">`Loading started <span class="hljs-subst">${performance.now()}</span>ms ago`</span>);
<span class="hljs-comment">// 类似于 &quot;Loading started 34731.26000000001ms ago&quot;</span>
<span class="hljs-comment">// .26 表示的是微秒（260 微秒）</span>
<span class="hljs-comment">// 小数点后超过 3 位的数字是精度错误，只有前三位数字是正确的</span></code></pre>
<p>Node.js 有 <code>microtime</code> 模块以及其他方法。从技术上讲，几乎所有的设备和环境都允许获取更高精度的数值，只是不是通过 <code>Date</code> 对象。</p>

      </fieldset>
      
      <fieldset id='_VQOJoS'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John Smith&quot;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">35</span>
};

*!*
<span class="hljs-keyword">let</span> user2 = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(user));
*/!*</code></pre>

      </fieldset>
      
      <fieldset id='_YnNAAY'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="将对象转换为-json，然后再转换回来">将对象转换为 JSON，然后再转换回来</h1>
<p>将 <code>user</code> 转换为 JSON，然后将其转换回到另一个变量。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John Smith&quot;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">35</span>
};</code></pre>

      </fieldset>
      
      <fieldset id='_TgTM5G'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-keyword">let</span> room = {
  <span class="hljs-attr">number</span>: <span class="hljs-number">23</span>
};

<span class="hljs-keyword">let</span> meetup = {
  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Conference&quot;</span>,
  <span class="hljs-attr">occupiedBy</span>: [{<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>}, {<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>}],
  <span class="hljs-attr">place</span>: room
};

room.occupiedBy = meetup;
meetup.self = meetup;

alert( <span class="hljs-built_in">JSON</span>.stringify(meetup, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replacer</span>(<span class="hljs-params">key, value</span>) </span>{
  <span class="hljs-keyword">return</span> (key != <span class="hljs-string">&quot;&quot;</span> &amp;&amp; value == meetup) ? <span class="hljs-literal">undefined</span> : value;
}));

<span class="hljs-comment">/* 
{
  &quot;title&quot;:&quot;Conference&quot;,
  &quot;occupiedBy&quot;:[{&quot;name&quot;:&quot;John&quot;},{&quot;name&quot;:&quot;Alice&quot;}],
  &quot;place&quot;:{&quot;number&quot;:23}
}
*/</span></code></pre>
<p>这里我们还需要判断 <code>key==&quot;&quot;</code> 以排除第一个调用时 <code>value</code> 是 <code>meetup</code> 的情况。</p>

      </fieldset>
      
      <fieldset id='_ue0Jg1'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="排除反向引用">排除反向引用</h1>
<p>在简单循环引用的情况下，我们可以通过名称排除序列化中违规的属性。</p>
<p>但是，有时我们不能只使用名称，因为它既可能在循环引用中也可能在常规属性中使用。因此，我们可以通过属性值来检查属性。</p>
<p>编写 <code>replacer</code> 函数，移除引用 <code>meetup</code> 的属性，并将其他所有属性序列化：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> room = {
  <span class="hljs-attr">number</span>: <span class="hljs-number">23</span>
};

<span class="hljs-keyword">let</span> meetup = {
  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Conference&quot;</span>,
  <span class="hljs-attr">occupiedBy</span>: [{<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>}, {<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>}],
  <span class="hljs-attr">place</span>: room
};

*!*
<span class="hljs-comment">// 循环引用</span>
room.occupiedBy = meetup;
meetup.self = meetup;
*/!*

alert( <span class="hljs-built_in">JSON</span>.stringify(meetup, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replacer</span>(<span class="hljs-params">key, value</span>) </span>{
  <span class="hljs-comment">/* your code */</span>
}));

<span class="hljs-comment">/* 结果应该是：
{
  &quot;title&quot;:&quot;Conference&quot;,
  &quot;occupiedBy&quot;:[{&quot;name&quot;:&quot;John&quot;},{&quot;name&quot;:&quot;Alice&quot;}],
  &quot;place&quot;:{&quot;number&quot;:23}
}
*/</span></code></pre>

      </fieldset>
      
      <fieldset id='_bTlFGE'>
      <legend>article</legend>
      <h1 id="json-方法，tojson">JSON 方法，toJSON</h1>
<p>假设我们有一个复杂的对象，我们希望将其转换为字符串，以通过网络发送，或者只是为了在日志中输出它。</p>
<p>当然，这样的字符串应该包含所有重要的属性。</p>
<p>我们可以像这样实现转换：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,

*!*
  <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`{name: &quot;<span class="hljs-subst">${<span class="hljs-built_in">this</span>.name}</span>&quot;, age: <span class="hljs-subst">${<span class="hljs-built_in">this</span>.age}</span>}`</span>;
  }
*/!*
};

alert(user); <span class="hljs-comment">// {name: &quot;John&quot;, age: 30}</span></code></pre>
<p>……但在开发过程中，会新增一些属性，旧的属性会被重命名和删除。每次更新这种 <code>toString</code> 都会非常痛苦。我们可以尝试遍历其中的属性，但是如果对象很复杂，并且在属性中嵌套了对象呢？我们也需要对它们进行转换。</p>
<p>幸运的是，不需要编写代码来处理所有这些问题。这项任务已经解决了。</p>
<h2 id="jsonstringify">JSON.stringify</h2>
<p><a href="http://en.wikipedia.org/wiki/JSON">JSON</a>（JavaScript Object Notation）是表示值和对象的通用格式。在 <a href="http://tools.ietf.org/html/rfc4627">RFC 4627</a> 标准中有对其的描述。最初它是为 JavaScript 而创建的，但许多其他编程语言也有用于处理它的库。因此，当客户端使用 JavaScript 而服务器端是使用 Ruby/PHP/Java 等语言编写的时，使用 JSON 可以很容易地进行数据交换。</p>
<p>JavaScript 提供了如下方法：</p>
<ul>
<li><code>JSON.stringify</code> 将对象转换为 JSON。</li>
<li><code>JSON.parse</code> 将 JSON 转换回对象。</li>
</ul>
<p>例如，在这里我们 <code>JSON.stringify</code> 一个 <code>student</code> 对象：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> student = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,
  <span class="hljs-attr">isAdmin</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">courses</span>: [<span class="hljs-string">&#x27;html&#x27;</span>, <span class="hljs-string">&#x27;css&#x27;</span>, <span class="hljs-string">&#x27;js&#x27;</span>],
  <span class="hljs-attr">wife</span>: <span class="hljs-literal">null</span>
};

*!*
<span class="hljs-keyword">let</span> json = <span class="hljs-built_in">JSON</span>.stringify(student);
*/!*

alert(<span class="hljs-keyword">typeof</span> json); <span class="hljs-comment">// we&#x27;ve got a string!</span>

alert(json);
*!*
<span class="hljs-comment">/* JSON 编码的对象：
{
  &quot;name&quot;: &quot;John&quot;,
  &quot;age&quot;: 30,
  &quot;isAdmin&quot;: false,
  &quot;courses&quot;: [&quot;html&quot;, &quot;css&quot;, &quot;js&quot;],
  &quot;wife&quot;: null
}
*/</span>
*/!*</code></pre>
<p>方法 <code>JSON.stringify(student)</code> 接收对象并将其转换为字符串。</p>
<p>得到的 <code>json</code> 字符串是一个被称为 <strong>JSON 编码（JSON-encoded）</strong> 或 <strong>序列化（serialized）</strong> 或 <strong>字符串化（stringified）</strong> 或 <strong>编组化（marshalled）</strong> 的对象。我们现在已经准备好通过有线发送它或将其放入普通数据存储。</p>
<p>请注意，JSON 编码的对象与对象字面量有几个重要的区别：</p>
<ul>
<li>字符串使用双引号。JSON 中没有单引号或反引号。所以 <code>&#39;John&#39;</code> 被转换为 <code>&quot;John&quot;</code>。</li>
<li>对象属性名称也是双引号的。这是强制性的。所以 <code>age:30</code> 被转换成 <code>&quot;age&quot;:30</code>。</li>
</ul>
<p><code>JSON.stringify</code> 也可以应用于原始（primitive）数据类型。</p>
<p>JSON 支持以下数据类型：</p>
<ul>
<li>Objects <code>{ ... }</code></li>
<li>Arrays <code>[ ... ]</code></li>
<li>Primitives：<ul>
<li>strings，</li>
<li>numbers，</li>
<li>boolean values <code>true/false</code>，</li>
<li><code>null</code>。</li>
</ul>
</li>
</ul>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-comment">// 数字在 JSON 还是数字</span>
alert( <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-number">1</span>) ) <span class="hljs-comment">// 1</span>

<span class="hljs-comment">// 字符串在 JSON 中还是字符串，只是被双引号扩起来</span>
alert( <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-string">&#x27;test&#x27;</span>) ) <span class="hljs-comment">// &quot;test&quot;</span>

alert( <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-literal">true</span>) ); <span class="hljs-comment">// true</span>

alert( <span class="hljs-built_in">JSON</span>.stringify([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) ); <span class="hljs-comment">// [1,2,3]</span></code></pre>
<p>JSON 是语言无关的纯数据规范，因此一些特定于 JavaScript 的对象属性会被 <code>JSON.stringify</code> 跳过。</p>
<p>即：</p>
<ul>
<li>函数属性（方法）。</li>
<li>Symbol 类型的属性。</li>
<li>存储 <code>undefined</code> 的属性。</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-comment">// 被忽略</span>
    alert(<span class="hljs-string">&quot;Hello&quot;</span>);
  },
  [<span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>)]: <span class="hljs-number">123</span>, <span class="hljs-comment">// 被忽略</span>
  <span class="hljs-attr">something</span>: <span class="hljs-literal">undefined</span> <span class="hljs-comment">// 被忽略</span>
};

alert( <span class="hljs-built_in">JSON</span>.stringify(user) ); <span class="hljs-comment">// {}（空对象）</span></code></pre>
<p>通常这很好。如果这不是我们想要的方式，那么我们很快就会看到如何自定义转换方式。</p>
<p>最棒的是支持嵌套对象转换，并且可以自动对其进行转换。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> meetup = {
  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Conference&quot;</span>,
*!*
  room: {
    <span class="hljs-attr">number</span>: <span class="hljs-number">23</span>,
    <span class="hljs-attr">participants</span>: [<span class="hljs-string">&quot;john&quot;</span>, <span class="hljs-string">&quot;ann&quot;</span>]
  }
*/!*
};

alert( <span class="hljs-built_in">JSON</span>.stringify(meetup) );
<span class="hljs-comment">/* 整个解构都被字符串化了
{
  &quot;title&quot;:&quot;Conference&quot;,
  &quot;room&quot;:{&quot;number&quot;:23,&quot;participants&quot;:[&quot;john&quot;,&quot;ann&quot;]},
}
*/</span></code></pre>
<p>重要的限制：不得有循环引用。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> room = {
  <span class="hljs-attr">number</span>: <span class="hljs-number">23</span>
};

<span class="hljs-keyword">let</span> meetup = {
  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Conference&quot;</span>,
  <span class="hljs-attr">participants</span>: [<span class="hljs-string">&quot;john&quot;</span>, <span class="hljs-string">&quot;ann&quot;</span>]
};

meetup.place = room;       <span class="hljs-comment">// meetup 引用了 room</span>
room.occupiedBy = meetup; <span class="hljs-comment">// room 引用了 meetup</span>

*!*
<span class="hljs-built_in">JSON</span>.stringify(meetup); <span class="hljs-comment">// Error: Converting circular structure to JSON</span>
*/!*</code></pre>
<p>在这里，转换失败了，因为循环引用：<code>room.occupiedBy</code> 引用了 <code>meetup</code>，<code>meetup.place</code> 引用了 <code>room</code>：</p>
<p><img src="json-meetup.svg" alt=""></p>
<h2 id="排除和转换：replacer">排除和转换：replacer</h2>
<p><code>JSON.stringify</code> 的完整语法是：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> json = <span class="hljs-built_in">JSON</span>.stringify(value[, replacer, space])</code></pre>
<p>value
: 要编码的值。</p>
<p>replacer
: 要编码的属性数组或映射函数 <code>function(key, value)</code>。</p>
<p>space
: 用于格式化的空格数量</p>
<p>大部分情况，<code>JSON.stringify</code> 仅与第一个参数一起使用。但是，如果我们需要微调替换过程，比如过滤掉循环引用，我们可以使用 <code>JSON.stringify</code> 的第二个参数。</p>
<p>如果我们传递一个属性数组给它，那么只有这些属性会被编码。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> room = {
  <span class="hljs-attr">number</span>: <span class="hljs-number">23</span>
};

<span class="hljs-keyword">let</span> meetup = {
  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Conference&quot;</span>,
  <span class="hljs-attr">participants</span>: [{<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>}, {<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>}],
  <span class="hljs-attr">place</span>: room <span class="hljs-comment">// meetup 引用了 room</span>
};

room.occupiedBy = meetup; <span class="hljs-comment">// room 引用了 meetup</span>

alert( <span class="hljs-built_in">JSON</span>.stringify(meetup, *!*[<span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;participants&#x27;</span>]*/!*) );
<span class="hljs-comment">// {&quot;title&quot;:&quot;Conference&quot;,&quot;participants&quot;:[{},{}]}</span></code></pre>
<p>这里我们可能过于严格了。属性列表应用于了整个对象结构。所以 <code>participants</code> 是空的，因为 <code>name</code> 不在列表中。</p>
<p>让我们包含除了会导致循环引用的 <code>room.occupiedBy</code> 之外的所有属性：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> room = {
  <span class="hljs-attr">number</span>: <span class="hljs-number">23</span>
};

<span class="hljs-keyword">let</span> meetup = {
  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Conference&quot;</span>,
  <span class="hljs-attr">participants</span>: [{<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>}, {<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>}],
  <span class="hljs-attr">place</span>: room <span class="hljs-comment">// meetup 引用了 room</span>
};

room.occupiedBy = meetup; <span class="hljs-comment">// room 引用了 meetup</span>

alert( <span class="hljs-built_in">JSON</span>.stringify(meetup, *!*[<span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;participants&#x27;</span>, <span class="hljs-string">&#x27;place&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;number&#x27;</span>]*/!*) );
<span class="hljs-comment">/*
{
  &quot;title&quot;:&quot;Conference&quot;,
  &quot;participants&quot;:[{&quot;name&quot;:&quot;John&quot;},{&quot;name&quot;:&quot;Alice&quot;}],
  &quot;place&quot;:{&quot;number&quot;:23}
}
*/</span></code></pre>
<p>现在，除 <code>occupiedBy</code> 以外的所有内容都被序列化了。但是属性的列表太长了。</p>
<p>幸运的是，我们可以使用一个函数代替数组作为 <code>replacer</code>。</p>
<p>该函数会为每个 <code>(key,value)</code> 对调用并返回“已替换”的值，该值将替换原有的值。如果值被跳过了，则为 <code>undefined</code>。</p>
<p>在我们的例子中，我们可以为 <code>occupiedBy</code> 以外的所有内容按原样返回 <code>value</code>。为了 <code>occupiedBy</code>，下面的代码返回 <code>undefined</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> room = {
  <span class="hljs-attr">number</span>: <span class="hljs-number">23</span>
};

<span class="hljs-keyword">let</span> meetup = {
  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Conference&quot;</span>,
  <span class="hljs-attr">participants</span>: [{<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>}, {<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>}],
  <span class="hljs-attr">place</span>: room <span class="hljs-comment">// meetup 引用了 room</span>
};

room.occupiedBy = meetup; <span class="hljs-comment">// room 引用了 meetup</span>

alert( <span class="hljs-built_in">JSON</span>.stringify(meetup, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replacer</span>(<span class="hljs-params">key, value</span>) </span>{
  alert(<span class="hljs-string">`<span class="hljs-subst">${key}</span>: <span class="hljs-subst">${value}</span>`</span>);
  <span class="hljs-keyword">return</span> (key == <span class="hljs-string">&#x27;occupiedBy&#x27;</span>) ? <span class="hljs-literal">undefined</span> : value;
}));

<span class="hljs-comment">/* key:value pairs that come to replacer:
:             [object Object]
title:        Conference
participants: [object Object],[object Object]
0:            [object Object]
name:         John
1:            [object Object]
name:         Alice
place:        [object Object]
number:       23
*/</span></code></pre>
<p>请注意 <code>replacer</code> 函数会获取每个键/值对，包括嵌套对象和数组项。它被递归地应用。<code>replacer</code> 中的 <code>this</code> 的值是包含当前属性的对象。</p>
<p>第一个调用很特别。它是使用特殊的“包装对象”制作的：<code>{&quot;&quot;: meetup}</code>。换句话说，第一个 <code>(key, value)</code> 对的键是空的，并且该值是整个目标对象。这就是上面的示例中第一行是 <code>&quot;:[object Object]&quot;</code> 的原因。</p>
<p>这个理念是为了给 <code>replacer</code> 提供尽可能多的功能：如果有必要，它有机会分析并替换/跳过整个对象。</p>
<h2 id="格式化：space">格式化：space</h2>
<p><code>JSON.stringify(value, replacer, spaces)</code> 的第三个参数是用于优化格式的空格数量。</p>
<p>以前，所有字符串化的对象都没有缩进和额外的空格。如果我们想通过网络发送一个对象，那就没什么问题。<code>space</code> 参数专门用于调整出更美观的输出。</p>
<p>这里的 <code>space = 2</code> 告诉 JavaScript 在多行中显示嵌套的对象，对象内部缩紧 2 个空格：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>,
  <span class="hljs-attr">roles</span>: {
    <span class="hljs-attr">isAdmin</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">isEditor</span>: <span class="hljs-literal">true</span>
  }
};

alert(<span class="hljs-built_in">JSON</span>.stringify(user, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>));
<span class="hljs-comment">/* 两个空格的缩进：
{
  &quot;name&quot;: &quot;John&quot;,
  &quot;age&quot;: 25,
  &quot;roles&quot;: {
    &quot;isAdmin&quot;: false,
    &quot;isEditor&quot;: true
  }
}
*/</span>

<span class="hljs-comment">/* 对于 JSON.stringify(user, null, 4) 的结果会有更多缩进：
{
    &quot;name&quot;: &quot;John&quot;,
    &quot;age&quot;: 25,
    &quot;roles&quot;: {
        &quot;isAdmin&quot;: false,
        &quot;isEditor&quot;: true
    }
}
*/</span></code></pre>
<p><code>spaces</code> 参数仅用于日志记录和美化输出。</p>
<h2 id="自定义-tojson">自定义 &quot;toJSON&quot;</h2>
<p>像 <code>toString</code> 进行字符串转换，对象也可以提供 <code>toJSON</code> 方法来进行 JSON 转换。如果可用，<code>JSON.stringify</code> 会自动调用它。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> room = {
  <span class="hljs-attr">number</span>: <span class="hljs-number">23</span>
};

<span class="hljs-keyword">let</span> meetup = {
  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Conference&quot;</span>,
  <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-built_in">Date</span>.UTC(<span class="hljs-number">2017</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)),
  room
};

alert( <span class="hljs-built_in">JSON</span>.stringify(meetup) );
<span class="hljs-comment">/*
  {
    &quot;title&quot;:&quot;Conference&quot;,
*!*
    &quot;date&quot;:&quot;2017-01-01T00:00:00.000Z&quot;,  // (1)
*/</span>!*
    <span class="hljs-string">&quot;room&quot;</span>: {<span class="hljs-string">&quot;number&quot;</span>:<span class="hljs-number">23</span>}               <span class="hljs-comment">// (2)</span>
  }
*/</code></pre>
<p>在这儿我们可以看到 <code>date</code> <code>(1)</code> 变成了一个字符串。这是因为所有日期都有一个内置的 <code>toJSON</code> 方法来返回这种类型的字符串。</p>
<p>现在让我们为对象 <code>room</code> 添加一个自定义的 <code>toJSON</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> room = {
  <span class="hljs-attr">number</span>: <span class="hljs-number">23</span>,
*!*
  <span class="hljs-function"><span class="hljs-title">toJSON</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.number;
  }
*/!*
};

<span class="hljs-keyword">let</span> meetup = {
  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Conference&quot;</span>,
  room
};

*!*
alert( <span class="hljs-built_in">JSON</span>.stringify(room) ); <span class="hljs-comment">// 23</span>
*/!*

alert( <span class="hljs-built_in">JSON</span>.stringify(meetup) );
<span class="hljs-comment">/*
  {
    &quot;title&quot;:&quot;Conference&quot;,
*!*
    &quot;room&quot;: 23
*/</span>!*
  }
*/</code></pre>
<p>正如我们所看到的，<code>toJSON</code> 既可以用于直接调用 <code>JSON.stringify(room)</code> 也可以用于当 <code>room</code> 嵌套在另一个编码对象中时。</p>
<h2 id="jsonparse">JSON.parse</h2>
<p>要解码 JSON 字符串，我们需要另一个方法 <a href="mdn:js/JSON/parse">JSON.parse</a>。</p>
<p>语法：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> value = <span class="hljs-built_in">JSON</span>.parse(str, [reviver]);</code></pre>
<p>str
: 要解析的 JSON 字符串。</p>
<p>reviver
: 可选的函数 function(key,value)，该函数将为每个 <code>(key, value)</code> 对调用，并可以对值进行转换。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-comment">// 字符串化数组</span>
<span class="hljs-keyword">let</span> numbers = <span class="hljs-string">&quot;[0, 1, 2, 3]&quot;</span>;

numbers = <span class="hljs-built_in">JSON</span>.parse(numbers);

alert( numbers[<span class="hljs-number">1</span>] ); <span class="hljs-comment">// 1</span></code></pre>
<p>对于嵌套对象：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> userData = <span class="hljs-string">&#x27;{ &quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 35, &quot;isAdmin&quot;: false, &quot;friends&quot;: [0,1,2,3] }&#x27;</span>;

<span class="hljs-keyword">let</span> user = <span class="hljs-built_in">JSON</span>.parse(userData);

alert( user.friends[<span class="hljs-number">1</span>] ); <span class="hljs-comment">// 1</span></code></pre>
<p>JSON 可能会非常复杂，对象和数组可以包含其他对象和数组。但是它们必须遵循相同的 JSON 格式。</p>
<p>以下是手写 JSON 时的典型错误（有时我们必须出于调试目的编写它）：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> json = <span class="hljs-string">`{
  *!*name*/!*: &quot;John&quot;,                     // 错误：属性名没有双引号
  &quot;surname&quot;: *!*&#x27;Smith&#x27;*/!*,               // 错误：值使用的是单引号（必须使用双引号）
  *!*&#x27;isAdmin&#x27;*/!*: false                  // 错误：键使用的是单引号（必须使用双引号）
  &quot;birthday&quot;: *!*new Date(2000, 2, 3)*/!*, // 错误：不允许使用 &quot;new&quot;，只能是裸值
  &quot;friends&quot;: [0,1,2,3]              // 这个没问题
}`</span>;</code></pre>
<p>此外，JSON 不支持注释。向 JSON 添加注释无效。</p>
<p>还有另一种名为 <a href="http://json5.org/">JSON5</a> 的格式，它允许未加引号的键，也允许注释等。但这是一个独立的库，不在语言的规范中。</p>
<p>常规的 JSON 格式严格，并不是因为它的开发者很懒，而是为了实现简单，可靠且快速地实现解析算法。</p>
<h2 id="使用-reviver">使用 reviver</h2>
<p>想象一下，我们从服务器上获得了一个字符串化的 <code>meetup</code> 对象。</p>
<p>它看起来像这样：</p>
<pre><code class="language-js"><span class="hljs-comment">// title: (meetup title), date: (meetup date)</span>
<span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;{&quot;title&quot;:&quot;Conference&quot;,&quot;date&quot;:&quot;2017-11-30T12:00:00.000Z&quot;}&#x27;</span>;</code></pre>
<p>……现在我们需要对它进行 <strong>反序列（deserialize）</strong>，把它转换回 JavaScript 对象。</p>
<p>让我们通过调用 <code>JSON.parse</code> 来完成：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;{&quot;title&quot;:&quot;Conference&quot;,&quot;date&quot;:&quot;2017-11-30T12:00:00.000Z&quot;}&#x27;</span>;

<span class="hljs-keyword">let</span> meetup = <span class="hljs-built_in">JSON</span>.parse(str);

*!*
alert( meetup.date.getDate() ); <span class="hljs-comment">// Error!</span>
*/!*</code></pre>
<p>啊！报错了！</p>
<p><code>meetup.date</code> 的值是一个字符串，而不是 <code>Date</code> 对象。<code>JSON.parse</code> 怎么知道应该将字符串转换为 <code>Date</code> 呢？</p>
<p>让我们将 reviver 函数传递给 <code>JSON.parse</code> 作为第二个参数，该函数按照“原样”返回所有值，但是 <code>date</code> 会变成 <code>Date</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;{&quot;title&quot;:&quot;Conference&quot;,&quot;date&quot;:&quot;2017-11-30T12:00:00.000Z&quot;}&#x27;</span>;

*!*
<span class="hljs-keyword">let</span> meetup = <span class="hljs-built_in">JSON</span>.parse(str, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key, value</span>) </span>{
  <span class="hljs-keyword">if</span> (key == <span class="hljs-string">&#x27;date&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(value);
  <span class="hljs-keyword">return</span> value;
});
*/!*

alert( meetup.date.getDate() ); <span class="hljs-comment">// 现在正常运行了！</span></code></pre>
<p>顺便说一下，这也适用于嵌套对象：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> schedule = <span class="hljs-string">`{
  &quot;meetups&quot;: [
    {&quot;title&quot;:&quot;Conference&quot;,&quot;date&quot;:&quot;2017-11-30T12:00:00.000Z&quot;},
    {&quot;title&quot;:&quot;Birthday&quot;,&quot;date&quot;:&quot;2017-04-18T12:00:00.000Z&quot;}
  ]
}`</span>;

schedule = <span class="hljs-built_in">JSON</span>.parse(schedule, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key, value</span>) </span>{
  <span class="hljs-keyword">if</span> (key == <span class="hljs-string">&#x27;date&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(value);
  <span class="hljs-keyword">return</span> value;
});

*!*
alert( schedule.meetups[<span class="hljs-number">1</span>].date.getDate() ); <span class="hljs-comment">// 正常运行了！</span>
*/!*</code></pre>
<h2 id="总结">总结</h2>
<ul>
<li>JSON 是一种数据格式，具有自己的独立标准和大多数编程语言的库。</li>
<li>JSON 支持 object，array，string，number，boolean 和 <code>null</code>。</li>
<li>JavaScript 提供序列化（serialize）成 JSON 的方法 <a href="mdn:js/JSON/stringify">JSON.stringify</a> 和解析 JSON 的方法 <a href="mdn:js/JSON/parse">JSON.parse</a>。</li>
<li>这两种方法都支持用于智能读/写的转换函数。</li>
<li>如果一个对象具有 <code>toJSON</code>，那么它会被 <code>JSON.stringify</code> 调用。</li>
</ul>

      </fieldset>
      
      <fieldset id='_3NoglX'>
      <legend>solution</legend>
      <p>使用循环的解法：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sumTo</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {
    sum += i;
  }
  <span class="hljs-keyword">return</span> sum;
}

alert( sumTo(<span class="hljs-number">100</span>) );</code></pre>
<p>使用递归的解法：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sumTo</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  <span class="hljs-keyword">return</span> n + sumTo(n - <span class="hljs-number">1</span>);
}

alert( sumTo(<span class="hljs-number">100</span>) );</code></pre>
<p>使用公式 <code>sumTo(n) = n*(n+1)/2</code> 的解法：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sumTo</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">return</span> n * (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
}

alert( sumTo(<span class="hljs-number">100</span>) );</code></pre>
<p>P.S. 当然是公式解法最快。对任何数字 <code>n</code>，只需要进行 3 次运算。数学大法好！</p>
<p>循环的速度次之。在循环和递归方法里，我们对相同的数字求和。但是递归涉及嵌套调用和执行堆栈管理。这也会占用资源，因此递归的速度更慢一些。</p>
<p>P.P.S. 一些引擎支持“尾调用（tail call）”优化：如果递归调用是函数中的最后一个调用（例如上面的 <code>sumTo</code>），那么外部的函数就不再需要恢复执行，因此引擎也就不再需要记住他的执行上下文。这样就减轻了内存负担，因此计算 <code>sumTo(100000)</code> 就变得可能。但是如果你的 JavaScript 引擎不支持尾调用优化，那就会报错：超出最大堆栈深度，因为通常总堆栈的大小是有限制的。</p>

      </fieldset>
      
      <fieldset id='_vwZq1I'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="对数字求和到给定值">对数字求和到给定值</h1>
<p>编写一个函数 <code>sumTo(n)</code> 计算 <code>1 + 2 + ... + n</code> 的和。</p>
<p>举个例子：</p>
<pre><code class="language-js">sumTo(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span>
sumTo(<span class="hljs-number">2</span>) = <span class="hljs-number">2</span> + <span class="hljs-number">1</span> = <span class="hljs-number">3</span>
sumTo(<span class="hljs-number">3</span>) = <span class="hljs-number">3</span> + <span class="hljs-number">2</span> + <span class="hljs-number">1</span> = <span class="hljs-number">6</span>
sumTo(<span class="hljs-number">4</span>) = <span class="hljs-number">4</span> + <span class="hljs-number">3</span> + <span class="hljs-number">2</span> + <span class="hljs-number">1</span> = <span class="hljs-number">10</span>
...
sumTo(<span class="hljs-number">100</span>) = <span class="hljs-number">100</span> + <span class="hljs-number">99</span> + ... + <span class="hljs-number">2</span> + <span class="hljs-number">1</span> = <span class="hljs-number">5050</span></code></pre>
<p>用三种方式实现：</p>
<ol>
<li>使用循环。</li>
<li>使用递归，对 <code>n &gt; 1</code> 执行 <code>sumTo(n) = n + sumTo(n-1)</code>。</li>
<li>使用 <a href="https://en.wikipedia.org/wiki/Arithmetic_progression">等差数列</a> 求和公式.</li>
</ol>
<p>结果示例：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sumTo</span>(<span class="hljs-params">n</span>) </span>{ <span class="hljs-comment">/*... 你的代码 ... */</span> }

alert( sumTo(<span class="hljs-number">100</span>) ); <span class="hljs-comment">// 5050</span></code></pre>
<p>P.S. 哪种解决方式最快？哪种最慢？为什么？</p>
<p>P.P.S. 我们可以使用递归来计算 <code>sumTo(100000)</code> 吗？</p>

      </fieldset>
      
      <fieldset id='_WF29gw'>
      <legend>solution</legend>
      <p>根据定义，阶乘 <code>n!</code> 可以被写成 <code>n * (n-1)!</code>。</p>
<p>换句话说，<code>factorial(n)</code> 的结果可以用 <code>n</code> 乘以 <code>factorial(n-1)</code> 的结果来获得。对 <code>n-1</code> 的调用同理可以依次地递减，直到 <code>1</code>。</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">factorial</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">return</span> (n != <span class="hljs-number">1</span>) ? n * factorial(n - <span class="hljs-number">1</span>) : <span class="hljs-number">1</span>;
}

alert( factorial(<span class="hljs-number">5</span>) ); <span class="hljs-comment">// 120</span></code></pre>
<p>递归的基础是数值 <code>1</code>。我们也可以用 <code>0</code> 作为基础，不影响，除了会多一次递归步骤：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">factorial</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">return</span> n ? n * factorial(n - <span class="hljs-number">1</span>) : <span class="hljs-number">1</span>;
}

alert( factorial(<span class="hljs-number">5</span>) ); <span class="hljs-comment">// 120</span></code></pre>

      </fieldset>
      
      <fieldset id='_nDoDRS'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="计算阶乘">计算阶乘</h1>
<p>自然数的 <a href="https://en.wikipedia.org/wiki/Factorial">阶乘</a> 是指，一个数乘以 <code>数字减去 1</code>，然后乘以 <code>数字减去 2</code>，以此类推直到乘以 <code>1</code>。<code>n</code> 的阶乘被记作 <code>n!</code>。</p>
<p>我们可以将阶乘的定义写成这样：</p>
<pre><code class="language-js">n! = n * (n - <span class="hljs-number">1</span>) * (n - <span class="hljs-number">2</span>) * ...*<span class="hljs-number">1</span></code></pre>
<p>不同 <code>n</code> 的阶乘的值：</p>
<pre><code class="language-js"><span class="hljs-number">1</span>! = <span class="hljs-number">1</span>
<span class="hljs-number">2</span>! = <span class="hljs-number">2</span> * <span class="hljs-number">1</span> = <span class="hljs-number">2</span>
<span class="hljs-number">3</span>! = <span class="hljs-number">3</span> * <span class="hljs-number">2</span> * <span class="hljs-number">1</span> = <span class="hljs-number">6</span>
<span class="hljs-number">4</span>! = <span class="hljs-number">4</span> * <span class="hljs-number">3</span> * <span class="hljs-number">2</span> * <span class="hljs-number">1</span> = <span class="hljs-number">24</span>
<span class="hljs-number">5</span>! = <span class="hljs-number">5</span> * <span class="hljs-number">4</span> * <span class="hljs-number">3</span> * <span class="hljs-number">2</span> * <span class="hljs-number">1</span> = <span class="hljs-number">120</span></code></pre>
<p>任务是编写一个函数 <code>factorial(n)</code> 使用递归调用计算 <code>n!</code>。</p>
<pre><code class="language-js">alert( factorial(<span class="hljs-number">5</span>) ); <span class="hljs-comment">// 120</span></code></pre>
<p>P.S. 提示：<code>n!</code> 可以被写成 <code>n * (n-1)!</code>，比如 <code>3! = 3*2! = 3*2*1! = 6</code>。</p>

      </fieldset>
      
      <fieldset id='_vCJdpS'>
      <legend>solution</legend>
      <p>我们可以尝试的第一种解法是递归。</p>
<p>斐波那契数根据定义是递归的：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fib</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">return</span> n &lt;= <span class="hljs-number">1</span> ? n : fib(n - <span class="hljs-number">1</span>) + fib(n - <span class="hljs-number">2</span>);
}

alert( fib(<span class="hljs-number">3</span>) ); <span class="hljs-comment">// 2</span>
alert( fib(<span class="hljs-number">7</span>) ); <span class="hljs-comment">// 13</span>
<span class="hljs-comment">// fib(77); // 超级慢！</span></code></pre>
<p>……但是 <code>n</code> 比较大时会很慢。比如 <code>fib(77)</code> 会挂起引擎一段时间，并且消耗所有 CPU 资源。</p>
<p>因为函数产生了太多的子调用。同样的值被一遍又一遍地计算。</p>
<p>例如，我们看下计算 <code>fib(5)</code> 的片段：</p>
<pre><code class="language-js">...
fib(<span class="hljs-number">5</span>) = fib(<span class="hljs-number">4</span>) + fib(<span class="hljs-number">3</span>)
fib(<span class="hljs-number">4</span>) = fib(<span class="hljs-number">3</span>) + fib(<span class="hljs-number">2</span>)
...</code></pre>
<p>可以看到，<code>fib(5)</code> 和 <code>fib(4)</code> 都需要 <code>fib(3)</code> 的值，所以 <code>fib(3)</code> 被独立计算了两次。</p>
<p>这是完整的递归树：</p>
<p><img src="fibonacci-recursion-tree.svg" alt="斐波那契递归树"></p>
<p>我们可以清楚的看到 <code>fib(3)</code> 被计算了两次，<code>fib(2)</code> 被计算了三次。总计算量远远超过了 <code>n</code>，这造成仅仅对于计算 <code>n=77</code> 来讲，计算量就是巨量的。</p>
<p>我们可以通过记录已经计算过的值来进行优化：如果一个值比如 <code>fib(3)</code> 已经被计算过一次，那么我们可以在后面的计算中重复使用它。</p>
<p>另一个选择就是不使用递归，而是使用完全不同的基于循环的算法。</p>
<p>与从 <code>n</code> 到降到更小的值相反，我们可以使用循环从 <code>1</code> 和 <code>2</code> 开始，然后得到它们的和 <code>fib(3)</code>，然后再通过前两个数的和得到 <code>fib(4)</code>，然后 <code>fib(5)</code>，以此类推，直至达到所需要的值。在每一步，我们只需要记录前两个值就可以。</p>
<p>下面是新算法的细节步骤：</p>
<p>开始：</p>
<pre><code class="language-js"><span class="hljs-comment">// a = fib(1), b = fib(2)，这些值是根据定义 1 得到的</span>
<span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">1</span>;

<span class="hljs-comment">// 求两者的和得到 c = fib(3)</span>
<span class="hljs-keyword">let</span> c = a + b;

<span class="hljs-comment">/* 现在我们有 fib(1)，fib(2) 和 fib(3)
a  b  c
1, 1, 2
*/</span></code></pre>
<p>现在我们想要得到 <code>fib(4) = fib(2) + fib(3)</code>。</p>
<p>我们移动变量：<code>a,b</code> 将得到 <code>fib(2),fib(3)</code>，<code>c</code> 将得到两者的和：</p>
<pre><code class="language-js">a = b; <span class="hljs-comment">// 现在 a = fib(2)</span>
b = c; <span class="hljs-comment">// 现在 b = fib(3)</span>
c = a + b; <span class="hljs-comment">// c = fib(4)</span>

<span class="hljs-comment">/* 现在我们有这样的序列
   a  b  c
1, 1, 2, 3
*/</span></code></pre>
<p>下一步得到另一个序列数：</p>
<pre><code class="language-js">a = b; <span class="hljs-comment">// 现在 a = fib(3)</span>
b = c; <span class="hljs-comment">// 现在 b = fib(4)</span>
c = a + b; <span class="hljs-comment">// c = fib(5)</span>

<span class="hljs-comment">/* 现在序列是（又加了一个数）：
      a  b  c
1, 1, 2, 3, 5
*/</span></code></pre>
<p>……依次类推，直到我们得到需要的值。这比递归快很多，而且没有重复计算。</p>
<p>完整代码：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fib</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">let</span> b = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) {
    <span class="hljs-keyword">let</span> c = a + b;
    a = b;
    b = c;
  }
  <span class="hljs-keyword">return</span> b;
}

alert( fib(<span class="hljs-number">3</span>) ); <span class="hljs-comment">// 2</span>
alert( fib(<span class="hljs-number">7</span>) ); <span class="hljs-comment">// 13</span>
alert( fib(<span class="hljs-number">77</span>) ); <span class="hljs-comment">// 5527939700884757</span></code></pre>
<p>循环从 <code>i=3</code> 开始，因为前两个序列值被硬编码到变量 <code>a=1</code>，<code>b=1</code>。</p>
<p>这种方式称为 <a href="https://en.wikipedia.org/wiki/Dynamic_programming">自下而上的动态规划</a>。</p>

      </fieldset>
      
      <fieldset id='_zodrVT'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="斐波那契数">斐波那契数</h1>
<p><a href="https://en.wikipedia.org/wiki/Fibonacci_number">斐波那契数</a> 序列有这样的公式： <code>F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub></code>。换句话说，下一个数字是前两个数字的和。</p>
<p>前两个数字是 <code>1</code>，然后是 <code>2(1+1)</code>，然后 <code>3(1+2)</code>，<code>5(2+3)</code> 等：<code>1, 1, 2, 3, 5, 8, 13, 21...</code>。</p>
<p>斐波那契数与 <a href="https://en.wikipedia.org/wiki/Golden_ratio">黄金比例</a> 以及我们周围的许多自然现象有关。</p>
<p>编写一个函数 <code>fib(n)</code> 返回第 <code>n</code> 个斐波那契数。</p>
<p>工作示例：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fib</span>(<span class="hljs-params">n</span>) </span>{ <span class="hljs-comment">/* 你的代码 */</span> }

alert(fib(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 2</span>
alert(fib(<span class="hljs-number">7</span>)); <span class="hljs-comment">// 13</span>
alert(fib(<span class="hljs-number">77</span>)); <span class="hljs-comment">// 5527939700884757</span></code></pre>
<p>P.S. 函数运行速度要快，对 <code>fib(77)</code> 的调用不应该超过几分之一秒。</p>

      </fieldset>
      
      <fieldset id='_wkYv09'>
      <legend>solution</legend>
      <h1 id="循环解法">循环解法</h1>
<p>基于循环的解法：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> list = {
  <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">next</span>: {
    <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>,
    <span class="hljs-attr">next</span>: {
      <span class="hljs-attr">value</span>: <span class="hljs-number">3</span>,
      <span class="hljs-attr">next</span>: {
        <span class="hljs-attr">value</span>: <span class="hljs-number">4</span>,
        <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>
      }
    }
  }
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printList</span>(<span class="hljs-params">list</span>) </span>{
  <span class="hljs-keyword">let</span> tmp = list;

  <span class="hljs-keyword">while</span> (tmp) {
    alert(tmp.value);
    tmp = tmp.next;
  }

}

printList(list);</code></pre>
<p>请注意，我们使用了一个临时变量 <code>tmp</code> 来遍历链表。从技术上讲，我们可以使用函数的入参 <code>list</code> 来代替：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printList</span>(<span class="hljs-params">list</span>) </span>{

  <span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-params">*!*list*/!*</span>)</span> {
    alert(list.value);
    list = list.next;
  }

}</code></pre>
<p>……但是这不够明智。未来我们可能想要扩展这个函数，使用这个链表做其他的事儿，如果我们修改了 <code>list</code>，那么我们就失去了这个能力。</p>
<p>说到好的变量命名，<code>list</code> 在这里是链表本身。代表它的第一个元素。它应该保持原样，这是清晰可靠的。</p>
<p>从另一个方面来说，<code>tmp</code> 是充当了完全遍历链表的角色，就像 <code>for</code> 循环中的 <code>i</code> 一样。</p>
<h1 id="递归解法">递归解法</h1>
<p><code>printList(list)</code> 的递归实现遵循一个简单的逻辑：为了输出链表，我们应该输出 <code>list</code> 的当前的元素，<code>list.next</code> 同理：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> list = {
  <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">next</span>: {
    <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>,
    <span class="hljs-attr">next</span>: {
      <span class="hljs-attr">value</span>: <span class="hljs-number">3</span>,
      <span class="hljs-attr">next</span>: {
        <span class="hljs-attr">value</span>: <span class="hljs-number">4</span>,
        <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>
      }
    }
  }
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printList</span>(<span class="hljs-params">list</span>) </span>{

  alert(list.value); <span class="hljs-comment">// 输出当前元素</span>

  <span class="hljs-keyword">if</span> (list.next) {
    printList(list.next); <span class="hljs-comment">// 链表中其余部分同理</span>
  }

}

printList(list);</code></pre>
<p>哪个更好呢？</p>
<p>从技术上讲，循环更有效。这两种解法的做了同样的事儿，但循环不会为嵌套函数调用消耗资源。</p>
<p>另一方面，递归解法更简洁，有时更容易理解。</p>

      </fieldset>
      
      <fieldset id='_dIFEJk'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="输出一个单链表">输出一个单链表</h1>
<p>假设我们有一个单链表（在 <a href="info:recursion">info:recursion</a> 那章有讲过）：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> list = {
  <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">next</span>: {
    <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>,
    <span class="hljs-attr">next</span>: {
      <span class="hljs-attr">value</span>: <span class="hljs-number">3</span>,
      <span class="hljs-attr">next</span>: {
        <span class="hljs-attr">value</span>: <span class="hljs-number">4</span>,
        <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>
      }
    }
  }
};</code></pre>
<p>编写一个可以逐个输出链表元素的函数 <code>printList(list)</code>。</p>
<p>使用两种方式实现：循环和递归。</p>
<p>哪个更好：用递归还是不用递归的？</p>

      </fieldset>
      
      <fieldset id='_JfkvS7'>
      <legend>solution</legend>
      <h1 id="使用递归">使用递归</h1>
<p>递归逻辑在这稍微有点儿棘手。</p>
<p>我们需要先输出列表的其它元素，<strong>然后</strong> 输出当前的元素：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> list = {
  <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">next</span>: {
    <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>,
    <span class="hljs-attr">next</span>: {
      <span class="hljs-attr">value</span>: <span class="hljs-number">3</span>,
      <span class="hljs-attr">next</span>: {
        <span class="hljs-attr">value</span>: <span class="hljs-number">4</span>,
        <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>
      }
    }
  }
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printReverseList</span>(<span class="hljs-params">list</span>) </span>{

  <span class="hljs-keyword">if</span> (list.next) {
    printReverseList(list.next);
  }

  alert(list.value);
}

printReverseList(list);</code></pre>
<h1 id="使用循环">使用循环</h1>
<p>循环解法也比直接输出稍微复杂了点儿。</p>
<p>在这而没有什么方法可以获取 <code>list</code> 中的最后一个值。我们也不能“从后向前”读取。</p>
<p>因此，我们可以做的就是直接按顺序遍历每个元素，并把它们存到一个数组中，然后反向输出我们存储在数组中的元素：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> list = {
  <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">next</span>: {
    <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>,
    <span class="hljs-attr">next</span>: {
      <span class="hljs-attr">value</span>: <span class="hljs-number">3</span>,
      <span class="hljs-attr">next</span>: {
        <span class="hljs-attr">value</span>: <span class="hljs-number">4</span>,
        <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>
      }
    }
  }
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printReverseList</span>(<span class="hljs-params">list</span>) </span>{
  <span class="hljs-keyword">let</span> arr = [];
  <span class="hljs-keyword">let</span> tmp = list;

  <span class="hljs-keyword">while</span> (tmp) {
    arr.push(tmp.value);
    tmp = tmp.next;
  }

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = arr.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
    alert( arr[i] );
  }
}

printReverseList(list);</code></pre>
<p>请注意，递归解法实际上也是这样做的：它顺着链表，记录每一个嵌套调用里链表的元素（在执行上下文堆栈里），然后输出它们。</p>

      </fieldset>
      
      <fieldset id='_svp1S7'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="反向输出单链表">反向输出单链表</h1>
<p>反向输出前一个任务 <a href="info:task/output-single-linked-list">info:task/output-single-linked-list</a> 中的单链表。</p>
<p>使用两种解法：循环和递归。</p>

      </fieldset>
      
      <fieldset id='_2P39dy'>
      <legend>article</legend>
      <h1 id="递归和堆栈">递归和堆栈</h1>
<p>让我们回到函数，进行更深入的研究。</p>
<p>我们的第一个主题是 <strong>递归（recursion）</strong>。</p>
<p>如果你不是刚接触编程，那么你可能已经很熟悉它了，那么你可以跳过这一章。</p>
<p>递归是一种编程模式，在一个任务可以自然地拆分成多个相同类型但更简单的任务的情况下非常有用。或者，在一个任务可以简化为一个简单的行为加上该任务的一个更简单的变体的时候可以使用。或者，就像我们很快会看到的那样，处理某些数据结构。</p>
<p>当一个函数解决一个任务时，在解决的过程中它可以调用很多其它函数。在部分情况下，函数会调用 <strong>自身</strong>。这就是所谓的 <strong>递归</strong>。</p>
<h2 id="两种思考方式">两种思考方式</h2>
<p>简单起见，让我们写一个函数 <code>pow(x, n)</code>，它可以计算 <code>x</code> 的 <code>n</code> 次方。换句话说就是，<code>x</code> 乘以自身 <code>n</code> 次。</p>
<pre><code class="language-js">pow(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>) = <span class="hljs-number">4</span>
pow(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) = <span class="hljs-number">8</span>
pow(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>) = <span class="hljs-number">16</span></code></pre>
<p>有两种实现方式。</p>
<ol>
<li><p>迭代思路：使用 <code>for</code> 循环：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pow</span>(<span class="hljs-params">x, n</span>) </span>{
  <span class="hljs-keyword">let</span> result = <span class="hljs-number">1</span>;

  <span class="hljs-comment">// 再循环中，用 x 乘以 result n 次</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
    result *= x;
  }

  <span class="hljs-keyword">return</span> result;
}

alert( pow(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) ); <span class="hljs-comment">// 8</span></code></pre>
</li>
<li><p>递归思路：简化任务，调用自身：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pow</span>(<span class="hljs-params">x, n</span>) </span>{
  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> x;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> x * pow(x, n - <span class="hljs-number">1</span>);
  }
}

alert( pow(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) ); <span class="hljs-comment">// 8</span></code></pre>
</li>
</ol>
<p>请注意，递归变体在本质上是不同的。</p>
<p>当 <code>pow(x, n)</code> 被调用时，执行分为两个分支：</p>
<pre><code class="language-js">              <span class="hljs-keyword">if</span> n==<span class="hljs-number">1</span>  = x
             /
pow(x, n) =
             \       
              <span class="hljs-keyword">else</span>     = x * pow(x, n - <span class="hljs-number">1</span>)</code></pre>
<ol>
<li>如果 <code>n == 1</code>，所有事情都会很简单，这叫做 <strong>基础</strong> 的递归，因为它会立即产生明显的结果：<code>pow(x, 1)</code> 等于 <code>x</code>。</li>
<li>否则，我们可以用 <code>x * pow(x, n - 1)</code> 表示 <code>pow(x, n)</code>。在数学里，可能会写为 <code>x<sup>n</sup> = x * x<sup>n-1</sup></code>。这叫做 <strong>一个递归步骤</strong>：我们将任务转化为更简单的行为（<code>x</code> 的乘法）和更简单的同类任务的调用（带有更小的 <code>n</code> 的 <code>pow</code> 运算）。接下来的步骤将其进一步简化，直到 <code>n</code> 达到 <code>1</code>。</li>
</ol>
<p>我们也可以说 <code>pow</code> <strong>递归地调用自身</strong> 直到 <code>n == 1</code>。</p>
<p><img src="recursion-pow.svg" alt="pow 的递归示意图"></p>
<p>比如，为了计算 <code>pow(2, 4)</code>，递归变体经过了下面几个步骤：</p>
<ol>
<li><code>pow(2, 4) = 2 * pow(2, 3)</code></li>
<li><code>pow(2, 3) = 2 * pow(2, 2)</code></li>
<li><code>pow(2, 2) = 2 * pow(2, 1)</code></li>
<li><code>pow(2, 1) = 2</code></li>
</ol>
<p>因此，递归将函数调用简化为一个更简单的函数调用，然后再将其简化为一个更简单的函数，以此类推，直到结果变得显而易见。</p>
<pre><code class="language-smart">递归解通常比迭代解更短。

在这儿，我们可以使用条件运算符 `?` 而不是 `if` 语句，从而使 `pow(x, n)` 更简洁并且可读性依然很高：

```js run
function pow(x, n) {
  return (n == 1) ? x : (x * pow(x, n - 1));
}
```</code></pre>
<p>最大的嵌套调用次数（包括首次）被称为 <strong>递归深度</strong>。在我们的例子中，它正好等于 <code>n</code>。</p>
<p>最大递归深度受限于 JavaScript 引擎。对我们来说，引擎在最大迭代深度为 10000 及以下时是可靠的，有些引擎可能允许更大的最大深度，但是对于大多数引擎来说，100000 可能就超出限制了。有一些自动优化能够帮助减轻这种情况（尾部调用优化），但目前它们还没有被完全支持，只能用于简单场景。</p>
<p>这就限制了递归的应用，但是递归仍然被广泛使用。有很多任务中，递归思维方式会使代码更简单，更容易维护。</p>
<h2 id="执行上下文和堆栈">执行上下文和堆栈</h2>
<p>现在我们来研究一下递归调用是如何工作的。为此，我们会先看看函数底层的工作原理。</p>
<p>有关正在运行的函数的执行过程的相关信息被存储在其 <strong>执行上下文</strong> 中。</p>
<p><a href="https://tc39.github.io/ecma262/#sec-execution-contexts">执行上下文</a> 是一个内部数据结构，它包含有关函数执行时的详细细节：当前控制流所在的位置，当前的变量，<code>this</code> 的值（此处我们不使用它），以及其它的一些内部细节。</p>
<p>一个函数调用仅具有一个与其相关联的执行上下文。</p>
<p>当一个函数进行嵌套调用时，将发生以下的事儿：</p>
<ul>
<li>当前函数被暂停；</li>
<li>与它关联的执行上下文被一个叫做 <strong>执行上下文堆栈</strong> 的特殊数据结构保存；</li>
<li>执行嵌套调用；</li>
<li>嵌套调用结束后，从堆栈中恢复之前的执行上下文，并从停止的位置恢复外部函数。</li>
</ul>
<p>让我们看看 <code>pow(2, 3)</code> 调用期间都发生了什么。</p>
<h3 id="pow2-3">pow(2, 3)</h3>
<p>在调用 <code>pow(2, 3)</code> 的开始，执行上下文（context）会存储变量：<code>x = 2, n = 3</code>，执行流程在函数的第 <code>1</code> 行。</p>
<p>我们将其描绘如下：</p>
<ul class="function-execution-context-list">
  <li>
    <span class="function-execution-context">Context: { x: 2, n: 3, at line 1 }</span>
    <span class="function-execution-context-call">pow(2, 3)</span>
  </li>
</ul>

<p>这是函数开始执行的时候。条件 <code>n == 1</code> 结果为 false，所以执行流程进入 <code>if</code> 的第二分支。</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pow</span>(<span class="hljs-params">x, n</span>) </span>{
  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> x;
  } <span class="hljs-keyword">else</span> {
*!*
    <span class="hljs-keyword">return</span> x * pow(x, n - <span class="hljs-number">1</span>);
*/!*
  }
}

alert( pow(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) );</code></pre>
<p>变量相同，但是行改变了，因此现在的上下文是：</p>
<ul class="function-execution-context-list">
  <li>
    <span class="function-execution-context">Context: { x: 2, n: 3, at line 5 }</span>
    <span class="function-execution-context-call">pow(2, 3)</span>
  </li>
</ul>

<p>为了计算 <code>x * pow(x, n - 1)</code>，我们需要使用带有新参数的新的 <code>pow</code> 子调用 <code>pow(2, 2)</code>。</p>
<h3 id="pow（2-2">pow（2, 2)</h3>
<p>为了执行嵌套调用，JavaScript 会在 <strong>执行上下文堆栈</strong> 中记住当前的执行上下文。</p>
<p>这里我们调用相同的函数 <code>pow</code>，但这绝对没问题。所有函数的处理都是一样的：</p>
<ol>
<li>当前上下文被“记录”在堆栈的顶部。</li>
<li>为子调用创建新的上下文。</li>
<li>当子调用结束后 —— 前一个上下文被从堆栈中弹出，并继续执行。</li>
</ol>
<p>下面是进入子调用 <code>pow(2, 2)</code> 时的上下文堆栈：</p>
<ul class="function-execution-context-list">
  <li>
    <span class="function-execution-context">Context: { x: 2, n: 2, at line 1 }</span>
    <span class="function-execution-context-call">pow(2, 2)</span>
  </li>
  <li>
    <span class="function-execution-context">Context: { x: 2, n: 3, at line 5 }</span>
    <span class="function-execution-context-call">pow(2, 3)</span>
  </li>
</ul>

<p>新的当前执行上下文位于顶部（粗体显示），之前记住的上下文位于下方。</p>
<p>当我们完成子调用后 —— 很容易恢复上一个上下文，因为它既保留了变量，也保留了当时所在代码的确切位置。</p>
<pre><code class="language-smart">在上面的图中，我们使用“行”一词作为示例，每一行只有一个子调用，但通常一行代码可能会包含多个子调用，像 `pow(…) + pow(…) + somethingElse(…)`。

因此，更准确地说，执行是“在子调用之后立即恢复”的。</code></pre>
<h3 id="pow2-1">pow(2, 1)</h3>
<p>重复该过程：在第 <code>5</code> 行生成新的子调用，现在的参数是 <code>x=2</code>, <code>n=1</code>。</p>
<p>新的执行上下文被创建，前一个被压入堆栈顶部：</p>
<ul class="function-execution-context-list">
  <li>
    <span class="function-execution-context">Context: { x: 2, n: 1, at line 1 }</span>
    <span class="function-execution-context-call">pow(2, 1)</span>
  </li>
  <li>
    <span class="function-execution-context">Context: { x: 2, n: 2, at line 5 }</span>
    <span class="function-execution-context-call">pow(2, 2)</span>
  </li>
  <li>
    <span class="function-execution-context">Context: { x: 2, n: 3, at line 5 }</span>
    <span class="function-execution-context-call">pow(2, 3)</span>
  </li>
</ul>

<p>此时，有 2 个旧的上下文和 1 个当前正在运行的 <code>pow(2, 1)</code> 的上下文。</p>
<h3 id="出口">出口</h3>
<p>在执行 <code>pow(2, 1)</code> 时，与之前的不同，条件 <code>n == 1</code> 为 true，因此 <code>if</code> 的第一个分支生效：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pow</span>(<span class="hljs-params">x, n</span>) </span>{
  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) {
*!*
    <span class="hljs-keyword">return</span> x;
*/!*
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> x * pow(x, n - <span class="hljs-number">1</span>);
  }
}</code></pre>
<p>此时不再有更多的嵌套调用，所以函数结束，返回 <code>2</code>。</p>
<p>函数完成后，就不再需要其执行上下文了，因此它被从内存中移除。前一个上下文恢复到堆栈的顶部：</p>
<ul class="function-execution-context-list">
  <li>
    <span class="function-execution-context">Context: { x: 2, n: 2, at line 5 }</span>
    <span class="function-execution-context-call">pow(2, 2)</span>
  </li>
  <li>
    <span class="function-execution-context">Context: { x: 2, n: 3, at line 5 }</span>
    <span class="function-execution-context-call">pow(2, 3)</span>
  </li>
</ul>

<p>恢复执行 <code>pow(2, 2)</code>。它拥有子调用 <code>pow(2, 1)</code> 的结果，因此也可以完成 <code>x * pow(x, n - 1)</code> 的执行，并返回 <code>4</code>。</p>
<p>然后，前一个上下文被恢复：</p>
<ul class="function-execution-context-list">
  <li>
    <span class="function-execution-context">Context: { x: 2, n: 3, at line 5 }</span>
    <span class="function-execution-context-call">pow(2, 3)</span>
  </li>
</ul>

<p>当它结束后，我们得到了结果 <code>pow(2, 3) = 8</code>。</p>
<p>本示例中的递归深度为：<strong>3</strong>。</p>
<p>从上面的插图我们可以看出，递归深度等于堆栈中上下文的最大数量。</p>
<p>请注意内存要求。上下文占用内存，在我们的示例中，求 <code>n</code> 次方需要存储 <code>n</code> 个上下文，以供更小的 <code>n</code> 值进行计算使用。</p>
<p>而循环算法更节省内存：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pow</span>(<span class="hljs-params">x, n</span>) </span>{
  <span class="hljs-keyword">let</span> result = <span class="hljs-number">1</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
    result *= x;
  }

  <span class="hljs-keyword">return</span> result;
}</code></pre>
<p>迭代 <code>pow</code> 的过程中仅使用了一个上下文用于修改 <code>i</code> 和 <code>result</code>。它的内存要求小，并且是固定了，不依赖于 <code>n</code>。</p>
<p><strong>任何递归都可以用循环来重写。通常循环变体更有效。</strong></p>
<p>……但有时重写很难，尤其是函数根据条件使用不同的子调用，然后合并它们的结果，或者分支比较复杂时。而且有些优化可能没有必要，完全不值得。</p>
<p>递归可以使代码更短，更易于理解和维护。并不是每个地方都需要优化，大多数时候我们需要一个好代码，这就是为什么要使用它。</p>
<h2 id="递归遍历">递归遍历</h2>
<p>递归的另一个重要应用就是递归遍历。</p>
<p>假设我们有一家公司。人员结构可以表示为一个对象：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> company = {
  <span class="hljs-attr">sales</span>: [{
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>,
    <span class="hljs-attr">salary</span>: <span class="hljs-number">1000</span>
  }, {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,
    <span class="hljs-attr">salary</span>: <span class="hljs-number">1600</span>
  }],

  <span class="hljs-attr">development</span>: {
    <span class="hljs-attr">sites</span>: [{
      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Peter&#x27;</span>,
      <span class="hljs-attr">salary</span>: <span class="hljs-number">2000</span>
    }, {
      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alex&#x27;</span>,
      <span class="hljs-attr">salary</span>: <span class="hljs-number">1800</span>
    }],

    <span class="hljs-attr">internals</span>: [{
      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>,
      <span class="hljs-attr">salary</span>: <span class="hljs-number">1300</span>
    }]
  }
};</code></pre>
<p>换句话说，一家公司有很多部门。</p>
<ul>
<li><p>一个部门可能有一 <strong>数组</strong> 的员工，比如，<code>sales</code> 部门有 2 名员工：John 和 Alice。</p>
</li>
<li><p>或者，一个部门可能会划分为几个子部门，比如 <code>development</code> 有两个分支：<code>sites</code> 和 <code>internals</code>，它们都有自己的员工。</p>
</li>
<li><p>当一个子部门增长时，它也有可能被拆分成几个子部门（或团队）。</p>
<p>  例如，<code>sites</code> 部门在未来可能会分为 <code>siteA</code> 和 <code>siteB</code>。并且，它们可能会被再继续拆分。没有图示，脑补一下吧。</p>
</li>
</ul>
<p>现在，如果我们需要一个函数来获取所有薪资的总数。我们该怎么做？</p>
<p>迭代方式并不容易，因为结构比较复杂。首先想到的可能是在 <code>company</code> 上使用 <code>for</code> 循环，并在第一层部分上嵌套子循环。但是，之后我们需要更多的子循环来遍历像 <code>sites</code> 这样的二级部门的员工…… 然后，将来可能会出现在三级部门上的另一个子循环？如果我们在代码中写 3-4 级嵌套的子循环来遍历单个对象， 那代码得多丑啊。</p>
<p>我们试试递归吧。</p>
<p>我们可以看到，当我们的函数对一个部门求和时，有两种可能的情况：</p>
<ol>
<li>要么是由一 <strong>数组</strong> 的人组成的“简单”的部门 —— 这样我们就可以通过一个简单的循环来计算薪资的总和。</li>
<li>或者它是一个有 <code>N</code> 个子部门的 <strong>对象</strong> —— 那么我们可以通过 <code>N</code> 层递归调用来求每一个子部门的薪资，然后将它们合并起来。</li>
</ol>
<p>第一种情况是由一数组的人组成的部门，这种情况很简单，是最基础的递归。</p>
<p>第二种情况是我们得到的是对象。那么可将这个复杂的任务拆分成适用于更小部门的子任务。它们可能会被继续拆分，但很快或者不久就会拆分到第一种情况那样。</p>
<p>这个算法从代码来看可能会更简单：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> company = { <span class="hljs-comment">// 是同一个对象，简洁起见被压缩了</span>
  <span class="hljs-attr">sales</span>: [{<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-attr">salary</span>: <span class="hljs-number">1000</span>}, {<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-attr">salary</span>: <span class="hljs-number">1600</span> }],
  <span class="hljs-attr">development</span>: {
    <span class="hljs-attr">sites</span>: [{<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Peter&#x27;</span>, <span class="hljs-attr">salary</span>: <span class="hljs-number">2000</span>}, {<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alex&#x27;</span>, <span class="hljs-attr">salary</span>: <span class="hljs-number">1800</span> }],
    <span class="hljs-attr">internals</span>: [{<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-attr">salary</span>: <span class="hljs-number">1300</span>}]
  }
};

<span class="hljs-comment">// 用来完成任务的函数</span>
*!*
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sumSalaries</span>(<span class="hljs-params">department</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(department)) { <span class="hljs-comment">// 情况（1）</span>
    <span class="hljs-keyword">return</span> department.reduce(<span class="hljs-function">(<span class="hljs-params">prev, current</span>) =&gt;</span> prev + current.salary, <span class="hljs-number">0</span>); <span class="hljs-comment">// 求数组的和</span>
  } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 情况（2）</span>
    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> subdep <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.values(department)) {
      sum += sumSalaries(subdep); <span class="hljs-comment">// 递归调用所有子部门，对结果求和</span>
    }
    <span class="hljs-keyword">return</span> sum;
  }
}
*/!*

alert(sumSalaries(company)); <span class="hljs-comment">// 7700</span></code></pre>
<p>代码很短也容易理解（希望是这样？）。这就是递归的能力。它适用于任何层次的子部门嵌套。</p>
<p>下面是调用图：</p>
<p><img src="recursive-salaries.svg" alt="递归 salaries 的示意图"></p>
<p>我们可以很容易地看到其原理：对于对象 <code>{...}</code> 会生成子调用，而数组 <code>[...]</code> 是递归树的“叶子”，它们会立即给出结果。</p>
<p>请注意，该代码使用了我们之前讲过的智能特性（smart features）：</p>
<ul>
<li>在 <a href="info:array-methods">info:array-methods</a> 中我们介绍过的数组求和方法 <code>arr.reduce</code>。</li>
<li>使用循环 <code>for(val of Object.values(obj))</code> 遍历对象的（属性）值：<code>Object.values</code> 返回它们组成的数组。</li>
</ul>
<h2 id="递归结构">递归结构</h2>
<p>递归（递归定义的）数据结构是一种部分复制自身的结构。</p>
<p>我们刚刚在上面的公司结构的示例中看过了它。</p>
<p>一个公司的 <strong>部门</strong> 是：</p>
<ul>
<li>一数组的人。</li>
<li>或一个 <strong>部门</strong> 对象。</li>
</ul>
<p>对于 Web 开发者而言，有更熟知的例子：HTML 和 XML 文档。</p>
<p>在 HTML 文档中，一个 <strong>HTML 标签</strong> 可能包括以下内容：</p>
<ul>
<li>文本片段。</li>
<li>HTML 注释。</li>
<li>其它 <strong>HTML 标签</strong>（它有可能又包括文本片段、注释或其它标签等）。</li>
</ul>
<p>这又是一个递归定义。</p>
<p>为了更好地理解递归，我们再讲一个递归结构的例子“链表”，在某些情况下，它可能是优于数组的选择。</p>
<h3 id="链表">链表</h3>
<p>想象一下，我们要存储一个有序的对象列表。</p>
<p>正常的选择会是一个数组：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [obj1, obj2, obj3];</code></pre>
<p>……但是用数组有个问题。“删除元素”和“插入元素”的操作代价非常大。例如，<code>arr.unshift(obj)</code> 操作必须对所有元素重新编号以便为新的元素 <code>obj</code> 腾出空间，而且如果数组很大，会很耗时。<code>arr.shift()</code> 同理。</p>
<p>唯一对数组结构做修改而不需要大量重排的操作就是对数组末端的操作：<code>arr.push/pop</code>。因此，对于大队列来说，当我们必须对数组首端的元素进行操作时，数组会很慢。（译注：此处的首端操作其实指的是在尾端以外的数组内的元素进行插入/删除操作。）</p>
<p>如果我们确实需要快速插入/删除，则可以选择另一种叫做 <a href="https://en.wikipedia.org/wiki/Linked_list">链表</a> 的数据结构。</p>
<p><strong>链表元素</strong> 是一个使用以下元素通过递归定义的对象：</p>
<ul>
<li><code>value</code>。</li>
<li><code>next</code> 属性引用下一个 <strong>链表元素</strong> 或者代表末尾的 <code>null</code>。</li>
</ul>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> list = {
  <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">next</span>: {
    <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>,
    <span class="hljs-attr">next</span>: {
      <span class="hljs-attr">value</span>: <span class="hljs-number">3</span>,
      <span class="hljs-attr">next</span>: {
        <span class="hljs-attr">value</span>: <span class="hljs-number">4</span>,
        <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>
      }
    }
  }
};</code></pre>
<p>链表的图形表示：</p>
<p><img src="linked-list.svg" alt="链表"></p>
<p>一段用来创建链表的代码：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> list = { <span class="hljs-attr">value</span>: <span class="hljs-number">1</span> };
list.next = { <span class="hljs-attr">value</span>: <span class="hljs-number">2</span> };
list.next.next = { <span class="hljs-attr">value</span>: <span class="hljs-number">3</span> };
list.next.next.next = { <span class="hljs-attr">value</span>: <span class="hljs-number">4</span> };
list.next.next.next.next = <span class="hljs-literal">null</span>;</code></pre>
<p>在这儿我们可以清楚地看到，这里有很多个对象，每一个都有 <code>value</code> 和指向邻居的 <code>next</code>。变量 <code>list</code> 是链条中的第一个对象，因此顺着 <code>next</code> 指针，我们可以抵达任何元素。</p>
<p>该链表可以很容易被拆分为多个部分，然后再重新组装回去：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> secondList = list.next.next;
list.next.next = <span class="hljs-literal">null</span>;</code></pre>
<p><img src="linked-list-split.svg" alt="链表分割"></p>
<p>合并：</p>
<pre><code class="language-js">list.next.next = secondList;</code></pre>
<p>当然，我们可以在任何位置插入或移除元素。</p>
<p>比如，要添加一个新值，我们需要更新链表的头：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> list = { <span class="hljs-attr">value</span>: <span class="hljs-number">1</span> };
list.next = { <span class="hljs-attr">value</span>: <span class="hljs-number">2</span> };
list.next.next = { <span class="hljs-attr">value</span>: <span class="hljs-number">3</span> };
list.next.next.next = { <span class="hljs-attr">value</span>: <span class="hljs-number">4</span> };

*!*
<span class="hljs-comment">// 将新值添加到链表头部</span>
list = { <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;new item&quot;</span>, <span class="hljs-attr">next</span>: list };
*/!*</code></pre>
<p><img src="linked-list-0.svg" alt="链表"></p>
<p>要从中间删除一个值，可以修改前一个元素的 <code>next</code>：</p>
<pre><code class="language-js">list.next = list.next.next;</code></pre>
<p><img src="linked-list-remove-1.svg" alt="链表"></p>
<p>我们让 <code>list.next</code> 从 <code>1</code> 跳到值 <code>2</code>。现在值 <code>1</code> 就被从链表中移除了。如果它没有被存储在其它任何地方，那么它会被自动从内存中删除。</p>
<p>与数组不同，链表没有大规模重排，我们可以很容易地重新排列元素。</p>
<p>当然，链表也不总是优于数组的。不然大家就都去使用链表了。</p>
<p>链表主要的缺点就是我们无法很容易地通过元素的编号获取元素。但在数组中却很容易：<code>arr[n]</code> 是一个直接引用。而在链表中，我们需要从起点元素开始，顺着 <code>next</code> 找 <code>N</code> 次才能获取到第 N 个元素。</p>
<p>……但是我们也并不是总需要这样的操作。比如，当我们需要一个队列甚至一个 <a href="https://en.wikipedia.org/wiki/Double-ended_queue">双向队列</a> —— 有序结构必须可以快速地从两端添加/移除元素，但是不需要访问的元素。</p>
<p>链表可以得到增强：</p>
<ul>
<li>我们可以在 <code>next</code> 之外，再添加 <code>prev</code> 属性来引用前一个元素，以便轻松地往回移动。</li>
<li>我们还可以添加一个名为 <code>tail</code> 的变量，该变量引用链表的最后一个元素（并在从末尾添加/删除元素时对该引用进行更新）。</li>
<li>……数据结构可能会根据我们的需求而变化。</li>
</ul>
<h2 id="总结">总结</h2>
<p>术语：</p>
<ul>
<li><p><strong>递归</strong> 是编程的一个术语，表示从自身调用函数（译注：也就是自调用）。递归函数可用于以更优雅的方式解决问题。</p>
<p>  当一个函数调用自身时，我们称其为 <strong>递归步骤</strong>。递归的 <strong>基础</strong> 是函数参数使任务简单到该函数不再需要进行进一步调用。</p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Recursive_data_type">递归定义</a> 的数据结构是指可以使用自身来定义的数据结构。</p>
<p>  例如，链表可以被定义为由对象引用一个列表（或 <code>null</code>）而组成的数据结构。</p>
<pre><code class="language-js">list = { value, next -&gt; list }</code></pre>
<p>  像 HTML 元素树或者本章中的  <code>department</code> 树等，本质上也是递归：它们有分支，而且分支又可以有其他分支。</p>
<p>  就像我们在示例 <code>sumSalary</code> 中看到的那样，可以使用递归函数来遍历它们。</p>
</li>
</ul>
<p>任何递归函数都可以被重写为迭代（译注：也就是循环）形式。有时这是在优化代码时需要做的。但对于大多数任务来说，递归方法足够快，并且容易编写和维护。</p>

      </fieldset>
      
      <fieldset id='_ta1Ddm'>
      <legend>article</legend>
      <h1 id="rest-参数与-spread-语法">Rest 参数与 Spread 语法</h1>
<p>在 JavaScript 中，很多内建函数都支持传入任意数量的参数。</p>
<p>例如：</p>
<ul>
<li><code>Math.max(arg1, arg2, ..., argN)</code> —— 返回入参中的最大值。</li>
<li><code>Object.assign(dest, src1, ..., srcN)</code> —— 依次将属性从 <code>src1..N</code> 复制到 <code>dest</code>。</li>
<li>……等。</li>
</ul>
<p>在本章中，我们将学习如何编程实现支持函数可传入任意数量的参数。以及，如何将数组作为参数传递给这类函数。</p>
<h2 id="rest-参数-">Rest 参数 <code>...</code></h2>
<p>在 JavaScript 中，无论函数是如何定义的，你都可以使用任意数量的参数调用函数。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">return</span> a + b;
}

alert( sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>) );</code></pre>
<p>虽然这里不会因为传入“过多”的参数而报错。但是当然，在结果中只有前两个参数被计算进去了。</p>
<p>Rest 参数可以通过使用三个点 <code>...</code> 并在后面跟着包含剩余参数的数组名称，来将它们包含在函数定义中。这些点的字面意思是“将剩余参数收集到一个数组中”。</p>
<p>例如，我们需要把所有的参数都放到数组 <code>args</code> 中：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sumAll</span>(<span class="hljs-params">...args</span>) </span>{ <span class="hljs-comment">// 数组名为 args</span>
  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> arg <span class="hljs-keyword">of</span> args) sum += arg;

  <span class="hljs-keyword">return</span> sum;
}

alert( sumAll(<span class="hljs-number">1</span>) ); <span class="hljs-comment">// 1</span>
alert( sumAll(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) ); <span class="hljs-comment">// 3</span>
alert( sumAll(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) ); <span class="hljs-comment">// 6</span></code></pre>
<p>我们也可以选择获取第一个参数作为变量，并将剩余的参数收集起来。</p>
<p>下面的例子把前两个参数定义为变量，并把剩余的参数收集到 <code>titles</code> 数组中：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showName</span>(<span class="hljs-params">firstName, lastName, ...titles</span>) </span>{
  alert( firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName ); <span class="hljs-comment">// Julius Caesar</span>

  <span class="hljs-comment">// 剩余的参数被放入 titles 数组中</span>
  <span class="hljs-comment">// i.e. titles = [&quot;Consul&quot;, &quot;Imperator&quot;]</span>
  alert( titles[<span class="hljs-number">0</span>] ); <span class="hljs-comment">// Consul</span>
  alert( titles[<span class="hljs-number">1</span>] ); <span class="hljs-comment">// Imperator</span>
  alert( titles.length ); <span class="hljs-comment">// 2</span>
}

showName(<span class="hljs-string">&quot;Julius&quot;</span>, <span class="hljs-string">&quot;Caesar&quot;</span>, <span class="hljs-string">&quot;Consul&quot;</span>, <span class="hljs-string">&quot;Imperator&quot;</span>);</code></pre>
<pre><code class="language-warn">Rest 参数会收集剩余的所有参数，因此下面这种用法没有意义，并且会导致错误：

```js
function f(arg1, ...rest, arg2) { // arg2 在 ...rest 后面？！
  // error
}
```

`...rest` 必须处在最后。</code></pre>
<h2 id="arguments-变量">&quot;arguments&quot; 变量</h2>
<p>有一个名为 <code>arguments</code> 的特殊的类数组对象，该对象按参数索引包含所有参数。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showName</span>(<span class="hljs-params"></span>) </span>{
  alert( <span class="hljs-built_in">arguments</span>.length );
  alert( <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] );
  alert( <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] );

  <span class="hljs-comment">// 它是可遍历的</span>
  <span class="hljs-comment">// for(let arg of arguments) alert(arg);</span>
}

<span class="hljs-comment">// 依次显示：2，Julius，Caesar</span>
showName(<span class="hljs-string">&quot;Julius&quot;</span>, <span class="hljs-string">&quot;Caesar&quot;</span>);

<span class="hljs-comment">// 依次显示：1，Ilya，undefined（没有第二个参数）</span>
showName(<span class="hljs-string">&quot;Ilya&quot;</span>);</code></pre>
<p>在过去，JavaScript 中没有 rest 参数，而使用 <code>arguments</code> 是获取函数所有参数的唯一方法。现在它仍然有效，我们可以在一些老代码里找到它。</p>
<p>但缺点是，尽管 <code>arguments</code> 是一个类数组，也是可迭代对象，但它终究不是数组。它不支持数组方法，因此我们不能调用 <code>arguments.map(...)</code> 等方法。</p>
<p>此外，它始终包含所有参数，我们不能像使用 rest 参数那样只截取入参的一部分。</p>
<p>因此，当我们需要这些功能时，最好使用 rest 参数。</p>
<p>````smart header=&quot;箭头函数是没有 <code>\&quot;arguments\&quot;</code>&quot;
如果我们在箭头函数中访问 <code>arguments</code>，访问到的 <code>arguments</code> 并不属于箭头函数，而是属于箭头函数外部的“普通”函数。</p>
<p>举个例子：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> showArg = <span class="hljs-function">() =&gt;</span> alert(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]);
  showArg();
}

f(<span class="hljs-number">1</span>); <span class="hljs-comment">// 1</span></code></pre>
<p>我们已经知道，箭头函数没有自身的 <code>this</code>。现在我们知道了它们也没有特殊的 <code>arguments</code> 对象。</p>
<pre><code>

## Spread 语法 [#spread-syntax]

我们刚刚看到了如何从参数列表中获取数组。

不过有时候我们也需要做与之相反的事儿。

例如，内建函数 [Math.max](mdn:js/Math/max) 会返回参数中最大的值：

```js run
alert( Math.max(3, 5, 1) ); // 5
```

假如我们有一个数组 `[3, 5, 1]`，我们该如何用它调用 `Math.max` 呢？

直接把数组“原样”传入是不会奏效的，因为 `Math.max` 希望你传入一个列表形式的数值型参数，而不是一个数组：

```js run
let arr = [3, 5, 1];

*!*
alert( Math.max(arr) ); // NaN
*/!*
```

毫无疑问，我们不可能手动地去一一设置参数 `Math.max(arg[0], arg[1], arg[2])`，因为我们不确定这儿有多少个。在脚本执行时，可能参数数组中有很多个元素，也可能一个都没有。并且这样设置的代码也很丑。

**Spread 语法** 来帮助你了！它看起来和 rest 参数很像，也使用 `...`，但是二者的用途完全相反。

当在函数调用中使用 `...arr` 时，它会把可迭代对象 `arr` “展开”到参数列表中。

以 `Math.max` 为例：

```js run
let arr = [3, 5, 1];

alert( Math.max(...arr) ); // 5（spread 语法把数组转换为参数列表）
```

我们还可以通过这种方式传递多个可迭代对象：

```js run
let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];

alert( Math.max(...arr1, ...arr2) ); // 8
```

我们甚至还可以将 spread 语法与常规值结合使用：


```js run
let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];

alert( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25
```

并且，我们还可以使用 spread 语法来合并数组：

```js run
let arr = [3, 5, 1];
let arr2 = [8, 9, 15];

*!*
let merged = [0, ...arr, 2, ...arr2];
*/!*

alert(merged); // 0,3,5,1,2,8,9,15（0，然后是 arr，然后是 2，然后是 arr2）
```

在上面的示例中，我们使用数组展示了 spread 语法，其实任何可迭代对象都可以。

例如，在这儿我们使用 spread 语法将字符串转换为字符数组：

```js run
let str = &quot;Hello&quot;;

alert( [...str] ); // H,e,l,l,o
```

Spread 语法内部使用了迭代器来收集元素，与 `for..of` 的方式相同。

因此，对于一个字符串，`for..of` 会逐个返回该字符串中的字符，`...str` 也同理会得到 `&quot;H&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;` 这样的结果。随后，字符列表被传递给数组初始化器 `[...str]`。

对于这个特定任务，我们还可以使用 `Array.from` 来实现，因为该方法会将一个可迭代对象（如字符串）转换为数组：

```js run
let str = &quot;Hello&quot;;

// Array.from 将可迭代对象转换为数组
alert( Array.from(str) ); // H,e,l,l,o
```

运行结果与 `[...str]` 相同。

不过 `Array.from(obj)` 和 `[...obj]` 存在一个细微的差别：

- `Array.from` 适用于类数组对象也适用于可迭代对象。
- Spread 语法只适用于可迭代对象。

因此，对于将一些“东西”转换为数组的任务，`Array.from` 往往更通用。


## 获取一个 array/object 的副本

还记得我们 [之前讲过的](info:object-copy#fu-zhi-he-he-bing-objectassign) `Object.assign()` 吗？

使用 spread 语法也可以做同样的事情。

```js run
let arr = [1, 2, 3];
let arrCopy = [...arr]; // 将数组 spread 到参数列表中
                        // 然后将结果放到一个新数组

// 两个数组中的内容相同吗？
alert(JSON.stringify(arr) === JSON.stringify(arrCopy)); // true

// 两个数组相等吗？
alert(arr === arrCopy); // false（它们的引用是不同的）

// 修改我们初始的数组不会修改副本：
arr.push(4);
alert(arr); // 1, 2, 3, 4
alert(arrCopy); // 1, 2, 3
```

并且，也可以通过相同的方式来复制一个对象：

```js run
let obj = { a: 1, b: 2, c: 3 };
let objCopy = { ...obj }; // 将对象 spread 到参数列表中
                          // 然后将结果返回到一个新对象

// 两个对象中的内容相同吗？
alert(JSON.stringify(obj) === JSON.stringify(objCopy)); // true

// 两个对象相等吗？
alert(obj === objCopy); // false (not same reference)

// 修改我们初始的对象不会修改副本：
obj.d = 4;
alert(JSON.stringify(obj)); // {&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3,&quot;d&quot;:4}
alert(JSON.stringify(objCopy)); // {&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3}
```

这种方式比使用 `let arrCopy = Object.assign([], arr);` 来复制数组，或使用 `let objCopy = Object.assign({}, obj);` 来复制对象写起来要短得多。因此，只要情况允许，我们更喜欢使用它。


## 总结

当我们在代码中看到 `&quot;...&quot;` 时，它要么是 rest 参数，要么就是 spread 语法。

有一个简单的方法可以区分它们：

- 若 `...` 出现在函数参数列表的最后，那么它就是 rest 参数，它会把参数列表中剩余的参数收集到一个数组中。
- 若 `...` 出现在函数调用或类似的表达式中，那它就是 spread 语法，它会把一个数组展开为列表。

使用场景：

- Rest 参数用于创建可接受任意数量参数的函数。
- Spread 语法用于将数组传递给通常需要含有许多参数的列表的函数。

它们俩的出现帮助我们轻松地在列表和参数数组之间来回转换。

“旧式”的 `arguments`（类数组且可迭代的对象）也依然能够帮助我们获取函数调用中的所有参数。</code></pre>

      </fieldset>
      
      <fieldset id='_Hw0qMo'>
      <legend>solution</legend>
      <p>答案：<strong>Pete</strong>。</p>
<p>函数将从内到外依次在对应的词法环境中寻找目标变量，它使用最新的值。</p>
<p>旧变量值不会保存在任何地方。当一个函数想要一个变量时，它会从自己的词法环境或外部词法环境中获取当前值。</p>

      </fieldset>
      
      <fieldset id='_MMawPg'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="函数会选择最新的内容吗？">函数会选择最新的内容吗？</h1>
<p>函数 sayHi 使用外部变量。当函数运行时，将使用哪个值？</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;John&quot;</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-string">&quot;Hi, &quot;</span> + name);
}

name = <span class="hljs-string">&quot;Pete&quot;</span>;

sayHi(); <span class="hljs-comment">// 会显示什么：&quot;John&quot; 还是 &quot;Pete&quot;？</span></code></pre>
<p>这种情况在浏览器和服务器端开发中都很常见。一个函数可能被计划在创建之后一段时间后才执行，例如在用户行为或网络请求之后。</p>
<p>因此，问题是：它会接收最新的修改吗？</p>

      </fieldset>
      
      <fieldset id='_KTfQQQ'>
      <legend>solution</legend>
      <p>让我们检查一下 <code>makeArmy</code> 内部做了什么，那么答案就显而易见了。</p>
<ol>
<li><p>它创建了一个空数组 <code>shooters</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> shooters = [];</code></pre>
</li>
<li><p>在循环中，通过 <code>shooters.push(function...)</code> 填充它（数组）。</p>
<p> 每个元素都是函数，所以数组看起来是这样的：</p>
<pre><code class="language-js">shooters = [
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ alert(i); },
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ alert(i); },
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ alert(i); },
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ alert(i); },
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ alert(i); },
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ alert(i); },
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ alert(i); },
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ alert(i); },
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ alert(i); },
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ alert(i); }
];</code></pre>
</li>
<li><p>该数组返回自函数。</p>
</li>
</ol>
<p>随后，<code>army[5]()</code> 从数组中获得元素 <code>army[5]</code>（函数）并调用。</p>
<p>为什么现在所有函数显示的都一样呢？</p>
<p>这是因为 <code>shooter</code> 函数内没有局部变量 <code>i</code>。当调用一个这样的函数时，<code>i</code> 是来自于外部词法环境的。</p>
<p><code>i</code> 的值是什么呢？</p>
<p>如果我们查看一下源头：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeArmy</span>(<span class="hljs-params"></span>) </span>{
  ...
  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">10</span>) {
    <span class="hljs-keyword">let</span> shooter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// shooter 函数</span>
      alert( i ); <span class="hljs-comment">// 应该显示它自己的编号</span>
    };
    ...
  }
  ...
}</code></pre>
<p>……我们可以看到它存在于当前 <code>makeArmy()</code> 运行相关的词法环境中。但调用 <code>army[5]()</code> 时，<code>makeArmy</code> 已经完运行完了，<code>i</code> 现在为结束时的值：<code>10</code>（<code>while</code> 结束时）。</p>
<p>因此，所有的 <code>shooter</code> 获得的都是外部词法环境中的同一个值，即最后的 <code>i=10</code>。</p>
<p>我们可以通过将变量定义移动到循环中来修复它：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeArmy</span>(<span class="hljs-params"></span>) </span>{

  <span class="hljs-keyword">let</span> shooters = [];

*!*
  <span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++</span>)</span> {
*/!*
    <span class="hljs-keyword">let</span> shooter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// shooter 函数</span>
      alert( i ); <span class="hljs-comment">// 应该显示它自己的编号</span>
    };
    shooters.push(shooter);
  }

  <span class="hljs-keyword">return</span> shooters;
}

<span class="hljs-keyword">let</span> army = makeArmy();

army[<span class="hljs-number">0</span>](); <span class="hljs-comment">// 0</span>
army[<span class="hljs-number">5</span>](); <span class="hljs-comment">// 5</span></code></pre>
<p>现在正常工作了，因为每次执行代码块 <code>for (let i=0...) {...}</code> 中的代码时，都会为其创建一个新的词法环境，其中具有对应的 <code>i</code> 值。</p>
<p>所以，现在 <code>i</code> 值的位置更近了（译注：指转到了更内部的词法环境）。现在它不是在 <code>makeArmy()</code> 的词法环境中，而是在与当前循环迭代相对应的词法环境中。这就是它为什么现在可以正常工作了。</p>
<p><img src="lexenv-makearmy.svg" alt=""></p>
<p>这里我们把 <code>while</code> 改写为了 <code>for</code>。</p>
<p>其他技巧也是可以的，让我们了解一下，以便更好地理解这个问题：</p>
<pre><code class="language-js">function makeArmy() {
  let shooters = [];

  let i = 0;
  while (i &lt; 10) {
*!*
    let j = i;
*/!*
    let shooter = function() { // shooter 函数
      alert( *!*j*/!* ); // 应该显示当前的编号
    };
    shooters.push(shooter);
    i++;
  }

  return shooters;
}

let army = makeArmy();

army[0](); // 0
army[5](); // 5</code></pre>
<p><code>while</code> 和 <code>for</code> 循环差不多，每次运行都会创建了一个新的词法环境。所以在这里我们能确保 <code>shooter</code> 能够获取正确的值。</p>
<p>我们复制 <code>let j = i</code>。这个操作创建了循环体局部变量 <code>j</code>，并将 <code>i</code> 的值复制给了它。原始值是按值传递的，所以实际上，我们获得了属于当前循环迭代的完全独立的 <code>i</code> 的副本。</p>

      </fieldset>
      
      <fieldset id='_nWuTRC'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="函数大军">函数大军</h1>
<p>下列的代码创建一个 <code>shooters</code> 数组。</p>
<p>每个函数都应该输出其编号。但好像出了点问题……</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeArmy</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> shooters = [];

  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">10</span>) {
    <span class="hljs-keyword">let</span> shooter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// shooter 函数</span>
      alert( i ); <span class="hljs-comment">// 应该显示其编号</span>
    };
    shooters.push(shooter);
    i++;
  }

  <span class="hljs-keyword">return</span> shooters;
}

<span class="hljs-keyword">let</span> army = makeArmy();

army[<span class="hljs-number">0</span>](); <span class="hljs-comment">// 编号为 0 的 shooter 值为 10</span>
army[<span class="hljs-number">5</span>](); <span class="hljs-comment">// 编号为 5 的 shooter 值也是 10……</span>
<span class="hljs-comment">// ... 所有的 shooter 的值都是 10，而不是他们的编号 0, 1, 2, 3...</span></code></pre>
<p>为什么所有的 shooter 显示同样的值？修改代码以让代码正常工作。</p>

      </fieldset>
      
      <fieldset id='_vKsn35'>
      <legend>solution</legend>
      <p>答案：<strong>Pete</strong>.</p>
<p>下方代码中的函数 <code>work()</code> 在其被创建的位置通过外部词法环境引用获取 <code>name</code>：</p>
<p><img src="lexenv-nested-work.svg" alt=""></p>
<p>所以这里的结果是 <code>&quot;Pete&quot;</code>。</p>
<p>但如果在 <code>makeWorker()</code> 中没有 <code>let name</code>，那么将继续向外搜索并最终找到全局变量，正如我们可以从上图中看到的那样。在这种情况下，结果将是 <code>&quot;John&quot;</code>。</p>

      </fieldset>
      
      <fieldset id='_agPl6k'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="哪些变量可用呢？">哪些变量可用呢？</h1>
<p>下面的 <code>makeWorker</code> 函数创建了另一个函数并返回该函数。可以在其他地方调用这个新函数。</p>
<p>它是否可以从它被创建的位置或调用位置（或两者）访问外部变量？</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeWorker</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;Pete&quot;</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    alert(name);
  };
}

<span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;John&quot;</span>;

<span class="hljs-comment">// create a function</span>
<span class="hljs-keyword">let</span> work = makeWorker();

<span class="hljs-comment">// call it</span>
work(); <span class="hljs-comment">// 会显示什么？</span></code></pre>
<p>会显示哪个值？&quot;Pete&quot; 还是 &quot;John&quot;？</p>

      </fieldset>
      
      <fieldset id='_m6W5vr'>
      <legend>solution</legend>
      <p>答案是：<strong>0，1。</strong></p>
<p>函数 <code>counter</code> 和 <code>counter2</code> 是通过 <code>makeCounter</code> 的不同调用创建的。</p>
<p>因此，它们具有独立的外部词法环境，每一个都有自己的 <code>count</code>。</p>

      </fieldset>
      
      <fieldset id='_DS2Z6j'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="counter-是独立的吗？">Counter 是独立的吗？</h1>
<p>在这儿我们用相同的 <code>makeCounter</code> 函数创建了两个计数器（counters）：<code>counter</code> 和 <code>counter2</code>。</p>
<p>它们是独立的吗？第二个 counter 会显示什么？<code>0,1</code> 或 <code>2,3</code> 还是其他？</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeCounter</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> count++;
  };
}

<span class="hljs-keyword">let</span> counter = makeCounter();
<span class="hljs-keyword">let</span> counter2 = makeCounter();

alert( counter() ); <span class="hljs-comment">// 0</span>
alert( counter() ); <span class="hljs-comment">// 1</span>

*!*
alert( counter2() ); <span class="hljs-comment">// ?</span>
alert( counter2() ); <span class="hljs-comment">// ?</span>
*/!*</code></pre>

      </fieldset>
      
      <fieldset id='_egmyQZ'>
      <legend>solution</legend>
      <p>当然行得通。</p>
<p>这两个嵌套函数都是在同一个词法环境中创建的，所以它们可以共享对同一个 count 变量的访问：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;

  <span class="hljs-built_in">this</span>.up = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> ++count;
  };

  <span class="hljs-built_in">this</span>.down = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> --count;
  };
}

<span class="hljs-keyword">let</span> counter = <span class="hljs-keyword">new</span> Counter();

alert( counter.up() ); <span class="hljs-comment">// 1</span>
alert( counter.up() ); <span class="hljs-comment">// 2</span>
alert( counter.down() ); <span class="hljs-comment">// 1</span></code></pre>

      </fieldset>
      
      <fieldset id='_MDpjbW'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="counter-对象">Counter 对象</h1>
<p>这里通过构造函数创建了一个 counter 对象。</p>
<p>它能正常工作吗？它会显示什么呢？</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;

  <span class="hljs-built_in">this</span>.up = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> ++count;
  };
  <span class="hljs-built_in">this</span>.down = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> --count;
  };
}

<span class="hljs-keyword">let</span> counter = <span class="hljs-keyword">new</span> Counter();

alert( counter.up() ); <span class="hljs-comment">// ?</span>
alert( counter.up() ); <span class="hljs-comment">// ?</span>
alert( counter.down() ); <span class="hljs-comment">// ?</span></code></pre>

      </fieldset>
      
      <fieldset id='_bAHNsS'>
      <legend>solution</legend>
      <p>答案：<strong>error</strong>。</p>
<p>函数 <code>sayHi</code> 是在 <code>if</code> 内声明的，所以它只存在于 <code>if</code> 中。外部是没有 <code>sayHi</code> 的。</p>

      </fieldset>
      
      <fieldset id='_ZBJNN0'>
      <legend>task</legend>
      <h1 id="if-内的函数">if 内的函数</h1>
<p>看看下面这个代码。最后一行代码的执行结果是什么？</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> phrase = <span class="hljs-string">&quot;Hello&quot;</span>;

<span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">let</span> user = <span class="hljs-string">&quot;John&quot;</span>;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>{
    alert(<span class="hljs-string">`<span class="hljs-subst">${phrase}</span>, <span class="hljs-subst">${user}</span>`</span>);
  }
}

*!*
sayHi();
*/!*</code></pre>

      </fieldset>
      
      <fieldset id='_9Pw602'>
      <legend>solution</legend>
      <p>为了使第二个括号有效，第一个（括号）必须返回一个函数。</p>
<p>就像这样：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a</span>) </span>{

  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">b</span>) </span>{
    <span class="hljs-keyword">return</span> a + b; <span class="hljs-comment">// 从外部词法环境获得 &quot;a&quot;</span>
  };

}

alert( sum(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>) ); <span class="hljs-comment">// 3</span>
alert( sum(<span class="hljs-number">5</span>)(-<span class="hljs-number">1</span>) ); <span class="hljs-comment">// 4</span></code></pre>

      </fieldset>
      
      <fieldset id='_gKFutt'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="闭包-sum">闭包 sum</h1>
<p>编写一个像 <code>sum(a)(b) = a+b</code> 这样工作的 <code>sum</code> 函数。</p>
<p>是的，就是这种通过双括号的方式（并不是错误）。</p>
<p>举个例子：</p>
<pre><code class="language-js">sum(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>) = <span class="hljs-number">3</span>
sum(<span class="hljs-number">5</span>)(-<span class="hljs-number">1</span>) = <span class="hljs-number">4</span></code></pre>

      </fieldset>
      
      <fieldset id='_hrP4rI'>
      <legend>solution</legend>
      <p>答案：<strong>error</strong>。</p>
<p>你运行一下试试：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>{
*!*
  <span class="hljs-built_in">console</span>.log(x); <span class="hljs-comment">// ReferenceError: Cannot access &#x27;x&#x27; before initialization</span>
*/!*
  <span class="hljs-keyword">let</span> x = <span class="hljs-number">2</span>;
}

func();</code></pre>
<p>在这个例子中，我们可以观察到“不存在”的变量和“未初始化”的变量之间的特殊差异。</p>
<p>你可能已经在 <a href="info:closure"></a> 中学过了，从程序执行进入代码块（或函数）的那一刻起，变量就开始进入“未初始化”状态。它一直保持未初始化状态，直至程序执行到相应的 <code>let</code> 语句。</p>
<p>换句话说，一个变量从技术的角度来讲是存在的，但是在 <code>let</code> 之前还不能使用。</p>
<p>下面的这段代码证实了这一点。</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>{
*!*
  <span class="hljs-comment">// 引擎从函数开始就知道局部变量 x，</span>
  <span class="hljs-comment">// 但是变量 x 一直处于“未初始化”（无法使用）的状态，直到结束 let（“死区”）</span>
  <span class="hljs-comment">// 因此答案是 error</span>
*/!*

  <span class="hljs-built_in">console</span>.log(x); <span class="hljs-comment">// ReferenceError: Cannot access &#x27;x&#x27; before initialization</span>

  <span class="hljs-keyword">let</span> x = <span class="hljs-number">2</span>;
}</code></pre>
<p>变量暂时无法使用的区域（从代码块的开始到 <code>let</code>）有时被称为“死区”。</p>

      </fieldset>
      
      <fieldset id='_PMuh7l'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="变量可见吗？">变量可见吗？</h1>
<p>下面这段代码的结果会是什么？</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(x); <span class="hljs-comment">// ?</span>

  <span class="hljs-keyword">let</span> x = <span class="hljs-number">2</span>;
}

func();</code></pre>
<p>P.S. 这个任务有一个陷阱。解决方案并不明显。</p>

      </fieldset>
      
      <fieldset id='_yfTN2f'>
      <legend>solution</legend>
      <h1 id="inbetween-筛选器">inBetween 筛选器</h1>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inBetween</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{
    <span class="hljs-keyword">return</span> x &gt;= a &amp;&amp; x &lt;= b;
  };
}

<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>];
alert( arr.filter(inBetween(<span class="hljs-number">3</span>, <span class="hljs-number">6</span>)) ); <span class="hljs-comment">// 3,4,5,6</span></code></pre>
<h1 id="inarray-筛选器">inArray 筛选器</h1>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inArray</span>(<span class="hljs-params">arr</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{
    <span class="hljs-keyword">return</span> arr.includes(x);
  };
}

<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>];
alert( arr.filter(inArray([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>])) ); <span class="hljs-comment">// 1,2</span></code></pre>

      </fieldset>
      
      <fieldset id='_fohcp1'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="通过函数筛选">通过函数筛选</h1>
<p>我们有一个内建的数组方法 <code>arr.filter(f)</code>。它通过函数 <code>f</code> 过滤元素。如果它返回 <code>true</code>，那么该元素会被返回到结果数组中。</p>
<p>制造一系列“即用型”过滤器：</p>
<ul>
<li><code>inBetween(a, b)</code> —— 在 <code>a</code> 和 <code>b</code> 之间或与它们相等（包括）。</li>
<li><code>inArray([...])</code> —— 包含在给定的数组中。</li>
</ul>
<p>用法如下所示：</p>
<ul>
<li><code>arr.filter(inBetween(3,6))</code> —— 只挑选范围在 3 到 6 的值。</li>
<li><code>arr.filter(inArray([1,2,3]))</code> —— 只挑选与 <code>[1,2,3]</code> 中的元素匹配的元素。</li>
</ul>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-comment">/* .. inBetween 和 inArray 的代码 */</span>
<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>];

alert( arr.filter(inBetween(<span class="hljs-number">3</span>, <span class="hljs-number">6</span>)) ); <span class="hljs-comment">// 3,4,5,6</span>

alert( arr.filter(inArray([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>])) ); <span class="hljs-comment">// 1,2</span></code></pre>

      </fieldset>
      
      <fieldset id='_9RZeg8'>
      <legend>solution</legend>
      
      </fieldset>
      
      <fieldset id='_9iVNUX'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="按字段排序">按字段排序</h1>
<p>我们有一组要排序的对象：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> users = [
  { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">surname</span>: <span class="hljs-string">&quot;Johnson&quot;</span> },
  { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Pete&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>, <span class="hljs-attr">surname</span>: <span class="hljs-string">&quot;Peterson&quot;</span> },
  { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Ann&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">19</span>, <span class="hljs-attr">surname</span>: <span class="hljs-string">&quot;Hathaway&quot;</span> }
];</code></pre>
<p>通常的做法应该是这样的：</p>
<pre><code class="language-js"><span class="hljs-comment">// 通过 name (Ann, John, Pete)</span>
users.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.name &gt; b.name ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>);

<span class="hljs-comment">// 通过 age (Pete, Ann, John)</span>
users.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.age &gt; b.age ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>);</code></pre>
<p>我们可以让它更加简洁吗，比如这样？</p>
<pre><code class="language-js">users.sort(byField(<span class="hljs-string">&#x27;name&#x27;</span>));
users.sort(byField(<span class="hljs-string">&#x27;age&#x27;</span>));</code></pre>
<p>这样我们就只需要写 <code>byField(fieldName)</code>，而不是写一个函数。</p>
<p>编写函数 <code>byField</code> 来实现这个需求。</p>

      </fieldset>
      
      <fieldset id='_nxyYKB'>
      <legend>article</legend>
      <h1 id="闭包">闭包</h1>
<p>JavaScript 是一种非常面向函数的语言。它给了我们很大的自由度。在 JavaScript 中，我们可以动态创建函数，可以将函数作为参数传递给另一个函数，并在完全不同的代码位置进行调用。</p>
<p>我们已经知道函数可以访问其外部的变量。</p>
<p>现在，让我们扩展知识，来看看更复杂的场景。</p>
<p>```smart header=&quot;我们将在这探讨一下 <code>let/const</code>&quot;
在 JavaScript 中，有三种声明变量的方式：<code>let</code>，<code>const</code>（现代方式），<code>var</code>（过去留下来的方式）。</p>
<ul>
<li>在本文的示例中，我们将使用 <code>let</code> 声明变量。</li>
<li>用 <code>const</code> 声明的变量的行为也相同（译注：与 <code>let</code> 在作用域等特性上是相同的），因此，本文也涉及用 <code>const</code> 进行变量声明。</li>
<li>旧的 <code>var</code> 与上面两个有着明显的区别，我们将在 <a href="info:var">info:var</a> 中详细介绍。<pre><code></code></pre>
</li>
</ul>
<h2 id="代码块">代码块</h2>
<p>如果在代码块 <code>{...}</code> 内声明了一个变量，那么这个变量只在该代码块内可见。</p>
<p>例如：</p>
<pre><code class="language-js">{
  <span class="hljs-comment">// 使用在代码块外不可见的局部变量做一些工作</span>

  <span class="hljs-keyword">let</span> message = <span class="hljs-string">&quot;Hello&quot;</span>; <span class="hljs-comment">// 只在此代码块内可见</span>

  alert(message); <span class="hljs-comment">// Hello</span>
}

alert(message); <span class="hljs-comment">// Error: message is not defined</span></code></pre>
<p>我们可以使用它来隔离一段代码，该段代码执行自己的任务，并使用仅属于自己的变量：</p>
<pre><code class="language-js">{
  <span class="hljs-comment">// 显示 message</span>
  <span class="hljs-keyword">let</span> message = <span class="hljs-string">&quot;Hello&quot;</span>;
  alert(message);
}

{
  <span class="hljs-comment">// 显示另一个 message</span>
  <span class="hljs-keyword">let</span> message = <span class="hljs-string">&quot;Goodbye&quot;</span>;
  alert(message);
}</code></pre>
<pre><code class="language-smart">请注意，如果我们使用 `let` 对已存在的变量进行重复声明，如果对应的变量没有单独的代码块，则会出现错误：

```js run
// 显示 message
let message = &quot;Hello&quot;;
alert(message);

// 显示另一个 message
*!*
let message = &quot;Goodbye&quot;; // Error: variable already declared
*/!*
alert(message);
```</code></pre>
<p>对于 <code>if</code>，<code>for</code> 和 <code>while</code> 等，在 <code>{...}</code> 中声明的变量也仅在内部可见：</p>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">let</span> phrase = <span class="hljs-string">&quot;Hello!&quot;</span>;

  alert(phrase); <span class="hljs-comment">// Hello!</span>
}

alert(phrase); <span class="hljs-comment">// Error, no such variable!</span></code></pre>
<p>在这儿，当 <code>if</code> 执行完毕，则下面的 <code>alert</code> 将看不到 <code>phrase</code>，因此会出现错误。（译注：就算下面的 <code>alert</code> 想在 <code>if</code> 没执行完成时去取 <code>phrase</code>（虽然这种情况不可能发生）也是取不到的，因为 <code>let</code> 声明的变量在代码块外不可见。）</p>
<p>太好了，因为这就允许我们创建特定于 <code>if</code> 分支的块级局部变量。</p>
<p>对于 <code>for</code> 和 <code>while</code> 循环也是如此：</p>
<pre><code class="language-js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {
  <span class="hljs-comment">// 变量 i 仅在这个 for 循环的内部可见</span>
  alert(i); <span class="hljs-comment">// 0，然后是 1，然后是 2</span>
}

alert(i); <span class="hljs-comment">// Error, no such variable</span></code></pre>
<p>从视觉上看，<code>let i</code> 位于 <code>{...}</code> 之外。但是 <code>for</code> 构造在这里很特殊：在其中声明的变量被视为块的一部分。</p>
<h2 id="嵌套函数">嵌套函数</h2>
<p>当一个函数是在另一个函数中创建的时，那么该函数就被称为“嵌套”的。</p>
<p>在 JavaScript 中很容易实现这一点。</p>
<p>我们可以使用嵌套来组织代码，比如这样：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHiBye</span>(<span class="hljs-params">firstName, lastName</span>) </span>{

  <span class="hljs-comment">// 辅助嵌套函数使用如下</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFullName</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&quot; &quot;</span> + lastName;
  }

  alert( <span class="hljs-string">&quot;Hello, &quot;</span> + getFullName() );
  alert( <span class="hljs-string">&quot;Bye, &quot;</span> + getFullName() );

}</code></pre>
<p>这里创建的 <strong>嵌套</strong> 函数 <code>getFullName()</code> 是为了更加方便。它可以访问外部变量，因此可以返回全名。嵌套函数在 JavaScript 中很常见。</p>
<p>更有意思的是，可以返回一个嵌套函数：作为一个新对象的属性或作为结果返回。之后可以在其他地方使用。不论在哪里调用，它仍然可以访问相同的外部变量。</p>
<p>下面的 <code>makeCounter</code> 创建了一个 &quot;counter&quot; 函数，该函数在每次调用时返回下一个数字：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeCounter</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> count++;
  };
}

<span class="hljs-keyword">let</span> counter = makeCounter();

alert( counter() ); <span class="hljs-comment">// 0</span>
alert( counter() ); <span class="hljs-comment">// 1</span>
alert( counter() ); <span class="hljs-comment">// 2</span></code></pre>
<p>尽管很简单，但稍加变型就具有很强的实际用途，比如，用作 <a href="https://en.wikipedia.org/wiki/Pseudorandom_number_generator">随机数生成器</a> 以生成用于自动化测试的随机数值。</p>
<p>这是如何运作的呢？如果我们创建多个计数器，它们会是独立的吗？这里的变量是怎么回事？</p>
<p>理解这些内容对于掌握 JavaScript 的整体知识很有帮助，并且对于应对更复杂的场景也很有益处。因此，让我们继续深入探究。</p>
<h2 id="词法环境">词法环境</h2>
<pre><code class="language-warn">深入的技术讲解就在下面。

尽管我很想避免编程语言的一些底层细节，但是如果没有这些细节，它们就不完整，所以请准备开始学习吧！</code></pre>
<p>为了使内容更清晰，这里将分步骤进行讲解。</p>
<h3 id="step-1-变量">Step 1. 变量</h3>
<p>在 JavaScript 中，每个运行的函数，代码块 <code>{...}</code> 以及整个脚本，都有一个被称为 <strong>词法环境（Lexical Environment）</strong> 的内部（隐藏）的关联对象。</p>
<p>词法环境对象由两部分组成：</p>
<ol>
<li><strong>环境记录（Environment Record）</strong> —— 一个存储所有局部变量作为其属性（包括一些其他信息，例如 <code>this</code> 的值）的对象。</li>
<li>对 <strong>外部词法环境</strong> 的引用，与外部代码相关联。</li>
</ol>
<p>一个“变量”只是 <strong>环境记录</strong> 这个特殊的内部对象的一个属性。“获取或修改变量”意味着“获取或修改词法环境的一个属性”。</p>
<p>举个例子，这段没有函数的简单的代码中只有一个词法环境：</p>
<p><img src="lexical-environment-global.svg" alt="lexical environment"></p>
<p>这就是所谓的与整个脚本相关联的 <strong>全局</strong> 词法环境。</p>
<p>在上面的图片中，矩形表示环境记录（变量存储），箭头表示外部引用。全局词法环境没有外部引用，所以箭头指向了 <code>null</code>。</p>
<p>随着代码开始并继续运行，词法环境发生了变化。</p>
<p>这是更长的代码：</p>
<p><img src="closure-variable-phrase.svg" alt="lexical environment"></p>
<p>右侧的矩形演示了执行过程中全局词法环境的变化：</p>
<ol>
<li>当脚本开始运行，词法环境预先填充了所有声明的变量。<ul>
<li>最初，它们处于“未初始化（Uninitialized）”状态。这是一种特殊的内部状态，这意味着引擎知道变量，但是在用 <code>let</code> 声明前，不能引用它。几乎就像变量不存在一样。</li>
</ul>
</li>
<li>然后 <code>let phrase</code> 定义出现了。它尚未被赋值，因此它的值为 <code>undefined</code>。从这一刻起，我们就可以使用变量了。</li>
<li><code>phrase</code> 被赋予了一个值。</li>
<li><code>phrase</code> 的值被修改。</li>
</ol>
<p>现在看起来都挺简单的，是吧？</p>
<ul>
<li>变量是特殊内部对象的属性，与当前正在执行的（代码）块/函数/脚本有关。</li>
<li>操作变量实际上是操作该对象的属性。</li>
</ul>
<pre><code class="language-smart">“词法环境”是一个规范对象（specification object）：它仅仅是存在于 [编程语言规范](https://tc39.es/ecma262/#sec-lexical-environments) 中的“理论上”存在的，用于描述事物如何运作的对象。我们无法在代码中获取该对象并直接对其进行操作。

但 JavaScript 引擎同样可以优化它，比如清除未被使用的变量以节省内存和执行其他内部技巧等，但显性行为应该是和上述的无差。</code></pre>
<h3 id="step-2-函数声明">Step 2. 函数声明</h3>
<p>一个函数其实也是一个值，就像变量一样。</p>
<p><strong>不同之处在于函数声明的初始化会被立即完成。</strong></p>
<p>当创建了一个词法环境（Lexical Environment）时，函数声明会立即变为即用型函数（不像 <code>let</code> 那样直到声明处才可用）。</p>
<p>这就是为什么我们可以在（函数声明）的定义之前调用函数声明。</p>
<p>例如，这是添加一个函数时全局词法环境的初始状态：</p>
<p><img src="closure-function-declaration.svg" alt=""></p>
<p>正常来说，这种行为仅适用于函数声明，而不适用于我们将函数分配给变量的函数表达式，例如 <code>let say = function(name)...</code>。</p>
<h3 id="step-3-内部和外部的词法环境">Step 3. 内部和外部的词法环境</h3>
<p>在一个函数运行时，在调用刚开始时，会自动创建一个新的词法环境以存储这个调用的局部变量和参数。</p>
<p>例如，对于 <code>say(&quot;John&quot;)</code>，它看起来像这样（当前执行位置在箭头标记的那一行上）：</p>
<!--
    ```js
    let phrase = "Hello";

    function say(name) {
     alert( `${phrase}, ${name}` );
    }

    say("John"); // Hello, John
    ```-->

<p><img src="lexical-environment-simple.svg" alt=""></p>
<p>在这个函数调用期间，我们有两个词法环境：内部一个（用于函数调用）和外部一个（全局）：</p>
<ul>
<li>内部词法环境与 <code>say</code> 的当前执行相对应。它具有一个单独的属性：<code>name</code>，函数的参数。我们调用的是 <code>say(&quot;John&quot;)</code>，所以 <code>name</code> 的值为 <code>&quot;John&quot;</code>。</li>
<li>外部词法环境是全局词法环境。它具有 <code>phrase</code> 变量和函数本身。</li>
</ul>
<p>内部词法环境引用了 <code>outer</code>。</p>
<p><strong>当代码要访问一个变量时 —— 首先会搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，以此类推，直到全局词法环境。</strong></p>
<p>如果在任何地方都找不到这个变量，那么在严格模式下就会报错（在非严格模式下，为了向下兼容，给未定义的变量赋值会创建一个全局变量）。</p>
<p>在这个示例中，搜索过程如下：</p>
<ul>
<li>对于 <code>name</code> 变量，当 <code>say</code> 中的 <code>alert</code> 试图访问 <code>name</code> 时，会立即在内部词法环境中找到它。</li>
<li>当它试图访问 <code>phrase</code> 时，然而内部没有 <code>phrase</code>，所以它顺着对外部词法环境的引用找到了它。</li>
</ul>
<p><img src="lexical-environment-simple-lookup.svg" alt="lexical environment lookup"></p>
<h3 id="step-4-返回函数">Step 4. 返回函数</h3>
<p>让我们回到 <code>makeCounter</code> 这个例子。</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeCounter</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> count++;
  };
}

<span class="hljs-keyword">let</span> counter = makeCounter();</code></pre>
<p>在每次 <code>makeCounter()</code> 调用的开始，都会创建一个新的词法环境对象，以存储该 <code>makeCounter</code> 运行时的变量。</p>
<p>因此，我们有两层嵌套的词法环境，就像上面的示例一样：</p>
<p><img src="closure-makecounter.svg" alt=""></p>
<p>不同的是，在执行 <code>makeCounter()</code> 的过程中创建了一个仅占一行的嵌套函数：<code>return count++</code>。我们尚未运行它，仅创建了它。</p>
<p>所有的函数在“诞生”时都会记住创建它们的词法环境。从技术上讲，这里没有什么魔法：所有函数都有名为 <code>[[Environment]]</code> 的隐藏属性，该属性保存了对创建该函数的词法环境的引用。</p>
<p><img src="closure-makecounter-environment.svg" alt=""></p>
<p>因此，<code>counter.[[Environment]]</code> 有对 <code>{count: 0}</code> 词法环境的引用。这就是函数记住它创建于何处的方式，与函数被在哪儿调用无关。<code>[[Environment]]</code> 引用在函数创建时被设置并永久保存。</p>
<p>稍后，当调用 <code>counter()</code> 时，会为该调用创建一个新的词法环境，并且其外部词法环境引用获取于 <code>counter.[[Environment]]</code>：</p>
<p><img src="closure-makecounter-nested-call.svg" alt=""></p>
<p>现在，当 <code>counter()</code> 中的代码查找 <code>count</code> 变量时，它首先搜索自己的词法环境（为空，因为那里没有局部变量），然后是外部 <code>makeCounter()</code> 的词法环境，并且在哪里找到就在哪里修改。</p>
<p><strong>在变量所在的词法环境中更新变量。</strong></p>
<p>这是执行后的状态：</p>
<p><img src="closure-makecounter-nested-call-2.svg" alt=""></p>
<p>如果我们调用 <code>counter()</code> 多次，<code>count</code> 变量将在同一位置增加到 <code>2</code>，<code>3</code> 等。</p>
<pre><code class="language-smart">开发者通常应该都知道“闭包”这个通用的编程术语。

[闭包](https://en.wikipedia.org/wiki/Closure_(computer_programming)) 是指内部函数总是可以访问其所在的外部函数中声明的变量和参数，即使在其外部函数被返回（寿命终结）了之后。在某些编程语言中，这是不可能的，或者应该以特殊的方式编写函数来实现。但是如上所述，在 JavaScript 中，所有函数都是天生闭包的（只有一个例外，将在 &lt;info:new-function&gt; 中讲到）。

也就是说：JavaScript 中的函数会自动通过隐藏的 `[[Environment]]` 属性记住创建它们的位置，所以它们都可以访问外部变量。

在面试时，前端开发者通常会被问到“什么是闭包？”，正确的回答应该是闭包的定义，并解释清楚为什么 JavaScript 中的所有函数都是闭包的，以及可能的关于 `[[Environment]]` 属性和词法环境原理的技术细节。</code></pre>
<h2 id="垃圾收集">垃圾收集</h2>
<p>通常，函数调用完成后，会将词法环境和其中的所有变量从内存中删除。因为现在没有任何对它们的引用了。与 JavaScript 中的任何其他对象一样，词法环境仅在可达时才会被保留在内存中。</p>
<p>……但是，如果有一个嵌套函数在函数结束后仍可达，则它具有引用词法环境的 <code>[[Environment]]</code> 属性。</p>
<p>在下面这个例子中，即使在函数执行完成后，词法环境仍然可达。因此，此嵌套函数仍然有效。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> value = <span class="hljs-number">123</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    alert(value);
  }
}

<span class="hljs-keyword">let</span> g = f(); <span class="hljs-comment">// g.[[Environment]] 存储了对相应 f() 调用的词法环境的引用</span></code></pre>
<p>请注意，如果多次调用 <code>f()</code>，并且返回的函数被保存，那么所有相应的词法环境对象也会保留在内存中。下面代码中有三个这样的函数：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> value = <span class="hljs-built_in">Math</span>.random();

  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ alert(value); };
}

<span class="hljs-comment">// 数组中的 3 个函数，每个都与来自对应的 f() 的词法环境相关联</span>
<span class="hljs-keyword">let</span> arr = [f(), f(), f()];</code></pre>
<p>当词法环境对象变得不可达时，它就会死去（就像其他任何对象一样）。换句话说，它仅在至少有一个嵌套函数引用它时才存在。</p>
<p>在下面的代码中，嵌套函数被删除后，其封闭的词法环境（以及其中的 <code>value</code>）也会被从内存中删除：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> value = <span class="hljs-number">123</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    alert(value);
  }
}

<span class="hljs-keyword">let</span> g = f(); <span class="hljs-comment">// 当 g 函数存在时，该值会被保留在内存中</span>

g = <span class="hljs-literal">null</span>; <span class="hljs-comment">// ……现在内存被清理了</span></code></pre>
<h3 id="实际开发中的优化">实际开发中的优化</h3>
<p>正如我们所看到的，理论上当函数可达时，它外部的所有变量也都将存在。</p>
<p>但在实际中，JavaScript 引擎会试图优化它。它们会分析变量的使用情况，如果从代码中可以明显看出有未使用的外部变量，那么就会将其删除。</p>
<p><strong>在 V8（Chrome，Opera）中的一个重要的副作用是，此类变量在调试中将不可用。</strong></p>
<p>打开 Chrome 浏览器的开发者工具，并尝试运行下面的代码。</p>
<p>当代码执行暂停时，在控制台中输入 <code>alert(value)</code>。</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> value = <span class="hljs-built_in">Math</span>.random();

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">g</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">debugger</span>; <span class="hljs-comment">// 在 Console 中：输入 alert(value); No such variable!</span>
  }

  <span class="hljs-keyword">return</span> g;
}

<span class="hljs-keyword">let</span> g = f();
g();</code></pre>
<p>正如你所见的 —— No such variable! 理论上，它应该是可以访问的，但引擎把它优化掉了。</p>
<p>这可能会导致有趣的（如果不是那么耗时的）调试问题。其中之一 —— 我们可以看到的是一个同名的外部变量，而不是预期的变量：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> value = <span class="hljs-string">&quot;Surprise!&quot;</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> value = <span class="hljs-string">&quot;the closest value&quot;</span>;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">g</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">debugger</span>; <span class="hljs-comment">// 在 console 中：输入 alert(value); Surprise!</span>
  }

  <span class="hljs-keyword">return</span> g;
}

<span class="hljs-keyword">let</span> g = f();
g();</code></pre>
<p>V8 引擎的这个特性你真的应该知道。如果你要使用 Chrome/Opera 进行代码调试，迟早会遇到这样的问题。</p>
<p>这不是调试器的 bug，而是 V8 的一个特别的特性。也许以后会被修改。你始终可以通过运行本文中的示例来进行检查。</p>
<!--

## 补充内容

```smart header="说明"
为了更清晰地讲解闭包，本文经过大幅重写，以下内容是重写时部分被优化掉的内容，译者认为还是很有学习价值的，遂保留下来供大家学习。
```

### 代码块

我们可以使用“空”的代码块将变量隔离到“局部作用域”中。

比如，在 Web 浏览器中，所有脚本都共享同一个全局环境。如果我们在一个脚本中创建一个全局变量，对于其他脚本来说它也是可用的。但是如果两个脚本有使用同一个变量并且相互覆盖，那么这会成为冲突的根源。

如果变量名是一个被广泛使用的词，并且不同脚本的作者可能彼此也不知道。

如果我们要避免这个，我们可以使用代码块来隔离整个脚本或其中一部分：

```js run
{
  // 用局部变量完成一些不应该被外面访问的工作

  let message = "Hello";

  alert(message); // Hello
}

alert(message); // Error: message is not defined
```

这是因为代码块有其自身的词法环境，块之外（或另一个脚本内）的代码访问不到代码块内的变量。

-->

      </fieldset>
      
      <fieldset id='_L7unjB'>
      <legend>article</legend>
      <h1 id="旧时的-var">旧时的 &quot;var&quot;</h1>
<pre><code class="language-smart">本文所讲的内容对于帮助理解旧脚本很有用。

但这不是我们编写新代码的方式。</code></pre>
<p>在本教程最开始那部分的 <a href="info:variables">变量</a> 这章中，我们提到了变量声明的三种方式：</p>
<ol>
<li><code>let</code></li>
<li><code>const</code></li>
<li><code>var</code></li>
</ol>
<p><code>var</code> 声明与 <code>let</code> 相似。大部分情况下，我们可以用 <code>let</code> 代替 <code>var</code> 或者 <code>var</code> 代替 <code>let</code>，都能达到预期的效果：</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> message = <span class="hljs-string">&quot;Hi&quot;</span>;
alert(message); <span class="hljs-comment">// Hi</span></code></pre>
<p>但实际上 <code>var</code> 却是一头非常不同的，源自远古时代的怪兽。在现代脚本中一般不再使用它，但它仍然潜伏在旧脚本中。</p>
<p>如果你不打算接触这样的脚本，你甚至可以跳过本章或推迟阅读本章。</p>
<p>另一方面，了解将旧脚本从 <code>var</code> 迁移到 <code>let</code> 时的区别，以避免奇怪的错误，是很重要的。</p>
<h2 id="var-没有块级作用域">&quot;var&quot; 没有块级作用域</h2>
<p>用 <code>var</code> 声明的变量，不是函数作用域就是全局作用域。它们在代码块外也是可见的（译注：也就是说，<code>var</code> 声明的变量只有函数作用域和全局作用域，没有块级作用域）。</p>
<p>举个例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">var</span> test = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 使用 &quot;var&quot; 而不是 &quot;let&quot;</span>
}

*!*
alert(test); <span class="hljs-comment">// true，变量在 if 结束后仍存在</span>
*/!*</code></pre>
<p>由于 <code>var</code> 会忽略代码块，因此我们有了一个全局变量 <code>test</code>。</p>
<p>如果我们在第二行使用 <code>let test</code> 而不是 <code>var test</code>，那么该变量将仅在 <code>if</code> 内部可见：</p>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">let</span> test = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 使用 &quot;let&quot;</span>
}

*!*
alert(test); <span class="hljs-comment">// Error: test is not defined</span>
*/!*</code></pre>
<p>对于循环也是这样的，<code>var</code> 声明的变量没有块级作用域也没有循环局部作用域：</p>
<pre><code class="language-js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
  <span class="hljs-comment">// ...</span>
}

*!*
alert(i); <span class="hljs-comment">// 10，&quot;i&quot; 在循环结束后仍可见，它是一个全局变量</span>
*/!*</code></pre>
<p>如果一个代码块位于函数内部，那么 <code>var</code> 声明的变量的作用域将为函数作用域：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">var</span> phrase = <span class="hljs-string">&quot;Hello&quot;</span>;
  }

  alert(phrase); <span class="hljs-comment">// works</span>
}

sayHi();
alert(phrase); <span class="hljs-comment">// Error: phrase is not defined（检查开发者控制台）</span></code></pre>
<p>可以看到，<code>var</code> 穿透了 <code>if</code>，<code>for</code> 和其它代码块。这是因为在早期的 JavaScript 中，块没有词法环境。而 <code>var</code> 就是这个时期的代表之一。</p>
<h2 id="var-允许重新声明">&quot;var&quot; 允许重新声明</h2>
<p>如果我们用 <code>let</code> 在同一作用域下将同一个变量声明两次，则会出现错误：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user;
<span class="hljs-keyword">let</span> user; <span class="hljs-comment">// SyntaxError: &#x27;user&#x27; has already been declared</span></code></pre>
<p>使用 <code>var</code>，我们可以重复声明一个变量，不管多少次都行。如果我们对一个已经声明的变量使用 <code>var</code>，这条新的声明语句会被忽略：</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> user = <span class="hljs-string">&quot;Pete&quot;</span>;

<span class="hljs-keyword">var</span> user = <span class="hljs-string">&quot;John&quot;</span>; <span class="hljs-comment">// 这个 &quot;var&quot; 无效（因为变量已经声明过了）</span>
<span class="hljs-comment">// ……不会触发错误</span>

alert(user); <span class="hljs-comment">// John</span></code></pre>
<h2 id="var-声明的变量，可以在其声明语句前被使用">&quot;var&quot; 声明的变量，可以在其声明语句前被使用</h2>
<p>当函数开始的时候，就会处理 <code>var</code> 声明（脚本启动对应全局变量）。</p>
<p>换言之，<code>var</code> 声明的变量会在函数开头被定义，与它在代码中定义的位置无关（这里不考虑定义在嵌套函数中的情况）。</p>
<p>那么看一下这段代码：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>{
  phrase = <span class="hljs-string">&quot;Hello&quot;</span>;

  alert(phrase);

*!*
  <span class="hljs-keyword">var</span> phrase;
*/!*
}
sayHi();</code></pre>
<p>……从技术上讲，它与下面这种情况是一样的（<code>var phrase</code> 被上移至函数开头）：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>{
*!*
  <span class="hljs-keyword">var</span> phrase;
*/!*

  phrase = <span class="hljs-string">&quot;Hello&quot;</span>;

  alert(phrase);
}
sayHi();</code></pre>
<p>……甚至与这种情况也一样（记住，代码块是会被忽略的）：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>{
  phrase = <span class="hljs-string">&quot;Hello&quot;</span>; <span class="hljs-comment">// (*)</span>

  *!*
  <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) {
    <span class="hljs-keyword">var</span> phrase;
  }
  */!*

  alert(phrase);
}
sayHi();</code></pre>
<p>人们将这种行为称为“提升”（英文为 &quot;hoisting&quot; 或 &quot;raising&quot;），因为所有的 <code>var</code> 都被“提升”到了函数的顶部。</p>
<p>所以，在上面的例子中，<code>if (false)</code> 分支永远都不会执行，但没关系，它里面的 <code>var</code> 在函数刚开始时就被处理了，所以在执行 <code>(*)</code> 那行代码时，变量是存在的。</p>
<p><strong>声明会被提升，但是赋值不会。</strong></p>
<p>我们最好用例子来说明：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>{
  alert(phrase);  

*!*
  <span class="hljs-keyword">var</span> phrase = <span class="hljs-string">&quot;Hello&quot;</span>;
*/!*
}

sayHi();</code></pre>
<p><code>var phrase = &quot;Hello&quot;</code> 这行代码包含两个行为：</p>
<ol>
<li>使用 <code>var</code> 声明变量</li>
<li>使用 <code>=</code> 给变量赋值。</li>
</ol>
<p>声明在函数刚开始执行的时候（“提升”）就被处理了，但是赋值操作始终是在它出现的地方才起作用。所以这段代码实际上是这样工作的：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>{
*!*
  <span class="hljs-keyword">var</span> phrase; <span class="hljs-comment">// 在函数刚开始时进行变量声明</span>
*/!*

  alert(phrase); <span class="hljs-comment">// undefined</span>

*!*
  phrase = <span class="hljs-string">&quot;Hello&quot;</span>; <span class="hljs-comment">// ……赋值 — 当程序执行到这一行时。</span>
*/!*
}

sayHi();</code></pre>
<p>因为所有的 <code>var</code> 声明都是在函数开头处理的，我们可以在任何地方引用它们。但是在它们被赋值之前都是 undefined。</p>
<p>上面两个例子中 <code>alert</code> 运行都不会报错，因为变量 <code>phrase</code> 是存在的。但是它还没有被赋值，所以显示 <code>undefiend</code>。</p>
<h3 id="iife">IIFE</h3>
<p>在之前，JavaScript 中只有 <code>var</code> 这一种声明变量的方式，并且这种方式声明的变量没有块级作用域，程序员们就发明了一种模仿块级作用域的方法。这种方法被称为“立即调用函数表达式”（immediately-invoked function expressions，IIFE）。</p>
<p>如今，我们不应该再使用 IIFE 了，但是你可以在旧脚本中找到它们。</p>
<p>IIFE 看起来像这样：</p>
<pre><code class="language-js">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{

  <span class="hljs-keyword">let</span> message = <span class="hljs-string">&quot;Hello&quot;</span>;

  alert(message); <span class="hljs-comment">// Hello</span>

})();</code></pre>
<p>这里创建了一个函数表达式并立即调用。因此，代码立即执行并拥有了自己的私有变量。</p>
<p>函数表达式被括号 <code>(function {...})</code> 包裹起来，因为在 JavaScript 中，当主代码流遇到 <code>&quot;function&quot;</code> 时，它会把它当成一个函数声明的开始。但函数声明必须有一个函数名，所以这样的代码会导致错误：</p>
<pre><code class="language-js"><span class="hljs-comment">// 尝试声明并立即调用一个函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// &lt;-- Error: Function statements require a function name</span>

  <span class="hljs-keyword">let</span> message = <span class="hljs-string">&quot;Hello&quot;</span>;

  alert(message); <span class="hljs-comment">// Hello</span>

}();</code></pre>
<p>即使我们说：“好吧，那我们加一个名称吧”，但它仍然不工作，因为 JavaScript 不允许立即调用函数声明：</p>
<pre><code class="language-js"><span class="hljs-comment">// 下面的括号会导致语法错误</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">go</span>(<span class="hljs-params"></span>) </span>{

}(); <span class="hljs-comment">// &lt;-- 不能立即调用函数声明</span></code></pre>
<p>因此，需要使用圆括号把该函数表达式包起来，以告诉 JavaScript，这个函数是在另一个表达式的上下文中创建的，因此它是一个函数表达式：它不需要函数名，可以立即调用。</p>
<p>除了使用括号，还有其他方式可以告诉 JavaScript 在这我们指的是函数表达式：</p>
<pre><code class="language-js"><span class="hljs-comment">// 创建 IIFE 的方法</span>

(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-string">&quot;Parentheses around the function&quot;</span>);
}*!*)*/!*();

(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-string">&quot;Parentheses around the whole thing&quot;</span>);
}()*!*)*/!*;

*!*!*/!*<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-string">&quot;Bitwise NOT operator starts the expression&quot;</span>);
}();

*!*+*/!*<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-string">&quot;Unary plus starts the expression&quot;</span>);
}();</code></pre>
<p>在上面的所有情况中，我们都声明了一个函数表达式并立即运行它。请再注意一下：如今我们没有理由来编写这样的代码。</p>
<h2 id="总结">总结</h2>
<p><code>var</code> 与 <code>let/const</code> 有两个主要的区别：</p>
<ol>
<li><code>var</code> 声明的变量没有块级作用域，它们的最小作用域就是函数级作用域。</li>
<li><code>var</code>  变量声明在函数开头就会被处理（脚本启动对应全局变量）。</li>
</ol>
<p>涉及全局对象时，还有一个非常小的差异，我们将在下一章中介绍。</p>
<p>这些差异使 <code>var</code> 在大多数情况下都比 <code>let</code> 更糟糕。块级作用域是这么好的一个东西。这就是 <code>let</code> 在几年前就被写入到标准中的原因，并且现在（与 <code>const</code> 一起）已经成为了声明变量的主要方式。</p>

      </fieldset>
      
      <fieldset id='_NFsfiw'>
      <legend>article</legend>
      <h1 id="全局对象">全局对象</h1>
<p>全局对象提供可在任何地方使用的变量和函数。默认情况下，这些全局变量内置于语言或环境中。</p>
<p>在浏览器中，它的名字是 &quot;window&quot;，对 Node.js 而言，它的名字是 &quot;global&quot;，其它环境可能用的是别的名字。</p>
<p>最近，<code>globalThis</code> 被作为全局对象的标准名称加入到了 JavaScript 中，所有环境都应该支持该名称。在有些浏览器中，即 non-Chromium Edge，尚不支持 <code>globalThis</code>，但可以很容易地对其进行填充（polyfilled）。</p>
<p>假设我们的环境是浏览器，我们将在这儿使用 &quot;window&quot;。如果你的脚本可能会用来在其他环境中运行，则最好使用 <code>globalThis</code>。</p>
<p>全局对象的所有属性都可以被直接访问：</p>
<pre><code class="language-js">alert(<span class="hljs-string">&quot;Hello&quot;</span>);
<span class="hljs-comment">// 等同于</span>
<span class="hljs-built_in">window</span>.alert(<span class="hljs-string">&quot;Hello&quot;</span>);</code></pre>
<p>在浏览器中，使用 <code>var</code>（而不是 <code>let/const</code>！）声明的全局函数和变量会成为全局对象的属性。</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> gVar = <span class="hljs-number">5</span>;

alert(<span class="hljs-built_in">window</span>.gVar); <span class="hljs-comment">// 5（成为了全局对象的属性）</span></code></pre>
<p>请不要依赖它！这种行为是出于兼容性而存在的。现代脚本通过使用 <a href="info:modules">JavaScript modules</a> 来避免这种情况的发生。</p>
<p>如果我们使用 <code>let</code>，就不会发生这种情况：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> gLet = <span class="hljs-number">5</span>;

alert(<span class="hljs-built_in">window</span>.gLet); <span class="hljs-comment">// undefined（不会成为全局对象的属性）</span></code></pre>
<p>如果一个值非常重要，以至于你想使它在全局范围内可用，那么可以直接将其作为属性写入：</p>
<pre><code class="language-js">*!*
<span class="hljs-comment">// 将当前用户信息全局化，以允许所有脚本访问它</span>
<span class="hljs-built_in">window</span>.currentUser = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>
};
*/!*

<span class="hljs-comment">// 代码中的另一个位置</span>
alert(currentUser.name);  <span class="hljs-comment">// John</span>

<span class="hljs-comment">// 或者，如果我们有一个名为 &quot;currentUser&quot; 的局部变量</span>
<span class="hljs-comment">// 从 window 显示地获取它（这是安全的！）</span>
alert(<span class="hljs-built_in">window</span>.currentUser.name); <span class="hljs-comment">// John</span></code></pre>
<p>也就是说，一般不建议使用全局变量。全局变量应尽可能的少。与使用外部变量或全局变量相比，函数获取“输入”变量并产生特定“输出”的代码设计更加清晰，不易出错且更易于测试。</p>
<h2 id="使用-polyfills">使用 polyfills</h2>
<p>我们使用全局对象来测试对现代语言功能的支持。</p>
<p>例如，测试是否存在内建的 <code>Promise</code> 对象（在版本特别旧的浏览器中不存在）：</p>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">window</span>.Promise) {
  alert(<span class="hljs-string">&quot;Your browser is really old!&quot;</span>);
}</code></pre>
<p>如果没有（例如，我们使用的是旧版浏览器），那么我们可以创建 &quot;polyfills&quot;：添加环境不支持但在现代标准中存在的功能。</p>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">window</span>.Promise) {
  <span class="hljs-built_in">window</span>.Promise = ... <span class="hljs-comment">// 定制实现现代语言功能</span>
}</code></pre>
<h2 id="总结">总结</h2>
<ul>
<li><p>全局对象包含应该在任何位置都可见的变量。</p>
<p>  其中包括 JavaScript 的内建方法，例如 &quot;Array&quot; 和环境特定（environment-specific）的值，例如 <code>window.innerHeight</code> — 浏览器中的窗口高度。</p>
</li>
<li><p>全局对象有一个通用名称 <code>globalThis</code>。</p>
<p>  ……但是更常见的是使用“老式”的环境特定（environment-specific）的名字，例如 <code>window</code>（浏览器）和 <code>global</code>（Node.js）。由于 <code>globalThis</code> 是最近的提议，因此在 non-Chromium Edge 中不受支持（但可以进行 polyfills）。</p>
</li>
<li><p>仅当值对于我们的项目而言确实是全局的时，才应将其存储在全局对象中。并保持其数量最少。</p>
</li>
<li><p>在浏览器中，除非我们使用 <a href="info:modules">modules</a>，否则使用 <code>var</code> 声明的全局函数和变量会成为全局对象的属性。</p>
</li>
<li><p>为了使我们的代码面向未来并更易于理解，我们应该使用直接的方式访问全局对象的属性，如 <code>window.x</code>。</p>
</li>
</ul>

      </fieldset>
      
      <fieldset id='_qPOET0'>
      <legend>solution</legend>
      <p>该解决方案在局部变量中使用 <code>count</code>，而进行加法操作的方法是直接写在 <code>counter</code> 中的。它们共享同一个外部词法环境，并且可以访问当前的 <code>count</code>。</p>

      </fieldset>
      
      <fieldset id='_khWGTc'>
      <legend>solution</legend>
      <ol>
<li>为了使整个程序无论如何都能正常工作，<code>sum</code> 的结果必须是函数。</li>
<li>这个函数必须将两次调用之间的当前值保存在内存中。</li>
<li>根据这个题目，当函数被用于 <code>==</code> 比较时必须转换成数字。函数是对象，所以转换规则会按照 <a href="info:object-toprimitive">info:object-toprimitive</a> 章节所讲的进行，我们可以提供自己的方法来返回数字。</li>
</ol>
<p>代码如下：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a</span>) </span>{

  <span class="hljs-keyword">let</span> currentSum = a;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">b</span>) </span>{
    currentSum += b;
    <span class="hljs-keyword">return</span> f;
  }

  f.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> currentSum;
  };

  <span class="hljs-keyword">return</span> f;
}

alert( sum(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>) ); <span class="hljs-comment">// 3</span>
alert( sum(<span class="hljs-number">5</span>)(-<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>) ); <span class="hljs-comment">// 6</span>
alert( sum(<span class="hljs-number">6</span>)(-<span class="hljs-number">1</span>)(-<span class="hljs-number">2</span>)(-<span class="hljs-number">3</span>) ); <span class="hljs-comment">// 0</span>
alert( sum(<span class="hljs-number">0</span>)(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)(<span class="hljs-number">5</span>) ); <span class="hljs-comment">// 15</span></code></pre>
<p>请注意 <code>sum</code> 函数只工作一次，它返回了函数 <code>f</code>。</p>
<p>然后，接下来的每一次子调用，<code>f</code> 都会把自己的参数加到求和 <code>currentSum</code> 上，然后 <code>f</code> 自身。</p>
<p><strong>在 <code>f</code> 的最后一行没有递归。</strong></p>
<p>递归是这样子的：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">b</span>) </span>{
  currentSum += b;
  <span class="hljs-keyword">return</span> f(); <span class="hljs-comment">// &lt;-- 递归调用</span>
}</code></pre>
<p>在我们的例子中，只是返回了函数，并没有调用它：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">b</span>) </span>{
  currentSum += b;
  <span class="hljs-keyword">return</span> f; <span class="hljs-comment">// &lt;-- 没有调用自己，只是返回了自己</span>
}</code></pre>
<p>这个 <code>f</code> 会被用于下一次调用，然后再次返回自己，按照需要重复。然后，当它被用做数字或字符串时 —— <code>toString</code> 返回 <code>currentSum</code>。我们也可以使用 <code>Symbol.toPrimitive</code> 或者 <code>valueOf</code> 来实现转换。</p>

      </fieldset>
      
      <fieldset id='_TabftG'>
      <legend>task</legend>
      <p>importance: 2</p>
<hr>
<h1 id="任意数量的括号求和">任意数量的括号求和</h1>
<p>写一个函数 <code>sum</code>，它有这样的功能：</p>
<pre><code class="language-js">sum(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>) == <span class="hljs-number">3</span>; <span class="hljs-comment">// 1 + 2</span>
sum(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>) == <span class="hljs-number">6</span>; <span class="hljs-comment">// 1 + 2 + 3</span>
sum(<span class="hljs-number">5</span>)(-<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>) == <span class="hljs-number">6</span>
sum(<span class="hljs-number">6</span>)(-<span class="hljs-number">1</span>)(-<span class="hljs-number">2</span>)(-<span class="hljs-number">3</span>) == <span class="hljs-number">0</span>
sum(<span class="hljs-number">0</span>)(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)(<span class="hljs-number">5</span>) == <span class="hljs-number">15</span></code></pre>
<p>P.S. 提示：你可能需要创建自定义对象来为你的函数提供基本类型转换。</p>

      </fieldset>
      
      <fieldset id='_9ACjmX'>
      <legend>article</legend>
      <h1 id="函数对象，nfe">函数对象，NFE</h1>
<p>我们已经知道，在 JavaScript 中，函数就是值。</p>
<p>JavaScript 中的每个值都有一种类型，那么函数是什么类型呢？</p>
<p>在 JavaScript 中，函数就是对象。</p>
<p>一个容易理解的方式是把函数想象成可被调用的“行为对象（action object）”。我们不仅可以调用它们，还能把它们当作对象来处理：增/删属性，按引用传递等。</p>
<h2 id="属性-name">属性 &quot;name&quot;</h2>
<p>函数对象包含一些便于使用的属性。</p>
<p>比如，一个函数的名字可以通过属性 &quot;name&quot; 来访问：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-string">&quot;Hi&quot;</span>);
}

alert(sayHi.name); <span class="hljs-comment">// sayHi</span></code></pre>
<p>更有趣的是，名称赋值的逻辑很智能。即使函数被创建时没有名字，名称赋值的逻辑也能给它赋予一个正确的名字，然后进行赋值：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-string">&quot;Hi&quot;</span>);
};

alert(sayHi.name); <span class="hljs-comment">// sayHi（有名字！）</span></code></pre>
<p>当以默认值的方式完成了赋值时，它也有效：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">sayHi = <span class="hljs-keyword">function</span>() {}</span>) </span>{
  alert(sayHi.name); <span class="hljs-comment">// sayHi（生效了！）</span>
}

f();</code></pre>
<p>规范中把这种特性叫做「上下文命名」。如果函数自己没有提供，那么在赋值中，会根据上下文来推测一个。</p>
<p>对象方法也有名字：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {

  <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-comment">// ...</span>
  },

  <span class="hljs-attr">sayBye</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// ...</span>
  }

}

alert(user.sayHi.name); <span class="hljs-comment">// sayHi</span>
alert(user.sayBye.name); <span class="hljs-comment">// sayBye</span></code></pre>
<p>这没有什么神奇的。有时会出现无法推测名字的情况。此时，属性 <code>name</code> 会是空，像这样：</p>
<pre><code class="language-js"><span class="hljs-comment">// 函数是在数组中创建的</span>
<span class="hljs-keyword">let</span> arr = [<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{}];

alert( arr[<span class="hljs-number">0</span>].name ); <span class="hljs-comment">// &lt;空字符串&gt;</span>
<span class="hljs-comment">// 引擎无法设置正确的名字，所以没有值</span></code></pre>
<p>而实际上，大多数函数都是有名字的。</p>
<h2 id="属性-length">属性 &quot;length&quot;</h2>
<p>还有另一个内置属性 &quot;length&quot;，它返回函数入参的个数，比如：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params">a</span>) </span>{}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params">a, b</span>) </span>{}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">many</span>(<span class="hljs-params">a, b, ...more</span>) </span>{}

alert(f1.length); <span class="hljs-comment">// 1</span>
alert(f2.length); <span class="hljs-comment">// 2</span>
alert(many.length); <span class="hljs-comment">// 2</span></code></pre>
<p>可以看到，rest 参数不参与计数。</p>
<p>属性 <code>length</code> 有时在操作其它函数的函数中用于做 <a href="https://zh.wikipedia.org/wiki/%E5%86%85%E7%9C%81_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">内省/运行时检查（introspection）</a>。</p>
<p>比如，下面的代码中函数 <code>ask</code> 接受一个询问答案的参数 <code>question</code> 和可能包含任意数量 <code>handler</code> 的参数 <code>...handlers</code>。</p>
<p>当用户提供了自己的答案后，函数会调用那些 <code>handlers</code>。我们可以传入两种 <code>handlers</code>：</p>
<ul>
<li>一种是无参函数，它仅在用户回答给出积极的答案时被调用。</li>
<li>一种是有参函数，它在两种情况都会被调用，并且返回一个答案。</li>
</ul>
<p>为了正确地调用 <code>handler</code>，我们需要检查 <code>handler.length</code> 属性。</p>
<p>我们的想法是，我们用一个简单的无参数的 <code>handler</code> 语法来处理积极的回答（最常见的变体），但也要能够提供通用的 handler：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ask</span>(<span class="hljs-params">question, ...handlers</span>) </span>{
  <span class="hljs-keyword">let</span> isYes = confirm(question);

  <span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> handler <span class="hljs-keyword">of</span> handlers</span>)</span> {
    <span class="hljs-keyword">if</span> (handler.length == <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">if</span> (isYes) handler();
    } <span class="hljs-keyword">else</span> {
      handler(isYes);
    }
  }

}

<span class="hljs-comment">// 对于积极的回答，两个 handler 都会被调用</span>
<span class="hljs-comment">// 对于负面的回答，只有第二个 handler 被调用</span>
ask(<span class="hljs-string">&quot;Question?&quot;</span>, <span class="hljs-function">() =&gt;</span> alert(<span class="hljs-string">&#x27;You said yes&#x27;</span>), <span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> alert(result));</code></pre>
<p>这种特别的情况就是所谓的 <a href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)">多态性</a> —— 根据参数的类型，或者根据在我们的具体情景下的 <code>length</code> 来做不同的处理。这种思想在 JavaScript 的库里有应用。</p>
<h2 id="自定义属性">自定义属性</h2>
<p>我们也可以添加我们自己的属性。</p>
<p>这里我们添加了 <code>counter</code> 属性，用来跟踪总的调用次数：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-string">&quot;Hi&quot;</span>);

  *!*
  <span class="hljs-comment">// 计算调用次数</span>
  sayHi.counter++;
  */!*
}
sayHi.counter = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始值</span>

sayHi(); <span class="hljs-comment">// Hi</span>
sayHi(); <span class="hljs-comment">// Hi</span>

alert( <span class="hljs-string">`Called <span class="hljs-subst">${sayHi.counter}</span> times`</span> ); <span class="hljs-comment">// Called 2 times</span></code></pre>
<pre><code class="language-warn">被赋值给函数的属性，比如 `sayHi.counter = 0`，**不会** 在函数内定义一个局部变量 `counter`。换句话说，属性 `counter` 和变量 `let counter` 是毫不相关的两个东西。

我们可以把函数当作对象，在它里面存储属性，但是这对它的执行没有任何影响。变量不是函数属性，反之亦然。它们之间是平行的。</code></pre>
<p>函数属性有时会用来替代闭包。例如，我们可以使用函数属性将 <a href="info:closure">info:closure</a> 章节中 counter 函数的例子进行重写：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeCounter</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// 不需要这个了</span>
  <span class="hljs-comment">// let count = 0</span>

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">counter</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> counter.count++;
  };

  counter.count = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">return</span> counter;
}

<span class="hljs-keyword">let</span> counter = makeCounter();
alert( counter() ); <span class="hljs-comment">// 0</span>
alert( counter() ); <span class="hljs-comment">// 1</span></code></pre>
<p>现在 <code>count</code> 被直接存储在函数里，而不是它外部的词法环境。</p>
<p>那么它和闭包谁好谁赖？</p>
<p>两者最大的不同就是如果 <code>count</code> 的值位于外层（函数）变量中，那么外部的代码无法访问到它，只有嵌套的函数可以修改它。而如果它是绑定到函数的，那么就很容易：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeCounter</span>(<span class="hljs-params"></span>) </span>{

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">counter</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> counter.count++;
  };

  counter.count = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">return</span> counter;
}

<span class="hljs-keyword">let</span> counter = makeCounter();

*!*
counter.count = <span class="hljs-number">10</span>;
alert( counter() ); <span class="hljs-comment">// 10</span>
*/!*</code></pre>
<p>所以，选择哪种实现方式取决于我们的需求是什么。</p>
<h2 id="命名函数表达式">命名函数表达式</h2>
<p>命名函数表达式（NFE，Named Function Expression），指带有名字的函数表达式的术语。</p>
<p>例如，让我们写一个普通的函数表达式：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">who</span>) </span>{
  alert(<span class="hljs-string">`Hello, <span class="hljs-subst">${who}</span>`</span>);
};</code></pre>
<p>然后给它加一个名字：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span> *!*<span class="hljs-title">func</span>*/!*(<span class="hljs-params">who</span>) </span>{
  alert(<span class="hljs-string">`Hello, <span class="hljs-subst">${who}</span>`</span>);
};</code></pre>
<p>我们这里得到了什么吗？为它添加一个 <code>&quot;func&quot;</code> 名字的目的是什么？</p>
<p>首先请注意，它仍然是一个函数表达式。在 <code>function</code> 后面加一个名字 <code>&quot;func&quot;</code> 没有使它成为一个函数声明，因为它仍然是作为赋值表达式中的一部分被创建的。</p>
<p>添加这个名字当然也没有打破任何东西。</p>
<p>函数依然可以通过 <code>sayHi()</code> 来调用：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span> *!*<span class="hljs-title">func</span>*/!*(<span class="hljs-params">who</span>) </span>{
  alert(<span class="hljs-string">`Hello, <span class="hljs-subst">${who}</span>`</span>);
};

sayHi(<span class="hljs-string">&quot;John&quot;</span>); <span class="hljs-comment">// Hello, John</span></code></pre>
<p>关于名字 <code>func</code> 有两个特殊的地方，这就是添加它的原因：</p>
<ol>
<li>它允许函数在内部引用自己。</li>
<li>它在函数外是不可见的。</li>
</ol>
<p>例如，下面的函数 <code>sayHi</code> 会在没有入参 <code>who</code> 时，以 <code>&quot;Guest&quot;</code> 为入参调用自己：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span> *!*<span class="hljs-title">func</span>*/!*(<span class="hljs-params">who</span>) </span>{
  <span class="hljs-keyword">if</span> (who) {
    alert(<span class="hljs-string">`Hello, <span class="hljs-subst">${who}</span>`</span>);
  } <span class="hljs-keyword">else</span> {
*!*
    func(<span class="hljs-string">&quot;Guest&quot;</span>); <span class="hljs-comment">// 使用 func 再次调用函数自身</span>
*/!*
  }
};

sayHi(); <span class="hljs-comment">// Hello, Guest</span>

<span class="hljs-comment">// 但这不工作：</span>
func(); <span class="hljs-comment">// Error, func is not defined（在函数外不可见）</span></code></pre>
<p>我们为什么使用 <code>func</code> 呢？为什么不直接使用 <code>sayHi</code> 进行嵌套调用？</p>
<p>当然，在大多数情况下我们可以这样做：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">who</span>) </span>{
  <span class="hljs-keyword">if</span> (who) {
    alert(<span class="hljs-string">`Hello, <span class="hljs-subst">${who}</span>`</span>);
  } <span class="hljs-keyword">else</span> {
*!*
    sayHi(<span class="hljs-string">&quot;Guest&quot;</span>);
*/!*
  }
};</code></pre>
<p>上面这段代码的问题在于 <code>sayHi</code> 的值可能会被函数外部的代码改变。如果该函数被赋值给另外一个变量（译注：也就是原变量被修改），那么函数就会开始报错：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">who</span>) </span>{
  <span class="hljs-keyword">if</span> (who) {
    alert(<span class="hljs-string">`Hello, <span class="hljs-subst">${who}</span>`</span>);
  } <span class="hljs-keyword">else</span> {
*!*
    sayHi(<span class="hljs-string">&quot;Guest&quot;</span>); <span class="hljs-comment">// Error: sayHi is not a function</span>
*/!*
  }
};

<span class="hljs-keyword">let</span> welcome = sayHi;
sayHi = <span class="hljs-literal">null</span>;

welcome(); <span class="hljs-comment">// Error，嵌套调用 sayHi 不再有效！</span></code></pre>
<p>发生这种情况是因为该函数从它的外部词法环境获取 <code>sayHi</code>。没有局部的 <code>sayHi</code> 了，所以使用外部变量。而当调用时，外部的 <code>sayHi</code> 是 <code>null</code>。</p>
<p>我们给函数表达式添加的可选的名字，正是用来解决这类问题的。</p>
<p>让我们使用它来修复我们的代码：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span> *!*<span class="hljs-title">func</span>*/!*(<span class="hljs-params">who</span>) </span>{
  <span class="hljs-keyword">if</span> (who) {
    alert(<span class="hljs-string">`Hello, <span class="hljs-subst">${who}</span>`</span>);
  } <span class="hljs-keyword">else</span> {
*!*
    func(<span class="hljs-string">&quot;Guest&quot;</span>); <span class="hljs-comment">// 现在一切正常</span>
*/!*
  }
};

<span class="hljs-keyword">let</span> welcome = sayHi;
sayHi = <span class="hljs-literal">null</span>;

welcome(); <span class="hljs-comment">// Hello, Guest（嵌套调用有效）</span></code></pre>
<p>现在它可以正常运行了，因为名字 <code>func</code> 是函数局部域的。它不是从外部获取的（而且它对外部也是不可见的）。规范确保它只会引用当前函数。</p>
<p>外部代码仍然有该函数的 <code>sayHi</code> 或 <code>welcome</code> 变量。而且 <code>func</code> 是一个“内部函数名”，可用于函数在自身内部进行自调用。</p>
<pre><code class="language-smart">这里所讲的“内部名”特性只针对函数表达式，而不是函数声明。对于函数声明，没有用来添加“内部”名的语法。

有时，当我们需要一个可靠的内部名时，这就成为了你把函数声明重写成函数表达式的理由了。</code></pre>
<h2 id="总结">总结</h2>
<p>函数就是对象。</p>
<p>我们介绍了它们的一些属性：</p>
<ul>
<li><code>name</code> —— 函数的名字。通常取自函数定义，但如果函数定义时没设定函数名，JavaScript 会尝试通过函数的上下文猜一个函数名（例如把赋值的变量名取为函数名）。</li>
<li><code>length</code> —— 函数定义时的入参的个数。Rest 参数不参与计数。</li>
</ul>
<p>如果函数是通过函数表达式的形式被声明的（不是在主代码流里），并且附带了名字，那么它被称为命名函数表达式（Named Function Expression）。这个名字可以用于在该函数内部进行自调用，例如递归调用等。</p>
<p>此外，函数可以带有额外的属性。很多知名的 JavaScript 库都充分利用了这个功能。</p>
<p>它们创建一个“主”函数，然后给它附加很多其它“辅助”函数。例如，<a href="https://jquery.com">jQuery</a> 库创建了一个名为 <code>$</code> 的函数。<a href="https://lodash.com">lodash</a> 库创建一个 <code>_</code> 函数，然后为其添加了 <code>_.add</code>、<code>_.keyBy</code> 以及其它属性（欲了解详情，参见 <a href="https://lodash.com/docs">docs</a>）。实际上，它们这么做是为了减少对全局空间的污染，这样一个库就只会有一个全局变量。这样就降低了命名冲突的可能性。</p>
<p>所以，一个函数本身可以完成一项有用的工作，还可以在自身的属性中附带许多其他功能。</p>

      </fieldset>
      
      <fieldset id='_dP5jms'>
      <legend>article</legend>
      <h1 id="new-function-语法">&quot;new Function&quot; 语法</h1>
<p>还有一种创建函数的方法。它很少被使用，但有些时候只能选择它。</p>
<h2 id="语法">语法</h2>
<p>创建函数的语法：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> func = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span> ([arg1, arg2, ...argN], functionBody);</code></pre>
<p>该函数是通过使用参数 <code>arg1...argN</code> 和给定的 <code>functionBody</code> 创建的。</p>
<p>下面这个例子可以帮助你理解创建语法。这是一个带有两个参数的函数：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> sum = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;return a + b&#x27;</span>);

alert( sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) ); <span class="hljs-comment">// 3</span></code></pre>
<p>这里有一个没有参数的函数，只有函数体：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> sayHi = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">&#x27;alert(&quot;Hello&quot;)&#x27;</span>);

sayHi(); <span class="hljs-comment">// Hello</span></code></pre>
<p>与我们已知的其他方法相比，这种方法最大的不同在于，它实际上是通过运行时通过参数传递过来的字符串创建的。</p>
<p>以前的所有声明方法都需要我们 —— 程序员，在脚本中编写函数的代码。</p>
<p>但是 <code>new Function</code> 允许我们将任意字符串变为函数。例如，我们可以从服务器接收一个新的函数并执行它：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> str = ... 动态地接收来自服务器的代码 ...

<span class="hljs-keyword">let</span> func = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(str);
func();</code></pre>
<p>使用 <code>new Function</code> 创建函数的应用场景非常特殊，比如在复杂的 Web 应用程序中，我们需要从服务器获取代码或者动态地从模板编译函数时才会使用。</p>
<h2 id="闭包">闭包</h2>
<p>通常，闭包是指使用一个特殊的属性 <code>[[Environment]]</code> 来记录函数自身的创建时的环境的函数。它具体指向了函数创建时的词法环境。（我们在 <a href="info:closure">info:closure</a> 一章中对此进行了详细的讲解）。</p>
<p>但是如果我们使用 <code>new Function</code> 创建一个函数，那么该函数的 <code>[[Environment]]</code> 并不指向当前的词法环境，而是指向全局环境。</p>
<p>因此，此类函数无法访问外部（outer）变量，只能访问全局变量。</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFunc</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> value = <span class="hljs-string">&quot;test&quot;</span>;

*!*
  <span class="hljs-keyword">let</span> func = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">&#x27;alert(value)&#x27;</span>);
*/!*

  <span class="hljs-keyword">return</span> func;
}

getFunc()(); <span class="hljs-comment">// error: value is not defined</span></code></pre>
<p>将其与常规行为进行比较：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFunc</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> value = <span class="hljs-string">&quot;test&quot;</span>;

*!*
  <span class="hljs-keyword">let</span> func = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ alert(value); };
*/!*

  <span class="hljs-keyword">return</span> func;
}

getFunc()(); <span class="hljs-comment">// *!*&quot;test&quot;*/!*，从 getFunc 的词法环境中获取的</span></code></pre>
<p><code>new Function</code> 的这种特性看起来有点奇怪，不过在实际中却非常实用。</p>
<p>想象以下我们必须通过一个字符串来创建一个函数。在编写脚本时我们不会知道该函数的代码（这也就是为什么我们不用常规方法创建函数），但在执行过程中会知道了。我们可能会从服务器或其他来源获取它。</p>
<p>我们的新函数需要和主脚本进行交互。</p>
<p>如果这个函数能够访问外部（outer）变量会怎么样？</p>
<p>问题在于，在将 JavaScript 发布到生产环境之前，需要使用 <strong>压缩程序（minifier）</strong> 对其进行压缩 —— 一个特殊的程序，通过删除多余的注释和空格等压缩代码 —— 更重要的是，将局部变量命名为较短的变量。</p>
<p>例如，如果一个函数有 <code>let userName</code>，压缩程序会把它替换为 <code>let a</code>（如果 a 已被占用了，那就使用其他字符），剩余的局部变量也会被进行类似的替换。一般来说这样的替换是安全的，毕竟这些变量是函数内的局部变量，函数外的任何东西都无法访问它。在函数内部，压缩程序会替换所有使用了使用了这些变量的代码。压缩程序很聪明，它会分析代码的结构，而不是呆板地查找然后替换，因此它不会“破坏”你的程序。</p>
<p>但是在这种情况下，如果使 <code>new Function</code> 可以访问自身函数以外的变量，它也很有可能无法找到重命名的 <code>userName</code>，这是因为新函数的创建发生在代码压缩以后，变量名已经被替换了。</p>
<p><strong>即使我们可以在 <code>new Function</code> 中访问外部词法环境，我们也会受挫于压缩程序。</strong></p>
<p>此外，这样的代码在架构上很差并且容易出错。</p>
<p>当我们需要向 <code>new Function</code> 创建出的新函数传递数据时，我们必须显式地通过参数进行传递。</p>
<h2 id="总结">总结</h2>
<p>语法：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> func = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span> ([arg1, arg2, ...argN], functionBody);</code></pre>
<p>由于历史原因，参数也可以按逗号分隔符的形式给出。 </p>
<p>以下三种声明的含义相同：</p>
<pre><code class="language-js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;return a + b&#x27;</span>); <span class="hljs-comment">// 基础语法</span>
<span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">&#x27;a,b&#x27;</span>, <span class="hljs-string">&#x27;return a + b&#x27;</span>); <span class="hljs-comment">// 逗号分隔</span>
<span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">&#x27;a , b&#x27;</span>, <span class="hljs-string">&#x27;return a + b&#x27;</span>); <span class="hljs-comment">// 逗号和空格分隔</span></code></pre>
<p>使用 <code>new Function</code> 创建的函数，它的 <code>[[Environment]]</code> 指向全局词法环境，而不是函数所在的外部词法环境。因此，我们不能在 <code>new Function</code> 中直接使用外部变量。不过这样是好事，这有助于降低我们代码出错的可能。并且，从代码架构上讲，显式地使用参数传值是一种更好的方法，并且避免了与使用压缩程序而产生冲突的问题。</p>

      </fieldset>
      
      <fieldset id='_i96cle'>
      <legend>solution</legend>
      <p>使用 <code>setInterval</code>：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printNumbers</span>(<span class="hljs-params"><span class="hljs-keyword">from</span>, to</span>) </span>{
  <span class="hljs-keyword">let</span> current = <span class="hljs-keyword">from</span>;

  <span class="hljs-keyword">let</span> timerId = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    alert(current);
    <span class="hljs-keyword">if</span> (current == to) {
      <span class="hljs-built_in">clearInterval</span>(timerId);
    }
    current++;
  }, <span class="hljs-number">1000</span>);
}

<span class="hljs-comment">// 用例：</span>
printNumbers(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);</code></pre>
<p>使用嵌套的 <code>setTimeout</code>：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printNumbers</span>(<span class="hljs-params"><span class="hljs-keyword">from</span>, to</span>) </span>{
  <span class="hljs-keyword">let</span> current = <span class="hljs-keyword">from</span>;

  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">go</span>(<span class="hljs-params"></span>) </span>{
    alert(current);
    <span class="hljs-keyword">if</span> (current &lt; to) {
      <span class="hljs-built_in">setTimeout</span>(go, <span class="hljs-number">1000</span>);
    }
    current++;
  }, <span class="hljs-number">1000</span>);
}

<span class="hljs-comment">// 用例：</span>
printNumbers(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);</code></pre>
<p>请注意，在这两种解决方案中，在第一个输出之前都有一个初始延迟。函数在 <code>1000ms</code> 之后才被第一次调用。</p>
<p>如果我们还希望函数立即运行，那么我们可以在单独的一行上添加一个额外的调用，像这样：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printNumbers</span>(<span class="hljs-params"><span class="hljs-keyword">from</span>, to</span>) </span>{
  <span class="hljs-keyword">let</span> current = <span class="hljs-keyword">from</span>;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">go</span>(<span class="hljs-params"></span>) </span>{
    alert(current);
    <span class="hljs-keyword">if</span> (current == to) {
      <span class="hljs-built_in">clearInterval</span>(timerId);
    }
    current++;
  }

*!*
  go();
*/!*
  <span class="hljs-keyword">let</span> timerId = <span class="hljs-built_in">setInterval</span>(go, <span class="hljs-number">1000</span>);
}

printNumbers(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);</code></pre>

      </fieldset>
      
      <fieldset id='_uPeaa7'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="每秒输出一次">每秒输出一次</h1>
<p>编写一个函数 <code>printNumbers(from, to)</code>，使其每秒输出一个数字，数字从 <code>from </code> 开始，到 <code>to</code> 结束。</p>
<p>使用以下两种方法来实现。</p>
<ol>
<li>使用 <code>setInterval</code>。</li>
<li>使用嵌套的 <code>setTimeout</code>。</li>
</ol>

      </fieldset>
      
      <fieldset id='_ROC9IG'>
      <legend>solution</legend>
      <p>任何 <code>setTimeout</code> 都只会在当前代码执行完毕之后才会执行。</p>
<p>所以 <code>i</code> 的取值为：<code>100000000</code>。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> alert(i), <span class="hljs-number">100</span>); <span class="hljs-comment">// 100000000</span>

<span class="hljs-comment">// 假设这段代码的运行时间 &gt;100ms</span>
<span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100000000</span>; j++</span>)</span> {
  i++; 
}</code></pre>

      </fieldset>
      
      <fieldset id='_xaJPT3'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="settimeout-会显示什么？">setTimeout 会显示什么？</h1>
<p>下面代码中使用 <code>setTimeout</code> 调度了一个调用，然后需要运行一个计算量很大的 <code>for</code> 循环，这段运算耗时超过 100 毫秒。</p>
<p>调度的函数会在何时运行？</p>
<ol>
<li>循环执行完成后。</li>
<li>循环执行前。</li>
<li>循环刚开始时。</li>
</ol>
<p><code>alert</code> 会显示什么？</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> alert(i), <span class="hljs-number">100</span>); <span class="hljs-comment">// ?</span>

<span class="hljs-comment">// 假设这段代码的运行时间 &gt;100ms</span>
<span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100000000</span>; j++</span>)</span> {
  i++; 
}</code></pre>

      </fieldset>
      
      <fieldset id='_ALiG5M'>
      <legend>article</legend>
      <h1 id="调度：settimeout-和-setinterval">调度：setTimeout 和 setInterval</h1>
<p>有时我们并不想立即执行一个函数，而是等待特定一段时间之后再执行。这就是所谓的“计划调用（scheduling a call）”。</p>
<p>目前有两种方式可以实现：</p>
<ul>
<li><code>setTimeout</code> 允许我们将函数推迟到一段时间间隔之后再执行。</li>
<li><code>setInterval</code> 允许我们重复运行一个函数，从一段时间间隔之后开始运行，之后以该时间间隔连续重复运行该函数。</li>
</ul>
<p>这两个方法并不在 JavaScript 的规范中。但是大多数运行环境都有内建的调度程序，并且提供了这些方法。目前来讲，所有浏览器以及 Node.js 都支持这两个方法。</p>
<h2 id="settimeout">setTimeout</h2>
<p>语法：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> timerId = <span class="hljs-built_in">setTimeout</span>(func|code, [delay], [arg1], [arg2], ...)</code></pre>
<p>参数说明：</p>
<p><code>func|code</code>
: 想要执行的函数或代码字符串。
一般传入的都是函数。由于某些历史原因，支持传入代码字符串，但是不建议这样做。</p>
<p><code>delay</code>
: 执行前的延时，以毫秒为单位（1000 毫秒 = 1 秒），默认值是 0；</p>
<p><code>arg1</code>，<code>arg2</code>...
: 要传入被执行函数（或代码字符串）的参数列表（IE9 以下不支持）</p>
<p>例如，在下面这个示例中，<code>sayHi()</code> 方法会在 1 秒后执行：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-string">&#x27;Hello&#x27;</span>);
}

*!*
<span class="hljs-built_in">setTimeout</span>(sayHi, <span class="hljs-number">1000</span>);
*/!*</code></pre>
<p>带参数的情况：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params">phrase, who</span>) </span>{
  alert( phrase + <span class="hljs-string">&#x27;, &#x27;</span> + who );
}

*!*
<span class="hljs-built_in">setTimeout</span>(sayHi, <span class="hljs-number">1000</span>, <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;John&quot;</span>); <span class="hljs-comment">// Hello, John</span>
*/!*</code></pre>
<p>如果第一个参数位传入的是字符串，JavaScript 会自动为其创建一个函数。</p>
<p>所以这么写也是可以的：</p>
<pre><code class="language-js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-string">&quot;alert(&#x27;Hello&#x27;)&quot;</span>, <span class="hljs-number">1000</span>);</code></pre>
<p>但是，不建议使用字符串，我们可以使用箭头函数代替它们，如下所示：</p>
<pre><code class="language-js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> alert(<span class="hljs-string">&#x27;Hello&#x27;</span>), <span class="hljs-number">1000</span>);</code></pre>
<pre><code class="language-smart">新手开发者有时候会误将一对括号 `()` 加在函数后面：

```js
// 错的！
setTimeout(sayHi(), 1000);
```
这样不行，因为 `setTimeout` 期望得到一个对函数的引用。而这里的 `sayHi()` 很明显是在执行函数，所以实际上传入 `setTimeout` 的是 **函数的执行结果**。在这个例子中，`sayHi()` 的执行结果是 `undefined`（也就是说函数没有返回任何结果），所以实际上什么也没有调度。</code></pre>
<h3 id="用-cleartimeout-来取消调度">用 clearTimeout 来取消调度</h3>
<p><code>setTimeout</code> 在调用时会返回一个“定时器标识符（timer identifier）”，在我们的例子中是 <code>timerId</code>，我们可以使用它来取消执行。</p>
<p>取消调度的语法：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> timerId = <span class="hljs-built_in">setTimeout</span>(...);
<span class="hljs-built_in">clearTimeout</span>(timerId);</code></pre>
<p>在下面的代码中，我们对一个函数进行了调度，紧接着取消了这次调度（中途反悔了）。所以最后什么也没发生：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> timerId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> alert(<span class="hljs-string">&quot;never happens&quot;</span>), <span class="hljs-number">1000</span>);
alert(timerId); <span class="hljs-comment">// 定时器标识符</span>

<span class="hljs-built_in">clearTimeout</span>(timerId);
alert(timerId); <span class="hljs-comment">// 还是这个标识符（并没有因为调度被取消了而变成 null）</span></code></pre>
<p>从 <code>alert</code> 的输出来看，在浏览器中，定时器标识符是一个数字。在其他环境中，可能是其他的东西。例如 Node.js 返回的是一个定时器对象，这个对象包含一系列方法。</p>
<p>我再重申一遍，这些方法没有统一的规范定义，所以这没什么问题。</p>
<p>针对浏览器环境，定时器在 HTML5 的标准中有详细描述，详见 <a href="https://www.w3.org/TR/html5/webappapis.html#timers">timers section</a>。</p>
<h2 id="setinterval">setInterval</h2>
<p><code>setInterval</code> 方法和 <code>setTimeout</code> 的语法相同：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> timerId = <span class="hljs-built_in">setInterval</span>(func|code, [delay], [arg1], [arg2], ...)</code></pre>
<p>所有参数的意义也是相同的。不过与 <code>setTimeout</code> 只执行一次不同，<code>setInterval</code> 是每间隔给定的时间周期性执行。</p>
<p>想要阻止后续调用，我们需要调用 <code>clearInterval(timerId)</code>。</p>
<p>下面的例子将每间隔 2 秒就会输出一条消息。5 秒之后，输出停止：</p>
<pre><code class="language-js"><span class="hljs-comment">// 每 2 秒重复一次</span>
<span class="hljs-keyword">let</span> timerId = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> alert(<span class="hljs-string">&#x27;tick&#x27;</span>), <span class="hljs-number">2000</span>);

<span class="hljs-comment">// 5 秒之后停止</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> { <span class="hljs-built_in">clearInterval</span>(timerId); alert(<span class="hljs-string">&#x27;stop&#x27;</span>); }, <span class="hljs-number">5000</span>);</code></pre>
<pre><code class="language-smart">在大多数浏览器中，包括 Chrome 和 Firefox，在显示 `alert/confirm/prompt` 弹窗时，内部的定时器仍旧会继续“嘀嗒”。

所以，在运行上面的代码时，如果在一定时间内没有关掉 `alert` 弹窗，那么在你关闭弹窗后，下一个 `alert` 会立即显示。两次 `alert` 之间的时间间隔将小于 2 秒。</code></pre>
<h2 id="嵌套的-settimeout">嵌套的 setTimeout</h2>
<p>周期性调度有两种方式。</p>
<p>一种是使用 <code>setInterval</code>，另外一种就是嵌套的 <code>setTimeout</code>，就像这样：</p>
<pre><code class="language-js"><span class="hljs-comment">/** instead of:
let timerId = setInterval(() =&gt; alert(&#x27;tick&#x27;), 2000);
*/</span>

<span class="hljs-keyword">let</span> timerId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tick</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-string">&#x27;tick&#x27;</span>);
*!*
  timerId = <span class="hljs-built_in">setTimeout</span>(tick, <span class="hljs-number">2000</span>); <span class="hljs-comment">// (*)</span>
*/!*
}, <span class="hljs-number">2000</span>);</code></pre>
<p>上面这个 <code>setTimeout</code> 在当前这一次函数执行完时 <code>(*)</code> 立即调度下一次调用。</p>
<p>嵌套的 <code>setTimeout</code> 要比 <code>setInterval</code> 灵活得多。采用这种方式可以根据当前执行结果来调度下一次调用，因此下一次调用可以与当前这一次不同。</p>
<p>例如，我们要实现一个服务（server），每间隔 5 秒向服务器发送一个数据请求，但如果服务器过载了，那么就要降低请求频率，比如将间隔增加到 10、20、40 秒等。</p>
<p>以下是伪代码：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> delay = <span class="hljs-number">5000</span>;

<span class="hljs-keyword">let</span> timerId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span>(<span class="hljs-params"></span>) </span>{
  ...发送请求...

  <span class="hljs-keyword">if</span> (request failed due to server overload) {
    <span class="hljs-comment">// 下一次执行的间隔是当前的 2 倍</span>
    delay *= <span class="hljs-number">2</span>;
  }

  timerId = <span class="hljs-built_in">setTimeout</span>(request, delay);

}, delay);</code></pre>
<p>并且，如果我们调度的函数占用大量的 CPU，那么我们可以测量执行所需要花费的时间，并安排下次调用是应该提前还是推迟。</p>
<p><strong>嵌套的 <code>setTimeout</code> 能够精确地设置两次执行之间的延时，而 <code>setInterval</code> 却不能。</strong></p>
<p>下面来比较这两个代码片段。第一个使用的是 <code>setInterval</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;
<span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  func(i++);
}, <span class="hljs-number">100</span>);</code></pre>
<p>第二个使用的是嵌套的 <code>setTimeout</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>{
  func(i++);
  <span class="hljs-built_in">setTimeout</span>(run, <span class="hljs-number">100</span>);
}, <span class="hljs-number">100</span>);</code></pre>
<p>对 <code>setInterval</code> 而言，内部的调度程序会每间隔 100 毫秒执行一次 <code>func(i++)</code>：</p>
<p><img src="setinterval-interval.svg" alt=""></p>
<p>注意到了吗？</p>
<p><strong>使用 <code>setInterval</code> 时，<code>func</code> 函数的实际调用间隔要比代码中设定的时间间隔要短！</strong></p>
<p>这也是正常的，因为 <code>func</code> 的执行所花费的时间“消耗”了一部分间隔时间。</p>
<p>也可能出现这种情况，就是 <code>func</code> 的执行所花费的时间比我们预期的时间更长，并且超出了 100 毫秒。</p>
<p>在这种情况下，JavaScript 引擎会等待 <code>func</code> 执行完成，然后检查调度程序，如果时间到了，则 <strong>立即</strong> 再次执行它。</p>
<p>极端情况下，如果函数每次执行时间都超过 <code>delay</code> 设置的时间，那么每次调用之间将完全没有停顿。</p>
<p>这是嵌套的 <code>setTimeout</code> 的示意图：</p>
<p><img src="settimeout-interval.svg" alt=""></p>
<p><strong>嵌套的 <code>setTimeout</code> 就能确保延时的固定（这里是 100 毫秒）。</strong></p>
<p>这是因为下一次调用是在前一次调用完成时再调度的。</p>
<pre><code class="language-smart">当一个函数传入 `setInterval/setTimeout` 时，将为其创建一个内部引用，并保存在调度程序中。这样，即使这个函数没有其他引用，也能防止垃圾回收器（GC）将其回收。

```js
// 在调度程序调用这个函数之前，这个函数将一直存在于内存中
setTimeout(function() {...}, 100);
```

对于 `setInterval`，传入的函数也是一直存在于内存中，直到 `clearInterval` 被调用。

这里还要提到一个副作用。如果函数引用了外部变量（译注：闭包），那么只要这个函数还存在，外部变量也会随之存在。它们可能比函数本身占用更多的内存。因此，当我们不再需要调度函数时，最好取消它，即使这是个（占用内存）很小的函数。</code></pre>
<h2 id="零延时的-settimeout">零延时的 setTimeout</h2>
<p>这儿有一种特殊的用法：<code>setTimeout(func, 0)</code>，或者仅仅是 <code>setTimeout(func)</code>。</p>
<p>这样调度可以让 <code>func</code> 尽快执行。但是只有在当前正在执行的脚本执行完成后，调度程序才会调用它。</p>
<p>也就是说，该函数被调度在当前脚本执行完成“之后”立即执行。</p>
<p>例如，下面这段代码会先输出 &quot;Hello&quot;，然后立即输出 &quot;World&quot;：</p>
<pre><code class="language-js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> alert(<span class="hljs-string">&quot;World&quot;</span>));

alert(<span class="hljs-string">&quot;Hello&quot;</span>);</code></pre>
<p>第一行代码“将调用安排到日程（calendar）0 毫秒处”。但是调度程序只有在当前脚本执行完毕时才会去“检查日程”，所以先输出 <code>&quot;Hello&quot;</code>，然后才输出 <code>&quot;World&quot;</code>。</p>
<p>此外，还有与浏览器相关的 0 延时 timeout 的高级用例，我们将在 <a href="info:event-loop">info:event-loop</a> 一章中详细讲解。</p>
<pre><code class="language-smart">在浏览器环境下，嵌套定时器的运行频率是受限制的。根据 [HTML5 标准](https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers) 所讲：“经过 5 重嵌套定时器之后，时间间隔被强制设定为至少 4 毫秒”。

让我们用下面的示例来看看这到底是什么意思。其中 `setTimeout` 调用会以零延时重新调度自身的调用。每次调用都会在 `times` 数组中记录上一次调用的实际时间。那么真正的延迟是什么样的？让我们来看看：

```js run
let start = Date.now();
let times = [];

setTimeout(function run() {
  times.push(Date.now() - start); // 保存前一个调用的延时

  if (start + 100 &lt; Date.now()) alert(times); // 100 毫秒之后，显示延时信息
  else setTimeout(run); // 否则重新调度
});

// 输出示例：
// 1,1,1,1,9,15,20,24,30,35,40,45,50,55,59,64,70,75,80,85,90,95,100
```

第一次，定时器是立即执行的（正如规范里所描述的那样），接下来我们可以看到 `9, 15, 20, 24...`。两次调用之间必须经过 4 毫秒以上的强制延时。（译注：这里作者没说清楚，timer 数组里存放的是每次定时器运行的时刻与 start 的差值，所以数字只会越来越大，实际上前后调用的延时是数组值的差值。示例中前几次都是 1，所以延时为 0）

如果我们使用 `setInterval` 而不是 `setTimeout`，也会发生类似的情况：`setInterval(f)` 会以零延时运行几次 `f`，然后以 4 毫秒以上的强制延时运行。

这个限制来自“远古时代”，并且许多脚本都依赖于此，所以这个机制也就存在至今。

对于服务端的 JavaScript，就没有这个限制，并且还有其他调度即时异步任务的方式。例如 Node.js 的 [setImmediate](https://nodejs.org/api/timers.html)。因此，这个提醒只是针对浏览器环境的。</code></pre>
<h2 id="总结">总结</h2>
<ul>
<li><code>setTimeout(func, delay, ...args)</code> 和 <code>setInterval(func, delay, ...args)</code> 方法允许我们在 <code>delay</code> 毫秒之后运行 <code>func</code> 一次或以 <code>delay</code> 毫秒为时间间隔周期性运行 <code>func</code>。</li>
<li>要取消函数的执行，我们应该调用 <code>clearInterval/clearTimeout</code>，并将 <code>setInterval/setTimeout</code> 返回的值作为入参传入。</li>
<li>嵌套的 <code>setTimeout</code> 比 <code>setInterval</code> 用起来更加灵活，允许我们更精确地设置两次执行之间的时间。</li>
<li>零延时调度 <code>setTimeout(func, 0)</code>（与 <code>setTimeout(func)</code> 相同）用来调度需要尽快执行的调用，但是会在当前脚本执行完成后进行调用。</li>
<li>浏览器会将 <code>setTimeout</code> 或 <code>setInterval</code> 的五层或更多层嵌套调用（调用五次之后）的最小延时限制在 4ms。这是历史遗留问题。</li>
</ul>
<p>请注意，所有的调度方法都不能 <strong>保证</strong> 确切的延时。</p>
<p>例如，浏览器内的计时器可能由于许多原因而变慢：</p>
<ul>
<li>CPU 过载。</li>
<li>浏览器页签处于后台模式。</li>
<li>笔记本电脑用的是电池供电（译注：使用电池供电会以降低性能为代价提升续航）。</li>
</ul>
<p>所有这些因素，可能会将定时器的最小计时器分辨率（最小延迟）增加到 300ms 甚至 1000ms，具体以浏览器及其设置为准。</p>
<!--

### 分割 CPU 高占用的任务

下面讲一个用 `setTimeout` 分割 CPU 高占用任务的技巧。

譬如，一个语法高亮脚本（用来给示例代码着色）会占用非常大的 CPU 资源。为了给代码进行高亮显示，它首先要进行代码分析，然后创建一堆着色后的元素，再将其添加到页面文档中 —— 文本量很大时，耗费时间也会很长。有时候甚至会导致浏览器“挂起”，这种情况是显然不能接受的。

所以，我们不妨将长文本分割成几部分处理。首先处理前 100 行，然后用 `setTimeout(...,0)` 安排接下来 100 行的处理，以此类推。

为了方便理解，来考虑一个稍微简单点的例子。比如我们有个函数，从 `1` 数到 `1000000000`。

运行时，会观察到 CPU 挂起，服务器端 JS 表现的尤为明显。如果在浏览器下运行，试试点击页面的其他按钮，你会发现整个 JavaScript 的执行都暂停了，除非等这段代码运行完，否则什么也做不了。

```js run
let i = 0;

let start = Date.now();

function count() {

  // 执行一个耗时的任务
  for (let j = 0; j < 1e9; j++) {
    i++;
  }

  alert("Done in " + (Date.now() - start) + 'ms');
}

count();
```

机会好的话，浏览器还会显示“the script takes too long（页面脚本执行时间过长）”这样的警告（实际上不太可能，毕竟给的数字也不是特别大）。

下面用 `setTimeout` 分割任务：

```js run
let i = 0;

let start = Date.now();

function count() {

  // 先完成一部分任务(*)
  do {
    i++;
  } while (i % 1e6 != 0);

  if (i == 1e9) {
    alert("Done in " + (Date.now() - start) + 'ms');
  } else {
    setTimeout(count, 0); // 安排下一次任务 (**)
  }

}

count();
```

现在，浏览器的 UI 界面即使在“计数”正在进行的情况下也能正常工作了。

`(*)` 处代码是这么一步步完成任务的：

1. 第一次做：`i=1...1000000` 的计数。
2. 第二次做：`i=1000001..2000000` 的计数。
3. ...等等，其中 `while` 语句检查 `i` 是否刚好能被 `1000000` 整除。

如果任务还没完成，在代码 `(*)` 处安排下一次调用。

`count` 函数调用的间隙足以让 JavaScript 引擎“缓口气了”，（浏览器）趁这段时间可以对用户的操作作出回应。

用 `setTimeout` 进行分割和没用这两种做法在速度方面平分秋色，总的计数过程所花的时间几乎没什么差别。

为了进一步阐述，下面做一下改进。

将调度代码挪到 `count()` 函数开头位置：

```js run
let i = 0;

let start = Date.now();

function count() {

  // 现在将调度放在开头
  if (i < 1e9 - 1e6) {
    setTimeout(count, 0); // 安排下一次调用
  }

  do {
    i++;
  } while (i % 1e6 != 0);

  if (i == 1e9) {
    alert("Done in " + (Date.now() - start) + 'ms');
  }

}

count();
```

因为知道 `count()` 不会只执行一次，所以这一次在计数开始前就安排好下一次计数任务。

如果你自己跑一遍，会观察到这次的耗时要短上不少。

### 给浏览器渲染的机会

行间脚本还有个益处，可以用来向用户展示进度条等。因为浏览器在所有脚本执行完后，才会开始“重绘（repainting）”过程。

所以，如果运行一个非常耗时的函数，即便在这个函数中改变了文档内容，除非这个函数执行完，那么变化是不会立刻反映到页面上的。

以下是一个示例：
```html run
<div id="progress"></div>

<script>
  let i = 0;

  function count() {
    for (let j = 0; j < 1e6; j++) {
      i++;
      // 将当前 i 值放到 <div> 内
      // （innerHTML 在以后具体章节会讲到，这行代码看懂应该没问题）
      progress.innerHTML = i;
    }
  }

  count();
</script>
```

运行后会发现，`i` 值只在整个计数过程完成后才显示。

接下来用 `setTimeout` 对任务进行分割，这样就能在每一轮运行的间隙观察到变化了，效果要好得多：

```html run
<div id="progress"></div>

<script>
  let i = 0;

  function count() {

    // 每次只完成一部分 (*)
    do {
      i++;
      progress.innerHTML = i;
    } while (i % 1e3 != 0);

    if (i < 1e9) {
      setTimeout(count, 0);
    }

  }

  count();
</script>
```

现在就可以观察到 `<div>` 里 `i` 值的增长过程了。

-->

      </fieldset>
      
      <fieldset id='_6WH7qz'>
      <legend>solution</legend>
      <p>由 <code>spy(f)</code> 返回的包装器应存储所有参数，然后使用 <code>f.apply</code> 转发调用。</p>

      </fieldset>
      
      <fieldset id='_CFrhNY'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="间谍装饰者">间谍装饰者</h1>
<p>创建一个装饰者 <code>spy(func)</code>，它应该返回一个包装器，该包装器将所有对函数的调用保存在其 <code>calls</code> 属性中。 </p>
<p>每个调用都保存为一个参数数组。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">work</span>(<span class="hljs-params">a, b</span>) </span>{
  alert( a + b ); <span class="hljs-comment">// work 是一个任意的函数或方法</span>
}

*!*
work = spy(work);
*/!*

work(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 3</span>
work(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 9</span>

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> args <span class="hljs-keyword">of</span> work.calls) {
  alert( <span class="hljs-string">&#x27;call:&#x27;</span> + args.join() ); <span class="hljs-comment">// &quot;call:1,2&quot;, &quot;call:4,5&quot;</span>
}</code></pre>
<p>P.S. 该装饰者有时对于单元测试很有用。它的高级形式是 <a href="http://sinonjs.org/">Sinon.JS</a> 库中的 <code>sinon.spy</code>。</p>

      </fieldset>
      
      <fieldset id='_keOLd0'>
      <legend>solution</legend>
      <p>解决方案：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delay</span>(<span class="hljs-params">f, ms</span>) </span>{

  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> f.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>), ms);
  };

}

<span class="hljs-keyword">let</span> f1000 = delay(alert, <span class="hljs-number">1000</span>);

f1000(<span class="hljs-string">&quot;test&quot;</span>); <span class="hljs-comment">// shows &quot;test&quot; after 1000ms</span></code></pre>
<p>注意这里是如何使用箭头函数的。我们知道，箭头函数没有自己的 <code>this</code> 和 <code>arguments</code>，所以 <code>f.apply(this, arguments)</code> 从包装器中获取 <code>this</code> 和 <code>arguments</code>。</p>
<p>如果我们传递一个常规函数，<code>setTimeout</code> 将调用它且不带参数和 <code>this=window</code>（假设我们在浏览器环境）。</p>
<p>我们仍然可以通过使用中间变量来传递正确的 <code>this</code>，但这有点麻烦：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delay</span>(<span class="hljs-params">f, ms</span>) </span>{

  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>{
    <span class="hljs-keyword">let</span> savedThis = <span class="hljs-built_in">this</span>; <span class="hljs-comment">// 将 this 存储到中间变量</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      f.apply(savedThis, args); <span class="hljs-comment">// 在这儿使用它</span>
    }, ms);
  };

}</code></pre>

      </fieldset>
      
      <fieldset id='_whoriu'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="延时装饰者">延时装饰者</h1>
<p>创建一个装饰者 <code>delay(f, ms)</code>，该装饰者将 <code>f</code> 的每次调用延时 <code>ms</code> 毫秒。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">x</span>) </span>{
  alert(x);
}

<span class="hljs-comment">// create wrappers</span>
<span class="hljs-keyword">let</span> f1000 = delay(f, <span class="hljs-number">1000</span>);
<span class="hljs-keyword">let</span> f1500 = delay(f, <span class="hljs-number">1500</span>);

f1000(<span class="hljs-string">&quot;test&quot;</span>); <span class="hljs-comment">// 在 1000ms 后显示 &quot;test&quot;</span>
f1500(<span class="hljs-string">&quot;test&quot;</span>); <span class="hljs-comment">// 在 1500ms 后显示 &quot;test&quot;</span></code></pre>
<p>换句话说，<code>delay(f, ms)</code> 返回的是延迟 <code>ms</code> 后的 <code>f</code> 的变体。</p>
<p>在上面的代码中，<code>f</code> 是单个参数的函数，但是你的解决方案应该传递所有参数和上下文 <code>this</code>。</p>

      </fieldset>
      
      <fieldset id='_9QwH2g'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">func, ms</span>) </span>{
  <span class="hljs-keyword">let</span> timeout;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">clearTimeout</span>(timeout);
    timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> func.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>), ms);
  };
}
</code></pre>
<p>A call to <code>debounce</code> returns a wrapper. When called, it schedules the original function call after given <code>ms</code> and cancels the previous such timeout.</p>

      </fieldset>
      
      <fieldset id='_g9wyOJ'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="debounce-decorator">Debounce decorator</h1>
<p>The result of <code>debounce(f, ms)</code> decorator is a wrapper that suspends calls to <code>f</code> until there&#39;s <code>ms</code> milliseconds of inactivity (no calls, &quot;cooldown period&quot;), then invokes <code>f</code> once with the latest arguments.</p>
<p>For instance, we had a function <code>f</code> and replaced it with <code>f = debounce(f, 1000)</code>.</p>
<p>Then if the wrapped function is called at 0ms, 200ms and 500ms, and then there are no calls, then the actual <code>f</code> will be only called once, at 1500ms. That is: after the cooldown period of 1000ms from the last call.</p>
<p><img src="debounce.svg" alt=""></p>
<p>...And it will get the arguments of the very last call, other calls are ignored.</p>
<p>Here&#39;s the code for it (uses the debounce decorator from the <a href="https://lodash.com/docs/4.17.15#debounce">Lodash library</a>:</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> f = _.debounce(alert, <span class="hljs-number">1000</span>);

f(<span class="hljs-string">&quot;a&quot;</span>); 
<span class="hljs-built_in">setTimeout</span>( <span class="hljs-function">() =&gt;</span> f(<span class="hljs-string">&quot;b&quot;</span>), <span class="hljs-number">200</span>);
<span class="hljs-built_in">setTimeout</span>( <span class="hljs-function">() =&gt;</span> f(<span class="hljs-string">&quot;c&quot;</span>), <span class="hljs-number">500</span>); 
<span class="hljs-comment">// debounced function waits 1000ms after the last call and then runs: alert(&quot;c&quot;)</span></code></pre>
<p>Now a practical example. Let&#39;s say, the user types something, and we&#39;d like to send a request to the server when the input is finished.</p>
<p>There&#39;s no point in sending the request for every character typed. Instead we&#39;d like to wait, and then process the whole result.</p>
<p>In a web-browser, we can setup an event handler -- a function that&#39;s called on every change of an input field. Normally, an event handler is called very often, for every typed key. But if we <code>debounce</code> it by 1000ms, then it will be only called once, after 1000ms after the last input.</p>
<pre><code class="language-online">
In this live example, the handler puts the result into a box below, try it:

[iframe border=1 src=&quot;debounce&quot; height=200]

See? The second input calls the debounced function, so its content is processed after 1000ms from the last input.</code></pre>
<p>So, <code>debounce</code> is a great way to process a sequence of events: be it a sequence of key presses, mouse movements or something else.</p>
<p>It waits the given time after the last call, and then runs its function, that can process the result.</p>
<p>The task is to implement <code>debounce</code> decorator.</p>
<p>Hint: that&#39;s just a few lines if you think about it :)</p>

      </fieldset>
      
      <fieldset id='_zNuN9Z'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">func, ms</span>) </span>{

  <span class="hljs-keyword">let</span> isThrottled = <span class="hljs-literal">false</span>,
    savedArgs,
    savedThis;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params"></span>) </span>{

    <span class="hljs-keyword">if</span> (isThrottled) { <span class="hljs-comment">// (2)</span>
      savedArgs = <span class="hljs-built_in">arguments</span>;
      savedThis = <span class="hljs-built_in">this</span>;
      <span class="hljs-keyword">return</span>;
    }

    func.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>); <span class="hljs-comment">// (1)</span>

    isThrottled = <span class="hljs-literal">true</span>;

    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      isThrottled = <span class="hljs-literal">false</span>; <span class="hljs-comment">// (3)</span>
      <span class="hljs-keyword">if</span> (savedArgs) {
        wrapper.apply(savedThis, savedArgs);
        savedArgs = savedThis = <span class="hljs-literal">null</span>;
      }
    }, ms);
  }

  <span class="hljs-keyword">return</span> wrapper;
}</code></pre>
<p>调用 <code>throttle(func, ms)</code> 返回 <code>wrapper</code>。</p>
<ol>
<li>在第一次调用期间，<code>wrapper</code> 只运行 <code>func</code> 并设置冷却状态（<code>isThrottled = true</code>）。</li>
<li>在这种状态下，所有调用都记忆在 <code>savedArgs/savedThis</code> 中。请注意，上下文和参数（arguments）同等重要，应该被记下来。我们同时需要他们以重现调用。</li>
<li>……然后经过 <code>ms</code> 毫秒后，触发 <code>setTimeout</code>。冷却状态被移除（<code>isThrottled = false</code>），如果我们忽略了调用，则将使用最后记忆的参数和上下文执行 <code>wrapper</code>。</li>
</ol>
<p>第 3 步运行的不是 <code>func</code>，而是 <code>wrapper</code>，因为我们不仅需要执行 <code>func</code>，还需要再次进入冷却状态并设置 timeout 以重置它。</p>

      </fieldset>
      
      <fieldset id='_wTighd'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="节流装饰者">节流装饰者</h1>
<p>创建一个“节流”装饰者 <code>throttle(f, ms)</code> —— 返回一个包装器。</p>
<p>当被多次调用时，它会在每 <code>ms</code> 毫秒最多将调用传递给 <code>f</code> 一次。</p>
<p>与去抖的不同是，它是个完全不同的装饰器：</p>
<ul>
<li><code>debounce</code> 会在“冷却（cooldown）”期后运行函数一次。适用于处理最终结果。</li>
<li><code>throttle</code> 运行函数的频率不会大于所给定的时间 <code>ms</code> 毫秒。适用于不应该经常进行的定期更新。</li>
</ul>
<p>让我们看看现实生活中的应用程序，以便更好地理解这个需求，并了解它的来源。</p>
<p><strong>例如，我们想要跟踪鼠标移动。</strong></p>
<p>在浏览器中，我们可以设置一个函数，使其在每次鼠标移动时运行，并获取鼠标移动时的指针位置。在使用鼠标的过程中，此函数通常会执行地非常频繁，大概每秒 100 次（每 10 毫秒）。</p>
<p><strong>我们想要在鼠标指针移动时，更新网页上的某些信息。</strong></p>
<p>……但是更新函数 <code>update()</code> 太重了，无法在每个微小移动上都执行。高于每 100ms 更新一次的更新频次也没有意义。</p>
<p>因此，我们将其包装到装饰者中：使用 <code>throttle(update, 100)</code> 作为在每次鼠标移动时运行的函数，而不是原始的 <code>update()</code>。装饰者会被频繁地调用，但是最多每 100ms 将调用转发给 <code>update()</code> 一次。</p>
<p>在视觉上，它看起来像这样：</p>
<ol>
<li>对于第一个鼠标移动，装饰的变体立即将调用传递给 <code>update</code>。这很重要，用户会立即看到我们对其动作的反应。</li>
<li>然后，随着鼠标移动，直到 <code>100ms</code> 没有任何反应。装饰的变体忽略了调用。</li>
<li>在 <code>100ms</code> 结束时 —— 最后一个坐标又发生了一次 <code>update</code>。</li>
<li>然后，最后，鼠标停在某处。装饰的变体会等到 <code>100ms</code> 到期，然后用最后一个坐标运行一次 <code>update</code>。因此，非常重要的是，处理最终的鼠标坐标。</li>
</ol>
<p>一个代码示例：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a</span>) </span>{
  <span class="hljs-built_in">console</span>.log(a);
}

<span class="hljs-comment">// f1000 最多每 1000ms 将调用传递给 f 一次</span>
<span class="hljs-keyword">let</span> f1000 = throttle(f, <span class="hljs-number">1000</span>);

f1000(<span class="hljs-number">1</span>); <span class="hljs-comment">// 显示 1</span>
f1000(<span class="hljs-number">2</span>); <span class="hljs-comment">// (节流，尚未到 1000ms)</span>
f1000(<span class="hljs-number">3</span>); <span class="hljs-comment">// (节流，尚未到 1000ms)</span>

<span class="hljs-comment">// 当 1000ms 时间到...</span>
<span class="hljs-comment">// ...输出 3，中间值 2 被忽略</span></code></pre>
<p>P.S. 参数（arguments）和传递给 <code>f1000</code> 的上下文 <code>this</code> 应该被传递给原始的 <code>f</code>。</p>

      </fieldset>
      
      <fieldset id='_IdmuXm'>
      <legend>article</legend>
      <h1 id="装饰者模式和转发，callapply">装饰者模式和转发，call/apply</h1>
<p>JavaScript 在处理函数时提供了非凡的灵活性。它们可以被传递，用作对象，现在我们将看到如何在它们之间 <strong>转发（forward）</strong> 调用并 <strong>装饰（decorate）</strong> 它们。</p>
<h2 id="透明缓存">透明缓存</h2>
<p>假设我们有一个 CPU 重负载的函数 <code>slow(x)</code>，但它的结果是稳定的。换句话说，对于相同的 <code>x</code>，它总是返回相同的结果。</p>
<p>如果经常调用该函数，我们可能希望将结果缓存（记住）下来，以避免在重新计算上花费额外的时间。</p>
<p>但是我们不是将这个功能添加到 <code>slow()</code> 中，而是创建一个包装器（wrapper）函数，该函数增加了缓存功能。正如我们将要看到的，这样做有很多好处。</p>
<p>下面是代码和解释：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">slow</span>(<span class="hljs-params">x</span>) </span>{
  <span class="hljs-comment">// 这里可能会有重负载的 CPU 密集型工作</span>
  alert(<span class="hljs-string">`Called with <span class="hljs-subst">${x}</span>`</span>);
  <span class="hljs-keyword">return</span> x;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cachingDecorator</span>(<span class="hljs-params">func</span>) </span>{
  <span class="hljs-keyword">let</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{
    <span class="hljs-keyword">if</span> (cache.has(x)) {    <span class="hljs-comment">// 如果缓存中有对应的结果</span>
      <span class="hljs-keyword">return</span> cache.get(x); <span class="hljs-comment">// 从缓存中读取结果</span>
    }

    <span class="hljs-keyword">let</span> result = func(x);  <span class="hljs-comment">// 否则就调用 func</span>

    cache.set(x, result);  <span class="hljs-comment">// 然后将结果缓存（记住）下来</span>
    <span class="hljs-keyword">return</span> result;
  };
}

slow = cachingDecorator(slow);

alert( slow(<span class="hljs-number">1</span>) ); <span class="hljs-comment">// slow(1) 被缓存下来了</span>
alert( <span class="hljs-string">&quot;Again: &quot;</span> + slow(<span class="hljs-number">1</span>) ); <span class="hljs-comment">// 一样的</span>

alert( slow(<span class="hljs-number">2</span>) ); <span class="hljs-comment">// slow(2) 被缓存下来了</span>
alert( <span class="hljs-string">&quot;Again: &quot;</span> + slow(<span class="hljs-number">2</span>) ); <span class="hljs-comment">// 和前面一行结果相同</span></code></pre>
<p>在上面的代码中，<code>cachingDecorator</code> 是一个 <strong>装饰者（decorator）</strong>：一个特殊的函数，它接受另一个函数并改变它的行为。</p>
<p>其思想是，我们可以为任何函数调用 <code>cachingDecorator</code>，它将返回缓存包装器。这很棒啊，因为我们有很多函数可以使用这样的特性，而我们需要做的就是将 <code>cachingDecorator</code> 应用于它们。</p>
<p>通过将缓存与主函数代码分开，我们还可以使主函数代码变得更简单。</p>
<p><code>cachingDecorator(func)</code> 的结果是一个“包装器”：<code>function(x)</code> 将 <code>func(x)</code> 的调用“包装”到缓存逻辑中：</p>
<p><img src="decorator-makecaching-wrapper.svg" alt=""></p>
<p>从外部代码来看，包装的 <code>slow</code> 函数执行的仍然是与之前相同的操作。它只是在其行为上添加了缓存功能。</p>
<p>总而言之，使用分离的 <code>cachingDecorator</code> 而不是改变 <code>slow</code> 本身的代码有几个好处：</p>
<ul>
<li><code>cachingDecorator</code> 是可重用的。我们可以将它应用于另一个函数。</li>
<li>缓存逻辑是独立的，它没有增加 <code>slow</code> 本身的复杂性（如果有的话）。</li>
<li>如果需要，我们可以组合多个装饰者（其他装饰者将遵循同样的逻辑）。</li>
</ul>
<h2 id="使用-funccall-设定上下文">使用 &quot;func.call&quot; 设定上下文</h2>
<p>上面提到的缓存装饰者不适用于对象方法。</p>
<p>例如，在下面的代码中，<code>worker.slow()</code> 在装饰后停止工作：</p>
<pre><code class="language-js"><span class="hljs-comment">// 我们将对 worker.slow 的结果进行缓存</span>
<span class="hljs-keyword">let</span> worker = {
  <span class="hljs-function"><span class="hljs-title">someMethod</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  },

  <span class="hljs-function"><span class="hljs-title">slow</span>(<span class="hljs-params">x</span>)</span> {
    <span class="hljs-comment">// 可怕的 CPU 过载任务</span>
    alert(<span class="hljs-string">&quot;Called with &quot;</span> + x);
    <span class="hljs-keyword">return</span> x * <span class="hljs-built_in">this</span>.someMethod(); <span class="hljs-comment">// (*)</span>
  }
};

<span class="hljs-comment">// 和之前例子中的代码相同</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cachingDecorator</span>(<span class="hljs-params">func</span>) </span>{
  <span class="hljs-keyword">let</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{
    <span class="hljs-keyword">if</span> (cache.has(x)) {
      <span class="hljs-keyword">return</span> cache.get(x);
    }
*!*
    <span class="hljs-keyword">let</span> result = func(x); <span class="hljs-comment">// (**)</span>
*/!*
    cache.set(x, result);
    <span class="hljs-keyword">return</span> result;
  };
}

alert( worker.slow(<span class="hljs-number">1</span>) ); <span class="hljs-comment">// 原始方法有效</span>

worker.slow = cachingDecorator(worker.slow); <span class="hljs-comment">// 现在对其进行缓存</span>

*!*
alert( worker.slow(<span class="hljs-number">2</span>) ); <span class="hljs-comment">// 蛤！Error: Cannot read property &#x27;someMethod&#x27; of undefined</span>
*/!*</code></pre>
<p>错误发生在试图访问 <code>this.someMethod</code> 并失败了的 <code>(*)</code> 行中。你能看出来为什么吗？</p>
<p>原因是包装器将原始函数调用为 <code>(**)</code> 行中的 <code>func(x)</code>。并且，当这样调用时，函数将得到 <code>this = undefined</code>。</p>
<p>如果尝试运行下面这段代码，我们会观察到类似的问题：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> func = worker.slow;
func(<span class="hljs-number">2</span>);</code></pre>
<p>因此，包装器将调用传递给原始方法，但没有上下文 <code>this</code>。因此，发生了错误。</p>
<p>让我们来解决这个问题。</p>
<p>有一个特殊的内置函数方法 <a href="mdn:js/Function/call">func.call(context, ...args)</a>，它允许调用一个显式设置 <code>this</code> 的函数。</p>
<p>语法如下：</p>
<pre><code class="language-js">func.call(context, arg1, arg2, ...)</code></pre>
<p>它运行 <code>func</code>，提供的第一个参数作为 <code>this</code>，后面的作为参数（arguments）。</p>
<p>简单地说，这两个调用几乎相同：</p>
<pre><code class="language-js">func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
func.call(obj, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</code></pre>
<p>它们调用的都是 <code>func</code>，参数是 <code>1</code>、<code>2</code> 和 <code>3</code>。唯一的区别是 <code>func.call</code> 还会将 <code>this</code> 设置为 <code>obj</code>。</p>
<p>例如，在下面的代码中，我们在不同对象的上下文中调用 <code>sayHi</code>：<code>sayHi.call(user)</code> 运行 <code>sayHi</code> 并提供了 <code>this=user</code>，然后下一行设置 <code>this=admin</code>：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-built_in">this</span>.name);
}

<span class="hljs-keyword">let</span> user = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> };
<span class="hljs-keyword">let</span> admin = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Admin&quot;</span> };

<span class="hljs-comment">// 使用 call 将不同的对象传递为 &quot;this&quot;</span>
sayHi.call( user ); <span class="hljs-comment">// John</span>
sayHi.call( admin ); <span class="hljs-comment">// Admin</span></code></pre>
<p>在这里我们用带有给定上下文和 phrase 的 <code>call</code> 调用 <code>say</code>：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">say</span>(<span class="hljs-params">phrase</span>) </span>{
  alert(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;: &#x27;</span> + phrase);
}

<span class="hljs-keyword">let</span> user = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> };

<span class="hljs-comment">// user 成为 this，&quot;Hello&quot; 成为第一个参数</span>
say.call( user, <span class="hljs-string">&quot;Hello&quot;</span> ); <span class="hljs-comment">// John: Hello</span></code></pre>
<p>在我们的例子中，我们可以在包装器中使用 <code>call</code> 将上下文传递给原始函数：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> worker = {
  <span class="hljs-function"><span class="hljs-title">someMethod</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  },

  <span class="hljs-function"><span class="hljs-title">slow</span>(<span class="hljs-params">x</span>)</span> {
    alert(<span class="hljs-string">&quot;Called with &quot;</span> + x);
    <span class="hljs-keyword">return</span> x * <span class="hljs-built_in">this</span>.someMethod(); <span class="hljs-comment">// (*)</span>
  }
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cachingDecorator</span>(<span class="hljs-params">func</span>) </span>{
  <span class="hljs-keyword">let</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{
    <span class="hljs-keyword">if</span> (cache.has(x)) {
      <span class="hljs-keyword">return</span> cache.get(x);
    }
*!*
    <span class="hljs-keyword">let</span> result = func.call(<span class="hljs-built_in">this</span>, x); <span class="hljs-comment">// 现在 &quot;this&quot; 被正确地传递了</span>
*/!*
    cache.set(x, result);
    <span class="hljs-keyword">return</span> result;
  };
}

worker.slow = cachingDecorator(worker.slow); <span class="hljs-comment">// 现在对其进行缓存</span>

alert( worker.slow(<span class="hljs-number">2</span>) ); <span class="hljs-comment">// 工作正常</span>
alert( worker.slow(<span class="hljs-number">2</span>) ); <span class="hljs-comment">// 工作正常，没有调用原始函数（使用的缓存）</span></code></pre>
<p>现在一切都正常工作了。</p>
<p>为了让大家理解地更清晰一些，让我们更深入地看看 <code>this</code> 是如何被传递的：</p>
<ol>
<li>在经过装饰之后，<code>worker.slow</code> 现在是包装器 <code>function (x) { ... }</code>。</li>
<li>因此，当 <code>worker.slow(2)</code> 执行时，包装器将 <code>2</code> 作为参数，并且 <code>this=worker</code>（它是点符号 <code>.</code> 之前的对象）。</li>
<li>在包装器内部，假设结果尚未缓存，<code>func.call(this, x)</code> 将当前的 <code>this</code>（<code>=worker</code>）和当前的参数（<code>=2</code>）传递给原始方法。</li>
</ol>
<h2 id="传递多个参数">传递多个参数</h2>
<p>现在让我们把 <code>cachingDecorator</code> 写得更加通用。到现在为止，它只能用于单参数函数。</p>
<p>现在如何缓存多参数 <code>worker.slow</code> 方法呢？</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> worker = {
  <span class="hljs-function"><span class="hljs-title">slow</span>(<span class="hljs-params">min, max</span>)</span> {
    <span class="hljs-keyword">return</span> min + max; <span class="hljs-comment">// scary CPU-hogger is assumed</span>
  }
};

<span class="hljs-comment">// 应该记住相同参数的调用</span>
worker.slow = cachingDecorator(worker.slow);</code></pre>
<p>之前，对于单个参数 <code>x</code>，我们可以只使用 <code>cache.set(x, result)</code> 来保存结果，并使用 <code>cache.get(x)</code> 来检索并获取结果。但是现在，我们需要记住 <strong>参数组合</strong> <code>(min,max)</code> 的结果。原生的 <code>Map</code> 仅将单个值作为键（key）。</p>
<p>这儿有许多解决方案可以实现：</p>
<ol>
<li>实现一个新的（或使用第三方的）类似 map 的更通用并且允许多个键的数据结构。</li>
<li>使用嵌套 map：<code>cache.set(min)</code> 将是一个存储（键值）对 <code>(max, result)</code> 的 <code>Map</code>。所以我们可以使用 <code>cache.get(min).get(max)</code> 来获取 <code>result</code>。</li>
<li>将两个值合并为一个。为了灵活性，我们可以允许为装饰者提供一个“哈希函数”，该函数知道如何将多个值合并为一个值。</li>
</ol>
<p>对于许多实际应用，第三种方式就足够了，所以我们就用这个吧。</p>
<p>当然，我们需要传入的不仅是 <code>x</code>，还需要传入 <code>func.call</code> 的所有参数。让我们回想一下，在 <code>function()</code> 中我们可以得到一个包含所有参数的伪数组（pseudo-array）<code>arguments</code>，那么 <code>func.call(this, x)</code> 应该被替换为 <code>func.call(this, ...arguments)</code>。</p>
<p>这是一个更强大的 <code>cachingDecorator</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> worker = {
  <span class="hljs-function"><span class="hljs-title">slow</span>(<span class="hljs-params">min, max</span>)</span> {
    alert(<span class="hljs-string">`Called with <span class="hljs-subst">${min}</span>,<span class="hljs-subst">${max}</span>`</span>);
    <span class="hljs-keyword">return</span> min + max;
  }
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cachingDecorator</span>(<span class="hljs-params">func, hash</span>) </span>{
  <span class="hljs-keyword">let</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
*!*
    <span class="hljs-keyword">let</span> key = hash(<span class="hljs-built_in">arguments</span>); <span class="hljs-comment">// (*)</span>
*/!*
    <span class="hljs-keyword">if</span> (cache.has(key)) {
      <span class="hljs-keyword">return</span> cache.get(key);
    }

*!*
    <span class="hljs-keyword">let</span> result = func.call(<span class="hljs-built_in">this</span>, ...arguments); <span class="hljs-comment">// (**)</span>
*/!*

    cache.set(key, result);
    <span class="hljs-keyword">return</span> result;
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hash</span>(<span class="hljs-params">args</span>) </span>{
  <span class="hljs-keyword">return</span> args[<span class="hljs-number">0</span>] + <span class="hljs-string">&#x27;,&#x27;</span> + args[<span class="hljs-number">1</span>];
}

worker.slow = cachingDecorator(worker.slow, hash);

alert( worker.slow(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>) ); <span class="hljs-comment">// works</span>
alert( <span class="hljs-string">&quot;Again &quot;</span> + worker.slow(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>) ); <span class="hljs-comment">// same (cached)</span></code></pre>
<p>现在这个包装器可以处理任意数量的参数了（尽管哈希函数还需要被进行调整以允许任意数量的参数。一种有趣的处理方法将在下面讲到）。</p>
<p>这里有两个变化：</p>
<ul>
<li>在 <code>(*)</code> 行中它调用 <code>hash</code> 来从 <code>arguments</code> 创建一个单独的键。这里我们使用一个简单的“连接”函数，将参数 <code>(3, 5)</code> 转换为键 <code>&quot;3,5&quot;</code>。更复杂的情况可能需要其他哈希函数。</li>
<li>然后 <code>(**)</code> 行使用 <code>func.call(this, ...arguments)</code> 将包装器获得的上下文和所有参数（不仅仅是第一个参数）传递给原始函数。</li>
</ul>
<h2 id="funcapply">func.apply</h2>
<p>我们可以使用 <code>func.apply(this, arguments)</code> 代替 <code>func.call(this, ...arguments)</code>。</p>
<p>内建方法 <a href="mdn:js/Function/apply">func.apply</a> 的语法是：</p>
<pre><code class="language-js">func.apply(context, args)</code></pre>
<p>它运行 <code>func</code> 设置 <code>this=context</code>，并使用类数组对象 <code>args</code> 作为参数列表（arguments）。</p>
<p><code>call</code> 和 <code>apply</code> 之间唯一的语法区别是，<code>call</code> 期望一个参数列表，而 <code>apply</code> 期望一个包含这些参数的类数组对象。</p>
<p>因此，这两个调用几乎是等效的：</p>
<pre><code class="language-js">func.call(context, ...args); <span class="hljs-comment">// 使用 spread 语法将数组作为列表传递</span>
func.apply(context, args);   <span class="hljs-comment">// 与使用 call 相同</span></code></pre>
<p>这里只有很小的区别：</p>
<ul>
<li>Spread 语法 <code>...</code> 允许将 <strong>可迭代对象</strong> <code>args</code> 作为列表传递给 <code>call</code>。</li>
<li><code>apply</code> 仅接受 <strong>类数组对象</strong> <code>args</code>。</li>
</ul>
<p>因此，当我们期望可迭代对象时，使用 <code>call</code>，当我们期望类数组对象时，使用 <code>apply</code>。</p>
<p>对于即可迭代又是类数组的对象，例如一个真正的数组，我们使用 <code>call</code> 或 <code>apply</code> 均可，但是 <code>apply</code> 可能会更快，因为大多数 JavaScript 引擎在内部对其进行了优化。</p>
<p>将所有参数连同上下文一起传递给另一个函数被称为“呼叫转移（call forwarding）”。</p>
<p>这是它的最简形式：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> wrapper = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> func.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);
};</code></pre>
<p>当外部代码调用这种包装器 <code>wrapper</code> 时，它与原始函数 <code>func</code> 的调用是无法区分的。</p>
<h2 id="借用一种方法-method-borrowing">借用一种方法 [#method-borrowing]</h2>
<p>现在，让我们对哈希函数再做一个较小的改进：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hash</span>(<span class="hljs-params">args</span>) </span>{
  <span class="hljs-keyword">return</span> args[<span class="hljs-number">0</span>] + <span class="hljs-string">&#x27;,&#x27;</span> + args[<span class="hljs-number">1</span>];
}</code></pre>
<p>截至目前，它仅适用于两个参数。如果它可以适用于任何数量的 <code>args</code> 就更好了。</p>
<p>自然的解决方案是使用 <a href="mdn:js/Array/join">arr.join</a> 方法：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hash</span>(<span class="hljs-params">args</span>) </span>{
  <span class="hljs-keyword">return</span> args.join();
}</code></pre>
<p>……不幸的是，这不行。因为我们正在调用 <code>hash(arguments)</code>，<code>arguments</code> 对象既是可迭代对象又是类数组对象，但它并不是真正的数组。</p>
<p>所以在它上面调用 <code>join</code> 会失败，我们可以在下面看到：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hash</span>(<span class="hljs-params"></span>) </span>{
*!*
  alert( <span class="hljs-built_in">arguments</span>.join() ); <span class="hljs-comment">// Error: arguments.join is not a function</span>
*/!*
}

hash(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);</code></pre>
<p>不过，有一种简单的方法可以使用数组的 join 方法：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hash</span>(<span class="hljs-params"></span>) </span>{
*!*
  alert( [].join.call(<span class="hljs-built_in">arguments</span>) ); <span class="hljs-comment">// 1,2</span>
*/!*
}

hash(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);</code></pre>
<p>这个技巧被称为 <strong>方法借用（method borrowing）</strong>。</p>
<p>我们从常规数组 <code>[].join</code> 中获取（借用）join 方法，并使用 <code>[].join.call</code> 在 <code>arguments</code> 的上下文中运行它。</p>
<p>它为什么有效？</p>
<p>那是因为原生方法 <code>arr.join(glue)</code> 的内部算法非常简单。</p>
<p>从规范中几乎“按原样”解释如下：</p>
<ol>
<li>让 <code>glue</code> 成为第一个参数，如果没有参数，则使用逗号 <code>&quot;,&quot;</code>。</li>
<li>让 <code>result</code> 为空字符串。</li>
<li>将 <code>this[0]</code> 附加到 <code>result</code>。</li>
<li>附加 <code>glue</code> 和 <code>this[1]</code>。</li>
<li>附加 <code>glue</code> 和 <code>this[2]</code>。</li>
<li>……以此类推，直到 <code>this.length</code> 项目被粘在一起。</li>
<li>返回 <code>result</code>。</li>
</ol>
<p>因此，从技术上讲，它需要 <code>this</code> 并将 <code>this[0]</code>，<code>this[1]</code> ……等 join 在一起。它的编写方式是故意允许任何类数组的 <code>this</code> 的（不是巧合，很多方法都遵循这种做法）。这就是为什么它也可以和 <code>this=arguments</code> 一起使用。</p>
<h2 id="装饰者和函数属性">装饰者和函数属性</h2>
<p>通常，用装饰的函数替换一个函数或一个方法是安全的，除了一件小东西。如果原始函数有属性，例如 <code>func.calledCount</code> 或其他，则装饰后的函数将不再提供这些属性。因为这是装饰者。因此，如果有人使用它们，那么就需要小心。</p>
<p>例如，在上面的示例中，如果 <code>slow</code> 函数具有任何属性，而 <code>cachingDecorator(slow)</code> 则是一个没有这些属性的包装器。</p>
<p>一些包装器可能会提供自己的属性。例如，装饰者会计算一个函数被调用了多少次以及花费了多少时间，并通过包装器属性公开（expose）这些信息。</p>
<p>存在一种创建装饰者的方法，该装饰者可保留对函数属性的访问权限，但这需要使用特殊的 <code>Proxy</code> 对象来包装函数。我们将在后面的 <a href="info:proxy#proxy-apply">info:proxy#proxy-apply</a> 中学习它。</p>
<h2 id="总结">总结</h2>
<p><strong>装饰者</strong> 是一个围绕改变函数行为的包装器。主要工作仍由该函数来完成。</p>
<p>装饰者可以被看作是可以添加到函数的 &quot;features&quot; 或 &quot;aspects&quot;。我们可以添加一个或添加多个。而这一切都无需更改其代码！</p>
<p>为了实现 <code>cachingDecorator</code>，我们研究了以下方法：</p>
<ul>
<li><a href="mdn:js/Function/call">func.call(context, arg1, arg2...)</a> —— 用给定的上下文和参数调用 <code>func</code>。</li>
<li><a href="mdn:js/Function/apply">func.apply(context, args)</a> —— 调用 <code>func</code> 将 <code>context</code> 作为 <code>this</code> 和类数组的 <code>args</code> 传递给参数列表。</li>
</ul>
<p>通用的 <strong>呼叫转移（call forwarding）</strong> 通常是使用 <code>apply</code> 完成的：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> wrapper = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> original.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);
};</code></pre>
<p>我们也可以看到一个 <strong>方法借用（method borrowing）</strong> 的例子，就是我们从一个对象中获取一个方法，并在另一个对象的上下文中“调用”它。采用数组方法并将它们应用于参数 <code>arguments</code> 是很常见的。另一种方法是使用 Rest 参数对象，该对象是一个真正的数组。</p>
<p>在 JavaScript 领域里有很多装饰者（decorators）。通过解决本章的任务，来检查你掌握它们的程度吧。</p>

      </fieldset>
      
      <fieldset id='_grvCHX'>
      <legend>solution</legend>
      <p>答案：<code>null</code>。</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  alert( <span class="hljs-built_in">this</span> ); <span class="hljs-comment">// null</span>
}

<span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">g</span>: f.bind(<span class="hljs-literal">null</span>)
};

user.g();</code></pre>
<p>绑定函数的上下文是硬绑定（hard-fixed）的。没有办法再修改它。</p>
<p>所以即使我们执行 <code>user.g()</code>，源方法调用时还是 <code>this=null</code>。</p>

      </fieldset>
      
      <fieldset id='_SOaeYe'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="作为方法的绑定函数">作为方法的绑定函数</h1>
<p>输出将会是什么？</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  alert( <span class="hljs-built_in">this</span> ); <span class="hljs-comment">// ?</span>
}

<span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">g</span>: f.bind(<span class="hljs-literal">null</span>)
};

user.g();</code></pre>

      </fieldset>
      
      <fieldset id='_XCcK9J'>
      <legend>solution</legend>
      <p>答案：<strong>John</strong>。</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-built_in">this</span>.name);
}

f = f.bind( {<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>} ).bind( {<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Pete&quot;</span>} );

f(); <span class="hljs-comment">// John</span></code></pre>
<p><code>f.bind(...)</code> 返回的外来（exotic）<a href="https://tc39.github.io/ecma262/#sec-bound-function-exotic-objects">绑定函数</a> 对象仅在创建的时候记忆上下文（以及参数，如果提供了的话）。</p>
<p>一个函数不能被重绑定（re-bound）。</p>

      </fieldset>
      
      <fieldset id='_3yjKq7'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="二次-bind">二次 bind</h1>
<p>我们可以通过额外的绑定改变 <code>this</code> 吗？</p>
<p>输出将会是什么？</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-built_in">this</span>.name);
}

f = f.bind( {<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>} ).bind( {<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Ann&quot;</span> } );

f();</code></pre>

      </fieldset>
      
      <fieldset id='_aC1Zzf'>
      <legend>solution</legend>
      <p>答案：<code>undefined</code>。</p>
<p><code>bind</code> 的结果是另一个对象。它并没有 <code>test</code> 属性。</p>

      </fieldset>
      
      <fieldset id='_KeureU'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="bind-后的函数属性">bind 后的函数属性</h1>
<p>函数的属性中有一个值。<code>bind</code> 之后它会改变吗？为什么，阐述一下？</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>{
  alert( <span class="hljs-built_in">this</span>.name );
}
sayHi.test = <span class="hljs-number">5</span>;

*!*
<span class="hljs-keyword">let</span> bound = sayHi.bind({
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>
});

alert( bound.test ); <span class="hljs-comment">// 输出将会是什么？为什么？</span>
*/!*</code></pre>

      </fieldset>
      
      <fieldset id='_4Pet8f'>
      <legend>solution</legend>
      <p>发生了错误是因为 <code>ask</code> 获得的是没有绑定对象的 <code>loginOk/loginFail</code> 函数。</p>
<p>当 <code>ask</code> 调用这两个函数时，它们自然会认定 <code>this=undefined</code>。</p>
<p>让我们 <code>bind</code> 上下文：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">askPassword</span>(<span class="hljs-params">ok, fail</span>) </span>{
  <span class="hljs-keyword">let</span> password = prompt(<span class="hljs-string">&quot;Password?&quot;</span>, <span class="hljs-string">&#x27;&#x27;</span>);
  <span class="hljs-keyword">if</span> (password == <span class="hljs-string">&quot;rockstar&quot;</span>) ok();
  <span class="hljs-keyword">else</span> fail();
}

<span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>,

  <span class="hljs-function"><span class="hljs-title">loginOk</span>(<span class="hljs-params"></span>)</span> {
    alert(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">this</span>.name}</span> logged in`</span>);
  },

  <span class="hljs-function"><span class="hljs-title">loginFail</span>(<span class="hljs-params"></span>)</span> {
    alert(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">this</span>.name}</span> failed to log in`</span>);
  },

};

*!*
askPassword(user.loginOk.bind(user), user.loginFail.bind(user));
*/!*</code></pre>
<p>现在它能正常工作了。</p>
<p>另一个可替换解决方案是：</p>
<pre><code class="language-js"><span class="hljs-comment">//...</span>
askPassword(<span class="hljs-function">() =&gt;</span> user.loginOk(), <span class="hljs-function">() =&gt;</span> user.loginFail());</code></pre>
<p>通常这也能正常工作，也看起来挺好的。</p>
<p>但是可能会在更复杂的场景下失效，例如变量 <code>user</code> 在调用 <code>askPassword</code> 之后但在访问者应答和调用 <code>() =&gt; user.loginOk()</code> 之前被修改。</p>

      </fieldset>
      
      <fieldset id='_v5fXRd'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="修复丢失了-this-的函数">修复丢失了 &quot;this&quot; 的函数</h1>
<p>下面代码中对 <code>askPassword()</code> 的调用将会检查 password，然后基于结果调用 <code>user.loginOk/loginFail</code>。</p>
<p>但是它导致了一个错误。为什么？</p>
<p>修改高亮的行，以使所有内容都能正常工作（其它行不用修改）。</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">askPassword</span>(<span class="hljs-params">ok, fail</span>) </span>{
  <span class="hljs-keyword">let</span> password = prompt(<span class="hljs-string">&quot;Password?&quot;</span>, <span class="hljs-string">&#x27;&#x27;</span>);
  <span class="hljs-keyword">if</span> (password == <span class="hljs-string">&quot;rockstar&quot;</span>) ok();
  <span class="hljs-keyword">else</span> fail();
}

<span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>,

  <span class="hljs-function"><span class="hljs-title">loginOk</span>(<span class="hljs-params"></span>)</span> {
    alert(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">this</span>.name}</span> logged in`</span>);
  },

  <span class="hljs-function"><span class="hljs-title">loginFail</span>(<span class="hljs-params"></span>)</span> {
    alert(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">this</span>.name}</span> failed to log in`</span>);
  },

};

*!*
askPassword(user.loginOk, user.loginFail);
*/!*</code></pre>

      </fieldset>
      
      <fieldset id='_pYEUcU'>
      <legend>solution</legend>
      <ol>
<li><p>使用包装（wapper）函数，箭头函数很简洁：</p>
<pre><code class="language-js">askPassword(<span class="hljs-function">() =&gt;</span> user.login(<span class="hljs-literal">true</span>), <span class="hljs-function">() =&gt;</span> user.login(<span class="hljs-literal">false</span>)); </code></pre>
<p> 现在它从外部变量中获得了 <code>user</code>，然后以常规方式运行它。</p>
</li>
<li><p>或者从 <code>user.login</code> 创建一个偏函数，该函数使用 <code>user</code> 作为上下文，并具有正确的第一个参数：</p>
</li>
</ol>
<pre><code>```js 
askPassword(user.login.bind(user, true), user.login.bind(user, false)); 
```</code></pre>

      </fieldset>
      
      <fieldset id='_yEdfXb'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="偏函数在登录中的应用">偏函数在登录中的应用</h1>
<p>这个任务是比 <a href="info:task/question-use-bind">info:task/question-use-bind</a> 略微复杂的变体。</p>
<p><code>user</code> 对象被修改了。现在不是两个函数 <code>loginOk/loginFail</code>，现在只有一个函数 <code>user.login(true/false)</code>。</p>
<p>在下面的代码中，我们应该向 <code>askPassword</code> 传入什么参数，以使得 <code>user.login(true)</code> 结果是 <code>ok</code>，<code>user.login(fasle)</code> 结果是 <code>fail</code>？</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">askPassword</span>(<span class="hljs-params">ok, fail</span>) </span>{
  <span class="hljs-keyword">let</span> password = prompt(<span class="hljs-string">&quot;Password?&quot;</span>, <span class="hljs-string">&#x27;&#x27;</span>);
  <span class="hljs-keyword">if</span> (password == <span class="hljs-string">&quot;rockstar&quot;</span>) ok();
  <span class="hljs-keyword">else</span> fail();
}

<span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>,

  <span class="hljs-function"><span class="hljs-title">login</span>(<span class="hljs-params">result</span>)</span> {
    alert( <span class="hljs-built_in">this</span>.name + (result ? <span class="hljs-string">&#x27; logged in&#x27;</span> : <span class="hljs-string">&#x27; failed to log in&#x27;</span>) );
  }
};

*!*
askPassword(?, ?); <span class="hljs-comment">// ?</span>
*/!*</code></pre>
<p>你只能修改高亮部分的代码。</p>

      </fieldset>
      
      <fieldset id='_aEbG06'>
      <legend>article</legend>
      <p>libs:</p>
<ul>
<li>lodash</li>
</ul>
<hr>
<h1 id="函数绑定">函数绑定</h1>
<p>当将对象方法作为回调进行传递，例如传递给 <code>setTimeout</code>，这儿会存在一个常见的问题：“丢失 <code>this</code>”。</p>
<p>在本章中，我们会学习如何去解决这个问题。</p>
<h2 id="丢失-this">丢失 &quot;this&quot;</h2>
<p>我们已经看到了丢失 <code>this</code> 的例子。一旦方法被传递到与对象分开的某个地方 —— <code>this</code> 就丢失。</p>
<p>下面是使用 <code>setTimeout</code> 时 <code>this</code> 是如何丢失的：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> {
    alert(<span class="hljs-string">`Hello, <span class="hljs-subst">${<span class="hljs-built_in">this</span>.firstName}</span>!`</span>);
  }
};

*!*
<span class="hljs-built_in">setTimeout</span>(user.sayHi, <span class="hljs-number">1000</span>); <span class="hljs-comment">// Hello, undefined!</span>
*/!*</code></pre>
<p>正如我们所看到的，输出没有像 <code>this.firstName</code> 那样显示 &quot;John&quot;，而显示了 <code>undefined</code>！</p>
<p>这是因为 <code>setTimeout</code> 获取到了函数 <code>user.sayHi</code>，但它和对象分离开了。最后一行可以被重写为：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> f = user.sayHi;
<span class="hljs-built_in">setTimeout</span>(f, <span class="hljs-number">1000</span>); <span class="hljs-comment">// 丢失了 user 上下文</span></code></pre>
<p>浏览器中的 <code>setTimeout</code> 方法有些特殊：它为函数调用设定了 <code>this=window</code>（对于 Node.js，<code>this</code> 则会变为计时器（timer）对象，但在这儿并不重要）。所以对于 <code>this.firstName</code>，它其实试图获取的是 <code>window.firstName</code>，这个变量并不存在。在其他类似的情况下，通常 <code>this</code> 会变为 <code>undefined</code>。</p>
<p>这个需求很典型 —— 我们想将一个对象方法传递到别的地方（这里 —— 传递到调度程序），然后在该位置调用它。如何确保在正确的上下文中调用它？</p>
<h2 id="解决方案-1：包装器">解决方案 1：包装器</h2>
<p>最简单的解决方案是使用一个包装函数：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> {
    alert(<span class="hljs-string">`Hello, <span class="hljs-subst">${<span class="hljs-built_in">this</span>.firstName}</span>!`</span>);
  }
};

*!*
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  user.sayHi(); <span class="hljs-comment">// Hello, John!</span>
}, <span class="hljs-number">1000</span>);
*/!*</code></pre>
<p>现在它可以正常工作了，因为它从外部词法环境中获取到了 <code>user</code>，就可以正常地调用方法了。</p>
<p>相同的功能，但是更简短：</p>
<pre><code class="language-js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> user.sayHi(), <span class="hljs-number">1000</span>); <span class="hljs-comment">// Hello, John!</span></code></pre>
<p>看起来不错，但是我们的代码结构中出现了一个小漏洞。</p>
<p>如果在 <code>setTimeout</code> 触发之前（有一秒的延迟！）<code>user</code> 的值改变了怎么办？那么，突然间，它将调用错误的对象！</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> {
    alert(<span class="hljs-string">`Hello, <span class="hljs-subst">${<span class="hljs-built_in">this</span>.firstName}</span>!`</span>);
  }
};

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> user.sayHi(), <span class="hljs-number">1000</span>);

<span class="hljs-comment">// ……user 的值在不到 1 秒的时间内发生了改变</span>
user = {
  <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> { alert(<span class="hljs-string">&quot;Another user in setTimeout!&quot;</span>); }
};

<span class="hljs-comment">// Another user in setTimeout!</span></code></pre>
<p>下一个解决方案保证了这样的事情不会发生。</p>
<h2 id="解决方案-2：bind">解决方案 2：bind</h2>
<p>函数提供了一个内建方法 <a href="mdn:js/Function/bind">bind</a>，它可以绑定 <code>this</code>。</p>
<p>基本的语法是：</p>
<pre><code class="language-js"><span class="hljs-comment">// 稍后将会有更复杂的语法</span>
<span class="hljs-keyword">let</span> boundFunc = func.bind(context);</code></pre>
<p><code>func.bind(context)</code> 的结果是一个特殊的类似于函数的“外来对象（exotic object）”，它可以像函数一样被调用，并且透明地（transparently）将调用传递给 <code>func</code> 并设定 <code>this=context</code>。</p>
<p>换句话说，<code>boundFunc</code> 调用就像绑定了 <code>this</code> 的 <code>func</code>。</p>
<p>举个例子，这里的 <code>funcUser</code> 将调用传递给了 <code>func</code> 同时 <code>this=user</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;John&quot;</span>
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-built_in">this</span>.firstName);
}

*!*
<span class="hljs-keyword">let</span> funcUser = func.bind(user);
funcUser(); <span class="hljs-comment">// John  </span>
*/!*</code></pre>
<p>这里的 <code>func.bind(user)</code> 作为 <code>func</code> 的“绑定的（bound）变体”，绑定了 <code>this=user</code>。</p>
<p>所有的参数（arguments）都被“原样”传递给了初始的 <code>func</code>，例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;John&quot;</span>
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params">phrase</span>) </span>{
  alert(phrase + <span class="hljs-string">&#x27;, &#x27;</span> + <span class="hljs-built_in">this</span>.firstName);
}

<span class="hljs-comment">// 将 this 绑定到 user</span>
<span class="hljs-keyword">let</span> funcUser = func.bind(user);

*!*
funcUser(<span class="hljs-string">&quot;Hello&quot;</span>); <span class="hljs-comment">// Hello, John（参数 &quot;Hello&quot; 被传递，并且 this=user）</span>
*/!*</code></pre>
<p>现在我们来尝试一个对象方法：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> {
    alert(<span class="hljs-string">`Hello, <span class="hljs-subst">${<span class="hljs-built_in">this</span>.firstName}</span>!`</span>);
  }
};

*!*
<span class="hljs-keyword">let</span> sayHi = user.sayHi.bind(user); <span class="hljs-comment">// (*)</span>
*/!*

<span class="hljs-comment">// 可以在没有对象（译注：与对象分离）的情况下运行它</span>
sayHi(); <span class="hljs-comment">// Hello, John!</span>

<span class="hljs-built_in">setTimeout</span>(sayHi, <span class="hljs-number">1000</span>); <span class="hljs-comment">// Hello, John!</span>

<span class="hljs-comment">// 即使 user 的值在不到 1 秒内发生了改变</span>
<span class="hljs-comment">// sayHi 还是会使用预先绑定（pre-bound）的值</span>
user = {
  <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> { alert(<span class="hljs-string">&quot;Another user in setTimeout!&quot;</span>); }
};</code></pre>
<p>在 <code>(*)</code> 行，我们取了方法 <code>user.sayHi</code> 并将其绑定到 <code>user</code>。<code>sayHi</code> 是一个“绑定后（bound）”的方法，它可以被单独调用，也可以被传递给 <code>setTimeout</code> —— 都没关系，函数上下文都会是正确的。</p>
<p>这里我们能够看到参数（arguments）都被“原样”传递了，只是 <code>this</code> 被 <code>bind</code> 绑定了：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-function"><span class="hljs-title">say</span>(<span class="hljs-params">phrase</span>)</span> {
    alert(<span class="hljs-string">`<span class="hljs-subst">${phrase}</span>, <span class="hljs-subst">${<span class="hljs-built_in">this</span>.firstName}</span>!`</span>);
  }
};

<span class="hljs-keyword">let</span> say = user.say.bind(user);

say(<span class="hljs-string">&quot;Hello&quot;</span>); <span class="hljs-comment">// Hello, John（参数 &quot;Hello&quot; 被传递给了 say）</span>
say(<span class="hljs-string">&quot;Bye&quot;</span>); <span class="hljs-comment">// Bye, John（参数 &quot;Bye&quot; 被传递给了 say）</span></code></pre>
<p>````smart header=&quot;便捷方法：<code>bindAll</code>&quot;
如果一个对象有很多方法，并且我们都打算将它们都传递出去，那么我们可以在一个循环中完成所有方法的绑定：</p>
<pre><code class="language-js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> user) {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> user[key] == <span class="hljs-string">&#x27;function&#x27;</span>) {
    user[key] = user[key].bind(user);
  }
}</code></pre>
<p>JavaScript 库还提供了方便批量绑定的函数，例如 lodash 中的 <a href="http://lodash.com/docs#bindAll">_.bindAll(object, methodNames)</a>。</p>
<pre><code>
## 偏函数（Partial functions）

到现在为止，我们只在谈论绑定 `this`。让我们再深入一步。

我们不仅可以绑定 `this`，还可以绑定参数（arguments）。虽然很少这么做，但有时它可以派上用场。

`bind` 的完整语法如下：

```js
let bound = func.bind(context, [arg1], [arg2], ...);
```

它允许将上下文绑定为 `this`，以及绑定函数的起始参数。

例如，我们有一个乘法函数 `mul(a, b)`：

```js
function mul(a, b) {
  return a * b;
}
```

让我们使用 `bind` 在该函数基础上创建一个 `double` 函数：

```js run
function mul(a, b) {
  return a * b;
}

*!*
let double = mul.bind(null, 2);
*/!*

alert( double(3) ); // = mul(2, 3) = 6
alert( double(4) ); // = mul(2, 4) = 8
alert( double(5) ); // = mul(2, 5) = 10
```

对 `mul.bind(null, 2)` 的调用创建了一个新函数 `double`，它将调用传递到 `mul`，将 `null` 绑定为上下文，并将 `2` 绑定为第一个参数。并且，参数（arguments）均被“原样”传递。

它被称为 [偏函数应用程序（partial function application）](https://en.wikipedia.org/wiki/Partial_application) —— 我们通过绑定先有函数的一些参数来创建一个新函数。

请注意，这里我们实际上没有用到 `this`。但是 `bind` 需要它，所以我们必须传入 `null` 之类的东西。

下面这段代码中的 `triple` 函数将值乘了三倍：

```js run
function mul(a, b) {
  return a * b;
}

*!*
let triple = mul.bind(null, 3);
*/!*

alert( triple(3) ); // = mul(3, 3) = 9
alert( triple(4) ); // = mul(3, 4) = 12
alert( triple(5) ); // = mul(3, 5) = 15
```

为什么我们通常会创建一个偏函数？

好处是我们可以创建一个具有可读性高的名字（`double`，`triple`）的独立函数。我们可以使用它，并且不必每次都提供一个参数，因为参数是被绑定了的。

另一方面，当我们有一个非常通用的函数，并希望有一个通用型更低的该函数的变体时，偏函数会非常有用。

例如，我们有一个函数 `send(from, to, text)`。然后，在一个 `user` 对象的内部，我们可能希望对它使用 `send` 的偏函数变体：从当前 user 发送 `sendTo(to, text)`。

## 在没有上下文情况下的 partial

当我们想绑定一些参数（arguments），但是这里没有上下文 `this`，应该怎么办？例如，对于一个对象方法。

原生的 `bind` 不允许这种情况。我们不可以省略上下文直接跳到参数（arguments）。

幸运的是，仅绑定参数（arguments）的函数 `partial` 比较容易实现。

像这样：

```js run
*!*
function partial(func, ...argsBound) {
  return function(...args) { // (*)
    return func.call(this, ...argsBound, ...args);
  }
}
*/!*

// 用法：
let user = {
  firstName: &quot;John&quot;,
  say(time, phrase) {
    alert(`[${time}] ${this.firstName}: ${phrase}!`);
  }
};

// 添加一个带有绑定时间的 partial 方法
user.sayNow = partial(user.say, new Date().getHours() + &#x27;:&#x27; + new Date().getMinutes());

user.sayNow(&quot;Hello&quot;);
// 类似于这样的一些内容：
// [10:00] John: Hello!
```

`partial(func[, arg1, arg2...])` 调用的结果是一个包装器 `(*)`，它调用 `func` 并具有以下内容：
- 与它获得的函数具有相同的 `this`（对于 `user.sayNow` 调用来说，它是 `user`）
- 然后给它 `...argsBound` —— 来自于 `partial` 调用的参数（`&quot;10:00&quot;`）
- 然后给它 `...args` —— 给包装器的参数（`&quot;Hello&quot;`）

使用 spread 可以很容易实现这些操作，对吧？

此外，还有来自 lodash 库的现成的 [_.partial](https://lodash.com/docs#partial) 实现。

## 总结

方法 `func.bind(context, ...args)` 返回函数 `func` 的“绑定的（bound）变体”，它绑定了上下文 `this` 和第一个参数（如果给定了）。

通常我们应用 `bind` 来绑定对象方法的 `this`，这样我们就可以把它们传递到其他地方使用。例如，传递给 `setTimeout`。

当我们绑定一个现有的函数的某些参数时，绑定后的（不太通用的）函数被称为 **partially applied** 或 **partial**。

当我们不想一遍又一遍地重复相同的参数时，partial 非常有用。就像我们有一个 `send(from, to)` 函数，并且对于我们的任务来说，`from` 应该总是一样的，那么我们就可以搞一个 partial 并使用它。</code></pre>

      </fieldset>
      
      <fieldset id='_7q2F80'>
      <legend>article</legend>
      <h1 id="深入理解箭头函数">深入理解箭头函数</h1>
<p>让我们深入研究一下箭头函数。</p>
<p>箭头函数不仅仅是编写简洁代码的“捷径”。它还具有非常特殊且有用的特性。</p>
<p>JavaScript 充满了我们需要编写在其他地方执行的小函数的情况。</p>
<p>例如：</p>
<ul>
<li><code>arr.forEach(func)</code> —— <code>forEach</code> 对每个数组元素都执行 <code>func</code>。</li>
<li><code>setTimeout(func)</code> —— <code>func</code> 由内建调度器执行。</li>
<li>……还有更多。</li>
</ul>
<p>JavaScript 的精髓在于创建一个函数并将其传递到某个地方。</p>
<p>在这样的函数中，我们通常不想离开当前上下文。这就是箭头函数的主战场啦。</p>
<h2 id="箭头函数没有-this">箭头函数没有 &quot;this&quot;</h2>
<p>正如我们在 <a href="info:object-methods">info:object-methods</a> 一章中所学到的，箭头函数没有 <code>this</code>。如果访问 <code>this</code>，则会从外部获取。</p>
<p>例如，我们可以使用它在对象方法内部进行迭代：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> group = {
  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Our Group&quot;</span>,
  <span class="hljs-attr">students</span>: [<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Pete&quot;</span>, <span class="hljs-string">&quot;Alice&quot;</span>],

  <span class="hljs-function"><span class="hljs-title">showList</span>(<span class="hljs-params"></span>)</span> {
*!*
    <span class="hljs-built_in">this</span>.students.forEach(
      <span class="hljs-function"><span class="hljs-params">student</span> =&gt;</span> alert(<span class="hljs-built_in">this</span>.title + <span class="hljs-string">&#x27;: &#x27;</span> + student)
    );
*/!*
  }
};

group.showList();</code></pre>
<p>这里 <code>forEach</code> 中使用了箭头函数，所以其中的 <code>this.title</code> 其实和外部方法 <code>showList</code> 的完全一样。那就是：<code>group.title</code>。</p>
<p>如果我们使用正常的函数，则会出现错误：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> group = {
  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Our Group&quot;</span>,
  <span class="hljs-attr">students</span>: [<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Pete&quot;</span>, <span class="hljs-string">&quot;Alice&quot;</span>],

  <span class="hljs-function"><span class="hljs-title">showList</span>(<span class="hljs-params"></span>)</span> {
*!*
    <span class="hljs-built_in">this</span>.students.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">student</span>) </span>{
      <span class="hljs-comment">// Error: Cannot read property &#x27;title&#x27; of undefined</span>
      alert(<span class="hljs-built_in">this</span>.title + <span class="hljs-string">&#x27;: &#x27;</span> + student)
    });
*/!*
  }
};

group.showList();</code></pre>
<p>报错是因为 <code>forEach</code> 运行它里面的这个函数，但是这个函数的 <code>this</code> 为默认值 <code>this=undefined</code>，因此就出现了尝试访问 <code>undefined.title</code> 的情况。</p>
<p>但箭头函数就没事，因为它们没有 <code>this</code>。</p>
<p>```warn header=&quot;不能对箭头函数进行 <code>new</code> 操作&quot;
不具有 <code>this</code> 自然也就意味着另一个限制：箭头函数不能用作构造器（constructor）。不能用 <code>new</code> 调用它们。</p>
<pre><code>
```smart header=&quot;箭头函数 VS bind&quot;
箭头函数 `=&gt;` 和使用 `.bind(this)` 调用的常规函数之间有细微的差别：

- `.bind(this)` 创建了一个该函数的“绑定版本”。
- 箭头函数 `=&gt;` 没有创建任何绑定。箭头函数只是没有 `this`。`this` 的查找与常规变量的搜索方式完全相同：在外部词法环境中查找。</code></pre>
<h2 id="箭头函数没有-arguments">箭头函数没有 &quot;arguments&quot;</h2>
<p>箭头函数也没有 <code>arguments</code> 变量。</p>
<p>当我们需要使用当前的 <code>this</code> 和 <code>arguments</code> 转发一个调用时，这对装饰者（decorators）来说非常有用。</p>
<p>例如，<code>defer(f, ms)</code> 获得了一个函数，并返回一个包装器，该包装器将调用延迟 <code>ms</code> 毫秒：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defer</span>(<span class="hljs-params">f, ms</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> f.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>), ms)
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params">who</span>) </span>{
  alert(<span class="hljs-string">&#x27;Hello, &#x27;</span> + who);
}

<span class="hljs-keyword">let</span> sayHiDeferred = defer(sayHi, <span class="hljs-number">2000</span>);
sayHiDeferred(<span class="hljs-string">&quot;John&quot;</span>); <span class="hljs-comment">// 2 秒后显示：Hello, John</span></code></pre>
<p>不用箭头函数的话，可以这么写：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defer</span>(<span class="hljs-params">f, ms</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>{
    <span class="hljs-keyword">let</span> ctx = <span class="hljs-built_in">this</span>;
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> f.apply(ctx, args);
    }, ms);
  };
}</code></pre>
<p>在这里，我们必须创建额外的变量 <code>args</code> 和 <code>ctx</code>，以便 <code>setTimeout</code> 内部的函数可以获取它们。</p>
<h2 id="总结">总结</h2>
<p>箭头函数：</p>
<ul>
<li>没有 <code>this</code></li>
<li>没有 <code>arguments</code></li>
<li>不能使用 <code>new</code> 进行调用</li>
<li>它们也没有 <code>super</code>，但目前我们还没有学到它。我们将在 <a href="info:class-inheritance">info:class-inheritance</a> 一章中学习它。</li>
</ul>
<p>这是因为，箭头函数是针对那些没有自己的“上下文”，但在当前上下文中起作用的短代码的。并且箭头函数确实在这种使用场景中大放异彩。</p>

      </fieldset>
      
      <fieldset id='_nzHyDj'>
      <legend>article</legend>
      <h1 id="属性标志和属性描述符">属性标志和属性描述符</h1>
<p>我们知道，对象可以存储属性。</p>
<p>到目前为止，属性对我们来说只是一个简单的“键值”对。但对象属性实际上是更灵活且更强大的东西。</p>
<p>在本章中，我们将学习其他配置选项，在下一章中，我们将学习如何将它们无形地转换为 getter/setter 函数。</p>
<h2 id="属性标志">属性标志</h2>
<p>对象属性（properties），除 <strong><code>value</code></strong> 外，还有三个特殊的特性（attributes），也就是所谓的“标志”：</p>
<ul>
<li><strong><code>writable</code></strong> — 如果为 <code>true</code>，则值可以被修改，否则它是只可读的。</li>
<li><strong><code>enumerable</code></strong> — 如果为 <code>true</code>，则会被在循环中列出，否则不会被列出。</li>
<li><strong><code>configurable</code></strong> — 如果为 <code>true</code>，则此特性可以被删除，这些属性也可以被修改，否则不可以。</li>
</ul>
<p>我们到现在还没看到它们，是因为它们通常不会出现。当我们用“常用的方式”创建一个属性时，它们都为 <code>true</code>。但我们也可以随时更改它们。</p>
<p>首先，让我们来看看如何获得这些标志。</p>
<p><a href="mdn:js/Object/getOwnPropertyDescriptor">Object.getOwnPropertyDescriptor</a> 方法允许查询有关属性的 <strong>完整</strong> 信息。</p>
<p>语法是：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> descriptor = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(obj, propertyName);</code></pre>
<p><code>obj</code>
: 需要从中获取信息的对象。</p>
<p><code>propertyName</code>
: 属性的名称。</p>
<p>返回值是一个所谓的“属性描述符”对象：它包含值和所有的标志。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>
};

<span class="hljs-keyword">let</span> descriptor = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(user, <span class="hljs-string">&#x27;name&#x27;</span>);

alert( <span class="hljs-built_in">JSON</span>.stringify(descriptor, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span> ) );
<span class="hljs-comment">/* 属性描述符：
{
  &quot;value&quot;: &quot;John&quot;,
  &quot;writable&quot;: true,
  &quot;enumerable&quot;: true,
  &quot;configurable&quot;: true
}
*/</span></code></pre>
<p>为了修改标志，我们可以使用 <a href="mdn:js/Object/defineProperty">Object.defineProperty</a>。</p>
<p>语法是：</p>
<pre><code class="language-js"><span class="hljs-built_in">Object</span>.defineProperty(obj, propertyName, descriptor)</code></pre>
<p><code>obj</code>，<code>propertyName</code>
: 要应用描述符的对象及其属性。</p>
<p><code>descriptor</code>
: 要应用的属性描述符对象。</p>
<p>如果该属性存在，<code>defineProperty</code> 会更新其标志。否则，它会使用给定的值和标志创建属性；在这种情况下，如果没有提供标志，则会假定它是 <code>false</code>。</p>
<p>例如，这里创建了一个属性 <code>name</code>，该属性的所有标志都为 <code>false</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {};

*!*
<span class="hljs-built_in">Object</span>.defineProperty(user, <span class="hljs-string">&quot;name&quot;</span>, {
  <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;John&quot;</span>
});
*/!*

<span class="hljs-keyword">let</span> descriptor = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(user, <span class="hljs-string">&#x27;name&#x27;</span>);

alert( <span class="hljs-built_in">JSON</span>.stringify(descriptor, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span> ) );
<span class="hljs-comment">/*
{
  &quot;value&quot;: &quot;John&quot;,
*!*
  &quot;writable&quot;: false,
  &quot;enumerable&quot;: false,
  &quot;configurable&quot;: false
*/</span>!*
}
 */</code></pre>
<p>将它与上面的“以常用方式创建的” <code>user.name</code> 进行比较：现在所有标志都为 <code>false</code>。如果这不是我们想要的，那么我们最好在 <code>descriptor</code> 中将它们设置为 <code>true</code>。</p>
<p>现在让我们通过示例来看看标志的影响。</p>
<h2 id="只读">只读</h2>
<p>让我们通过更改 <code>writable</code> 标志来把 <code>user.name</code> 设置为只读（<code>user.name</code> 不能被重新赋值）：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>
};

<span class="hljs-built_in">Object</span>.defineProperty(user, <span class="hljs-string">&quot;name&quot;</span>, {
*!*
  writable: <span class="hljs-literal">false</span>
*/!*
});

*!*
user.name = <span class="hljs-string">&quot;Pete&quot;</span>; <span class="hljs-comment">// Error: Cannot assign to read only property &#x27;name&#x27;</span>
*/!*</code></pre>
<p>现在没有人可以改变我们 <code>user</code> 的 <code>name</code>，除非它们应用自己的 <code>defineProperty</code> 来覆盖我们的 <code>user</code> 的 <code>name</code>。</p>
<pre><code class="language-smart">在非严格模式下，在对不可写的属性等进行写入操作时，不会出现错误。但是操作仍然不会成功。在非严格模式下，违反标志的行为（flag-violating action）只会被默默地忽略掉。</code></pre>
<p>这是相同的示例，但针对的是属性不存在的情况：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = { };

<span class="hljs-built_in">Object</span>.defineProperty(user, <span class="hljs-string">&quot;name&quot;</span>, {
*!*
  value: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-comment">// 对于新属性，我们需要明确地列出哪些是 true</span>
  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>
*/!*
});

alert(user.name); <span class="hljs-comment">// John</span>
user.name = <span class="hljs-string">&quot;Pete&quot;</span>; <span class="hljs-comment">// Error</span></code></pre>
<h2 id="不可枚举">不可枚举</h2>
<p>现在让我们向 <code>user</code> 添加一个自定义的 <code>toString</code>。</p>
<p>通常，对象的内置 <code>toString</code> 是不可枚举的，它不会显示在 <code>for..in</code> 中。但是如果我们添加我们自己的 <code>toString</code>，那么默认情况下它将显示在 <code>for..in</code> 中，如下所示：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;
  }
};

<span class="hljs-comment">// 默认情况下，我们的两个属性都会被列出：</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> user) alert(key); <span class="hljs-comment">// name, toString</span></code></pre>
<p>如果我们不喜欢它，那么我们可以设置 <code>enumerable:false</code>。之后它就不会出现在 <code>for..in</code> 循环中了，就像内建的 <code>toString</code> 一样：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;
  }
};

<span class="hljs-built_in">Object</span>.defineProperty(user, <span class="hljs-string">&quot;toString&quot;</span>, {
*!*
  enumerable: <span class="hljs-literal">false</span>
*/!*
});

*!*
<span class="hljs-comment">// 现在我们的 toString 消失了：</span>
*/!*
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> user) alert(key); <span class="hljs-comment">// name</span></code></pre>
<p>不可枚举的属性也会被 <code>Object.keys</code> 排除：</p>
<pre><code class="language-js">alert(<span class="hljs-built_in">Object</span>.keys(user)); <span class="hljs-comment">// name</span></code></pre>
<h2 id="不可配置">不可配置</h2>
<p>不可配置标志（<code>configurable:false</code>）有时会预设在内建对象和属性中。</p>
<p>不可配置的属性不能被删除。</p>
<p>例如，<code>Math.PI</code> 是只读的、不可枚举和不可配置的：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> descriptor = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(<span class="hljs-built_in">Math</span>, <span class="hljs-string">&#x27;PI&#x27;</span>);

alert( <span class="hljs-built_in">JSON</span>.stringify(descriptor, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span> ) );
<span class="hljs-comment">/*
{
  &quot;value&quot;: 3.141592653589793,
  &quot;writable&quot;: false,
  &quot;enumerable&quot;: false,
  &quot;configurable&quot;: false
}
*/</span></code></pre>
<p>因此，开发人员无法修改 <code>Math.PI</code> 的值或覆盖它。</p>
<pre><code class="language-js"><span class="hljs-built_in">Math</span>.PI = <span class="hljs-number">3</span>; <span class="hljs-comment">// Error</span>

<span class="hljs-comment">// 删除 Math.PI 也不会起作用</span></code></pre>
<p>使属性变成不可配置是一条单行道。我们无法使用 <code>defineProperty</code> 把它改回去。</p>
<p>确切地说，不可配置性对 <code>defineProperty</code> 施加了一些限制：</p>
<ol>
<li>不能修改 <code>configurable</code> 标志。</li>
<li>不能修改 <code>enumerable</code> 标志。</li>
<li>不能将 <code>writable: false</code> 修改为 <code>true</code>（反之亦然）。</li>
<li>不能修改访问者属性的 <code>get/set</code>（但是如果没有可以分配它们）。</li>
</ol>
<p>在这里，我们将 <code>user.name</code> 设置为“永久密封”的常量：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = { };

<span class="hljs-built_in">Object</span>.defineProperty(user, <span class="hljs-string">&quot;name&quot;</span>, {
  <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>
});

*!*
<span class="hljs-comment">// 不能修改 user.name 或它的标志</span>
<span class="hljs-comment">// 下面的所有操作都不起作用：</span>
<span class="hljs-comment">//   user.name = &quot;Pete&quot;</span>
<span class="hljs-comment">//   delete user.name</span>
<span class="hljs-comment">//   defineProperty(user, &quot;name&quot;, { value: &quot;Pete&quot; })</span>
<span class="hljs-built_in">Object</span>.defineProperty(user, <span class="hljs-string">&quot;name&quot;</span>, {<span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>}); <span class="hljs-comment">// Error</span>
*/!*</code></pre>
<pre><code class="language-smart">值得注意的例外情况：不可配置但可写的属性的值是可以被更改的。

`configurable: false` 的思想是防止更改属性标志或删除属性标志，而不是更改它的值。</code></pre>
<h2 id="objectdefineproperties">Object.defineProperties</h2>
<p>有一个方法 <a href="mdn:js/Object/defineProperties">Object.defineProperties(obj, descriptors)</a>，允许一次定义多个属性。</p>
<p>语法是：</p>
<pre><code class="language-js"><span class="hljs-built_in">Object</span>.defineProperties(obj, {
  <span class="hljs-attr">prop1</span>: descriptor1,
  <span class="hljs-attr">prop2</span>: descriptor2
  <span class="hljs-comment">// ...</span>
});</code></pre>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-built_in">Object</span>.defineProperties(user, {
  <span class="hljs-attr">name</span>: { <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span> },
  <span class="hljs-attr">surname</span>: { <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;Smith&quot;</span>, <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span> },
  <span class="hljs-comment">// ...</span>
});</code></pre>
<p>所以，我们可以一次性设置多个属性。</p>
<h2 id="objectgetownpropertydescriptors">Object.getOwnPropertyDescriptors</h2>
<p>要一次获取所有属性描述符，我们可以使用 <a href="mdn:js/Object/getOwnPropertyDescriptors">Object.getOwnPropertyDescriptors(obj)</a> 方法。</p>
<p>它与 <code>Object.defineProperties</code> 一起可以用作克隆对象的“标志感知”方式：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> clone = <span class="hljs-built_in">Object</span>.defineProperties({}, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(obj));</code></pre>
<p>通常，当我们克隆一个对象时，我们使用赋值的方式来复制属性，像这样：</p>
<pre><code class="language-js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> user) {
  clone[key] = user[key]
}</code></pre>
<p>……但是，这并不能复制标志。所以如果我们想要一个“更好”的克隆，那么 <code>Object.defineProperties</code> 是首选。</p>
<p>另一个区别是 <code>for..in</code> 会忽略 symbol 类型的属性，但是 <code>Object.getOwnPropertyDescriptors</code> 返回包含 symbol 类型的属性在内的 <strong>所有</strong> 属性描述符。</p>
<h2 id="设定一个全局的密封对象">设定一个全局的密封对象</h2>
<p>属性描述符在单个属性的级别上工作。</p>
<p>还有一些限制访问 <strong>整个</strong> 对象的方法：</p>
<p><a href="mdn:js/Object/preventExtensions">Object.preventExtensions(obj)</a>
: 禁止向对象添加新属性。</p>
<p><a href="mdn:js/Object/seal">Object.seal(obj)</a>
: 禁止添加/删除/修改属性。为所有现有的属性设置 <code>configurable: false</code>。</p>
<p><a href="mdn:js/Object/freeze">Object.freeze(obj)</a>
: 禁止添加/删除/更改属性。为所有现有的属性设置 <code>configurable: false, writable: false</code>。</p>
<p>还有针对它们的测试：</p>
<p><a href="mdn:js/Object/isExtensible">Object.isExtensible(obj)</a>
: 如果添加属性被禁止，则返回 <code>false</code>，否则返回 <code>true</code>。</p>
<p><a href="mdn:js/Object/isSealed">Object.isSealed(obj)</a>
: 如果添加/删除属性被禁止，并且所有现有的属性都具有 <code>configurable: false</code>则返回 <code>true</code>。</p>
<p><a href="mdn:js/Object/isFrozen">Object.isFrozen(obj)</a>
: 如果添加/删除/更改属性被禁止，并且所有当前属性都是 <code>configurable: false, writable: false</code>，则返回 <code>true</code>。</p>
<p>这些方法在实际中很少使用。</p>

      </fieldset>
      
      <fieldset id='_a315kB'>
      <legend>article</legend>
      <h1 id="属性的-getter-和-setter">属性的 getter 和 setter</h1>
<p>有两种类型的对象属性。</p>
<p>第一种是 <strong>数据属性</strong>。我们已经知道如何使用它们了。到目前为止，我们使用过的所有属性都是数据属性。</p>
<p>第二种类型的属性是新东西。它是 <strong>访问器属性（accessor properties）</strong>。它们本质上是用于获取和设置值的函数，但从外部代码来看就像常规属性。</p>
<h2 id="getter-和-setter">Getter 和 setter</h2>
<p>访问器属性由 &quot;getter&quot; 和 &quot;setter&quot; 方法表示。在对象字面量中，它们用 <code>get</code> 和 <code>set</code> 表示：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> obj = {
  *!*<span class="hljs-keyword">get</span> <span class="hljs-title">propName</span>()*/!* {
    <span class="hljs-comment">// 当读取 obj.propName 时，getter 起作用</span>
  },

  *!*<span class="hljs-keyword">set</span> <span class="hljs-title">propName</span>(<span class="hljs-params">value</span>)*/!* {
    <span class="hljs-comment">// 当执行 obj.propName = value 操作时，setter 起作用</span>
  }
};</code></pre>
<p>当读取 <code>obj.propName</code> 时，getter 起作用，当 <code>obj.propName</code> 被赋值时，setter 起作用。</p>
<p>例如，我们有一个具有 <code>name</code> 和 <code>surname</code> 属性的对象 <code>user</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">surname</span>: <span class="hljs-string">&quot;Smith&quot;</span>
};</code></pre>
<p>现在我们想添加一个 <code>fullName</code> 属性，该属性值应该为 <code>&quot;John Smith&quot;</code>。当然，我们不想复制粘贴已有的信息，因此我们可以使用访问器来实现：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">surname</span>: <span class="hljs-string">&quot;Smith&quot;</span>,

*!*
  <span class="hljs-keyword">get</span> <span class="hljs-title">fullName</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">this</span>.name}</span> <span class="hljs-subst">${<span class="hljs-built_in">this</span>.surname}</span>`</span>;
  }
*/!*
};

*!*
alert(user.fullName); <span class="hljs-comment">// John Smith</span>
*/!*</code></pre>
<p>从外表看，访问器属性看起来就像一个普通属性。这就是访问器属性的设计思想。我们不以函数的方式 <strong>调用</strong> <code>user.fullName</code>，我们正常 <strong>读取</strong> 它：getter 在幕后运行。</p>
<p>截至目前，<code>fullName</code> 只有一个 getter。如果我们尝试赋值操作 <code>user.fullName=</code>，将会出现错误：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-keyword">get</span> <span class="hljs-title">fullName</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`...`</span>;
  }
};

*!*
user.fullName = <span class="hljs-string">&quot;Test&quot;</span>; <span class="hljs-comment">// Error（属性只有一个 getter）</span>
*/!*</code></pre>
<p>让我们通过为 <code>user.fullName</code> 添加一个 setter 来修复它：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">surname</span>: <span class="hljs-string">&quot;Smith&quot;</span>,

  <span class="hljs-keyword">get</span> <span class="hljs-title">fullName</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">this</span>.name}</span> <span class="hljs-subst">${<span class="hljs-built_in">this</span>.surname}</span>`</span>;
  },

*!*
  <span class="hljs-keyword">set</span> <span class="hljs-title">fullName</span>(<span class="hljs-params">value</span>) {
    [<span class="hljs-built_in">this</span>.name, <span class="hljs-built_in">this</span>.surname] = value.split(<span class="hljs-string">&quot; &quot;</span>);
  }
*/!*
};

<span class="hljs-comment">// set fullName 将以给定值执行</span>
user.fullName = <span class="hljs-string">&quot;Alice Cooper&quot;</span>;

alert(user.name); <span class="hljs-comment">// Alice</span>
alert(user.surname); <span class="hljs-comment">// Cooper</span></code></pre>
<p>现在，我们就有一个“虚拟”属性。它是可读且可写的。</p>
<h2 id="访问器描述符">访问器描述符</h2>
<p>访问器属性的描述符与数据属性的不同。</p>
<p>对于访问器属性，没有 <code>value</code> 和 <code>writable</code>，但是有 <code>get</code> 和 <code>set</code> 函数。</p>
<p>所以访问器描述符可能有：</p>
<ul>
<li><strong><code>get</code></strong> —— 一个没有参数的函数，在读取属性时工作，</li>
<li><strong><code>set</code></strong> —— 带有一个参数的函数，当属性被设置时调用，</li>
<li><strong><code>enumerable</code></strong> —— 与数据属性的相同，</li>
<li><strong><code>configurable</code></strong> —— 与数据属性的相同。</li>
</ul>
<p>例如，要使用 <code>defineProperty</code> 创建一个 <code>fullName</code> 访问器，我们可以使用 <code>get</code> 和 <code>set</code> 来传递描述符：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">surname</span>: <span class="hljs-string">&quot;Smith&quot;</span>
};

*!*
<span class="hljs-built_in">Object</span>.defineProperty(user, <span class="hljs-string">&#x27;fullName&#x27;</span>, {
  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">this</span>.name}</span> <span class="hljs-subst">${<span class="hljs-built_in">this</span>.surname}</span>`</span>;
  },

  <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">value</span>)</span> {
    [<span class="hljs-built_in">this</span>.name, <span class="hljs-built_in">this</span>.surname] = value.split(<span class="hljs-string">&quot; &quot;</span>);
  }
*/!*
});

alert(user.fullName); <span class="hljs-comment">// John Smith</span>

<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> user) alert(key); <span class="hljs-comment">// name, surname</span></code></pre>
<p>请注意，一个属性要么是访问器（具有 <code>get/set</code> 方法），要么是数据属性（具有 <code>value</code>），但不能两者都是。</p>
<p>如果我们试图在同一个描述符中同时提供 <code>get</code> 和 <code>value</code>，则会出现错误：</p>
<pre><code class="language-js">*!*
<span class="hljs-comment">// Error: Invalid property descriptor.</span>
*/!*
<span class="hljs-built_in">Object</span>.defineProperty({}, <span class="hljs-string">&#x27;prop&#x27;</span>, {
  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
  },

  <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>
});</code></pre>
<h2 id="更聪明的-gettersetter">更聪明的 getter/setter</h2>
<p>Getter/setter 可以用作“真实”属性值的包装器，以便对它们进行更多的控制。</p>
<p>例如，如果我们想禁止太短的 <code>user</code> 的 name，我们可以创建一个 setter <code>name</code>，并将值存储在一个单独的属性 <code>_name</code> 中：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-keyword">get</span> <span class="hljs-title">name</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._name;
  },

  <span class="hljs-keyword">set</span> <span class="hljs-title">name</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-keyword">if</span> (value.length &lt; <span class="hljs-number">4</span>) {
      alert(<span class="hljs-string">&quot;Name is too short, need at least 4 characters&quot;</span>);
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-built_in">this</span>._name = value;
  }
};

user.name = <span class="hljs-string">&quot;Pete&quot;</span>;
alert(user.name); <span class="hljs-comment">// Pete</span>

user.name = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// Name 太短了……</span></code></pre>
<p>所以，name 被存储在 <code>_name</code> 属性中，并通过 getter 和 setter 进行访问。</p>
<p>从技术上讲，外部代码可以使用 <code>user._name</code> 直接访问 name。但是，这儿有一个众所周知的约定，即以下划线 <code>&quot;_&quot;</code> 开头的属性是内部属性，不应该从对象外部进行访问。</p>
<h2 id="兼容性">兼容性</h2>
<p>访问器的一大用途是，它们允许随时通过使用 getter 和 setter 替换“正常的”数据属性，来控制和调整这些属性的行为。</p>
<p>想象一下，我们开始使用数据属性 <code>name</code> 和 <code>age</code> 来实现 user 对象：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params">name, age</span>) </span>{
  <span class="hljs-built_in">this</span>.name = name;
  <span class="hljs-built_in">this</span>.age = age;
}

<span class="hljs-keyword">let</span> john = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-number">25</span>);

alert( john.age ); <span class="hljs-comment">// 25</span></code></pre>
<p>……但迟早，情况可能会发生变化。我们可能会决定存储 <code>birthday</code>，而不是 <code>age</code>，因为它更精确，更方便：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params">name, birthday</span>) </span>{
  <span class="hljs-built_in">this</span>.name = name;
  <span class="hljs-built_in">this</span>.birthday = birthday;
}

<span class="hljs-keyword">let</span> john = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">1992</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>));</code></pre>
<p>现在应该如何处理仍使用 <code>age</code> 属性的旧代码呢？</p>
<p>我们可以尝试找到所有这些地方并修改它们，但这会花费很多时间，而且如果其他很多人都在使用该代码，那么可能很难完成所有修改。而且，<code>user</code> 中有 <code>age</code> 是一件好事，对吧？</p>
<p>那我们就把它保留下来吧。</p>
<p>为 <code>age</code> 添加一个 getter 来解决这个问题：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params">name, birthday</span>) </span>{
  <span class="hljs-built_in">this</span>.name = name;
  <span class="hljs-built_in">this</span>.birthday = birthday;

*!*
  <span class="hljs-comment">// 年龄是根据当前日期和生日计算得出的</span>
  <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;age&quot;</span>, {
    <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> {
      <span class="hljs-keyword">let</span> todayYear = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getFullYear();
      <span class="hljs-keyword">return</span> todayYear - <span class="hljs-built_in">this</span>.birthday.getFullYear();
    }
  });
*/!*
}

<span class="hljs-keyword">let</span> john = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">1992</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>));

alert( john.birthday ); <span class="hljs-comment">// birthday 是可访问的</span>
alert( john.age );      <span class="hljs-comment">// ……age 也是可访问的</span></code></pre>
<p>现在旧的代码也可以工作，而且我们还拥有了一个不错的附加属性。</p>

      </fieldset>
      
      <fieldset id='_E8Soxe'>
      <legend>solution</legend>
      <ol>
<li><code>true</code>，来自于 <code>rabbit</code>。</li>
<li><code>null</code>，来自于 <code>animal</code>。</li>
<li><code>undefined</code>，不再有这样的属性存在。</li>
</ol>

      </fieldset>
      
      <fieldset id='_amKbkC'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="使用原型">使用原型</h1>
<p>下面这段代码创建了一对对象，然后对它们进行修改。</p>
<p>过程中会显示哪些值？</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> animal = {
  <span class="hljs-attr">jumps</span>: <span class="hljs-literal">null</span>
};
<span class="hljs-keyword">let</span> rabbit = {
  <span class="hljs-attr">__proto__</span>: animal,
  <span class="hljs-attr">jumps</span>: <span class="hljs-literal">true</span>
};

alert( rabbit.jumps ); <span class="hljs-comment">// ? (1)</span>

<span class="hljs-keyword">delete</span> rabbit.jumps;

alert( rabbit.jumps ); <span class="hljs-comment">// ? (2)</span>

<span class="hljs-keyword">delete</span> animal.jumps;

alert( rabbit.jumps ); <span class="hljs-comment">// ? (3)</span></code></pre>
<p>应该有 3 个答案。</p>

      </fieldset>
      
      <fieldset id='_L1apid'>
      <legend>solution</legend>
      <ol>
<li><p>让我们添加 <code>__proto__</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> head = {
  <span class="hljs-attr">glasses</span>: <span class="hljs-number">1</span>
};

<span class="hljs-keyword">let</span> table = {
  <span class="hljs-attr">pen</span>: <span class="hljs-number">3</span>,
  <span class="hljs-attr">__proto__</span>: head
};

<span class="hljs-keyword">let</span> bed = {
  <span class="hljs-attr">sheet</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">pillow</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">__proto__</span>: table
};

<span class="hljs-keyword">let</span> pockets = {
  <span class="hljs-attr">money</span>: <span class="hljs-number">2000</span>,
  <span class="hljs-attr">__proto__</span>: bed
};

alert( pockets.pen ); <span class="hljs-comment">// 3</span>
alert( bed.glasses ); <span class="hljs-comment">// 1</span>
alert( table.money ); <span class="hljs-comment">// undefined</span></code></pre>
</li>
<li><p>在现代引擎中，从性能的角度来看，我们是从对象还是从原型链获取属性都是没区别的。它们（引擎）会记住在哪里找到的该属性，并在下一次请求中重用它。</p>
<p> 例如，对于 <code>pockets.glasses</code> 来说，它们（引擎）会记得在哪里找到的 <code>glasses</code>（在 <code>head</code> 中），这样下次就会直接在这个位置进行搜索。并且引擎足够聪明，一旦有内容更改，它们就会自动更新内部缓存，因此，该优化是安全的。</p>
</li>
</ol>

      </fieldset>
      
      <fieldset id='_ILvRjH'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="搜索算法">搜索算法</h1>
<p>本题目有两个部分。</p>
<p>给定以下对象：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> head = {
  <span class="hljs-attr">glasses</span>: <span class="hljs-number">1</span>
};

<span class="hljs-keyword">let</span> table = {
  <span class="hljs-attr">pen</span>: <span class="hljs-number">3</span>
};

<span class="hljs-keyword">let</span> bed = {
  <span class="hljs-attr">sheet</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">pillow</span>: <span class="hljs-number">2</span>
};

<span class="hljs-keyword">let</span> pockets = {
  <span class="hljs-attr">money</span>: <span class="hljs-number">2000</span>
};</code></pre>
<ol>
<li>使用 <code>__proto__</code> 来分配原型，以使得任何属性的查找都遵循以下路径：<code>pockets</code> -&gt; <code>bed</code> -&gt; <code>table</code> -&gt; <code>head</code>。例如，<code>pockets.pen</code> 应该是 <code>3</code>（在 <code>table</code> 中找到），<code>bed.glasses</code> 应该是 <code>1</code>（在 <code>head</code> 中找到）。</li>
<li>回答问题：通过 <code>pockets.glasses</code> 或 <code>head.glasses</code> 获取 <code>glasses</code>，哪个更快？必要时需要进行基准测试。</li>
</ol>

      </fieldset>
      
      <fieldset id='_YFvhP5'>
      <legend>solution</legend>
      <p><strong>答案：<code>rabbit</code>。</strong></p>
<p>这是因为 <code>this</code> 是点符号前面的这个对象，因此 <code>rabbit.eat()</code> 修改了 <code>rabbit</code>。</p>
<p>属性查找和执行是两回事儿。</p>
<p>首先在原型中找到 <code>rabbit.eat</code> 方法，然后在 <code>this=rabbit</code> 的情况下执行。</p>

      </fieldset>
      
      <fieldset id='_PbF2nS'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="写在哪里？">写在哪里？</h1>
<p>我们有从 <code>animal</code> 中继承的 <code>rabbit</code>。</p>
<p>如果我们调用 <code>rabbit.eat()</code>，哪一个对象会接收到 <code>full</code> 属性：<code>animal</code> 还是 <code>rabbit</code>？</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> animal = {
  <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-built_in">this</span>.full = <span class="hljs-literal">true</span>;
  }
};

<span class="hljs-keyword">let</span> rabbit = {
  <span class="hljs-attr">__proto__</span>: animal
};

rabbit.eat();</code></pre>

      </fieldset>
      
      <fieldset id='_NVvCw8'>
      <legend>solution</legend>
      <p>我们仔细研究一下在调用 <code>speedy.eat(&quot;apple&quot;)</code> 的时候，发生了什么。</p>
<ol>
<li><p><code>speedy.eat</code> 方法在原型（<code>=hamster</code>）中被找到，然后执行 <code>this=speedy</code>（在点符号前面的对象）。</p>
</li>
<li><p><code>this.stomach.push()</code> 需要找到 <code>stomach</code> 属性，然后对其调用 <code>push</code>。它在 <code>this</code>（<code>=speedy</code>）中查找 <code>stomach</code>，但并没有找到。</p>
</li>
<li><p>然后它顺着原型链，在 <code>hamster</code> 中找到 <code>stomach</code>。</p>
</li>
<li><p>然后它对 <code>stomach</code> 调用 <code>push</code>，将食物添加到 <strong><code>stomach</code> 的原型</strong> 中。</p>
</li>
</ol>
<p>因此，所有的仓鼠共享了同一个胃！</p>
<p>对于 <code>lazy.stomach.push(...)</code> 和 <code>speedy.stomach.push()</code> 而言，属性 <code>stomach</code> 被在原型中找到（不是在对象自身），然后向其中 <code>push</code> 了新数据。</p>
<p>请注意，在简单的赋值 <code>this.stomach=</code> 的情况下不会出现这种情况：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> hamster = {
  <span class="hljs-attr">stomach</span>: [],

  <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params">food</span>)</span> {
*!*
    <span class="hljs-comment">// 分配给 this.stomach 而不是 this.stomach.push</span>
    <span class="hljs-built_in">this</span>.stomach = [food];
*/!*
  }
};

<span class="hljs-keyword">let</span> speedy = {
   <span class="hljs-attr">__proto__</span>: hamster
};

<span class="hljs-keyword">let</span> lazy = {
  <span class="hljs-attr">__proto__</span>: hamster
};

<span class="hljs-comment">// 仓鼠 Speedy 找到了食物</span>
speedy.eat(<span class="hljs-string">&quot;apple&quot;</span>);
alert( speedy.stomach ); <span class="hljs-comment">// apple</span>

<span class="hljs-comment">// 仓鼠 Lazy 的胃是空的</span>
alert( lazy.stomach ); <span class="hljs-comment">// &lt;nothing&gt;</span></code></pre>
<p>现在，一切都运行正常，因为 <code>this.stomach=</code> 不会执行对 <code>stomach</code> 的查找。该值会被直接写入 <code>this</code> 对象。</p>
<p>此外，我们还可以通过确保每只仓鼠都有自己的胃来完全回避这个问题：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> hamster = {
  <span class="hljs-attr">stomach</span>: [],

  <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params">food</span>)</span> {
    <span class="hljs-built_in">this</span>.stomach.push(food);
  }
};

<span class="hljs-keyword">let</span> speedy = {
  <span class="hljs-attr">__proto__</span>: hamster,
*!*
  stomach: []
*/!*
};

<span class="hljs-keyword">let</span> lazy = {
  <span class="hljs-attr">__proto__</span>: hamster,
*!*
  stomach: []
*/!*
};

<span class="hljs-comment">// 仓鼠 Speedy 找到了食物</span>
speedy.eat(<span class="hljs-string">&quot;apple&quot;</span>);
alert( speedy.stomach ); <span class="hljs-comment">// apple</span>

<span class="hljs-comment">// 仓鼠 Lazy 的胃是空的</span>
alert( lazy.stomach ); <span class="hljs-comment">// &lt;nothing&gt;</span></code></pre>
<p>作为一种常见的解决方案，所有描述特定对象状态的属性，例如上面的 <code>stomach</code>，都应该被写入该对象中。这样可以避免此类问题。</p>

      </fieldset>
      
      <fieldset id='_SAR43l'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="为什么两只仓鼠都饱了？">为什么两只仓鼠都饱了？</h1>
<p>我们有两只仓鼠：<code>speedy</code> 和 <code>lazy</code> 都继承自普通的 <code>hamster</code> 对象。 </p>
<p>当我们喂其中一只的时候，另一只也吃饱了。为什么？如何修复它？</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> hamster = {
  <span class="hljs-attr">stomach</span>: [],

  <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params">food</span>)</span> {
    <span class="hljs-built_in">this</span>.stomach.push(food);
  }
};

<span class="hljs-keyword">let</span> speedy = {
  <span class="hljs-attr">__proto__</span>: hamster
};

<span class="hljs-keyword">let</span> lazy = {
  <span class="hljs-attr">__proto__</span>: hamster
};

<span class="hljs-comment">// 这只仓鼠找到了食物</span>
speedy.eat(<span class="hljs-string">&quot;apple&quot;</span>);
alert( speedy.stomach ); <span class="hljs-comment">// apple</span>

<span class="hljs-comment">// 这只仓鼠也找到了食物，为什么？请修复它。</span>
alert( lazy.stomach ); <span class="hljs-comment">// apple</span></code></pre>

      </fieldset>
      
      <fieldset id='_vzMnCk'>
      <legend>article</legend>
      <h1 id="原型继承">原型继承</h1>
<p>在编程中，我们经常会想获取并扩展一些东西。</p>
<p>例如，我们有一个 <code>user</code> 对象及其属性和方法，并希望将 <code>admin</code> 和 <code>guest</code> 作为基于 <code>user</code> 稍加修改的变体。我们想重用 <code>user</code> 中的内容，而不是复制/重新实现它的方法，而只是在其之上构建一个新的对象。</p>
<p><strong>原型继承（Prototypal inheritance）</strong> 这个语言特性能够帮助我们实现这一需求。</p>
<h2 id="prototype">[[Prototype]]</h2>
<p>在 JavaScript 中，对象有一个特殊的隐藏属性 <code>[[Prototype]]</code>（如规范中所命名的），它要么为 <code>null</code>，要么就是对另一个对象的引用。该对象被称为“原型”：</p>
<p><img src="object-prototype-empty.svg" alt="prototype"></p>
<p>原型有点“神奇”。当我们想要从 <code>object</code> 中读取一个缺失的属性时，JavaScript 会自动从原型中获取该属性。在编程中，这种行为被称为“原型继承”。许多炫酷的语言特性和编程技巧都基于此。</p>
<p>属性 <code>[[Prototype]]</code> 是内部的而且是隐藏的，但是这儿有很多设置它的方式。</p>
<p>其中之一就是使用特殊的名字 <code>__proto__</code>，就像这样：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> animal = {
  <span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span>
};
<span class="hljs-keyword">let</span> rabbit = {
  <span class="hljs-attr">jumps</span>: <span class="hljs-literal">true</span>
};

*!*
rabbit.__proto__ = animal;
*/!*</code></pre>
<p>```smart header=&quot;<code>__proto__</code> 是 <code>[[Prototype]]</code> 的因历史原因而留下来的 getter/setter&quot;
请注意，<code>__proto__</code> 与 <code>[[Prototype]]</code> **不一样**。<code>__proto__</code> 是 <code>[[Prototype]]</code> 的 getter/setter。</p>
<p><code>__proto__</code> 的存在是历史的原因。在现代编程语言中，将其替换为函数 <code>Object.getPrototypeOf/Object.setPrototypeOf</code> 也能 get/set 原型。我们稍后将学习造成这种情况的原因以及这些函数。</p>
<p>根据规范，<code>__proto__</code> 必须仅在浏览器环境下才能得到支持，但实际上，包括服务端在内的所有环境都支持它。目前，由于 <code>__proto__</code> 标记在观感上更加明显，所以我们在后面的示例中将使用它。</p>
<pre><code>
如果我们在 `rabbit` 中查找一个缺失的属性，JavaScript 会自动从 `animal` 中获取它。

例如：

```js
let animal = {
  eats: true
};
let rabbit = {
  jumps: true
};

*!*
rabbit.__proto__ = animal; // (*)
*/!*

// 现在这两个属性我们都能在 rabbit 中找到：
*!*
alert( rabbit.eats ); // true (**)
*/!*
alert( rabbit.jumps ); // true</code></pre>
<p>这里的 <code>(*)</code> 行将 <code>animal</code> 设置为 <code>rabbit</code> 的原型。</p>
<p>当 <code>alert</code> 试图读取 <code>rabbit.eats</code> <code>(**)</code> 时，因为它不存在于 <code>rabbit</code> 中，所以 JavaScript 会顺着 <code>[[Prototype]]</code> 引用，在 <code>animal</code> 中查找（自下而上）：</p>
<p><img src="proto-animal-rabbit.svg" alt=""></p>
<p>在这儿我们可以说 &quot;<code>animal</code> 是 <code>rabbit</code> 的原型&quot;，或者说 &quot;<code>rabbit</code> 的原型是从 <code>animal</code> 继承而来的&quot;。</p>
<p>因此，如果 <code>animal</code> 有许多有用的属性和方法，那么它们将自动地变为在 <code>rabbit</code> 中可用。这种属性被称为“继承”。</p>
<p>如果我们在 <code>animal</code> 中有一个方法，它可以在 <code>rabbit</code> 中被调用：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> animal = {
  <span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span>,
*!*
  <span class="hljs-function"><span class="hljs-title">walk</span>(<span class="hljs-params"></span>)</span> {
    alert(<span class="hljs-string">&quot;Animal walk&quot;</span>);
  }
*/!*
};

<span class="hljs-keyword">let</span> rabbit = {
  <span class="hljs-attr">jumps</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">__proto__</span>: animal
};

<span class="hljs-comment">// walk 方法是从原型中获得的</span>
*!*
rabbit.walk(); <span class="hljs-comment">// Animal walk</span>
*/!*</code></pre>
<p>该方法是自动地从原型中获得的，像这样：</p>
<p><img src="proto-animal-rabbit-walk.svg" alt=""></p>
<p>原型链可以很长：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> animal = {
  <span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-function"><span class="hljs-title">walk</span>(<span class="hljs-params"></span>)</span> {
    alert(<span class="hljs-string">&quot;Animal walk&quot;</span>);
  }
};

<span class="hljs-keyword">let</span> rabbit = {
  <span class="hljs-attr">jumps</span>: <span class="hljs-literal">true</span>,
*!*
  __proto__: animal
*/!*
};

<span class="hljs-keyword">let</span> longEar = {
  <span class="hljs-attr">earLength</span>: <span class="hljs-number">10</span>,
*!*
  __proto__: rabbit
*/!*
};

<span class="hljs-comment">// walk 是通过原型链获得的</span>
longEar.walk(); <span class="hljs-comment">// Animal walk</span>
alert(longEar.jumps); <span class="hljs-comment">// true（从 rabbit）</span></code></pre>
<p><img src="proto-animal-rabbit-chain.svg" alt=""></p>
<p>这里只有两个限制：</p>
<ol>
<li>引用不能形成闭环。如果我们试图在一个闭环中分配 <code>__proto__</code>，JavaScript 会抛出错误。</li>
<li><code>__proto__</code> 的值可以是对象，也可以是 <code>null</code>。而其他的类型都会被忽略。</li>
</ol>
<p>当然，这可能很显而易见，但是仍然要强调：只能有一个 <code>[[Prototype]]</code>。一个对象不能从其他两个对象获得继承。</p>
<h2 id="写入不使用原型">写入不使用原型</h2>
<p>原型仅用于读取属性。</p>
<p>对于写入/删除操作可以直接在对象上进行。</p>
<p>在下面的示例中，我们将为 <code>rabbit</code> 分配自己的 <code>walk</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> animal = {
  <span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-function"><span class="hljs-title">walk</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-comment">/* rabbit 不会使用此方法 */</span>  
  }
};

<span class="hljs-keyword">let</span> rabbit = {
  <span class="hljs-attr">__proto__</span>: animal
};

*!*
rabbit.walk = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-string">&quot;Rabbit! Bounce-bounce!&quot;</span>);
};
*/!*

rabbit.walk(); <span class="hljs-comment">// Rabbit! Bounce-bounce!</span></code></pre>
<p>从现在开始，<code>rabbit.walk()</code> 将立即在对象中找到该方法并执行，而无需使用原型：</p>
<p><img src="proto-animal-rabbit-walk-2.svg" alt=""></p>
<p>访问器（accessor）属性是一个例外，因为分配（assignment）操作是由 setter 函数处理的。因此，写入此类属性实际上与调用函数相同。</p>
<p>也就是这个原因，所以下面这段代码中的 <code>admin.fullName</code> 能够正常运行：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">surname</span>: <span class="hljs-string">&quot;Smith&quot;</span>,

  <span class="hljs-keyword">set</span> <span class="hljs-title">fullName</span>(<span class="hljs-params">value</span>) {
    [<span class="hljs-built_in">this</span>.name, <span class="hljs-built_in">this</span>.surname] = value.split(<span class="hljs-string">&quot; &quot;</span>);
  },

  <span class="hljs-keyword">get</span> <span class="hljs-title">fullName</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">this</span>.name}</span> <span class="hljs-subst">${<span class="hljs-built_in">this</span>.surname}</span>`</span>;
  }
};

<span class="hljs-keyword">let</span> admin = {
  <span class="hljs-attr">__proto__</span>: user,
  <span class="hljs-attr">isAdmin</span>: <span class="hljs-literal">true</span>
};

alert(admin.fullName); <span class="hljs-comment">// John Smith (*)</span>

<span class="hljs-comment">// setter triggers!</span>
admin.fullName = <span class="hljs-string">&quot;Alice Cooper&quot;</span>; <span class="hljs-comment">// (**)</span></code></pre>
<p>在 <code>(*)</code> 行中，属性 <code>admin.fullName</code> 在原型 <code>user</code> 中有一个 getter，因此它会被调用。在 <code>(**)</code> 行中，属性在原型中有一个 setter，因此它会被调用。</p>
<h2 id="this-的值">&quot;this&quot; 的值</h2>
<p>在上面的例子中可能会出现一个有趣的问题：在 <code>set fullName(value)</code> 中 <code>this</code> 的值是什么？属性 <code>this.name</code> 和 <code>this.surname</code> 被写在哪里：在 <code>user</code> 还是 <code>admin</code>？</p>
<p>答案很简单：<code>this</code> 根本不受原型的影响。</p>
<p><strong>无论在哪里找到方法：在一个对象还是在原型中。在一个方法调用中，<code>this</code> 始终是点符号 <code>.</code> 前面的对象。</strong></p>
<p>因此，setter 调用 <code>admin.fullName=</code> 使用 <code>admin</code> 作为 <code>this</code>，而不是 <code>user</code>。</p>
<p>这是一件非常重要的事儿，因为我们可能有一个带有很多方法的大对象，并且还有从其继承的对象。当继承的对象运行继承的方法时，它们将仅修改自己的状态，而不会修改大对象的状态。</p>
<p>例如，这里的 <code>animal</code> 代表“方法存储”，<code>rabbit</code> 在使用其中的方法。</p>
<p>调用 <code>rabbit.sleep()</code> 会在 <code>rabbit</code> 对象上设置 <code>this.isSleeping</code>：</p>
<pre><code class="language-js"><span class="hljs-comment">// animal 有一些方法</span>
<span class="hljs-keyword">let</span> animal = {
  <span class="hljs-function"><span class="hljs-title">walk</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.isSleeping) {
      alert(<span class="hljs-string">`I walk`</span>);
    }
  },
  <span class="hljs-function"><span class="hljs-title">sleep</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-built_in">this</span>.isSleeping = <span class="hljs-literal">true</span>;
  }
};

<span class="hljs-keyword">let</span> rabbit = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;White Rabbit&quot;</span>,
  <span class="hljs-attr">__proto__</span>: animal
};

<span class="hljs-comment">// 修改 rabbit.isSleeping</span>
rabbit.sleep();

alert(rabbit.isSleeping); <span class="hljs-comment">// true</span>
alert(animal.isSleeping); <span class="hljs-comment">// undefined（原型中没有此属性）</span></code></pre>
<p>结果示意图：</p>
<p><img src="proto-animal-rabbit-walk-3.svg" alt=""></p>
<p>如果我们还有从 <code>animal</code> 继承的其他对象，像 <code>bird</code> 和 <code>snake</code> 等，它们也将可以访问 <code>animal</code> 的方法。但是，每个方法调用中的 <code>this</code> 都是在调用时（点符号前）评估的对应的对象，而不是 <code>animal</code>。因此，当我们将数据写入 <code>this</code> 时，会将其存储到这些对象中。</p>
<p>所以，方法是共享的，但对象状态不是。</p>
<h2 id="forin-循环">for..in 循环</h2>
<p><code>for..in</code> 循环也会迭代继承的属性。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> animal = {
  <span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span>
};

<span class="hljs-keyword">let</span> rabbit = {
  <span class="hljs-attr">jumps</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">__proto__</span>: animal
};

*!*
<span class="hljs-comment">// Object.keys 只返回自己的 key</span>
alert(<span class="hljs-built_in">Object</span>.keys(rabbit)); <span class="hljs-comment">// jumps</span>
*/!*

*!*
<span class="hljs-comment">// for..in 会遍历自己以及继承的键</span>
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> prop <span class="hljs-keyword">in</span> rabbit) alert(prop); <span class="hljs-comment">// jumps，然后是 eats</span>
*/!*</code></pre>
<p>如果这不是我们想要的，并且我们想排除继承的属性，那么这儿有一个内建方法 <a href="mdn:js/Object/hasOwnProperty">obj.hasOwnProperty(key)</a>：如果 <code>obj</code> 具有自己的（非继承的）名为 <code>key</code> 的属性，则返回 <code>true</code>。</p>
<p>因此，我们可以过滤掉继承的属性（或对它们进行其他操作）：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> animal = {
  <span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span>
};

<span class="hljs-keyword">let</span> rabbit = {
  <span class="hljs-attr">jumps</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">__proto__</span>: animal
};

<span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> prop <span class="hljs-keyword">in</span> rabbit</span>)</span> {
  <span class="hljs-keyword">let</span> isOwn = rabbit.hasOwnProperty(prop);

  <span class="hljs-keyword">if</span> (isOwn) {
    alert(<span class="hljs-string">`Our: <span class="hljs-subst">${prop}</span>`</span>); <span class="hljs-comment">// Our: jumps</span>
  } <span class="hljs-keyword">else</span> {
    alert(<span class="hljs-string">`Inherited: <span class="hljs-subst">${prop}</span>`</span>); <span class="hljs-comment">// Inherited: eats</span>
  }
}</code></pre>
<p>这里我们有以下继承链：<code>rabbit</code> 从 <code>animal</code> 中继承，<code>animal</code> 从 <code>Object.prototype</code> 中继承（因为 <code>animal</code> 是对象字面量 <code>{...}</code>，所以这是默认的继承），然后再向上是 <code>null</code>：</p>
<p><img src="rabbit-animal-object.svg" alt=""></p>
<p>注意，这有一件很有趣的事儿。方法 <code>rabbit.hasOwnProperty</code> 来自哪儿？我们并没有定义它。从上图中的原型链我们可以看到，该方法是 <code>Object.prototype.hasOwnProperty</code> 提供的。换句话说，它是继承的。</p>
<p>……如果 <code>for..in</code> 循环会列出继承的属性，那为什么 <code>hasOwnProperty</code> 没有像 <code>eats</code> 和 <code>jumps</code> 那样出现在 <code>for..in</code> 循环中？</p>
<p>答案很简单：它是不可枚举的。就像 <code>Object.prototype</code> 的其他属性，<code>hasOwnProperty</code> 有 <code>enumerable:false</code> 标志。并且 <code>for..in</code> 只会列出可枚举的属性。这就是为什么它和其余的 <code>Object.prototype</code> 属性都未被列出。</p>
<pre><code class="language-smart">几乎所有其他键/值获取方法，例如 `Object.keys` 和 `Object.values` 等，都会忽略继承的属性。

它们只会对对象自身进行操作。**不考虑** 继承自原型的属性。</code></pre>
<h2 id="总结">总结</h2>
<ul>
<li>在 JavaScript 中，所有的对象都有一个隐藏的 <code>[[Prototype]]</code> 属性，它要么是另一个对象，要么就是 <code>null</code>。</li>
<li>我们可以使用 <code>obj.__proto__</code> 访问它（历史遗留下来的 getter/setter，这儿还有其他方法，很快我们就会讲到）。</li>
<li>通过 <code>[[Prototype]]</code> 引用的对象被称为“原型”。</li>
<li>如果我们想要读取 <code>obj</code> 的一个属性或者调用一个方法，并且它不存在，那么 JavaScript 就会尝试在原型中查找它。</li>
<li>写/删除操作直接在对象上进行，它们不使用原型（假设它是数据属性，不是 setter）。</li>
<li>如果我们调用 <code>obj.method()</code>，而且 <code>method</code> 是从原型中获取的，<code>this</code> 仍然会引用 <code>obj</code>。因此，方法始终与当前对象一起使用，即使方法是继承的。</li>
<li><code>for..in</code> 循环在其自身和继承的属性上进行迭代。所有其他的键/值获取方法仅对对象本身起作用。</li>
</ul>

      </fieldset>
      
      <fieldset id='_cDgeNI'>
      <legend>solution</legend>
      <p>答案：</p>
<ol>
<li><p><code>true</code>。</p>
<p> <code>Rabbit.prototype</code> 的赋值操作为新对象设置了 <code>[[Prototype]]</code>，但它不影响已有的对象。</p>
</li>
<li><p><code>false</code>。</p>
<p> 对象通过引用被赋值。来自 <code>Rabbit.prototype</code> 的对象并没有被复制，它仍然是被 <code>Rabbit.prototype</code> 和 <code>rabbit</code> 的 <code>[[Prototype]]</code> 引用的单个对象。</p>
<p> 所以当我们通过一个引用更改其内容时，它对其他引用也是可见的。</p>
</li>
<li><p><code>true</code>。</p>
<p> 所有 <code>delete</code> 操作都直接应用于对象。这里的 <code>delete rabbit.eats</code> 试图从 <code>rabbit</code> 中删除 <code>eats</code> 属性，但 <code>rabbit</code> 对象并没有 <code>eats</code> 属性。所以这个操作不会有任何影响。</p>
</li>
<li><p><code>undefined</code>。</p>
<p> 属性 <code>eats</code> 被从 prototype 中删除，prototype 中就没有这个属性了。</p>
</li>
</ol>

      </fieldset>
      
      <fieldset id='_1qgeWt'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="修改-prototype">修改 &quot;prototype&quot;</h1>
<p>在下面的代码中，我们创建了 <code>new Rabbit</code>，然后尝试修改它的 prototype。</p>
<p>最初，我们有以下代码：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rabbit</span>(<span class="hljs-params"></span>) </span>{}
Rabbit.prototype = {
  <span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span>
};

<span class="hljs-keyword">let</span> rabbit = <span class="hljs-keyword">new</span> Rabbit();

alert( rabbit.eats ); <span class="hljs-comment">// true</span></code></pre>
<ol>
<li><p>我们增加了一个字符串（强调）。现在 <code>alert</code> 会显示什么？</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rabbit</span>(<span class="hljs-params"></span>) </span>{}
Rabbit.prototype = {
  <span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span>
};

<span class="hljs-keyword">let</span> rabbit = <span class="hljs-keyword">new</span> Rabbit();

*!*
Rabbit.prototype = {};
*/!*

alert( rabbit.eats ); <span class="hljs-comment">// ?</span></code></pre>
</li>
<li><p>……如果代码是这样的（修改了一行）？</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rabbit</span>(<span class="hljs-params"></span>) </span>{}
Rabbit.prototype = {
  <span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span>
};

<span class="hljs-keyword">let</span> rabbit = <span class="hljs-keyword">new</span> Rabbit();

*!*
Rabbit.prototype.eats = <span class="hljs-literal">false</span>;
*/!*

alert( rabbit.eats ); <span class="hljs-comment">// ?</span></code></pre>
</li>
<li><p>像这样呢（修改了一行）？</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rabbit</span>(<span class="hljs-params"></span>) </span>{}
Rabbit.prototype = {
  <span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span>
};

<span class="hljs-keyword">let</span> rabbit = <span class="hljs-keyword">new</span> Rabbit();

*!*
<span class="hljs-keyword">delete</span> rabbit.eats;
*/!*

alert( rabbit.eats ); <span class="hljs-comment">// ?</span></code></pre>
</li>
<li><p>最后一种变体：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rabbit</span>(<span class="hljs-params"></span>) </span>{}
Rabbit.prototype = {
  <span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span>
};

<span class="hljs-keyword">let</span> rabbit = <span class="hljs-keyword">new</span> Rabbit();

*!*
<span class="hljs-keyword">delete</span> Rabbit.prototype.eats;
*/!*

alert( rabbit.eats ); <span class="hljs-comment">// ?</span></code></pre>
</li>
</ol>

      </fieldset>
      
      <fieldset id='_hmBqqs'>
      <legend>solution</legend>
      <p>如果我们确信 <code>&quot;constructor&quot;</code> 属性具有正确的值，那么就可以使用这种方法。</p>
<p>例如，如果我们不触碰默认的 <code>&quot;prototype&quot;</code>，那么这段代码肯定可以正常运行：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-built_in">this</span>.name = name;
}

<span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&#x27;John&#x27;</span>);
<span class="hljs-keyword">let</span> user2 = <span class="hljs-keyword">new</span> user.constructor(<span class="hljs-string">&#x27;Pete&#x27;</span>);

alert( user2.name ); <span class="hljs-comment">// Pete (worked!)</span></code></pre>
<p>它起作用了，因为 <code>User.prototype.constructor == User</code>。</p>
<p>……但是如果有人，重写了 <code>User.prototype</code>，并忘记可重新创建 <code>constructor</code> 以引用 <code>User</code>，那么上面这段代码就会运行失败。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-built_in">this</span>.name = name;
}
*!*
User.prototype = {}; <span class="hljs-comment">// (*)</span>
*/!*

<span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&#x27;John&#x27;</span>);
<span class="hljs-keyword">let</span> user2 = <span class="hljs-keyword">new</span> user.constructor(<span class="hljs-string">&#x27;Pete&#x27;</span>);

alert( user2.name ); <span class="hljs-comment">// undefined</span></code></pre>
<p>为什么 <code>user2.name</code> 是 <code>undefined</code>？</p>
<p>这是 <code>new user.constructor(&#39;Pete&#39;)</code> 的工作流程：</p>
<ol>
<li>首先，它在 <code>user</code> 中寻找 <code>constructor</code>。没找到。</li>
<li>然后它追溯原型链。<code>user</code> 的原型是 <code>User.prototype</code>，它也什么都没有。</li>
<li><code>User.prototype</code> 的值是一个普通对象 <code>{}</code>，该对象的原型是 <code>Object.prototype</code>。并且 <code>Object.prototype.constructor == Object</code>。所以就用它了。</li>
</ol>
<p>最后，我们有 <code>let user2 = new Object(&#39;Pete&#39;)</code>。内建的 <code>Object</code> 构造函数会忽略参数，它总是创建一个类似于 <code>let user2 = {}</code> 的空对象，这就是最后我们在 <code>user2</code> 中拥有的东西。</p>

      </fieldset>
      
      <fieldset id='_1vJxgA'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="使用相同的构造函数创建一个对象">使用相同的构造函数创建一个对象</h1>
<p>想象一下，我们有一个由构造函数创建的对象 <code>obj</code> —— 我们不知道使用的是哪个构造函数，但是我们想使用它创建一个新对象。</p>
<p>我们可以这样做吗？</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> obj2 = <span class="hljs-keyword">new</span> obj.constructor();</code></pre>
<p>请给出一个可以使这样的代码正常工作的 <code>obj</code> 的构造函数的例子。再给出会导致这样的代码无法正确工作的例子。</p>

      </fieldset>
      
      <fieldset id='_KPTL97'>
      <legend>article</legend>
      <h1 id="fprototype">F.prototype</h1>
<p>我们还记得，可以使用诸如 <code>new F()</code> 这样的构造函数来创建一个新对象。</p>
<p>如果 <code>F.prototype</code> 是一个对象，那么 <code>new</code> 操作符会使用它为新对象设置 <code>[[Prototype]]</code>。</p>
<pre><code class="language-smart">JavaScript 从一开始就有了原型继承。这是 JavaScript 编程语言的核心特性之一。

但是在过去，没有直接对其进行访问的方式。唯一可靠的方法是本章中会介绍的构造函数的 `&quot;prototype&quot;` 属性。目前仍有许多脚本仍在使用它。</code></pre>
<p>请注意，这里的 <code>F.prototype</code> 指的是 <code>F</code> 的一个名为 <code>&quot;prototype&quot;</code> 的常规属性。这听起来与“原型”这个术语很类似，但这里我们实际上指的是具有该名字的常规属性。</p>
<p>下面是一个例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> animal = {
  <span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span>
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rabbit</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-built_in">this</span>.name = name;
}

*!*
Rabbit.prototype = animal;
*/!*

<span class="hljs-keyword">let</span> rabbit = <span class="hljs-keyword">new</span> Rabbit(<span class="hljs-string">&quot;White Rabbit&quot;</span>); <span class="hljs-comment">//  rabbit.__proto__ == animal</span>

alert( rabbit.eats ); <span class="hljs-comment">// true</span></code></pre>
<p>设置 <code>Rabbit.prototype = animal</code> 的字面意思是：“当创建了一个 <code>new Rabbit</code> 时，把它的 <code>[[Prototype]]</code> 赋值为 <code>animal</code>”。</p>
<p>这是结果示意图：</p>
<p><img src="proto-constructor-animal-rabbit.svg" alt=""></p>
<p>在上图中，<code>&quot;prototype&quot;</code> 是一个水平箭头，表示一个常规属性，<code>[[Prototype]]</code> 是垂直的，表示 <code>rabbit</code> 继承自 <code>animal</code>。</p>
<p>```smart header=&quot;<code>F.prototype</code> 仅用在 <code>new F</code> 时&quot;
<code>F.prototype</code> 属性仅在 <code>new F</code> 被调用时使用，它为新对象的 <code>[[Prototype]]</code> 赋值。</p>
<p>如果在创建之后，<code>F.prototype</code> 属性有了变化（<code>F.prototype = &lt;another object&gt;</code>），那么通过 <code>new F</code> 创建的新对象也将随之拥有新的对象作为 <code>[[Prototype]]</code>，但已经存在的对象将保持旧有的值。</p>
<pre><code>
##  默认的 F.prototype，构造器属性

每个函数都有 `&quot;prototype&quot;` 属性，即使我们没有提供它。

默认的 `&quot;prototype&quot;` 是一个只有属性 `constructor` 的对象，属性 `constructor` 指向函数自身。

像这样：

```js
function Rabbit() {}

/* default prototype
Rabbit.prototype = { constructor: Rabbit };
*/</code></pre>
<p><img src="function-prototype-constructor.svg" alt=""></p>
<p>我们可以检查一下：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rabbit</span>(<span class="hljs-params"></span>) </span>{}
<span class="hljs-comment">// by default:</span>
<span class="hljs-comment">// Rabbit.prototype = { constructor: Rabbit }</span>

alert( Rabbit.prototype.constructor == Rabbit ); <span class="hljs-comment">// true</span></code></pre>
<p>通常，如果我们什么都不做，<code>constructor</code> 属性可以通过 <code>[[Prototype]]</code> 给所有 rabbits 使用：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rabbit</span>(<span class="hljs-params"></span>) </span>{}
<span class="hljs-comment">// by default:</span>
<span class="hljs-comment">// Rabbit.prototype = { constructor: Rabbit }</span>

<span class="hljs-keyword">let</span> rabbit = <span class="hljs-keyword">new</span> Rabbit(); <span class="hljs-comment">// inherits from {constructor: Rabbit}</span>

alert(rabbit.constructor == Rabbit); <span class="hljs-comment">// true (from prototype)</span></code></pre>
<p><img src="rabbit-prototype-constructor.svg" alt=""></p>
<p>我们可以使用 <code>constructor</code> 属性来创建一个新对象，该对象使用与现有对象相同的构造器。</p>
<p>像这样：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rabbit</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-built_in">this</span>.name = name;
  alert(name);
}

<span class="hljs-keyword">let</span> rabbit = <span class="hljs-keyword">new</span> Rabbit(<span class="hljs-string">&quot;White Rabbit&quot;</span>);

*!*
<span class="hljs-keyword">let</span> rabbit2 = <span class="hljs-keyword">new</span> rabbit.constructor(<span class="hljs-string">&quot;Black Rabbit&quot;</span>);
*/!*</code></pre>
<p>当我们有一个对象，但不知道它使用了哪个构造器（例如它来自第三方库），并且我们需要创建另一个类似的对象时，用这种方法就很方便。</p>
<p>但是，关于 <code>&quot;constructor&quot;</code> 最重要的是……</p>
<p><strong>……JavaScript 自身并不能确保正确的 <code>&quot;constructor&quot;</code> 函数值。</strong></p>
<p>是的，它存在于函数的默认 <code>&quot;prototype&quot;</code> 中，但仅此而已。之后会发生什么 —— 完全取决于我们。</p>
<p>特别是，如果我们将整个默认 prototype 替换掉，那么其中就不会有 <code>&quot;constructor&quot;</code> 了。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rabbit</span>(<span class="hljs-params"></span>) </span>{}
Rabbit.prototype = {
  <span class="hljs-attr">jumps</span>: <span class="hljs-literal">true</span>
};

<span class="hljs-keyword">let</span> rabbit = <span class="hljs-keyword">new</span> Rabbit();
*!*
alert(rabbit.constructor === Rabbit); <span class="hljs-comment">// false</span>
*/!*</code></pre>
<p>因此，为了确保正确的 <code>&quot;constructor&quot;</code>，我们可以选择添加/删除属性到默认 <code>&quot;prototype&quot;</code>，而不是将其整个覆盖：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rabbit</span>(<span class="hljs-params"></span>) </span>{}

<span class="hljs-comment">// 不要将 Rabbit.prototype 整个覆盖</span>
<span class="hljs-comment">// 可以向其中添加内容 </span>
Rabbit.prototype.jumps = <span class="hljs-literal">true</span>
<span class="hljs-comment">// 默认的 Rabbit.prototype.constructor 被保留了下来</span></code></pre>
<p>或者，也可以手动重新创建 <code>constructor</code> 属性：</p>
<pre><code class="language-js">Rabbit.prototype = {
  <span class="hljs-attr">jumps</span>: <span class="hljs-literal">true</span>,
*!*
  <span class="hljs-title">constructor</span>: <span class="hljs-title">Rabbit</span>
*/!*
};

<span class="hljs-comment">// 这样的 constructor 也是正确的，因为我们手动添加了它</span></code></pre>
<h2 id="总结">总结</h2>
<p>在本章中，我们简要介绍了为通过构造函数创建的对象设置 <code>[[Prototype]]</code> 的方法。稍后我们将看到更多依赖于此的高级编程模式。</p>
<p>一切都很简单，只需要记住几条重点就可以清晰地掌握了：</p>
<ul>
<li><code>F.prototype</code> 属性（不要把它与 <code>[[Prototype]]</code> 弄混了）在 <code>new F</code> 被调用时为新对象的 <code>[[Prototype]]</code> 赋值。</li>
<li><code>F.prototype</code> 的值要么是一个对象，要么就是 <code>null</code>：其他值都不起作用。</li>
<li><code>&quot;prototype&quot;</code> 属性仅在设置了一个构造函数（constructor function），并通过 <code>new</code> 调用时，才具有这种特殊的影响。</li>
</ul>
<p>在常规对象上，<code>prototype</code> 没什么特别的：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">prototype</span>: <span class="hljs-string">&quot;Bla-bla&quot;</span> <span class="hljs-comment">// 这里只是普通的属性</span>
};</code></pre>
<p>默认情况下，所有函数都有 <code>F.prototype = {constructor：F}</code>，所以我们可以通过访问它的 <code>&quot;constructor&quot;</code> 属性来获取一个对象的构造器。</p>

      </fieldset>
      
      <fieldset id='_Lrktk5'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-built_in">Function</span>.prototype.defer = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ms</span>) </span>{
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-built_in">this</span>, ms);
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-string">&quot;Hello!&quot;</span>);
}

f.defer(<span class="hljs-number">1000</span>); <span class="hljs-comment">// shows &quot;Hello!&quot; after 1 sec</span></code></pre>

      </fieldset>
      
      <fieldset id='_uXm82o'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="给函数添加一个-fdeferms-方法">给函数添加一个 &quot;f.defer(ms)&quot; 方法</h1>
<p>在所有函数的原型中添加 <code>defer(ms)</code> 方法，该方法将在 <code>ms</code> 毫秒后运行该函数。</p>
<p>当你完成添加后，下面的代码应该是可执行的：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-string">&quot;Hello!&quot;</span>);
}

f.defer(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 1 秒后显示 &quot;Hello!&quot;</span></code></pre>

      </fieldset>
      
      <fieldset id='_eU2NYp'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-built_in">Function</span>.prototype.defer = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ms</span>) </span>{
  <span class="hljs-keyword">let</span> f = <span class="hljs-built_in">this</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>{
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> f.apply(<span class="hljs-built_in">this</span>, args), ms);
  }
};

<span class="hljs-comment">// check it</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a, b</span>) </span>{
  alert( a + b );
}

f.defer(<span class="hljs-number">1000</span>)(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 1 秒后显示 3</span></code></pre>
<p>请注意：我们在 <code>f.apply</code> 中使用 <code>this</code> 以使装饰者适用于对象方法。</p>
<p>因此，如果将包装器函数作为对象方法调用，那么 <code>this</code> 将会被传递给原始方法 <code>f</code>。</p>
<pre><code class="language-js"><span class="hljs-built_in">Function</span>.prototype.defer = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ms</span>) </span>{
  <span class="hljs-keyword">let</span> f = <span class="hljs-built_in">this</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>{
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> f.apply(<span class="hljs-built_in">this</span>, args), ms);
  }
};

<span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> {
    alert(<span class="hljs-built_in">this</span>.name);
  }
}

user.sayHi = user.sayHi.defer(<span class="hljs-number">1000</span>);

user.sayHi();</code></pre>

      </fieldset>
      
      <fieldset id='_6gBmRK'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="将装饰者-defer-添加到函数">将装饰者 &quot;defer()&quot; 添加到函数</h1>
<p>在所有函数的原型中添加 <code>defer(ms)</code> 方法，该方法返回一个包装器，将函数调用延迟 <code>ms</code> 毫秒。</p>
<p>下面是它应该如何执行的例子：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a, b</span>) </span>{
  alert( a + b );
}

f.defer(<span class="hljs-number">1000</span>)(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 1 秒后显示 3</span></code></pre>
<p>请注意，参数应该被传给原始函数。</p>

      </fieldset>
      
      <fieldset id='_IEqJnQ'>
      <legend>article</legend>
      <h1 id="原生的原型">原生的原型</h1>
<p><code>&quot;prototype&quot;</code> 属性在 JavaScript 自身的核心部分中被广泛地应用。所有的内置构造函数都用到了它。</p>
<p>首先，我们将看看原生原型的详细信息，然后学习如何使用它为内建对象添加新功能。</p>
<h2 id="objectprototype">Object.prototype</h2>
<p>假如我们输出一个空对象：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> obj = {};
alert( obj ); <span class="hljs-comment">// &quot;[object Object]&quot; ?</span></code></pre>
<p>生成字符串 <code>&quot;[object Object]&quot;</code> 的代码在哪里？那就是一个内建的 <code>toString</code> 方法，但是它在哪里呢？<code>obj</code> 是空的！</p>
<p>……然而简短的表达式 <code>obj = {}</code> 和 <code>obj = new Object()</code> 是一个意思，其中 <code>Object</code> 就是一个内建的对象构造函数，其自身的 <code>prototype</code> 指向一个带有 <code>toString</code> 和其他方法的一个巨大的对象。</p>
<p>就像这样：</p>
<p><img src="object-prototype.svg" alt=""></p>
<p>当 <code>new Object()</code> 被调用（或一个字面量对象 <code>{...}</code> 被创建），按照前面章节中我们学习过的规则，这个对象的 <code>[[Prototype]]</code> 属性被设置为 <code>Object.prototype</code>：</p>
<p><img src="object-prototype-1.svg" alt=""></p>
<p>所以，之后当 <code>obj.toString()</code> 被调用时，这个方法是从 <code>Object.prototype</code> 中获取的。</p>
<p>我们可以这样验证它：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> obj = {};

alert(obj.__proto__ === <span class="hljs-built_in">Object</span>.prototype); <span class="hljs-comment">// true</span>
<span class="hljs-comment">// obj.toString === obj.__proto__.toString == Object.prototype.toString</span></code></pre>
<p>请注意在 <code>Object.prototype</code> 上方的链中没有更多的 <code>[[Prototype]]</code>：</p>
<pre><code class="language-js">alert(<span class="hljs-built_in">Object</span>.prototype.__proto__); <span class="hljs-comment">// null</span></code></pre>
<h2 id="其他内建原型">其他内建原型</h2>
<p>其他内建对象，像 <code>Array</code>、<code>Date</code>、<code>Function</code> 及其他，都在 prototype 上挂载了方法。</p>
<p>例如，当我们创建一个数组 <code>[1, 2, 3]</code>，在内部会默认使用 <code>new Array()</code> 构造器。因此 <code>Array.prototype</code> 变成了这个数组的 prototype，并为这个数组提供数组的操作方法。这样内存的存储效率是很高的。</p>
<p>按照规范，所有的内建原型顶端都是 <code>Object.prototype</code>。这就是为什么有人说“一切都从对象继承而来”。</p>
<p>下面是完整的示意图（3 个内建对象）：</p>
<p><img src="native-prototypes-classes.svg" alt=""></p>
<p>让我们手动验证原型：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];

<span class="hljs-comment">// 它继承自 Array.prototype？</span>
alert( arr.__proto__ === <span class="hljs-built_in">Array</span>.prototype ); <span class="hljs-comment">// true</span>

<span class="hljs-comment">// 接下来继承自 Object.prototype？</span>
alert( arr.__proto__.__proto__ === <span class="hljs-built_in">Object</span>.prototype ); <span class="hljs-comment">// true</span>

<span class="hljs-comment">// 原型链的顶端为 null。</span>
alert( arr.__proto__.__proto__.__proto__ ); <span class="hljs-comment">// null</span></code></pre>
<p>一些方法在原型上可能会发生重叠，例如，<code>Array.prototype</code> 有自己的 <code>toString</code> 方法来列举出来数组的所有元素并用逗号分隔每一个元素。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
alert(arr); <span class="hljs-comment">// 1,2,3 &lt;-- Array.prototype.toString 的结果</span></code></pre>
<p>正如我们之前看到的那样，<code>Object.prototype</code> 也有 <code>toString</code> 方法，但是 <code>Array.prototype</code> 在原型链上更近，所以数组对象原型上的方法会被使用。</p>
<p><img src="native-prototypes-array-tostring.svg" alt=""></p>
<p>浏览器内的工具，像 Chrome 开发者控制台也会显示继承性（可能需要对内置对象使用 <code>console.dir</code>）：</p>
<p><img src="console_dir_array.png" alt=""></p>
<p>其他内建对象也以同样的方式运行。即使是函数 —— 它们是内建构造器 <code>Function</code> 的对象，并且它们的方法（<code>call</code>/<code>apply</code> 及其他）都取自 <code>Function.prototype</code>。函数也有自己的 <code>toString</code> 方法。</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{}

alert(f.__proto__ == <span class="hljs-built_in">Function</span>.prototype); <span class="hljs-comment">// true</span>
alert(f.__proto__.__proto__ == <span class="hljs-built_in">Object</span>.prototype); <span class="hljs-comment">// true, inherit from objects</span></code></pre>
<h2 id="基本数据类型">基本数据类型</h2>
<p>最复杂的事情发生在字符串、数字和布尔值上。</p>
<p>正如我们记忆中的那样，它们并不是对象。但是如果我们试图访问它们的属性，那么临时包装器对象将会通过内建的构造器 <code>String</code>、<code>Number</code> 和 <code>Boolean</code> 被创建。它们提供给我们操作字符串、数字和布尔值的方法然后消失。</p>
<p>这些对象对我们来说是无形地创建出来的。大多数引擎都会对其进行优化，但是规范中描述的就是通过这种方式。这些对象的方法也驻留在它们的 prototype 中，可以通过 <code>String.prototype</code>、<code>Number.prototype</code> 和 <code>Boolean.prototype</code> 进行获取。</p>
<p>```warn header=&quot;值 <code>null</code> 和 <code>undefined</code> 没有对象包装器&quot;
特殊值 <code>null</code> 和 <code>undefined</code> 比较特殊。它们没有对象包装器，所以它们没有方法和属性。并且它们也没有相应的原型。</p>
<pre><code>
## 更改原生原型 [#native-prototype-change]

原生的原型是可以被修改的。例如，我们向 `String.prototype` 中添加一个方法，这个方法将对所有的字符串都是可用的：

```js run
String.prototype.show = function() {
  alert(this);
};

&quot;BOOM!&quot;.show(); // BOOM!</code></pre>
<p>在开发的过程中，我们可能会想要一些新的内建方法，并且想把它们添加到原生原型中。但这通常是一个很不好的想法。</p>
<pre><code class="language-warn">原型是全局的，所以很容易造成冲突。如果有两个库都添加了 `String.prototype.show` 方法，那么其中的一个方法将被另一个覆盖。

所以，通常来说，修改原生原型被认为是一个很不好的想法。</code></pre>
<p><strong>在现代编程中，只有一种情况下允许修改原生原型。那就是 polyfilling。</strong></p>
<p>Polyfilling 是一个术语，表示某个方法在 JavaScript 规范中已存在，但是特定的 JavaScript 引擎尚不支持该方法，那么我们可以通过手动实现它，并用以填充内建原型。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">String</span>.prototype.repeat) { <span class="hljs-comment">// 如果这儿没有这个方法</span>
  <span class="hljs-comment">// 那就在 prototype 中添加它</span>

  <span class="hljs-built_in">String</span>.prototype.repeat = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>{
    <span class="hljs-comment">// 重复传入的字符串 n 次</span>

    <span class="hljs-comment">// 实际上，实现代码比这个要复杂一些（完整的方法可以在规范中找到）</span>
    <span class="hljs-comment">// 但即使是不够完美的 polyfill 也常常被认为是足够好的</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n + <span class="hljs-number">1</span>).join(<span class="hljs-built_in">this</span>);
  };
}

alert( <span class="hljs-string">&quot;La&quot;</span>.repeat(<span class="hljs-number">3</span>) ); <span class="hljs-comment">// LaLaLa</span></code></pre>
<h2 id="从原型中借用">从原型中借用</h2>
<p>在 <a href="info:call-apply-decorators#method-borrowing">info:call-apply-decorators#method-borrowing</a> 一章中，我们讨论了方法借用。</p>
<p>那是指我们从一个对象获取一个方法，并将其复制到另一个对象。</p>
<p>一些原生原型的方法通常会被借用。</p>
<p>例如，如果我们要创建类数组对象，则可能需要向其中复制一些 <code>Array</code> 方法。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> obj = {
  <span class="hljs-number">0</span>: <span class="hljs-string">&quot;Hello&quot;</span>,
  <span class="hljs-number">1</span>: <span class="hljs-string">&quot;world!&quot;</span>,
  <span class="hljs-attr">length</span>: <span class="hljs-number">2</span>,
};

*!*
obj.join = <span class="hljs-built_in">Array</span>.prototype.join;
*/!*

alert( obj.join(<span class="hljs-string">&#x27;,&#x27;</span>) ); <span class="hljs-comment">// Hello,world!</span></code></pre>
<p>上面这段代码有效，是因为内建的方法 <code>join</code> 的内部算法只关心正确的索引和 <code>length</code> 属性。它不会检查这个对象是否是真正的数组。许多内建方法就是这样。</p>
<p>另一种方式是通过将 <code>obj.__proto__</code> 设置为 <code>Array.prototype</code>，这样 <code>Array</code> 中的所有方法都自动地可以在 <code>obj</code> 中使用了。</p>
<p>但是如果 <code>obj</code> 已经从另一个对象进行了继承，那么这种方法就不可行了（译注：因为这样会覆盖掉已有的继承。此处 <code>obj</code> 其实已经从 <code>Object</code> 进行了继承，但是 <code>Array</code> 也继承自 <code>Object</code>，所以此处的方法借用不会影响 <code>obj</code> 对原有继承的继承，因为 <code>obj</code> 通过原型链依旧继承了 <code>Object</code>）。请记住，我们一次只能继承一个对象。</p>
<p>方法借用很灵活，它允许在需要时混合来自不同对象的方法。</p>
<h2 id="总结">总结</h2>
<ul>
<li>所有的内建对象都遵循相同的模式（pattern）：<ul>
<li>方法都存储在 prototype 中（<code>Array.prototype</code>、<code>Object.prototype</code>、<code>Date.prototype</code> 等）。</li>
<li>对象本身只存储数据（数组元素、对象属性、日期）。</li>
</ul>
</li>
<li>原始数据类型也将方法存储在包装器对象的 prototype 中：<code>Number.prototype</code>、<code>String.prototype</code> 和 <code>Boolean.prototype</code>。只有 <code>undefined</code> 和 <code>null</code> 没有包装器对象。</li>
<li>内建原型可以被修改或被用新的方法填充。但是不建议更改它们。唯一允许的情况可能是，当我们添加一个还没有被 JavaScript 引擎支持，但已经被加入 JavaScript 规范的新标准时，才可能允许这样做。</li>
</ul>

      </fieldset>
      
      <fieldset id='_ZuY1uU'>
      <legend>solution</legend>
      <p>可以使用 <code>Object.keys</code> 获取所有可枚举的键，并输出其列表。</p>
<p>为了使 <code>toString</code> 不可枚举，我们使用一个属性描述器来定义它。<code>Object.create</code> 语法允许我们为一个对象提供属性描述器作为第二参数。</p>
<pre><code class="language-js">*!*
<span class="hljs-keyword">let</span> dictionary = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>, {
  <span class="hljs-attr">toString</span>: { <span class="hljs-comment">// 定义 toString 属性</span>
    <span class="hljs-function"><span class="hljs-title">value</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-comment">// value 是一个 function</span>
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">this</span>).join();
    }
  }
});
*/!*

dictionary.apple = <span class="hljs-string">&quot;Apple&quot;</span>;
dictionary.__proto__ = <span class="hljs-string">&quot;test&quot;</span>;

<span class="hljs-comment">// apple 和 __proto__ 在循环中</span>
<span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> dictionary</span>)</span> {
  alert(key); <span class="hljs-comment">// &quot;apple&quot;，然后是 &quot;__proto__&quot;</span>
}  

<span class="hljs-comment">// 通过 toString 处理获得的以逗号分隔的属性列表</span>
alert(dictionary); <span class="hljs-comment">// &quot;apple,__proto__&quot;</span></code></pre>
<p>当我们使用描述器创建一个属性，它的标识默认是 <code>false</code>。因此在上面这段代码中，<code>dictonary.toString</code> 是不可枚举的。</p>
<p>请阅读 <a href="info:property-descriptors"></a> 一章进行回顾。</p>

      </fieldset>
      
      <fieldset id='_BKRgwh'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="为-dictionary-添加-tostring-方法">为 dictionary 添加 toString 方法</h1>
<p>这儿有一个通过 <code>Object.create(null)</code> 创建的，用来存储任意 <code>key/value</code> 对的对象 <code>dictionary</code>。</p>
<p>为该对象添加 <code>dictionary.toString()</code> 方法，该方法应该返回以逗号分隔的所有键的列表。你的 <code>toString</code> 方法不应该在使用 <code>for...in</code> 循环遍历数组的时候显现出来。</p>
<p>它的工作方式如下：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> dictionary = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);

*!*
<span class="hljs-comment">// 你的添加 dictionary.toString 方法的代码</span>
*/!*

<span class="hljs-comment">// 添加一些数据</span>
dictionary.apple = <span class="hljs-string">&quot;Apple&quot;</span>;
dictionary.__proto__ = <span class="hljs-string">&quot;test&quot;</span>; <span class="hljs-comment">// 这里 __proto__ 是一个常规的属性键</span>

<span class="hljs-comment">// 在循环中只有 apple 和 __proto__</span>
<span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> dictionary</span>)</span> {
  alert(key); <span class="hljs-comment">// &quot;apple&quot;, then &quot;__proto__&quot;</span>
}  

<span class="hljs-comment">// 你的 toString 方法在发挥作用</span>
alert(dictionary); <span class="hljs-comment">// &quot;apple,__proto__&quot;</span></code></pre>

      </fieldset>
      
      <fieldset id='_8sTMoz'>
      <legend>solution</legend>
      <p>第一个调用中 <code>this == rabbit</code>，其他的 <code>this</code> 等同于 <code>Rabbit.prototype</code>，因为 <code>this</code> 就是点符号前面的对象。</p>
<p>所以，只有第一个调用显示 <code>Rabbit</code>，其他的都显示的是 <code>undefined</code>：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rabbit</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-built_in">this</span>.name = name;
}
Rabbit.prototype.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  alert( <span class="hljs-built_in">this</span>.name );
}

<span class="hljs-keyword">let</span> rabbit = <span class="hljs-keyword">new</span> Rabbit(<span class="hljs-string">&quot;Rabbit&quot;</span>);

rabbit.sayHi();                        <span class="hljs-comment">// Rabbit</span>
Rabbit.prototype.sayHi();              <span class="hljs-comment">// undefined</span>
<span class="hljs-built_in">Object</span>.getPrototypeOf(rabbit).sayHi(); <span class="hljs-comment">// undefined</span>
rabbit.__proto__.sayHi();              <span class="hljs-comment">// undefined</span></code></pre>

      </fieldset>
      
      <fieldset id='_K9gaZy'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="调用方式的差异">调用方式的差异</h1>
<p>让我们创建一个新的 <code>rabbit</code> 对象：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rabbit</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-built_in">this</span>.name = name;
}
Rabbit.prototype.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-built_in">this</span>.name);
};

<span class="hljs-keyword">let</span> rabbit = <span class="hljs-keyword">new</span> Rabbit(<span class="hljs-string">&quot;Rabbit&quot;</span>);</code></pre>
<p>以下调用做的是相同的事儿还是不同的？</p>
<pre><code class="language-js">rabbit.sayHi();
Rabbit.prototype.sayHi();
<span class="hljs-built_in">Object</span>.getPrototypeOf(rabbit).sayHi();
rabbit.__proto__.sayHi();</code></pre>

      </fieldset>
      
      <fieldset id='_RnjbGc'>
      <legend>article</legend>
      <h1 id="原型方法，没有-proto-的对象">原型方法，没有 <strong>proto</strong> 的对象</h1>
<p>在这部分内容的第一章中，我们提到了设置原型的现代方法。</p>
<p><code>__proto__</code> 被认为是过时且不推荐使用的（deprecated），这里的不推荐使用是指 JavaScript 规范中规定，<strong>proto</strong> 必须仅在浏览器环境下才能得到支持。</p>
<p>现代的方法有：</p>
<ul>
<li><a href="mdn:js/Object/create">Object.create(proto, [descriptors])</a> —— 利用给定的 <code>proto</code> 作为 <code>[[Prototype]]</code> 和可选的属性描述来创建一个空对象。</li>
<li><a href="mdn:js/Object/getPrototypeOf">Object.getPrototypeOf(obj)</a> —— 返回对象 <code>obj</code> 的 <code>[[Prototype]]</code>。</li>
<li><a href="mdn:js/Object/setPrototypeOf">Object.setPrototypeOf(obj, proto)</a> —— 将对象 <code>obj</code> 的 <code>[[Prototype]]</code> 设置为 <code>proto</code>。</li>
</ul>
<p>应该使用这些方法来代替 <code>__proto__</code>。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> animal = {
  <span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span>
};

<span class="hljs-comment">// 创建一个以 animal 为原型的新对象</span>
*!*
<span class="hljs-keyword">let</span> rabbit = <span class="hljs-built_in">Object</span>.create(animal);
*/!*

alert(rabbit.eats); <span class="hljs-comment">// true</span>

*!*
alert(<span class="hljs-built_in">Object</span>.getPrototypeOf(rabbit) === animal); <span class="hljs-comment">// true</span>
*/!*

*!*
<span class="hljs-built_in">Object</span>.setPrototypeOf(rabbit, {}); <span class="hljs-comment">// 将 rabbit 的原型修改为 {}</span>
*/!*</code></pre>
<p><code>Object.create</code> 有一个可选的第二参数：属性描述器。我们可以在此处为新对象提供额外的属性，就像这样：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> animal = {
  <span class="hljs-attr">eats</span>: <span class="hljs-literal">true</span>
};

<span class="hljs-keyword">let</span> rabbit = <span class="hljs-built_in">Object</span>.create(animal, {
  <span class="hljs-attr">jumps</span>: {
    <span class="hljs-attr">value</span>: <span class="hljs-literal">true</span>
  }
});

alert(rabbit.jumps); <span class="hljs-comment">// true</span></code></pre>
<p>描述器的格式与 <a href="info:property-descriptors">info:property-descriptors</a> 一章中所讲的一样。</p>
<p>我们可以使用 <code>Object.create</code> 来实现比复制 <code>for..in</code> 循环中的属性更强大的对象克隆方式：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> clone = <span class="hljs-built_in">Object</span>.create(<span class="hljs-built_in">Object</span>.getPrototypeOf(obj), <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(obj));</code></pre>
<p>此调用可以对 <code>obj</code> 进行真正准确地拷贝，包括所有的属性：可枚举和不可枚举的，数据属性和 setters/getters —— 包括所有内容，并带有正确的 <code>[[Prototype]]</code>。</p>
<h2 id="原型简史">原型简史</h2>
<p>如果我们数一下有多少种处理 <code>[[Prototype]]</code> 的方式，答案是有很多！很多种方法做的都是同一件事儿！</p>
<p>为什么会出现这种情况？</p>
<p>这是历史原因。</p>
<ul>
<li>构造函数的 <code>&quot;prototype&quot;</code> 属性自古以来就起作用。</li>
<li>之后，在 2012 年，<code>Object.create</code> 出现在标准中。它提供了使用给定原型创建对象的能力。但没有提供 get/set 它的能力。因此，许多浏览器厂商实现了非标准的 <code>__proto__</code> 访问器，该访问器允许用户随时 get/set 原型。</li>
<li>之后，在 2015 年，<code>Object.setPrototypeOf</code> 和 <code>Object.getPrototypeOf</code> 被加入到标准中，执行与 <code>__proto__</code> 相同的功能。由于 <code>__proto__</code> 实际上已经在所有地方都得到了实现，但它已过时，所以被加入到该标准的附件 B 中，即：在非浏览器环境下，它的支持是可选的。</li>
</ul>
<p>目前为止，我们拥有了所有这些方式。</p>
<p>为什么将 <code>__proto__</code> 替换成函数 <code>getPrototypeOf/setPrototypeOf</code>？这是一个有趣的问题，需要我们理解为什么 <code>__proto__</code> 不好。继续阅读，你就会知道答案。</p>
<p>```warn header=&quot;如果速度很重要，就请不要修改已存在的对象的 <code>[[Prototype]]</code>&quot;
从技术上来讲，我们可以在任何时候 get/set <code>[[Prototype]]</code>。但是通常我们只在创建对象的时候设置它一次，自那之后不再修改：<code>rabbit</code> 继承自 <code>animal</code>，之后不再更改。</p>
<p>并且，JavaScript 引擎对此进行了高度优化。用 <code>Object.setPrototypeOf</code> 或 <code>obj.__proto__=</code> “即时”更改原型是一个非常缓慢的操作，因为它破坏了对象属性访问操作的内部优化。因此，除非你知道自己在做什么，或者 JavaScript 的执行速度对你来说完全不重要，否则请避免使用它。</p>
<pre><code>
## &quot;Very plain&quot; objects [#very-plain]

我们知道，对象可以用作关联数组（associative arrays）来存储键/值对。

……但是如果我们尝试在其中存储 **用户提供的** 键（例如：一个用户输入的字典），我们可以发现一个有趣的小故障：所有的键都正常工作，除了 `&quot;__proto__&quot;`。

看一下这个例子：

```js run
let obj = {};

let key = prompt(&quot;What&#x27;s the key?&quot;, &quot;__proto__&quot;);
obj[key] = &quot;some value&quot;;

alert(obj[key]); // [object Object]，并不是 &quot;some value&quot;！</code></pre>
<p>这里如果用户输入 <code>__proto__</code>，那么赋值会被忽略！</p>
<p>我们不应该对此感到惊讶。<code>__proto__</code> 属性很特别：它必须是对象或者 <code>null</code>。字符串不能成为 prototype。</p>
<p>但是我们不是 <strong>打算</strong> 实现这种行为，对吧？我们想要存储键值对，然而键名为 <code>&quot;__proto__&quot;</code> 的键值对没有被正确存储。所以这是一个 bug。</p>
<p>在这里，后果并没有很严重。但是在其他情况下，我们可能会对对象进行赋值操作，然后原型可能就被更改了。结果，可能会导致完全意想不到的结果。</p>
<p>最可怕的是 —— 通常开发者完全不会考虑到这一点。这让此类 bug 很难被发现，甚至变成漏洞，尤其是在 JavaScript 被用在服务端的时候。</p>
<p>为默认情况下为函数的 <code>toString</code> 以及其他内建方法执行赋值操作，也会出现意想不到的结果。</p>
<p>我们怎么避免这样的问题呢？</p>
<p>首先，我们可以改用 <code>Map</code> 来代替普通对象进行存储，这样一切都迎刃而解。</p>
<p>但是 <code>Object</code> 在这里同样可以运行得很好，因为 JavaScript 语言的制造者很早就注意到了这个问题。</p>
<p><code>__proto__</code> 不是一个对象的属性，只是 <code>Object.prototype</code> 的访问器属性：</p>
<p><img src="object-prototype-2.svg" alt=""></p>
<p>因此，如果 <code>obj.__proto__</code> 被读取或者赋值，那么对应的 getter/setter 会被从它的原型中调用，它会 set/get <code>[[Prototype]]</code>。</p>
<p>就像在本部分教程的开头所说的那样：<code>__proto__</code> 是一种访问 <code>[[Prototype]]</code> 的方式，而不是 <code>[[prototype]]</code> 本身。</p>
<p>现在，我们想要将一个对象用作关联数组，并且摆脱此类问题，我们可以使用一些小技巧：</p>
<pre><code class="language-js">*!*
<span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);
*/!*

<span class="hljs-keyword">let</span> key = prompt(<span class="hljs-string">&quot;What&#x27;s the key?&quot;</span>, <span class="hljs-string">&quot;__proto__&quot;</span>);
obj[key] = <span class="hljs-string">&quot;some value&quot;</span>;

alert(obj[key]); <span class="hljs-comment">// &quot;some value&quot;</span></code></pre>
<p><code>Object.create(null)</code> 创建了一个空对象，这个对象没有原型（<code>[[Prototype]]</code> 是 <code>null</code>）：</p>
<p><img src="object-prototype-null.svg" alt=""></p>
<p>因此，它没有继承 <code>__proto__</code> 的 getter/setter 方法。现在，它被作为正常的数据属性进行处理，因此上面的这个示例能够正常工作。</p>
<p>我们可以把这样的对象称为 &quot;very plain&quot; 或 &quot;pure dictionary&quot; 对象，因为它们甚至比通常的普通对象（plain object）<code>{...}</code> 还要简单。</p>
<p>缺点是这样的对象没有任何内建的对象的方法，例如 <code>toString</code>：</p>
<pre><code class="language-js">*!*
<span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);
*/!*

alert(obj); <span class="hljs-comment">// Error (no toString)</span></code></pre>
<p>……但是它们通常对关联数组而言还是很友好。</p>
<p>请注意，大多数与对象相关的方法都是 <code>Object.something(...)</code>，例如 <code>Object.keys(obj)</code> —— 它们不在 prototype 中，因此在 &quot;very plain&quot; 对象中它们还是可以继续使用：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> chineseDictionary = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);
chineseDictionary.hello = <span class="hljs-string">&quot;你好&quot;</span>;
chineseDictionary.bye = <span class="hljs-string">&quot;再见&quot;</span>;

alert(<span class="hljs-built_in">Object</span>.keys(chineseDictionary)); <span class="hljs-comment">// hello,bye</span></code></pre>
<h2 id="总结">总结</h2>
<p>设置和直接访问原型的现代方法有：</p>
<ul>
<li><a href="mdn:js/Object/create">Object.create(proto, [descriptors])</a> —— 利用给定的 <code>proto</code> 作为 <code>[[Prototype]]</code>（可以是 <code>null</code>）和可选的属性描述来创建一个空对象。</li>
<li><a href="mdn:js/Object/getPrototypeOf">Object.getPrototypeOf(obj)</a> —— 返回对象 <code>obj</code> 的 <code>[[Prototype]]</code>（与 <code>__proto__</code> 的 getter 相同）。</li>
<li><a href="mdn:js/Object/setPrototypeOf">Object.setPrototypeOf(obj, proto)</a> —— 将对象 <code>obj</code> 的 <code>[[Prototype]]</code> 设置为 <code>proto</code>（与 <code>__proto__</code> 的 setter 相同）。</li>
</ul>
<p>如果要将一个用户生成的键放入一个对象，那么内建的 <code>__proto__</code> getter/setter 是不安全的。因为用户可能会输入 <code>&quot;__proto__&quot;</code> 作为键，这会导致一个 error，虽然我们希望这个问题不会造成什么大影响，但通常会造成不可预料的后果。</p>
<p>因此，我们可以使用 <code>Object.create(null)</code> 创建一个没有 <code>__proto__</code> 的 &quot;very plain&quot; 对象，或者对此类场景坚持使用 <code>Map</code> 对象就可以了。</p>
<p>此外，<code>Object.create</code> 提供了一种简单的方式来浅拷贝一个对象的所有描述符：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> clone = <span class="hljs-built_in">Object</span>.create(<span class="hljs-built_in">Object</span>.getPrototypeOf(obj), <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(obj));</code></pre>
<p>此外，我们还明确了 <code>__proto__</code> 是 <code>[[Prototype]]</code> 的 getter/setter，就像其他方法一样，它位于 <code>Object.prototype</code>。</p>
<p>我们可以通过 <code>Object.create(null)</code> 来创建没有原型的对象。这样的对象被用作 &quot;pure dictionaries&quot;，对于它们而言，使用 <code>&quot;__proto__&quot;</code> 作为键是没有问题的。</p>
<p>其他方法：</p>
<ul>
<li><a href="mdn:js/Object/keys">Object.keys(obj)</a> / <a href="mdn:js/Object/values">Object.values(obj)</a> / <a href="mdn:js/Object/entries">Object.entries(obj)</a> —— 返回一个可枚举的由自身的字符串属性名/值/键值对组成的数组。</li>
<li><a href="mdn:js/Object/getOwnPropertySymbols">Object.getOwnPropertySymbols(obj)</a> —— 返回一个由自身所有的 symbol 类型的键组成的数组。</li>
<li><a href="mdn:js/Object/getOwnPropertyNames">Object.getOwnPropertyNames(obj)</a> —— 返回一个由自身所有的字符串键组成的数组。</li>
<li><a href="mdn:js/Reflect/ownKeys">Reflect.ownKeys(obj)</a> —— 返回一个由自身所有键组成的数组。</li>
<li><a href="mdn:js/Object/hasOwnProperty">obj.hasOwnProperty(key)</a>：如果 <code>obj</code> 拥有名为 <code>key</code> 的自身的属性（非继承而来的），则返回 <code>true</code>。</li>
</ul>
<p>所有返回对象属性的方法（如 <code>Object.keys</code> 及其他）—— 都返回“自身”的属性。如果我们想继承它们，我们可以使用 <code>for...in</code>。</p>

      </fieldset>
      
      <fieldset id='_AG2vth'>
      <legend>solution</legend>
      
      </fieldset>
      
      <fieldset id='_iBSr6I'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="重写为-class">重写为 class</h1>
<p><code>Clock</code> 类是以函数式编写的。请以 &quot;class&quot; 语法重写它。</p>
<p>P.S. 时钟在控制台（console）中滴答，打开控制台即可查看。</p>

      </fieldset>
      
      <fieldset id='_YA8FON'>
      <legend>article</legend>
      <h1 id="class-基本语法">Class 基本语法</h1>
<pre><code class="language-quote">在面向对象的编程中，*class* 是用于创建对象的可扩展的程序代码模版，它为对象提供了状态（成员变量）的初始值和行为（成员函数或方法）的实现。</code></pre>
<p>在日常开发中，我们经常需要创建许多相同类型的对象，例如用户（users）、商品（goods）或者任何其他东西。</p>
<p>正如我们在 <a href="info:constructor-new">info:constructor-new</a> 一章中已经学到的，<code>new function</code> 可以帮助我们实现这种需求。</p>
<p>但在现代 JavaScript 中，还有一个更高级的“类（class）”构造方式，它引入许多非常棒的新功能，这些功能对于面向对象编程很有用。</p>
<h2 id="class-语法">&quot;class&quot; 语法</h2>
<p>基本语法是：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
  <span class="hljs-comment">// class 方法</span>
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> { ... }
  <span class="hljs-function"><span class="hljs-title">method1</span>(<span class="hljs-params"></span>)</span> { ... }
  <span class="hljs-function"><span class="hljs-title">method2</span>(<span class="hljs-params"></span>)</span> { ... }
  <span class="hljs-function"><span class="hljs-title">method3</span>(<span class="hljs-params"></span>)</span> { ... }
  ...
}</code></pre>
<p>然后使用 <code>new MyClass()</code> 来创建具有上述列出的所有方法的新对象。</p>
<p><code>new</code> 会自动调用 <code>constructor()</code> 方法，因此我们可以在 <code>constructor()</code> 中初始化对象。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{

  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> {
    <span class="hljs-built_in">this</span>.name = name;
  }

  <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> {
    alert(<span class="hljs-built_in">this</span>.name);
  }

}

<span class="hljs-comment">// 用法：</span>
<span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;John&quot;</span>);
user.sayHi();</code></pre>
<p>当 <code>new User(&quot;John&quot;)</code> 被调用：</p>
<ol>
<li>一个新对象被创建。</li>
<li><code>constructor</code> 使用给定的参数运行，并为其分配 <code>this.name</code>。</li>
</ol>
<p>……然后我们就可以调用对象方法了，例如 <code>user.sayHi</code>。</p>
<pre><code class="language-warn">对于新手开发人员来说，常见的陷阱是在类的方法之间放置逗号，这会导致语法错误。

不要把这里的符号与对象字面量相混淆。在类中，不需要逗号。</code></pre>
<h2 id="什么是-class？">什么是 class？</h2>
<p>所以，<code>class</code> 到底是什么？正如人们可能认为的那样，这不是一个全新的语言级实体。</p>
<p>让我们揭开其神秘面纱，看看类究竟是什么。这将有助于我们理解许多复杂的方面。</p>
<p>在 JavaScript 中，类是一种函数。</p>
<p>看看下面这段代码：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> { <span class="hljs-built_in">this</span>.name = name; }
  <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> { alert(<span class="hljs-built_in">this</span>.name); }
}

<span class="hljs-comment">// 佐证：User 是一个函数</span>
*!*
alert(<span class="hljs-keyword">typeof</span> User); <span class="hljs-comment">// function</span>
*/!*</code></pre>
<p><code>class User {...}</code> 构造实际上做了如下的事儿：</p>
<ol>
<li>创建一个名为 <code>User</code> 的函数，该函数成为类声明的结果。该函数的代码来自于 <code>constructor</code> 方法（如果我们不编写这种方法，那么它就被假定为空）。</li>
<li>存储类中的方法，例如 <code>User.prototype</code> 中的 <code>sayHi</code>。</li>
</ol>
<p>当 <code>new User</code> 对象被创建后，当我们调用其方法时，它会从原型中获取对应的方法，正如我们在 <a href="info:function-prototype">info:function-prototype</a> 一章中所讲的那样。因此，对象 <code>new User</code> 可以访问类中的方法。</p>
<p>我们可以将 <code>class User</code> 声明的结果解释为：</p>
<p><img src="class-user.svg" alt=""></p>
<p>下面这些代码很好地解释了它们：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> { <span class="hljs-built_in">this</span>.name = name; }
  <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> { alert(<span class="hljs-built_in">this</span>.name); }
}

<span class="hljs-comment">// class 是一个函数</span>
alert(<span class="hljs-keyword">typeof</span> User); <span class="hljs-comment">// function</span>

<span class="hljs-comment">// ...或者，更确切地说，是 constructor 方法</span>
alert(User === User.prototype.constructor); <span class="hljs-comment">// true</span>

<span class="hljs-comment">// 方法在 User.prototype 中，例如：</span>
alert(User.prototype.sayHi); <span class="hljs-comment">// alert(this.name);</span>

<span class="hljs-comment">// 在原型中实际上有两个方法</span>
alert(<span class="hljs-built_in">Object</span>.getOwnPropertyNames(User.prototype)); <span class="hljs-comment">// constructor, sayHi</span></code></pre>
<h2 id="不仅仅是语法糖">不仅仅是语法糖</h2>
<p>人们常说 <code>class</code> 是一个语法糖（旨在使内容更易阅读，但不引入任何新内容的语法），因为我们实际上可以在没有 <code>class</code> 的情况下声明相同的内容：</p>
<pre><code class="language-js"><span class="hljs-comment">// 用纯函数重写 class User</span>

<span class="hljs-comment">// 1. 创建构造器函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-built_in">this</span>.name = name;
}
<span class="hljs-comment">// 函数的原型（prototype）默认具有 &quot;constructor&quot; 属性，</span>
<span class="hljs-comment">// 所以，我们不需要创建它</span>

<span class="hljs-comment">// 2. 将方法添加到原型</span>
User.prototype.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-built_in">this</span>.name);
};

<span class="hljs-comment">// 用法：</span>
<span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;John&quot;</span>);
user.sayHi();</code></pre>
<p>这个定义的结果与使用类得到的结果基本相同。因此，这确实是将 <code>class</code> 视为一种定义构造器及其原型方法的语法糖的理由。</p>
<p>尽管，它们之间存在着重大差异：</p>
<ol>
<li><p>首先，通过 <code>class</code> 创建的函数具有特殊的内部属性标记 <code>[[FunctionKind]]:&quot;classConstructor&quot;</code>。因此，它与手动创建并不完全相同。</p>
<p> 编程语言会在许多地方检查该属性。例如，与普通函数不同，必须使用 <code>new</code> 来调用它：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {}
}

alert(<span class="hljs-keyword">typeof</span> User); <span class="hljs-comment">// function</span>
User(); <span class="hljs-comment">// Error: Class constructor User cannot be invoked without &#x27;new&#x27;</span></code></pre>
<p> 此外，大多数 JavaScript 引擎中的类构造器的字符串表示形式都以 &quot;class...&quot; 开头</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {}
}

alert(User); <span class="hljs-comment">// class User { ... }</span></code></pre>
<p> 还有其他的不同之处，我们很快就会看到。</p>
</li>
<li><p>类方法不可枚举。
 类定义将 <code>&quot;prototype&quot;</code> 中的所有方法的 <code>enumerable</code> 标志设置为 <code>false</code>。</p>
<p> 这很好，因为如果我们对一个对象调用 <code>for..in</code> 方法，我们通常不希望 class 方法出现。</p>
</li>
<li><p>类总是使用 <code>use strict</code>。
 在类构造中的所有代码都将自动进入严格模式。</p>
</li>
</ol>
<p>此外，<code>class</code> 语法还带来了许多其他功能，我们稍后将会探索它们。</p>
<h2 id="类表达式">类表达式</h2>
<p>就像函数一样，类可以在另外一个表达式中被定义，被传递，被返回，被赋值等。</p>
<p>这是一个类表达式的例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> User = <span class="hljs-class"><span class="hljs-keyword">class</span> </span>{
  <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> {
    alert(<span class="hljs-string">&quot;Hello&quot;</span>);
  }
};</code></pre>
<p>类似于命名函数表达式（Named Function Expressions），类表达式可能也应该有一个名字。</p>
<p>如果类表达式有名字，那么该名字仅在类内部可见：</p>
<pre><code class="language-js"><span class="hljs-comment">// “命名类表达式（Named Class Expression）”</span>
<span class="hljs-comment">// (规范中没有这样的术语，但是它和命名函数表达式类似)</span>
<span class="hljs-keyword">let</span> User = <span class="hljs-class"><span class="hljs-keyword">class</span> *!*<span class="hljs-title">MyClass</span>*/!* </span>{
  <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> {
    alert(MyClass); <span class="hljs-comment">// MyClass 这个名字仅在类内部可见</span>
  }
};

<span class="hljs-keyword">new</span> User().sayHi(); <span class="hljs-comment">// 正常运行，显示 MyClass 中定义的内容</span>

alert(MyClass); <span class="hljs-comment">// error，MyClass 在外部不可见</span></code></pre>
<p>我们甚至可以动态地“按需”创建类，就像这样：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeClass</span>(<span class="hljs-params">phrase</span>) </span>{
  <span class="hljs-comment">// 声明一个类并返回它</span>
  <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> </span>{
    <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> {
      alert(phrase);
    };
  };
}

<span class="hljs-comment">// 创建一个新的类</span>
<span class="hljs-keyword">let</span> User = makeClass(<span class="hljs-string">&quot;Hello&quot;</span>);

<span class="hljs-keyword">new</span> User().sayHi(); <span class="hljs-comment">// Hello</span></code></pre>
<h2 id="getterssetters">Getters/setters</h2>
<p>就像对象字面量，类可能包括 getters/setters，计算属性（computed properties）等。</p>
<p>这是一个使用 <code>get/set</code> 实现 <code>user.name</code> 的示例：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{

  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> {
    <span class="hljs-comment">// 调用 setter</span>
    <span class="hljs-built_in">this</span>.name = name;
  }

*!*
  <span class="hljs-keyword">get</span> <span class="hljs-title">name</span>() {
*/!*
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._name;
  }

*!*
  <span class="hljs-keyword">set</span> <span class="hljs-title">name</span>(<span class="hljs-params">value</span>) {
*/!*
    <span class="hljs-keyword">if</span> (value.length &lt; <span class="hljs-number">4</span>) {
      alert(<span class="hljs-string">&quot;Name is too short.&quot;</span>);
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-built_in">this</span>._name = value;
  }

}

<span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;John&quot;</span>);
alert(user.name); <span class="hljs-comment">// John</span>

user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// Name is too short.</span></code></pre>
<p>从技术上来讲，这样的类声明可以通过在 <code>User.prototype</code> 中创建 getters 和 setters 来实现。</p>
<h2 id="计算属性名称-">计算属性名称 [...]</h2>
<p>这里有一个使用中括号 <code>[...]</code> 的计算方法名称示例：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{

*!*
  [<span class="hljs-string">&#x27;say&#x27;</span> + <span class="hljs-string">&#x27;Hi&#x27;</span>]() {
*/!*
    alert(<span class="hljs-string">&quot;Hello&quot;</span>);
  }

}

<span class="hljs-keyword">new</span> User().sayHi();</code></pre>
<p>这种特性很容易记住，因为它们和对象字面量类似。</p>
<h2 id="class-字段">Class 字段</h2>
<pre><code class="language-warn">类字段（field）是最近才添加到语言中的。</code></pre>
<p>之前，我们的类仅具有方法。</p>
<p>“类字段”是一种允许添加任何属性的语法。</p>
<p>例如，让我们在 <code>class User</code> 中添加一个 <code>name</code> 属性：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
*!*
  name = <span class="hljs-string">&quot;John&quot;</span>;
*/!*

  <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> {
    alert(<span class="hljs-string">`Hello, <span class="hljs-subst">${<span class="hljs-built_in">this</span>.name}</span>!`</span>);
  }
}

<span class="hljs-keyword">new</span> User().sayHi(); <span class="hljs-comment">// Hello, John!</span></code></pre>
<p>所以，我们就只需在表达式中写 &quot;<property name> = <value>&quot;，就这样。</p>
<p>类字段重要的不同之处在于，它们会在每个独立对象中被设好，而不是设在 <code>User.prototype</code>：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
*!*
  name = <span class="hljs-string">&quot;John&quot;</span>;
*/!*
}

<span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> User();
alert(user.name); <span class="hljs-comment">// John</span>
alert(User.prototype.name); <span class="hljs-comment">// undefined</span></code></pre>
<p>我们也可以在赋值时使用更复杂的表达式和函数调用：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
*!*
  name = prompt(<span class="hljs-string">&quot;Name, please?&quot;</span>, <span class="hljs-string">&quot;John&quot;</span>);
*/!*
}

<span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> User();
alert(user.name); <span class="hljs-comment">// John</span></code></pre>
<h3 id="使用类字段制作绑定方法">使用类字段制作绑定方法</h3>
<p>正如 <a href="info:bind">info:bind</a> 一章中所讲的，JavaScript 中的函数具有动态的 <code>this</code>。它取决于调用上下文。</p>
<p>因此，如果一个对象方法被传递到某处，或者在另一个上下文中被调用，则 <code>this</code> 将不再是对其对象的引用。</p>
<p>例如，此代码将显示 <code>undefined</code>：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Button</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">value</span>)</span> {
    <span class="hljs-built_in">this</span>.value = value;
  }

  <span class="hljs-function"><span class="hljs-title">click</span>(<span class="hljs-params"></span>)</span> {
    alert(<span class="hljs-built_in">this</span>.value);
  }
}

<span class="hljs-keyword">let</span> button = <span class="hljs-keyword">new</span> Button(<span class="hljs-string">&quot;hello&quot;</span>);

*!*
<span class="hljs-built_in">setTimeout</span>(button.click, <span class="hljs-number">1000</span>); <span class="hljs-comment">// undefined</span>
*/!*</code></pre>
<p>这个问题被称为“丢失 <code>this</code>”。</p>
<p>我们在 <a href="info:bind">info:bind</a> 一章中讲过，有两种可以修复它的方式：</p>
<ol>
<li>传递一个包装函数，例如 <code>setTimeout(() =&gt; button.click(), 1000)</code>。</li>
<li>将方法绑定到对象，例如在 constructor 中。</li>
</ol>
<p>类字段提供了另一种非常优雅的语法：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Button</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">value</span>)</span> {
    <span class="hljs-built_in">this</span>.value = value;
  }
*!*
  click = <span class="hljs-function">() =&gt;</span> {
    alert(<span class="hljs-built_in">this</span>.value);
  }
*/!*
}

<span class="hljs-keyword">let</span> button = <span class="hljs-keyword">new</span> Button(<span class="hljs-string">&quot;hello&quot;</span>);

<span class="hljs-built_in">setTimeout</span>(button.click, <span class="hljs-number">1000</span>); <span class="hljs-comment">// hello</span></code></pre>
<p>类字段 <code>click = () =&gt; {...}</code> 是基于每一个对象被创建的，在这里对于每一个 <code>Button</code> 对象都有一个独立的方法，在内部都有一个指向此对象的 <code>this</code>。我们可以把 <code>button.click</code> 传递到任何地方，而且 <code>this</code> 的值总是正确的。</p>
<p>在浏览器环境中，它对于进行事件监听尤为有用。</p>
<h2 id="总结">总结</h2>
<p>基本的类语法看起来像这样：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
  prop = value; <span class="hljs-comment">// 属性</span>

  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">...</span>)</span> { <span class="hljs-comment">// 构造器</span>
    <span class="hljs-comment">// ...</span>
  }

  <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params">...</span>)</span> {} <span class="hljs-comment">// method</span>

  <span class="hljs-keyword">get</span> <span class="hljs-title">something</span>(<span class="hljs-params">...</span>) {} <span class="hljs-comment">// getter 方法</span>
  <span class="hljs-keyword">set</span> <span class="hljs-title">something</span>(<span class="hljs-params">...</span>) {} <span class="hljs-comment">// setter 方法 </span>

  [<span class="hljs-built_in">Symbol</span>.iterator]() {} <span class="hljs-comment">// 有计算名称（computed name）的方法（此处为 symbol）</span>
  <span class="hljs-comment">// ...</span>
}</code></pre>
<p>技术上来说，<code>MyClass</code> 是一个函数（我们提供作为 <code>constructor</code> 的那个），而 methods、getters 和 settors 都被写入了 <code>MyClass.prototype</code>。</p>
<p>在下一章，我们将会进一步学习类的相关知识，包括继承和其他功能。</p>

      </fieldset>
      
      <fieldset id='_KQ255E'>
      <legend>solution</legend>
      <p>这是因为子类的 constructor 必须调用 <code>super()</code>。</p>
<p>这里是修正后的代码：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{

  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> {
    <span class="hljs-built_in">this</span>.name = name;
  }

}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rabbit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> {  
    *!*
    <span class="hljs-built_in">super</span>(name);
    */!*
    <span class="hljs-built_in">this</span>.created = <span class="hljs-built_in">Date</span>.now();
  }
}

*!*
<span class="hljs-keyword">let</span> rabbit = <span class="hljs-keyword">new</span> Rabbit(<span class="hljs-string">&quot;White Rabbit&quot;</span>); <span class="hljs-comment">// 现在好了</span>
*/!*
alert(rabbit.name); <span class="hljs-comment">// White Rabbit</span></code></pre>

      </fieldset>
      
      <fieldset id='_xHytE5'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="创建实例时出错">创建实例时出错</h1>
<p>这里有一份 <code>Rabbit</code> 扩展 <code>Animal</code> 的代码。</p>
<p>不幸的是，<code>Rabbit</code> 对象无法被创建。是哪里出错了呢？请解决它。</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{

  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> {
    <span class="hljs-built_in">this</span>.name = name;
  }

}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rabbit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> {  
    <span class="hljs-built_in">this</span>.name = name;
    <span class="hljs-built_in">this</span>.created = <span class="hljs-built_in">Date</span>.now();
  }
}

*!*
<span class="hljs-keyword">let</span> rabbit = <span class="hljs-keyword">new</span> Rabbit(<span class="hljs-string">&quot;White Rabbit&quot;</span>); <span class="hljs-comment">// Error: this is not defined</span>
*/!*
alert(rabbit.name);</code></pre>

      </fieldset>
      
      <fieldset id='_7iD6Q2'>
      <legend>solution</legend>
      <p>[js src=&quot;solution.view/extended-clock.js&quot;]</p>

      </fieldset>
      
      <fieldset id='_ZUfuNE'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="扩展-clock">扩展 clock</h1>
<p>我们获得了一个 <code>Clock</code> 类。到目前为止，它每秒都会打印一次时间。</p>
<p>[js src=&quot;source.view/clock.js&quot;]</p>
<p>创建一个继承自 <code>Clock</code> 的新的类 <code>ExtendedClock</code>，并添加参数 <code>precision</code> — 每次 &quot;ticks&quot; 之间间隔的毫秒数，默认是 <code>1000</code>（1 秒）。</p>
<ul>
<li>你的代码应该在 <code>extended-clock.js</code> 文件里。</li>
<li>不要修改原有的 <code>clock.js</code>。请扩展它。</li>
</ul>

      </fieldset>
      
      <fieldset id='_GR6Q9o'>
      <legend>article</legend>
      <h1 id="类继承">类继承</h1>
<p>类继承是一个类扩展另一个类的一种方式。</p>
<p>因此，我们可以在现有功能之上创建新功能。</p>
<h2 id="extends-关键字">&quot;extends&quot; 关键字</h2>
<p>假设我们有 class <code>Animal</code>：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> {
    <span class="hljs-built_in">this</span>.speed = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">this</span>.name = name;
  }
  <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params">speed</span>)</span> {
    <span class="hljs-built_in">this</span>.speed = speed;
    alert(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">this</span>.name}</span> runs with speed <span class="hljs-subst">${<span class="hljs-built_in">this</span>.speed}</span>.`</span>);
  }
  <span class="hljs-function"><span class="hljs-title">stop</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-built_in">this</span>.speed = <span class="hljs-number">0</span>;
    alert(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">this</span>.name}</span> stands still.`</span>);
  }
}

<span class="hljs-keyword">let</span> animal = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&quot;My animal&quot;</span>);</code></pre>
<p>这是我们对对象 <code>animal</code> 和 class <code>Animal</code> 的图形化表示：</p>
<p><img src="rabbit-animal-independent-animal.svg" alt=""></p>
<p>……然后我们想创建另一个 <code>class Rabbit</code>：</p>
<p>因为 rabbits 是 animals，所以 class <code>Rabbit</code> 应该是基于 class <code>Animal</code> 的，可以访问 animal 的方法，以便 rabbits 可以做“一般”动物可以做的事儿。</p>
<p>扩展另一个类的语法是：<code>class Child extends Parent</code>。</p>
<p>让我们创建一个继承自 <code>Animal</code> 的 <code>class Rabbit</code>：</p>
<pre><code class="language-js">*!*
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rabbit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>{
*/!*
  <span class="hljs-function"><span class="hljs-title">hide</span>(<span class="hljs-params"></span>)</span> {
    alert(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">this</span>.name}</span> hides!`</span>);
  }
}

<span class="hljs-keyword">let</span> rabbit = <span class="hljs-keyword">new</span> Rabbit(<span class="hljs-string">&quot;White Rabbit&quot;</span>);

rabbit.run(<span class="hljs-number">5</span>); <span class="hljs-comment">// White Rabbit runs with speed 5.</span>
rabbit.hide(); <span class="hljs-comment">// White Rabbit hides!</span></code></pre>
<p>Class <code>Rabbit</code> 的对象可以访问例如 <code>rabbit.hide()</code> 等 <code>Rabbit</code> 的方法，还可以访问例如 <code>rabbit.run()</code> 等 <code>Animal</code> 的方法。</p>
<p>在内部，关键字 <code>extends</code> 使用了很好的旧的原型机制进行工作。它将 <code>Rabbit.prototype.[[Prototype]]</code> 设置为 <code>Animal.prototype</code>。所以，如果在 <code>Rabbit.prototype</code> 中找不到一个方法，JavaScript 就会从 <code>Animal.prototype</code> 中获取该方法。</p>
<p><img src="animal-rabbit-extends.svg" alt=""></p>
<p>例如，要查找 <code>rabbit.run</code> 方法，JavaScript 引擎会进行如下检查（如图所示从下到上）：</p>
<ol>
<li>查找对象 <code>rabbit</code>（没有 <code>run</code>）。</li>
<li>查找它的原型，即 <code>Rabbit.prototype</code>（有 <code>hide</code>，但没有 <code>run</code>）。</li>
<li>查找它的原型，即（由于 <code>extends</code>）<code>Animal.prototype</code>，在这儿找到了 <code>run</code> 方法。</li>
</ol>
<p>我们可以回忆一下 <a href="info:native-prototypes">info:native-prototypes</a> 这一章的内容，JavaScript 内建对象同样也使用原型继承。例如，<code>Date.prototype.[[Prototype]]</code> 是 <code>Object.prototype</code>。这就是为什么日期可以访问通用对象的方法。</p>
<p>````smart header=&quot;在 <code>extends</code> 后允许任意表达式&quot;
类语法不仅允许指定一个类，在 <code>extends</code> 后可以指定任意表达式。</p>
<p>例如，一个生成父类的函数调用：</p>
<pre><code class="language-js">function f(phrase) {
  return class {
    sayHi() { alert(phrase) }
  }
}

*!*
class User extends f(&quot;Hello&quot;) {}
*/!*

new User().sayHi(); // Hello</code></pre>
<p>这里 <code>class User</code> 继承自 <code>f(&quot;Hello&quot;)</code> 的结果。</p>
<p>这对于高级编程模式，例如当我们根据许多条件使用函数生成类，并继承它们时来说可能很有用。</p>
<pre><code>
## 重写方法

现在，让我们继续前行并尝试重写一个方法。默认情况下，所有未在 `class Rabbit` 中指定的方法均从 `class Animal` 中直接获取。

但是如果我们在 `Rabbit` 中指定了我们自己的方法，例如 `stop()`，那么将会使用它：

```js
class Rabbit extends Animal {
  stop() {
    // ……现在这个将会被用作 rabbit.stop()
    // 而不是来自于 class Animal 的 stop()
  }
}
```

但是通常来说，我们不希望完全替换父类的方法，而是希望在父类方法的基础上进行调整或扩展其功能。我们在我们的方法中做一些事儿，但是在它之前或之后或在过程中会调用父类方法。

Class 为此提供了 `&quot;super&quot;` 关键字。

- 执行 `super.method(...)` 来调用一个父类方法。
- 执行 `super(...)` 来调用一个父类 constructor（只能在我们的 constructor 中）。

例如，让我们的 rabbit 在停下来的时候自动 hide：

```js run
class Animal {

  constructor(name) {
    this.speed = 0;
    this.name = name;
  }

  run(speed) {
    this.speed = speed;
    alert(`${this.name} runs with speed ${this.speed}.`);
  }

  stop() {
    this.speed = 0;
    alert(`${this.name} stands still.`);
  }

}

class Rabbit extends Animal {
  hide() {
    alert(`${this.name} hides!`);
  }

*!*
  stop() {
    super.stop(); // 调用父类的 stop
    this.hide(); // 然后 hide
  }
*/!*
}

let rabbit = new Rabbit(&quot;White Rabbit&quot;);

rabbit.run(5); // White Rabbit 以速度 5 奔跑
rabbit.stop(); // White Rabbit 停止了。White rabbit hide 了！
```

现在，`Rabbit` 在执行过程中调用父类的 `super.stop()` 方法，所以 `Rabbit` 也具有了 `stop` 方法。

````smart header=&quot;箭头函数没有 `super`&quot;
正如我们在 &lt;info:arrow-functions&gt; 一章中所提到的，箭头函数没有 `super`。

如果被访问，它会从外部函数获取。例如：
```js
class Rabbit extends Animal {
  stop() {
    setTimeout(() =&gt; super.stop(), 1000); // 1 秒后调用父类的 stop
  }
}
```

箭头函数中的 `super` 与 `stop()` 中的是一样的，所以它能按预期工作。如果我们在这里指定一个“普通”函数，那么将会抛出错误：

```js
// 意料之外的 super
setTimeout(function() { super.stop() }, 1000);
```</code></pre>
<h2 id="重写-constructor">重写 constructor</h2>
<p>对于重写 constructor 来说，则有点棘手。</p>
<p>到目前为止，<code>Rabbit</code> 还没有自己的 <code>constructor</code>。</p>
<p>根据 <a href="https://tc39.github.io/ecma262/#sec-runtime-semantics-classdefinitionevaluation">规范</a>，如果一个类扩展了另一个类并且没有 <code>constructor</code>，那么将生成下面这样的“空” <code>constructor</code>：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rabbit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-comment">// 为没有自己的 constructor 的扩展类生成的</span>
*!*
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">...args</span>)</span> {
    <span class="hljs-built_in">super</span>(...args);
  }
*/!*
}</code></pre>
<p>正如我们所看到的，它调用了父类的 <code>constructor</code>，并传递了所有的参数。如果我们没有写自己的 constructor，就会出现这种情况。</p>
<p>现在，我们给 <code>Rabbit</code> 添加一个自定义的 constructor。除了 <code>name</code> 之外，它还会指定 <code>earLength</code>。</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> {
    <span class="hljs-built_in">this</span>.speed = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">this</span>.name = name;
  }
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rabbit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>{

*!*
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, earLength</span>)</span> {
    <span class="hljs-built_in">this</span>.speed = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">this</span>.name = name;
    <span class="hljs-built_in">this</span>.earLength = earLength;
  }
*/!*

  <span class="hljs-comment">// ...</span>
}

*!*
<span class="hljs-comment">// 不工作！</span>
<span class="hljs-keyword">let</span> rabbit = <span class="hljs-keyword">new</span> Rabbit(<span class="hljs-string">&quot;White Rabbit&quot;</span>, <span class="hljs-number">10</span>); <span class="hljs-comment">// Error: this is not defined.</span>
*/!*</code></pre>
<p>哎呦！我们得到了一个报错。现在我们没法新建 rabbit。是什么地方出错了？</p>
<p>简短的解释是：</p>
<p><strong>继承类的 constructor 必须调用 <code>super(...)</code>，并且 (!) 一定要在使用 <code>this</code> 之前调用。</strong></p>
<p>……但这是为什么呢？这里发生了什么？确实，这个要求看起来很奇怪。</p>
<p>当然，本文会给出一个解释。让我们深入细节，这样你就可以真正地理解发生了什么。</p>
<p>在 JavaScript 中，继承类（所谓的“派生构造器”，英文为 &quot;derived constructor&quot;）的构造函数与其他函数之间是有区别的。派生构造器具有特殊的内部属性 <code>[[ConstructorKind]]:&quot;derived&quot;</code>。这是一个特殊的内部标签。</p>
<p>该标签会影响它的 <code>new</code> 行为：</p>
<ul>
<li>当通过 <code>new</code> 执行一个常规函数时，它将创建一个空对象，并将这个空对象赋值给 <code>this</code>。</li>
<li>但是当继承的 constructor 执行时，它不会执行此操作。它期望父类的 constructor 来完成这项工作。</li>
</ul>
<p>因此，派生的 constructor 必须调用 <code>super</code> 才能执行其父类（base）的 constructor，否则 <code>this</code> 指向的那个对象将不会被创建。并且我们会收到一个报错。</p>
<p>为了让 <code>Rabbit</code> 的 constructor 可以工作，它需要在使用 <code>this</code> 之前调用 <code>super()</code>，就像下面这样：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{

  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> {
    <span class="hljs-built_in">this</span>.speed = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">this</span>.name = name;
  }

  <span class="hljs-comment">// ...</span>
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rabbit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>{

  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, earLength</span>)</span> {
*!*
    <span class="hljs-built_in">super</span>(name);
*/!*
    <span class="hljs-built_in">this</span>.earLength = earLength;
  }

  <span class="hljs-comment">// ...</span>
}

*!*
<span class="hljs-comment">// 现在可以了</span>
<span class="hljs-keyword">let</span> rabbit = <span class="hljs-keyword">new</span> Rabbit(<span class="hljs-string">&quot;White Rabbit&quot;</span>, <span class="hljs-number">10</span>);
alert(rabbit.name); <span class="hljs-comment">// White Rabbit</span>
alert(rabbit.earLength); <span class="hljs-comment">// 10</span>
*/!*</code></pre>
<h3 id="重写类字段-一个棘手的注意要点">重写类字段: 一个棘手的注意要点</h3>
<pre><code class="language-warn">这个要点假设你对类已经有了一定的经验，或许是在其他编程语言中。

这里提供了一个更好的视角来窥探这门语言，且解释了它的行为为什么可能会是 bugs 的来源(但不是非常频繁)。

如果你发现这难以理解，什么都别管，继续往下阅读，之后有机会再回来看。</code></pre>
<p>我们不仅可以重写方法，还可以重写类字段。</p>
<p>不过，当我们访问在父类构造器中的一个被重写的字段时，这里会有一个诡异的行为，这与绝大多数其他编程语言都很不一样。</p>
<p>请思考此示例：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{
  name = <span class="hljs-string">&#x27;animal&#x27;</span>

  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {
    alert(<span class="hljs-built_in">this</span>.name); <span class="hljs-comment">// (*)</span>
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rabbit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>{
  name = <span class="hljs-string">&#x27;rabbit&#x27;</span>;
}

<span class="hljs-keyword">new</span> Animal(); <span class="hljs-comment">// animal</span>
*!*
<span class="hljs-keyword">new</span> Rabbit(); <span class="hljs-comment">// animal</span>
*/!*</code></pre>
<p>这里，<code>Rabbit</code> 继承自 <code>Animal</code>，并且用它自己的值重写了 <code>name</code> 字段。</p>
<p>因为 <code>Rabbit</code> 中没有自己的构造器，所以 <code>Animal</code> 的构造器被调用了。</p>
<p>有趣的是在这两种情况下：<code>new Animal()</code> 和 <code>new Rabbit()</code>，在 <code>(*)</code> 行的 <code>alert</code> 都打印了 <code>animal</code>。</p>
<p><strong>换句话说， 父类构造器总是会使用它自己字段的值，而不是被重写的那一个。</strong></p>
<p>古怪的是什么呢？</p>
<p>如果这还不清楚，那么让我们用方法来进行比较。</p>
<p>这里是相同的代码，但是我们调用 <code>this.showName()</code> 方法而不是 <code>this.name</code> 字段：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-function"><span class="hljs-title">showName</span>(<span class="hljs-params"></span>)</span> {  <span class="hljs-comment">// 而不是 this.name = &#x27;animal&#x27;</span>
    alert(<span class="hljs-string">&#x27;animal&#x27;</span>);
  }

  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-built_in">this</span>.showName(); <span class="hljs-comment">// 而不是 alert(this.name);</span>
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rabbit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-function"><span class="hljs-title">showName</span>(<span class="hljs-params"></span>)</span> {
    alert(<span class="hljs-string">&#x27;rabbit&#x27;</span>);
  }
}

<span class="hljs-keyword">new</span> Animal(); <span class="hljs-comment">// animal</span>
*!*
<span class="hljs-keyword">new</span> Rabbit(); <span class="hljs-comment">// rabbit</span>
*/!*</code></pre>
<p>请注意：这时的输出是不同的。</p>
<p>这才是我们本来所期待的结果。当父类构造器在派生的类中被调用时，它会使用被重写的方法。</p>
<p>……但对于类字段并非如此。正如前文所述，父类构造器总是使用父类的字段。</p>
<p>这里为什么会有这样的区别呢？</p>
<p>实际上，原因在于字段初始化的顺序。类字段是这样初始化的：</p>
<ul>
<li>对于基类（还未继承任何东西的那种），在构造函数调用前初始化。</li>
<li>对于派生类，在 <code>super()</code> 后立刻初始化。</li>
</ul>
<p>在我们的例子中，<code>Rabbit</code> 是派生类，里面没有 <code>constructor()</code>。正如先前所说，这相当于一个里面只有 <code>super(...args)</code> 的空构造器。</p>
<p>所以，<code>new Rabbit()</code> 调用了 <code>super()</code>，因此它执行了父类构造器，并且（根据派生类规则）只有在此之后，它的类字段才被初始化。在父类构造器被执行的时候，<code>Rabbit</code> 还没有自己的类字段，这就是为什么 <code>Animal</code> 类字段被使用了。</p>
<p>这种字段与方法之间微妙的区别只特定于 JavaScript。</p>
<p>幸运的是，这种行为仅在一个被重写的字段被父类构造器使用时才会显现出来。接下来它会发生的东西可能就比较难理解了，所以我们要在这里对此行为进行解释。</p>
<p>如果出问题了，我们可以通过使用方法或者 getter/setter 替代类字段，来修复这个问题。</p>
<h2 id="深入：内部探究和-homeobject">深入：内部探究和 [[HomeObject]]</h2>
<pre><code class="language-warn">如果你是第一次阅读本教程，那么则可以跳过本节。

这是关于继承和 `super` 背后的内部机制。</code></pre>
<p>让我们更深入地研究 <code>super</code>。我们将在这个过程中发现一些有趣的事儿。</p>
<p>首先要说的是，从我们迄今为止学到的知识来看，<code>super</code> 是不可能运行的。</p>
<p>的确是这样，让我们问问自己，以技术的角度它是如何工作的？当一个对象方法执行时，它会将当前对象作为 <code>this</code>。随后如果我们调用 <code>super.method()</code>，那么引擎需要从当前对象的原型中获取 <code>method</code>。但这是怎么做到的？</p>
<p>这个任务看起来是挺容易的，但其实并不简单。引擎知道当前对象的 <code>this</code>，所以它可以获取父 <code>method</code> 作为 <code>this.__proto__.method</code>。不幸的是，这个“天真”的解决方法是行不通的。</p>
<p>让我们演示一下这个问题。简单起见，我们使用普通对象而不使用类。</p>
<p>如果你不想知道更多的细节知识，你可以跳过此部分，并转到下面的 <code>[[HomeObject]]</code> 小节。这没关系的。但如果你感兴趣，想学习更深入的知识，那就继续阅读吧。</p>
<p>在下面的例子中，<code>rabbit.__proto__ = animal</code>。现在让我们尝试一下：在 <code>rabbit.eat()</code> 我们将会使用 <code>this.__proto__</code> 调用 <code>animal.eat()</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> animal = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Animal&quot;</span>,
  <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params"></span>)</span> {
    alert(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">this</span>.name}</span> eats.`</span>);
  }
};

<span class="hljs-keyword">let</span> rabbit = {
  <span class="hljs-attr">__proto__</span>: animal,
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Rabbit&quot;</span>,
  <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params"></span>)</span> {
*!*
    <span class="hljs-comment">// 这就是 super.eat() 可以大概工作的方式</span>
    <span class="hljs-built_in">this</span>.__proto__.eat.call(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// (*)</span>
*/!*
  }
};

rabbit.eat(); <span class="hljs-comment">// Rabbit eats.</span></code></pre>
<p>在 <code>(*)</code> 这一行，我们从原型（<code>animal</code>）中获取 <code>eat</code>，并在当前对象的上下文中调用它。请注意，<code>.call(this)</code> 在这里非常重要，因为简单的调用 <code>this.__proto__.eat()</code> 将在原型的上下文中执行 <code>eat</code>，而非当前对象。</p>
<p>在上面的代码中，它确实按照了期望运行：我们获得了正确的 <code>alert</code>。</p>
<p>现在，让我们在原型链上再添加一个对象。我们将看到这件事是如何被打破的：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> animal = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Animal&quot;</span>,
  <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params"></span>)</span> {
    alert(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">this</span>.name}</span> eats.`</span>);
  }
};

<span class="hljs-keyword">let</span> rabbit = {
  <span class="hljs-attr">__proto__</span>: animal,
  <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-comment">// ...bounce around rabbit-style and call parent (animal) method</span>
    <span class="hljs-built_in">this</span>.__proto__.eat.call(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// (*)</span>
  }
};

<span class="hljs-keyword">let</span> longEar = {
  <span class="hljs-attr">__proto__</span>: rabbit,
  <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-comment">// ...do something with long ears and call parent (rabbit) method</span>
    <span class="hljs-built_in">this</span>.__proto__.eat.call(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// (**)</span>
  }
};

*!*
longEar.eat(); <span class="hljs-comment">// Error: Maximum call stack size exceeded</span>
*/!*</code></pre>
<p>代码无法再运行了！我们可以看到，在试图调用 <code>longEar.eat()</code> 时抛出了错误。</p>
<p>原因可能不那么明显，但是如果我们跟踪 <code>longEar.eat()</code> 调用，就可以发现原因。在 <code>(*)</code> 和 <code>(**)</code> 这两行中，<code>this</code> 的值都是当前对象（<code>longEar</code>）。这是至关重要的一点：所有的对象方法都将当前对象作为 <code>this</code>，而非原型或其他什么东西。</p>
<p>因此，在 <code>(*)</code> 和 <code>(**)</code> 这两行中，<code>this.__proto__</code> 的值是完全相同的：都是 <code>rabbit</code>。它们俩都调用的是 <code>rabbit.eat</code>，它们在不停地循环调用自己，而不是在原型链上向上寻找方法。</p>
<p>这张图介绍了发生的情况：</p>
<p><img src="this-super-loop.svg" alt=""></p>
<ol>
<li><p>在 <code>longEar.eat()</code> 中，<code>(**)</code> 这一行调用 <code>rabbit.eat</code> 并为其提供 <code>this=longEar</code>。</p>
<pre><code class="language-js"><span class="hljs-comment">// 在 longEar.eat() 中我们有 this = longEar</span>
<span class="hljs-built_in">this</span>.__proto__.eat.call(<span class="hljs-built_in">this</span>) <span class="hljs-comment">// (**)</span>
<span class="hljs-comment">// 变成了</span>
longEar.__proto__.eat.call(<span class="hljs-built_in">this</span>)
<span class="hljs-comment">// 也就是</span>
rabbit.eat.call(<span class="hljs-built_in">this</span>);</code></pre>
</li>
<li><p>之后在 <code>rabbit.eat</code> 的 <code>(*)</code> 行中，我们希望将函数调用在原型链上向更高层传递，但是 <code>this=longEar</code>，所以 <code>this.__proto__.eat</code> 又是 <code>rabbit.eat</code>！</p>
<pre><code class="language-js"><span class="hljs-comment">// 在 rabbit.eat() 中我们依然有 this = longEar</span>
<span class="hljs-built_in">this</span>.__proto__.eat.call(<span class="hljs-built_in">this</span>) <span class="hljs-comment">// (*)</span>
<span class="hljs-comment">// 变成了</span>
longEar.__proto__.eat.call(<span class="hljs-built_in">this</span>)
<span class="hljs-comment">// 或（再一次）</span>
rabbit.eat.call(<span class="hljs-built_in">this</span>);</code></pre>
</li>
<li><p>……所以 <code>rabbit.eat</code> 在不停地循环调用自己，因此它无法进一步地提升。</p>
</li>
</ol>
<p>这个问题没法仅仅通过使用 <code>this</code> 来解决。</p>
<h3 id="homeobject"><code>[[HomeObject]]</code></h3>
<p>为了提供解决方法，JavaScript 为函数添加了一个特殊的内部属性：<code>[[HomeObject]]</code>。</p>
<p>当一个函数被定义为类或者对象方法时，它的 <code>[[HomeObject]]</code> 属性就成为了该对象。</p>
<p>然后 <code>super</code> 使用它来解析（resolve）父原型及其方法。</p>
<p>让我们看看它是怎么工作的，首先，对于普通对象：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> animal = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Animal&quot;</span>,
  <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params"></span>)</span> {         <span class="hljs-comment">// animal.eat.[[HomeObject]] == animal</span>
    alert(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">this</span>.name}</span> eats.`</span>);
  }
};

<span class="hljs-keyword">let</span> rabbit = {
  <span class="hljs-attr">__proto__</span>: animal,
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Rabbit&quot;</span>,
  <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params"></span>)</span> {         <span class="hljs-comment">// rabbit.eat.[[HomeObject]] == rabbit</span>
    <span class="hljs-built_in">super</span>.eat();
  }
};

<span class="hljs-keyword">let</span> longEar = {
  <span class="hljs-attr">__proto__</span>: rabbit,
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Long Ear&quot;</span>,
  <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params"></span>)</span> {         <span class="hljs-comment">// longEar.eat.[[HomeObject]] == longEar</span>
    <span class="hljs-built_in">super</span>.eat();
  }
};

*!*
<span class="hljs-comment">// 正确执行</span>
longEar.eat();  <span class="hljs-comment">// Long Ear eats.</span>
*/!*</code></pre>
<p>它基于 <code>[[HomeObject]]</code> 运行机制按照预期执行。一个方法，例如 <code>longEar.eat</code>，知道其 <code>[[HomeObject]]</code> 并且从其原型中获取父方法。并没有使用 <code>this</code>。</p>
<h3 id="方法并不是自由的">方法并不是“自由”的</h3>
<p>正如我们之前所知道的，函数通常都是“自由”的，并没有绑定到 JavaScript 中的对象。正因如此，它们可以在对象之间复制，并用另外一个 <code>this</code> 调用它。</p>
<p><code>[[HomeObject]]</code> 的存在违反了这个原则，因为方法记住了它们的对象。<code>[[HomeObject]]</code> 不能被更改，所以这个绑定是永久的。</p>
<p>在 JavaScript 语言中 <code>[[HomeObject]]</code> 仅被用于 <code>super</code>。所以，如果一个方法不使用 <code>super</code>，那么我们仍然可以视它为自由的并且可在对象之间复制。但是用了 <code>super</code> 再这样做可能就会出错。</p>
<p>下面是复制后错误的 <code>super</code> 结果的示例：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> animal = {
  <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`I&#x27;m an animal`</span>);
  }
};

<span class="hljs-comment">// rabbit 继承自 animal</span>
<span class="hljs-keyword">let</span> rabbit = {
  <span class="hljs-attr">__proto__</span>: animal,
  <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-built_in">super</span>.sayHi();
  }
};

<span class="hljs-keyword">let</span> plant = {
  <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;I&#x27;m a plant&quot;</span>);
  }
};

<span class="hljs-comment">// tree 继承自 plant</span>
<span class="hljs-keyword">let</span> tree = {
  <span class="hljs-attr">__proto__</span>: plant,
*!*
  sayHi: rabbit.sayHi <span class="hljs-comment">// (*)</span>
*/!*
};

*!*
tree.sayHi();  <span class="hljs-comment">// I&#x27;m an animal (?!?)</span>
*/!*</code></pre>
<p>调用 <code>tree.sayHi()</code> 显示 &quot;I&#39;m an animal&quot;。这绝对是错误的。</p>
<p>原因很简单：</p>
<ul>
<li>在 <code>(*)</code> 行，<code>tree.sayHi</code> 方法是从 <code>rabbit</code> 复制而来。也许我们只是想避免重复代码？</li>
<li>它的 <code>[[HomeObject]]</code> 是 <code>rabbit</code>，因为它是在 <code>rabbit</code> 中创建的。没有办法修改 <code>[[HomeObject]]</code>。</li>
<li><code>tree.sayHi()</code> 内具有 <code>super.sayHi()</code>。它从 <code>rabbit</code> 中上溯，然后从 <code>animal</code> 中获取方法。</li>
</ul>
<p>这是发生的情况示意图：</p>
<p><img src="super-homeobject-wrong.svg" alt=""></p>
<h3 id="方法，不是函数属性">方法，不是函数属性</h3>
<p><code>[[HomeObject]]</code> 是为类和普通对象中的方法定义的。但是对于对象而言，方法必须确切指定为 <code>method()</code>，而不是 <code>&quot;method: function()&quot;</code>。</p>
<p>这个差别对我们来说可能不重要，但是对 JavaScript 来说却非常重要。</p>
<p>在下面的例子中，使用非方法（non-method）语法进行了比较。未设置 <code>[[HomeObject]]</code> 属性，并且继承无效：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> animal = {
  <span class="hljs-attr">eat</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// 这里是故意这样写的，而不是 eat() {...</span>
    <span class="hljs-comment">// ...</span>
  }
};

<span class="hljs-keyword">let</span> rabbit = {
  <span class="hljs-attr">__proto__</span>: animal,
  <span class="hljs-attr">eat</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">super</span>.eat();
  }
};

*!*
rabbit.eat();  <span class="hljs-comment">// 错误调用 super（因为这里没有 [[HomeObject]]）</span>
*/!*</code></pre>
<h2 id="总结">总结</h2>
<ol>
<li>想要扩展一个类：<code>class Child extends Parent</code>：<ul>
<li>这意味着 <code>Child.prototype.__proto__</code> 将是 <code>Parent.prototype</code>，所以方法会被继承。</li>
</ul>
</li>
<li>重写一个 constructor：<ul>
<li>在使用 <code>this</code> 之前，我们必须在 <code>Child</code> 的 constructor 中将父 constructor 调用为 <code>super()</code>。</li>
</ul>
</li>
<li>重写一个方法：<ul>
<li>我们可以在一个 <code>Child</code> 方法中使用 <code>super.method()</code> 来调用 <code>Parent</code> 方法。</li>
</ul>
</li>
<li>内部：<ul>
<li>方法在内部的 <code>[[HomeObject]]</code> 属性中记住了它们的类/对象。这就是 <code>super</code> 如何解析父方法的。</li>
<li>因此，将一个带有 <code>super</code> 的方法从一个对象复制到另一个对象是不安全的。</li>
</ul>
</li>
</ol>
<p>补充：</p>
<ul>
<li>箭头函数没有自己的 <code>this</code> 或 <code>super</code>，所以它们能融入到就近的上下文中，像透明似的。</li>
</ul>

      </fieldset>
      
      <fieldset id='_NUzcpO'>
      <legend>solution</legend>
      <p>首先，让我们看看为什么之前的代码无法运行。</p>
<p>如果我们尝试运行它，就会发现原因其实很明显。派生类的 constructor 必须调用 <code>super()</code>。否则 <code>&quot;this&quot;</code> 不会被定义。</p>
<p>下面是修复后的代码：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rabbit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Object</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> {
*!*
    <span class="hljs-built_in">super</span>(); <span class="hljs-comment">// 需要在继承时调用父类的 constructor</span>
*/!*
    <span class="hljs-built_in">this</span>.name = name;
  }
}

<span class="hljs-keyword">let</span> rabbit = <span class="hljs-keyword">new</span> Rabbit(<span class="hljs-string">&quot;Rab&quot;</span>);

alert( rabbit.hasOwnProperty(<span class="hljs-string">&#x27;name&#x27;</span>) ); <span class="hljs-comment">// true</span></code></pre>
<p>但这还不是全部原因。</p>
<p>即便修复了它，<code>&quot;class Rabbit extends Object&quot;</code> 和 <code>class Rabbit</code> 之间仍存在着重要差异。</p>
<p>我们知道，&quot;extends&quot; 语法会设置两个原型：</p>
<ol>
<li>在构造函数的 <code>&quot;prototype&quot;</code> 之间设置原型（为了获取实例方法）。</li>
<li>在构造函数之间会设置原型（为了获取静态方法）。</li>
</ol>
<p>在我们的例子里，对于 <code>class Rabbit extends Object</code>，它意味着：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rabbit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Object</span> </span>{}

alert( Rabbit.prototype.__proto__ === <span class="hljs-built_in">Object</span>.prototype ); <span class="hljs-comment">// (1) true</span>
alert( Rabbit.__proto__ === <span class="hljs-built_in">Object</span> ); <span class="hljs-comment">// (2) true</span></code></pre>
<p>所以，现在 <code>Rabbit</code> 可以通过 <code>Rabbit</code> 访问 <code>Object</code> 的静态方法，像这样：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rabbit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Object</span> </span>{}

*!*
<span class="hljs-comment">// 通常我们调用 Object.getOwnPropertyNames</span>
alert ( Rabbit.getOwnPropertyNames({<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>})); <span class="hljs-comment">// a,b</span>
*/!*</code></pre>
<p>但是如果我们没有 <code>extends Object</code>，那么 <code>Rabbit.__proto__</code> 将不会被设置为 <code>Object</code>。</p>
<p>下面是示例：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rabbit</span> </span>{}

alert( Rabbit.prototype.__proto__ === <span class="hljs-built_in">Object</span>.prototype ); <span class="hljs-comment">// (1) true</span>
alert( Rabbit.__proto__ === <span class="hljs-built_in">Object</span> ); <span class="hljs-comment">// (2) false (!)</span>
alert( Rabbit.__proto__ === <span class="hljs-built_in">Function</span>.prototype ); <span class="hljs-comment">// true，所有函数都是默认如此</span>

*!*
<span class="hljs-comment">// error，Rabbit 中没有这样的函数</span>
alert ( Rabbit.getOwnPropertyNames({<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>})); <span class="hljs-comment">// Error</span>
*/!*</code></pre>
<p>所以，在这种情况下，<code>Rabbit</code> 没有提供对 <code>Object</code> 的静态方法的访问。</p>
<p>顺便说一下，<code>Function.prototype</code> 有一些“通用”函数方法，例如 <code>call</code> 和 <code>bind</code> 等。在上述的两种情况下它们都是可用的，因为对于内建的 <code>Object</code> 构造函数而言，<code>Object.__proto__ === Function.prototype</code>。</p>
<p>我们用一张图来解释：</p>
<p><img src="rabbit-extends-object.svg" alt=""></p>
<p>所以，简而言之，这里有两点区别：</p>
<table>
<thead>
<tr>
<th>class Rabbit</th>
<th>class Rabbit extends Object</th>
</tr>
</thead>
<tbody><tr>
<td>--</td>
<td>needs to call <code>super()</code> in constructor</td>
</tr>
<tr>
<td><code>Rabbit.__proto__ === Function.prototype</code></td>
<td><code>Rabbit.__proto__ === Object</code></td>
</tr>
</tbody></table>

      </fieldset>
      
      <fieldset id='_FME0UA'>
      <legend>task</legend>
      <p>importance: 3</p>
<hr>
<h1 id="类扩展自对象？">类扩展自对象？</h1>
<p>正如我们所知道的，所有的对象通常都继承自 <code>Object.prototype</code>，并且可以访问“通用”对象方法，例如 <code>hasOwnProperty</code> 等。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rabbit</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> {
    <span class="hljs-built_in">this</span>.name = name;
  }
}

<span class="hljs-keyword">let</span> rabbit = <span class="hljs-keyword">new</span> Rabbit(<span class="hljs-string">&quot;Rab&quot;</span>);

*!*
<span class="hljs-comment">// hasOwnProperty 方法来自于 Object.prototype</span>
alert( rabbit.hasOwnProperty(<span class="hljs-string">&#x27;name&#x27;</span>) ); <span class="hljs-comment">// true</span>
*/!*</code></pre>
<p>但是，如果我们像这样 <code>&quot;class Rabbit extends Object&quot;</code> 把它明确地写出来，那么结果会与简单的 <code>&quot;class Rabbit&quot;</code> 有所不同么？</p>
<p>不同之处在哪里？</p>
<p>下面是此类的示例代码（它无法正常运行 — 为什么？修复它？）：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rabbit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Object</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> {
    <span class="hljs-built_in">this</span>.name = name;
  }
}

<span class="hljs-keyword">let</span> rabbit = <span class="hljs-keyword">new</span> Rabbit(<span class="hljs-string">&quot;Rab&quot;</span>);

alert( rabbit.hasOwnProperty(<span class="hljs-string">&#x27;name&#x27;</span>) ); <span class="hljs-comment">// Error</span></code></pre>

      </fieldset>
      
      <fieldset id='_A74fI9'>
      <legend>article</legend>
      <h1 id="静态属性和静态方法">静态属性和静态方法</h1>
<p>我们可以把一个方法赋值给类的函数本身，而不是赋给它的 <code>&quot;prototype&quot;</code>。这样的方法被称为 <strong>静态的（static）</strong>。</p>
<p>在一个类中，它们以 <code>static</code> 关键字开头，如下所示：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
*!*
  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">staticMethod</span>(<span class="hljs-params"></span>)</span> {
*/!*
    alert(<span class="hljs-built_in">this</span> === User);
  }
}

User.staticMethod(); <span class="hljs-comment">// true</span></code></pre>
<p>这实际上跟直接将其作为属性赋值的作用相同：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{ }

User.staticMethod = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-built_in">this</span> === User);
};

User.staticMethod(); <span class="hljs-comment">// true</span></code></pre>
<p>在 <code>User.staticMethod()</code> 调用中的 <code>this</code> 的值是类构造器 <code>User</code> 自身（“点符号前面的对象”规则）。</p>
<p>通常，静态方法用于实现属于该类但不属于该类任何特定对象的函数。</p>
<p>例如，我们有对象 <code>Article</code>，并且需要一个方法来比较它们。一个自然的解决方案就是添加 <code>Article.compare</code> 方法，像下面这样：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Article</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">title, date</span>)</span> {
    <span class="hljs-built_in">this</span>.title = title;
    <span class="hljs-built_in">this</span>.date = date;
  }

*!*
  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">compare</span>(<span class="hljs-params">articleA, articleB</span>)</span> {
    <span class="hljs-keyword">return</span> articleA.date - articleB.date;
  }
*/!*
}

<span class="hljs-comment">// 用法</span>
<span class="hljs-keyword">let</span> articles = [
  <span class="hljs-keyword">new</span> Article(<span class="hljs-string">&quot;HTML&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2019</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)),
  <span class="hljs-keyword">new</span> Article(<span class="hljs-string">&quot;CSS&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2019</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)),
  <span class="hljs-keyword">new</span> Article(<span class="hljs-string">&quot;JavaScript&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2019</span>, <span class="hljs-number">11</span>, <span class="hljs-number">1</span>))
];

*!*
articles.sort(Article.compare);
*/!*

alert( articles[<span class="hljs-number">0</span>].title ); <span class="hljs-comment">// CSS</span></code></pre>
<p>这里 <code>Article.compare</code> 代表“上面的”文章，意思是比较它们。它不是文章的方法，而是整个 class 的方法。</p>
<p>另一个例子是所谓的“工厂”方法。想象一下，我们需要通过几种方法来创建一个文章：</p>
<ol>
<li>通过用给定的参数来创建（<code>title</code>，<code>date</code> 等）。</li>
<li>使用今天的日期来创建一个空的文章。</li>
<li>……其它方法。</li>
</ol>
<p>第一种方法我们可以通过 constructor 来实现。对于第二种方式，我们可以创建类的一个静态方法来实现。</p>
<p>就像这里的 <code>Article.createTodays()</code>：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Article</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">title, date</span>)</span> {
    <span class="hljs-built_in">this</span>.title = title;
    <span class="hljs-built_in">this</span>.date = date;
  }

*!*
  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">createTodays</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-comment">// 记住 this = Article</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">this</span>(<span class="hljs-string">&quot;Today&#x27;s digest&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>());
  }
*/!*
}

<span class="hljs-keyword">let</span> article = Article.createTodays();

alert( article.title ); <span class="hljs-comment">// Today&#x27;s digest</span></code></pre>
<p>现在，每当我们需要创建一个今天的文章时，我们就可以调用 <code>Article.createTodays()</code>。再说明一次，它不是一个文章的方法，而是整个 class 的方法。</p>
<p>静态方法也被用于与数据库相关的公共类，可以用于搜索/保存/删除数据库中的条目， 就像这样：</p>
<pre><code class="language-js"><span class="hljs-comment">// 假定 Article 是一个用来管理文章的特殊类</span>
<span class="hljs-comment">// 静态方法用于移除文章：</span>
Article.remove({<span class="hljs-attr">id</span>: <span class="hljs-number">12345</span>});</code></pre>
<h2 id="静态属性">静态属性</h2>
<p>[recent browser=Chrome]</p>
<p>静态的属性也是可能的，它们看起来就像常规的类属性，但前面加有 <code>static</code>：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Article</span> </span>{
  <span class="hljs-keyword">static</span> publisher = <span class="hljs-string">&quot;Levi Ding&quot;</span>;
}

alert( Article.publisher ); <span class="hljs-comment">// Levi Ding</span></code></pre>
<p>这等同于直接给 <code>Article</code> 赋值：</p>
<pre><code class="language-js">Article.publisher = <span class="hljs-string">&quot;Levi Ding&quot;</span>;</code></pre>
<h2 id="继承静态属性和方法">继承静态属性和方法</h2>
<p>静态属性和方法是可被继承的。</p>
<p>例如，下面这段代码中的 <code>Animal.compare</code> 和 <code>Animal.planet</code> 是可被继承的，可以通过 <code>Rabbit.compare</code> 和 <code>Rabbit.planet</code> 来访问：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-keyword">static</span> planet = <span class="hljs-string">&quot;Earth&quot;</span>;

  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, speed</span>)</span> {
    <span class="hljs-built_in">this</span>.speed = speed;
    <span class="hljs-built_in">this</span>.name = name;
  }

  <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params">speed = <span class="hljs-number">0</span></span>)</span> {
    <span class="hljs-built_in">this</span>.speed += speed;
    alert(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">this</span>.name}</span> runs with speed <span class="hljs-subst">${<span class="hljs-built_in">this</span>.speed}</span>.`</span>);
  }

*!*
  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">compare</span>(<span class="hljs-params">animalA, animalB</span>)</span> {
    <span class="hljs-keyword">return</span> animalA.speed - animalB.speed;
  }
*/!*

}

<span class="hljs-comment">// 继承于 Animal</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rabbit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-function"><span class="hljs-title">hide</span>(<span class="hljs-params"></span>)</span> {
    alert(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">this</span>.name}</span> hides!`</span>);
  }
}

<span class="hljs-keyword">let</span> rabbits = [
  <span class="hljs-keyword">new</span> Rabbit(<span class="hljs-string">&quot;White Rabbit&quot;</span>, <span class="hljs-number">10</span>),
  <span class="hljs-keyword">new</span> Rabbit(<span class="hljs-string">&quot;Black Rabbit&quot;</span>, <span class="hljs-number">5</span>)
];

*!*
rabbits.sort(Rabbit.compare);
*/!*

rabbits[<span class="hljs-number">0</span>].run(); <span class="hljs-comment">// Black Rabbit runs with speed 5.</span>

alert(Rabbit.planet); <span class="hljs-comment">// Earth</span></code></pre>
<p>现在我们调用 <code>Rabbit.compare</code> 时，继承的 <code>Animal.compare</code> 将会被调用。</p>
<p>它是如何工作的？再次，使用原型。你可能已经猜到了，<code>extends</code> 让 <code>Rabbit</code> 的 <code>[[Prototype]]</code> 指向了 <code>Animal</code>。</p>
<p><img src="animal-rabbit-static.svg" alt=""></p>
<p>所以，<code>Rabbit extends Animal</code> 创建了两个 <code>[[Prototype]]</code> 引用：</p>
<ol>
<li><code>Rabbit</code> 函数原型继承自 <code>Animal</code> 函数。</li>
<li><code>Rabbit.prototype</code> 原型继承自 <code>Animal.prototype</code>。</li>
</ol>
<p>结果就是，继承对常规方法和静态方法都有效。</p>
<p>这里，让我们通过代码来检验一下：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rabbit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>{}

<span class="hljs-comment">// 对于静态的</span>
alert(Rabbit.__proto__ === Animal); <span class="hljs-comment">// true</span>

<span class="hljs-comment">// 对于常规方法</span>
alert(Rabbit.prototype.__proto__ === Animal.prototype); <span class="hljs-comment">// true</span></code></pre>
<h2 id="总结">总结</h2>
<p>静态方法被用于实现属于整个类的功能。它与具体的类实例无关。</p>
<p>举个例子， 一个用于进行比较的方法 <code>Article.compare(article1, article2)</code> 或一个工厂（factory）方法 <code>Article.createTodays()</code>。</p>
<p>在类生命中，它们都被用关键字 <code>static</code> 进行了标记。</p>
<p>静态属性被用于当我们想要存储类级别的数据时，而不是绑定到实例。</p>
<p>语法如下所示：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
  <span class="hljs-keyword">static</span> property = ...;

  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> {
    ...
  }
}</code></pre>
<p>从技术上讲，静态声明与直接给类本身赋值相同：</p>
<pre><code class="language-js">MyClass.property = ...
MyClass.method = ...</code></pre>
<p>静态属性和方法是可被继承的。</p>
<p>对于 <code>class B extends A</code>，类 <code>B</code> 的 prototype 指向了 <code>A</code>：<code>B.[[Prototype]] = A</code>。因此，如果一个字段在 <code>B</code> 中没有找到，会继续在 <code>A</code> 中查找。</p>

      </fieldset>
      
      <fieldset id='_kIojnS'>
      <legend>article</legend>
      <h1 id="私有的和受保护的属性和方法">私有的和受保护的属性和方法</h1>
<p>面向对象编程最重要的原则之一 —— 将内部接口与外部接口分隔开来。</p>
<p>在开发比 &quot;hello world&quot; 应用程序更复杂的东西时，这是“必须”遵守的做法。</p>
<p>为了理解这一点，让我们脱离开发过程，把目光转向现实世界。</p>
<p>通常，我们使用的设备都非常复杂。但是，将内部接口与外部接口分隔开来可以让我们使用它们且没有任何问题。</p>
<h2 id="一个现实生活中的例子">一个现实生活中的例子</h2>
<p>例如，一个咖啡机。从外面看很简单：一个按钮，一个显示器，几个洞……当然，结果就是 —— 很棒的咖啡！:)</p>
<p><img src="coffee.jpg" alt=""></p>
<p>但是在内部……（一张摘自维修手册的图片）</p>
<p><img src="coffee-inside.jpg" alt=""></p>
<p>有非常多的细节。但我们可以在完全不了解这些内部细节的情况下使用它。</p>
<p>咖啡机非常可靠，不是吗？一台咖啡机我们可以使用好几年，只有在出现问题时 —— 把它送去维修。</p>
<p>咖啡机的可靠性和简洁性的秘诀 —— 所有细节都经过精心校并 <strong>隐藏</strong> 在内部。</p>
<p>如果我们从咖啡机上取下保护罩，那么使用它将变得复杂得多（要按哪里？），并且很危险（会触电）。</p>
<p>正如我们所看到的，在编程中，对象就像咖啡机。</p>
<p>但是为了隐藏内部细节，我们不会使用保护罩，而是使用语言和约定中的特殊语法。</p>
<h2 id="内部接口和外部接口">内部接口和外部接口</h2>
<p>在面向对象的编程中，属性和方法分为两组：</p>
<ul>
<li><strong>内部接口</strong> —— 可以通过该类的其他方法访问，但不能从外部访问的方法和属性。</li>
<li><strong>外部接口</strong> —— 也可以从类的外部访问的方法和属性。</li>
</ul>
<p>如果我们继续用咖啡机进行类比 —— 内部隐藏的内容：锅炉管，加热元件等 —— 是咖啡机的内部接口。</p>
<p>内部接口用于对象工作，它的细节相互使用。例如，锅炉管连接到加热元件。</p>
<p>但是从外面看，一台咖啡机被保护壳罩住了，所以没有人可以接触到其内部接口。细节信息被隐藏起来并且无法访问。我们可以通过外部接口使用它的功能。</p>
<p>所以，我们需要使用一个对象时只需知道它的外部接口。我们可能完全不知道它的内部是如何工作的，这太好了。</p>
<p>这是个概括性的介绍。</p>
<p>在 JavaScript 中，有两种类型的对象字段（属性和方法）：</p>
<ul>
<li>公共的：可从任何地方访问。它们构成了外部接口。到目前为止，我们只使用了公共的属性和方法。</li>
<li>私有的：只能从类的内部访问。这些用于内部接口。</li>
</ul>
<p>在许多其他编程语言中，还存在“受保护”的字段：只能从类的内部和基于其扩展的类的内部访问（例如私有的，但可以从继承的类进行访问）。它们对于内部接口也很有用。从某种意义上讲，它们比私有的属性和方法更为广泛，因为我们通常希望继承类来访问它们。</p>
<p>受保护的字段不是在语言级别的 Javascript 中实现的，但实际上它们非常方便，因为它们是在 Javascript 中模拟的类定义语法。</p>
<p>现在，我们将使用所有这些类型的属性在 Javascript 中制作咖啡机。咖啡机有很多细节，我们不会对它们进行全面模拟以保持简洁（尽管我们可以）。</p>
<h2 id="受保护的-wateramount">受保护的 &quot;waterAmount&quot;</h2>
<p>首先，让我们做一个简单的咖啡机类：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoffeeMachine</span> </span>{
  waterAmount = <span class="hljs-number">0</span>; <span class="hljs-comment">// 内部的水量</span>

  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">power</span>)</span> {
    <span class="hljs-built_in">this</span>.power = power;
    alert( <span class="hljs-string">`Created a coffee-machine, power: <span class="hljs-subst">${power}</span>`</span> );
  }

}

<span class="hljs-comment">// 创建咖啡机</span>
<span class="hljs-keyword">let</span> coffeeMachine = <span class="hljs-keyword">new</span> CoffeeMachine(<span class="hljs-number">100</span>);

<span class="hljs-comment">// 加水</span>
coffeeMachine.waterAmount = <span class="hljs-number">200</span>;</code></pre>
<p>现在，属性 <code>waterAmount</code> 和 <code>power</code> 是公共的。我们可以轻松地从外部将它们 get/set 成任何值。</p>
<p>让我们将 <code>waterAmount</code> 属性更改为受保护的属性，以对其进行更多控制。例如，我们不希望任何人将它的值设置为小于零的数。</p>
<p><strong>受保护的属性通常以下划线 <code>_</code> 作为前缀。</strong></p>
<p>这不是在语言级别强制实施的，但是程序员之间有一个众所周知的约定，即不应该从外部访问此类型的属性和方法。</p>
<p>所以我们的属性将被命名为 <code>_waterAmount</code>：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoffeeMachine</span> </span>{
  _waterAmount = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">set</span> <span class="hljs-title">waterAmount</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-keyword">if</span> (value &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Negative water&quot;</span>);
    <span class="hljs-built_in">this</span>._waterAmount = value;
  }

  <span class="hljs-keyword">get</span> <span class="hljs-title">waterAmount</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._waterAmount;
  }

  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">power</span>)</span> {
    <span class="hljs-built_in">this</span>._power = power;
  }

}

<span class="hljs-comment">// 创建咖啡机</span>
<span class="hljs-keyword">let</span> coffeeMachine = <span class="hljs-keyword">new</span> CoffeeMachine(<span class="hljs-number">100</span>);

<span class="hljs-comment">// 加水</span>
coffeeMachine.waterAmount = -<span class="hljs-number">10</span>; <span class="hljs-comment">// Error: Negative water</span></code></pre>
<p>现在访问已受到控制，因此将水量的值设置为小于零的数将会失败。</p>
<h2 id="只读的-power">只读的 &quot;power&quot;</h2>
<p>对于 <code>power</code> 属性，让我们将它设为只读。有时候一个属性必须只能被在创建时进行设置，之后不再被修改。</p>
<p>咖啡机就是这种情况：功率永远不会改变。</p>
<p>要做到这一点，我们只需要设置 getter，而不设置 setter：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoffeeMachine</span> </span>{
  <span class="hljs-comment">// ...</span>

  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">power</span>)</span> {
    <span class="hljs-built_in">this</span>._power = power;
  }

  <span class="hljs-keyword">get</span> <span class="hljs-title">power</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._power;
  }

}

<span class="hljs-comment">// 创建咖啡机</span>
<span class="hljs-keyword">let</span> coffeeMachine = <span class="hljs-keyword">new</span> CoffeeMachine(<span class="hljs-number">100</span>);

alert(<span class="hljs-string">`Power is: <span class="hljs-subst">${coffeeMachine.power}</span>W`</span>); <span class="hljs-comment">// 功率是：100W</span>

coffeeMachine.power = <span class="hljs-number">25</span>; <span class="hljs-comment">// Error（没有 setter）</span></code></pre>
<pre><code class="language-smart">这里我们使用了 getter/setter 语法。

但大多数时候首选 `get.../set...` 函数，像这样：

```js
class CoffeeMachine {
  _waterAmount = 0;

  *!*setWaterAmount(value)*/!* {
    if (value &lt; 0) throw new Error(&quot;Negative water&quot;);
    this._waterAmount = value;
  }

  *!*getWaterAmount()*/!* {
    return this._waterAmount;
  }
}

new CoffeeMachine().setWaterAmount(100);
```

这看起来有点长，但函数更灵活。它们可以接受多个参数（即使我们现在还不需要）。

另一方面，get/set 语法更短，所以最终没有严格的规定，而是由你自己来决定。</code></pre>
<pre><code class="language-smart">如果我们继承 `class MegaMachine extends CoffeeMachine`，那么什么都无法阻止我们从新的类中的方法访问 `this._waterAmount` 或 `this._power`。

所以受保护的字段是自然可被继承的。与我们接下来将看到的私有字段不同。</code></pre>
<h2 id="私有的-waterlimit">私有的 &quot;#waterLimit&quot;</h2>
<p>[recent browser=none]</p>
<p>这儿有一个马上就会被加到规范中的已完成的 Javascript 提案，它为私有属性和方法提供语言级支持。</p>
<p>私有属性和方法应该以 <code>#</code> 开头。它们只在类的内部可被访问。</p>
<p>例如，这儿有一个私有属性 <code>#waterLimit</code> 和检查水量的私有方法 <code>#checkWater</code>：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoffeeMachine</span> </span>{
*!*
  #waterLimit = <span class="hljs-number">200</span>;
*/!*

*!*
  #<span class="hljs-function"><span class="hljs-title">checkWater</span>(<span class="hljs-params">value</span>)</span> {
    <span class="hljs-keyword">if</span> (value &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Negative water&quot;</span>);
    <span class="hljs-keyword">if</span> (value &gt; <span class="hljs-built_in">this</span>.#waterLimit) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Too much water&quot;</span>);
  }
*/!*

}

<span class="hljs-keyword">let</span> coffeeMachine = <span class="hljs-keyword">new</span> CoffeeMachine();

*!*
<span class="hljs-comment">// 不能从类的外部访问类的私有属性和方法</span>
coffeeMachine.#checkWater(); <span class="hljs-comment">// Error</span>
coffeeMachine.#waterLimit = <span class="hljs-number">1000</span>; <span class="hljs-comment">// Error</span>
*/!*</code></pre>
<p>在语言级别，<code>#</code> 是该字段为私有的特殊标志。我们无法从外部或从继承的类中访问它。</p>
<p>私有字段与公共字段不会发生冲突。我们可以同时拥有私有的 <code>#waterAmount</code> 和公共的 <code>waterAmount</code> 字段。</p>
<p>例如，让我们使 <code>waterAmount</code> 成为 <code>#waterAmount</code> 的一个访问器：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoffeeMachine</span> </span>{

  #waterAmount = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">get</span> <span class="hljs-title">waterAmount</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.#waterAmount;
  }

  <span class="hljs-keyword">set</span> <span class="hljs-title">waterAmount</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-keyword">if</span> (value &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Negative water&quot;</span>);
    <span class="hljs-built_in">this</span>.#waterAmount = value;
  }
}

<span class="hljs-keyword">let</span> machine = <span class="hljs-keyword">new</span> CoffeeMachine();

machine.waterAmount = <span class="hljs-number">100</span>;
alert(machine.#waterAmount); <span class="hljs-comment">// Error</span></code></pre>
<p>与受保护的字段不同，私有字段由语言本身强制执行。这是好事儿。</p>
<p>但是如果我们继承自 <code>CoffeeMachine</code>，那么我们将无法直接访问 <code>#waterAmount</code>。我们需要依靠 <code>waterAmount</code> getter/setter：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MegaCoffeeMachine</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CoffeeMachine</span> </span>{
  <span class="hljs-function"><span class="hljs-title">method</span>(<span class="hljs-params"></span>)</span> {
*!*
    alert( <span class="hljs-built_in">this</span>.#waterAmount ); <span class="hljs-comment">// Error: can only access from CoffeeMachine</span>
*/!*
  }
}</code></pre>
<p>在许多情况下，这种限制太严重了。如果我们扩展 <code>CoffeeMachine</code>，则可能有正当理由访问其内部。这就是为什么大多数时候都会使用受保护字段，即使它们不受语言语法的支持。</p>
<pre><code class="language-warn">私有字段很特别。

正如我们所知道的，通常我们可以使用 `this[name]` 访问字段：

```js
class User {
  ...
  sayHi() {
    let fieldName = &quot;name&quot;;
    alert(`Hello, ${*!*this[fieldName]*/!*}`);
  }
}
```

对于私有字段来说，这是不可能的：`this[&#x27;#name&#x27;]` 不起作用。这是确保私有性的语法限制。</code></pre>
<h2 id="总结">总结</h2>
<p>就面向对象编程（OOP）而言，内部接口与外部接口的划分被称为 <a href="https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)">封装</a>。</p>
<p>它具有以下优点：</p>
<p>保护用户，使他们不会误伤自己
: 想象一下，有一群开发人员在使用一个咖啡机。这个咖啡机是由“最好的咖啡机”公司制造的，工作正常，但是保护罩被拿掉了。因此内部接口暴露了出来。</p>
<pre><code>所有的开发人员都是文明的 —— 他们按照预期使用咖啡机。但其中的一个人，约翰，他认为自己是最聪明的人，并对咖啡机的内部做了一些调整。然而，咖啡机两天后就坏了。

这肯定不是约翰的错，而是那个取下保护罩并让约翰进行操作的人的错。

编程也一样。如果一个 class 的使用者想要改变那些本不打算被从外部更改的东西 —— 后果是不可预测的。</code></pre>
<p>可支持性
: 编程的情况比现实生活中的咖啡机要复杂得多，因为我们不只是购买一次。我们还需要不断开发和改进代码。</p>
<pre><code>**如果我们严格界定内部接口，那么这个 class 的开发人员可以自由地更改其内部属性和方法，甚至无需通知用户。**

如果你是这样的 class 的开发者，那么你会很高兴知道可以安全地重命名私有变量，可以更改甚至删除其参数，因为没有外部代码依赖于它们。

对于用户来说，当新版本问世时，应用的内部可能被进行了全面检修，但如果外部接口相同，则仍然很容易升级。</code></pre>
<p>隐藏复杂性
: 人们喜欢使用简单的东西。至少从外部来看是这样。内部的东西则是另外一回事了。</p>
<pre><code>程序员也不例外。

**当实施细节被隐藏，并提供了简单且有据可查的外部接口时，总是很方便的。**</code></pre>
<p>为了隐藏内部接口，我们使用受保护的或私有的属性：</p>
<ul>
<li>受保护的字段以 <code>_</code> 开头。这是一个众所周知的约定，不是在语言级别强制执行的。程序员应该只通过它的类和从它继承的类中访问以 <code>_</code> 开头的字段。</li>
<li>私有字段以 <code>#</code> 开头。JavaScript 确保我们只能从类的内部访问它们。</li>
</ul>
<p>目前，各个浏览器对私有字段的支持不是很好，但可以用 polyfill 解决。</p>

      </fieldset>
      
      <fieldset id='_glf6NV'>
      <legend>article</legend>
      <h1 id="扩展内建类">扩展内建类</h1>
<p>内建的类，例如 <code>Array</code>，<code>Map</code> 等也都是可以扩展的（extendable）。</p>
<p>例如，这里有一个继承自原生 <code>Array</code> 的类 <code>PowerArray</code>： </p>
<pre><code class="language-js"><span class="hljs-comment">// 给 PowerArray 新增了一个方法（可以增加更多）</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PowerArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Array</span> </span>{
  <span class="hljs-function"><span class="hljs-title">isEmpty</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.length === <span class="hljs-number">0</span>;
  }
}

<span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> PowerArray(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>);
alert(arr.isEmpty()); <span class="hljs-comment">// false</span>

<span class="hljs-keyword">let</span> filteredArr = arr.filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item &gt;= <span class="hljs-number">10</span>);
alert(filteredArr); <span class="hljs-comment">// 10, 50</span>
alert(filteredArr.isEmpty()); <span class="hljs-comment">// false</span></code></pre>
<p>请注意一个非常有趣的事儿。内建的方法例如 <code>filter</code>，<code>map</code> 等 — 返回的正是子类 <code>PowerArray</code> 的新对象。它们内部使用了对象的 <code>constructor</code> 属性来实现这一功能。</p>
<p>在上面的例子中，</p>
<pre><code class="language-js">arr.constructor === PowerArray</code></pre>
<p>当 <code>arr.filter()</code> 被调用时，它的内部使用的是 <code>arr.constructor</code> 来创建新的结果数组，而不是使用原生的 <code>Array</code>。这真的很酷，因为我们可以在结果数组上继续使用 <code>PowerArray</code> 的方法。</p>
<p>甚至，我们可以定制这种行为。</p>
<p>我们可以给这个类添加一个特殊的静态 getter <code>Symbol.species</code>。如果存在，则应返回 JavaScript 在内部用来在 <code>map</code> 和 <code>filter</code> 等方法中创建新实体的 <code>constructor</code>。</p>
<p>如果我们希望像 <code>map</code> 或 <code>filter</code> 这样的内建方法返回常规数组，我们可以在 <code>Symbol.species</code> 中返回 <code>Array</code>，就像这样：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PowerArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Array</span> </span>{
  <span class="hljs-function"><span class="hljs-title">isEmpty</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.length === <span class="hljs-number">0</span>;
  }

*!*
  <span class="hljs-comment">// 内建方法将使用这个作为 constructor</span>
  <span class="hljs-keyword">static</span> get [<span class="hljs-built_in">Symbol</span>.species]() {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>;
  }
*/!*
}

<span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> PowerArray(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>);
alert(arr.isEmpty()); <span class="hljs-comment">// false</span>

<span class="hljs-comment">// filter 使用 arr.constructor[Symbol.species] 作为 constructor 创建新数组</span>
<span class="hljs-keyword">let</span> filteredArr = arr.filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item &gt;= <span class="hljs-number">10</span>);

*!*
<span class="hljs-comment">// filteredArr 不是 PowerArray，而是 Array</span>
*/!*
alert(filteredArr.isEmpty()); <span class="hljs-comment">// Error: filteredArr.isEmpty is not a function</span></code></pre>
<p>正如你所看到的，现在 <code>.filter</code> 返回 <code>Array</code>。所以扩展的功能不再传递。</p>
<pre><code class="language-smart">其他集合，例如 `Map` 和 `Set` 的工作方式类似。它们也使用 `Symbol.species`。</code></pre>
<h3 id="内建类没有静态方法继承">内建类没有静态方法继承</h3>
<p>内建对象有它们自己的静态方法，例如 <code>Object.keys</code>，<code>Array.isArray</code> 等。</p>
<p>如我们所知道的，原生的类互相扩展。例如，<code>Array</code> 扩展自 <code>Object</code>。</p>
<p>通常，当一个类扩展另一个类时，静态方法和非静态方法都会被继承。这已经在 <a href="info:static-properties-methods#statics-and-inheritance"></a> 中详细地解释过了。</p>
<p>但内建类却是一个例外。它们相互间不继承静态方法。</p>
<p>例如，<code>Array</code> 和 <code>Date</code> 都继承自 <code>Object</code>，所以它们的实例都有来自 <code>Object.prototype</code> 的方法。但 <code>Array.[[Prototype]]</code> 并不指向 <code>Object</code>，所以它们没有例如 <code>Array.keys()</code>（或 <code>Date.keys()</code>）这些静态方法。</p>
<p>这里有一张 <code>Date</code> 和 <code>Object</code> 的结构关系图：</p>
<p><img src="object-date-inheritance.svg" alt=""></p>
<p>正如你所看到的，<code>Date</code> 和 <code>Object</code> 之间没有连结。它们是独立的，只有 <code>Date.prototype</code> 继承自 <code>Object.prototype</code>，仅此而已。</p>
<p>与我们所了解的通过 <code>extends</code> 获得的继承相比，这是内建对象之间继承的一个重要区别。</p>

      </fieldset>
      
      <fieldset id='_o90nC0'>
      <legend>solution</legend>
      <p>是的，看起来确实很奇怪。</p>
<p><code>instanceof</code> 并不关心函数，而是关心函数的与原型链匹配的 <code>prototype</code>。</p>
<p>并且，这里 <code>a.__proto__ == B.prototype</code>，所以 <code>instanceof</code> 返回 <code>true</code>。</p>
<p>总之，根据 <code>instanceof</code> 的逻辑，真正决定类型的是 <code>prototype</code>，而不是构造函数。</p>

      </fieldset>
      
      <fieldset id='_RMbyJo'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="不按套路出牌的-instanceof">不按套路出牌的 instanceof</h1>
<p>在下面的代码中，为什么 <code>instanceof</code> 会返回 <code>true</code>？我们可以明显看到，<code>a</code> 并不是通过 <code>B()</code> 创建的。</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>{}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span>(<span class="hljs-params"></span>) </span>{}

A.prototype = B.prototype = {};

<span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> A();

*!*
alert( a <span class="hljs-keyword">instanceof</span> B ); <span class="hljs-comment">// true</span>
*/!*</code></pre>

      </fieldset>
      
      <fieldset id='_HKmy8y'>
      <legend>article</legend>
      <h1 id="类检查：instanceof">类检查：&quot;instanceof&quot;</h1>
<p><code>instanceof</code> 操作符用于检查一个对象是否属于某个特定的 class。同时，它还考虑了继承。</p>
<p>在许多情况下，可能都需要进行此类检查。在这儿，我们将使用它来构建一个 <strong>多态性（polymorphic）</strong> 的函数，该函数根据参数的类型对参数进行不同的处理。</p>
<h2 id="instanceof-操作符-ref-instanceof">instanceof 操作符 [#ref-instanceof]</h2>
<p>语法：</p>
<pre><code class="language-js">obj <span class="hljs-keyword">instanceof</span> Class</code></pre>
<p>如果 <code>obj</code> 隶属于 <code>Class</code> 类（或 <code>Class</code> 类的衍生类），则返回 <code>true</code>。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rabbit</span> </span>{}
<span class="hljs-keyword">let</span> rabbit = <span class="hljs-keyword">new</span> Rabbit();

<span class="hljs-comment">// rabbit 是 Rabbit class 的对象吗？</span>
*!*
alert( rabbit <span class="hljs-keyword">instanceof</span> Rabbit ); <span class="hljs-comment">// true</span>
*/!*</code></pre>
<p>它还可以与构造函数一起使用：</p>
<pre><code class="language-js">*!*
<span class="hljs-comment">// 这里是构造函数，而不是 class</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rabbit</span>(<span class="hljs-params"></span>) </span>{}
*/!*

alert( <span class="hljs-keyword">new</span> Rabbit() <span class="hljs-keyword">instanceof</span> Rabbit ); <span class="hljs-comment">// true</span></code></pre>
<p>……与诸如 <code>Array</code> 之类的内建 class 一起使用：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
alert( arr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> ); <span class="hljs-comment">// true</span>
alert( arr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> ); <span class="hljs-comment">// true</span></code></pre>
<p>有一点需要留意，<code>arr</code> 同时还隶属于 <code>Object</code> 类。因为从原型上来讲，<code>Array</code> 是继承自 <code>Object</code> 的。</p>
<p>通常，<code>instanceof</code> 在检查中会将原型链考虑在内。此外，我们还可以在静态方法 <code>Symbol.hasInstance</code> 中设置自定义逻辑。</p>
<p><code>obj instanceof Class</code> 算法的执行过程大致如下：</p>
<ol>
<li><p>如果这儿有静态方法 <code>Symbol.hasInstance</code>，那就直接调用这个方法：</p>
<p> 例如：</p>
<pre><code class="language-js"><span class="hljs-comment">// 设置 instanceOf 检查</span>
<span class="hljs-comment">// 并假设具有 canEat 属性的都是 animal</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{
  <span class="hljs-keyword">static</span> [<span class="hljs-built_in">Symbol</span>.hasInstance](obj) {
    <span class="hljs-keyword">if</span> (obj.canEat) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
}

<span class="hljs-keyword">let</span> obj = { <span class="hljs-attr">canEat</span>: <span class="hljs-literal">true</span> };

alert(obj <span class="hljs-keyword">instanceof</span> Animal); <span class="hljs-comment">// true：Animal[Symbol.hasInstance](obj) 被调用</span></code></pre>
</li>
<li><p>大多数 class 没有 <code>Symbol.hasInstance</code>。在这种情况下，标准的逻辑是：使用 <code>obj instanceOf Class</code> 检查 <code>Class.prototype</code> 是否等于 <code>obj</code> 的原型链中的原型之一。</p>
<p> 换句话说就是，一个接一个地比较：</p>
<pre><code class="language-js">obj.__proto__ === Class.prototype?
obj.__proto__.__proto__ === Class.prototype?
obj.__proto__.__proto__.__proto__ === Class.prototype?
...
<span class="hljs-comment">// 如果任意一个的答案为 true，则返回 true</span>
<span class="hljs-comment">// 否则，如果我们已经检查到了原型链的尾端，则返回 false</span></code></pre>
<p> 在上面那个例子中，<code>rabbit.__proto__ === Rabbit.prototype</code>，所以立即就给出了结果。</p>
<p> 而在继承的例子中，匹配将在第二步进行：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rabbit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>{}

<span class="hljs-keyword">let</span> rabbit = <span class="hljs-keyword">new</span> Rabbit();
*!*
alert(rabbit <span class="hljs-keyword">instanceof</span> Animal); <span class="hljs-comment">// true</span>
*/!*

<span class="hljs-comment">// rabbit.__proto__ === Rabbit.prototype</span>
*!*
<span class="hljs-comment">// rabbit.__proto__.__proto__ === Animal.prototype（匹配！）</span>
*/!*</code></pre>
</li>
</ol>
<p>下图展示了 <code>rabbit instanceof Animal</code> 的执行过程中，<code>Animal.prototype</code> 是如何参与比较的：</p>
<p><img src="instanceof.svg" alt=""></p>
<p>这里还要提到一个方法 <a href="mdn:js/object/isPrototypeOf">objA.isPrototypeOf(objB)</a>，如果 <code>objA</code> 处在 <code>objB</code> 的原型链中，则返回 <code>true</code>。所以，可以将 <code>obj instanceof Class</code> 检查改为 <code>Class.prototype.isPrototypeOf(obj)</code>。</p>
<p>这很有趣，但是 <code>Class</code> 的 constructor 自身是不参与检查的！检查过程只和原型链以及 <code>Class.prototype</code> 有关。</p>
<p>创建对象后，如果更改 <code>prototype</code> 属性，可能会导致有趣的结果。</p>
<p>就像这样：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rabbit</span>(<span class="hljs-params"></span>) </span>{}
<span class="hljs-keyword">let</span> rabbit = <span class="hljs-keyword">new</span> Rabbit();

<span class="hljs-comment">// 修改了 prototype</span>
Rabbit.prototype = {};

<span class="hljs-comment">// ...再也不是 rabbit 了！</span>
*!*
alert( rabbit <span class="hljs-keyword">instanceof</span> Rabbit ); <span class="hljs-comment">// false</span>
*/!*</code></pre>
<h2 id="福利：使用-objectprototypetostring-方法来揭示类型">福利：使用 Object.prototype.toString 方法来揭示类型</h2>
<p>大家都知道，一个普通对象被转化为字符串时为 <code>[object Object]</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> obj = {};

alert(obj); <span class="hljs-comment">// [object Object]</span>
alert(obj.toString()); <span class="hljs-comment">// 同上</span></code></pre>
<p>这是通过 <code>toString</code> 方法实现的。但是这儿有一个隐藏的功能，该功能可以使 <code>toString</code> 实际上比这更强大。我们可以将其作为 <code>typeof</code> 的增强版或者 <code>instanceof</code> 的替代方法来使用。</p>
<p>听起来挺不可思议？那是自然，精彩马上揭晓。</p>
<p>按照 <a href="https://tc39.github.io/ecma262/#sec-object.prototype.tostring">规范</a> 所讲，内建的 <code>toString</code> 方法可以被从对象中提取出来，并在任何其他值的上下文中执行。其结果取决于该值。</p>
<ul>
<li>对于 number 类型，结果是 <code>[object Number]</code></li>
<li>对于 boolean 类型，结果是 <code>[object Boolean]</code></li>
<li>对于 <code>null</code>：<code>[object Null]</code></li>
<li>对于 <code>undefined</code>：<code>[object Undefined]</code></li>
<li>对于数组：<code>[object Array]</code></li>
<li>……等（可自定义）</li>
</ul>
<p>让我们演示一下：</p>
<pre><code class="language-js"><span class="hljs-comment">// 方便起见，将 toString 方法复制到一个变量中</span>
<span class="hljs-keyword">let</span> objectToString = <span class="hljs-built_in">Object</span>.prototype.toString;

<span class="hljs-comment">// 它是什么类型的？</span>
<span class="hljs-keyword">let</span> arr = [];

alert( objectToString.call(arr) ); <span class="hljs-comment">// [object *!*Array*/!*]</span></code></pre>
<p>这里我们用到了在 <a href="info:call-apply-decorators"></a> 一章中讲过的 <a href="mdn:js/function/call">call</a> 方法来在上下文 <code>this=arr</code> 中执行函数 <code>objectToString</code>。</p>
<p>在内部，<code>toString</code> 的算法会检查 <code>this</code>，并返回相应的结果。再举几个例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> s = <span class="hljs-built_in">Object</span>.prototype.toString;

alert( s.call(<span class="hljs-number">123</span>) ); <span class="hljs-comment">// [object Number]</span>
alert( s.call(<span class="hljs-literal">null</span>) ); <span class="hljs-comment">// [object Null]</span>
alert( s.call(alert) ); <span class="hljs-comment">// [object Function]</span></code></pre>
<h3 id="symboltostringtag">Symbol.toStringTag</h3>
<p>可以使用特殊的对象属性 <code>Symbol.toStringTag</code> 自定义对象的 <code>toString</code> 方法的行为。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  [<span class="hljs-built_in">Symbol</span>.toStringTag]: <span class="hljs-string">&quot;User&quot;</span>
};

alert( {}.toString.call(user) ); <span class="hljs-comment">// [object User]</span></code></pre>
<p>对于大多数特定于环境的对象，都有一个这样的属性。下面是一些特定于浏览器的示例：</p>
<pre><code class="language-js"><span class="hljs-comment">// 特定于环境的对象和类的 toStringTag：</span>
alert( <span class="hljs-built_in">window</span>[<span class="hljs-built_in">Symbol</span>.toStringTag]); <span class="hljs-comment">// Window</span>
alert( XMLHttpRequest.prototype[<span class="hljs-built_in">Symbol</span>.toStringTag] ); <span class="hljs-comment">// XMLHttpRequest</span>

alert( {}.toString.call(<span class="hljs-built_in">window</span>) ); <span class="hljs-comment">// [object Window]</span>
alert( {}.toString.call(<span class="hljs-keyword">new</span> XMLHttpRequest()) ); <span class="hljs-comment">// [object XMLHttpRequest]</span></code></pre>
<p>正如我们所看到的，输出结果恰好是 <code>Symbol.toStringTag</code>（如果存在），只不过被包裹进了 <code>[object ...]</code> 里。</p>
<p>这样一来，我们手头上就有了个“磕了药似的 typeof”，不仅能检查原始数据类型，而且适用于内建对象，更可贵的是还支持自定义。</p>
<p>所以，如果我们想要获取内建对象的类型，并希望把该信息以字符串的形式返回，而不只是检查类型的话，我们可以用 <code>{}.toString.call</code> 替代 <code>instanceof</code>。</p>
<h2 id="总结">总结</h2>
<p>让我们总结一下我们知道的类型检查方法：</p>
<table>
<thead>
<tr>
<th></th>
<th>用于</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td><code>typeof</code></td>
<td>原始数据类型</td>
<td>string</td>
</tr>
<tr>
<td><code>{}.toString</code></td>
<td>原始数据类型，内建对象，包含 <code>Symbol.toStringTag</code> 属性的对象</td>
<td>string</td>
</tr>
<tr>
<td><code>instanceof</code></td>
<td>对象</td>
<td>true/false</td>
</tr>
</tbody></table>
<p>正如我们所看到的，从技术上讲，<code>{}.toString</code> 是一种“更高级的” <code>typeof</code>。</p>
<p>当我们使用类的层次结构（hierarchy），并想要对该类进行检查，同时还要考虑继承时，这种场景下 <code>instanceof</code> 操作符确实很出色。</p>

      </fieldset>
      
      <fieldset id='_U01WN7'>
      <legend>article</legend>
      <h1 id="mixin-模式">Mixin 模式</h1>
<p>在 JavaScript 中，我们只能继承单个对象。每个对象只能有一个 <code>[[Prototype]]</code>。并且每个类只可以扩展另外一个类。</p>
<p>但是有些时候这种设定（译注：单继承）会让人感到受限制。例如，我有一个 <code>StreetSweeper</code> 类和一个 <code>Bicycle</code> 类，现在想要一个它们的 mixin：<code>StreetSweepingBicycle</code> 类。</p>
<p>或者，我们有一个 <code>User</code> 类和一个 <code>EventEmitter</code> 类来实现事件生成（event generation），并且我们想将 <code>EventEmitter</code> 的功能添加到 <code>User</code> 中，以便我们的用户可以触发事件（emit event）。</p>
<p>有一个概念可以帮助我们，叫做 &quot;mixins&quot;。</p>
<p>根据维基百科的定义，<a href="https://en.wikipedia.org/wiki/Mixin">mixin</a> 是一个包含可被其他类使用而无需继承的方法的类。</p>
<p>换句话说，<em>mixin</em> 提供了实现特定行为的方法，但是我们不单独使用它，而是使用它来将这些行为添加到其他类中。</p>
<h2 id="一个-mixin-实例">一个 Mixin 实例</h2>
<p>在 JavaScript 中构造一个 mixin 最简单的方式就是构造一个拥有实用方法的对象，以便我们可以轻松地将这些实用的方法合并到任何类的原型中。</p>
<p>例如，这个名为 <code>sayHiMixin</code> 的 mixin 用于给 <code>User</code> 添加一些“语言功能”：</p>
<pre><code class="language-js">*!*
<span class="hljs-comment">// mixin</span>
*/!*
<span class="hljs-keyword">let</span> sayHiMixin = {
  <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> {
    alert(<span class="hljs-string">`Hello <span class="hljs-subst">${<span class="hljs-built_in">this</span>.name}</span>`</span>);
  },
  <span class="hljs-function"><span class="hljs-title">sayBye</span>(<span class="hljs-params"></span>)</span> {
    alert(<span class="hljs-string">`Bye <span class="hljs-subst">${<span class="hljs-built_in">this</span>.name}</span>`</span>);
  }
};

*!*
<span class="hljs-comment">// 用法：</span>
*/!*
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> {
    <span class="hljs-built_in">this</span>.name = name;
  }
}

<span class="hljs-comment">// 拷贝方法</span>
<span class="hljs-built_in">Object</span>.assign(User.prototype, sayHiMixin);

<span class="hljs-comment">// 现在 User 可以打招呼了</span>
<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Dude&quot;</span>).sayHi(); <span class="hljs-comment">// Hello Dude!</span></code></pre>
<p>这里没有继承，只有一个简单的方法拷贝。所以 <code>User</code> 可以从另一个类继承，还可以包括 mixin 来 &quot;mix-in“ 其它方法，就像这样：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>{
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-built_in">Object</span>.assign(User.prototype, sayHiMixin);</code></pre>
<p>Mixin 可以在自己内部使用继承。</p>
<p>例如，这里的 <code>sayHiMixin</code> 继承自 <code>sayMixin</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> sayMixin = {
  <span class="hljs-function"><span class="hljs-title">say</span>(<span class="hljs-params">phrase</span>)</span> {
    alert(phrase);
  }
};

<span class="hljs-keyword">let</span> sayHiMixin = {
  <span class="hljs-attr">__proto__</span>: sayMixin, <span class="hljs-comment">// (或者，我们可以在这儿使用 Object.create 来设置原型)</span>

  <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> {
    *!*
    <span class="hljs-comment">// 调用父类方法</span>
    */!*
    <span class="hljs-built_in">super</span>.say(<span class="hljs-string">`Hello <span class="hljs-subst">${<span class="hljs-built_in">this</span>.name}</span>`</span>); <span class="hljs-comment">// (*)</span>
  },
  <span class="hljs-function"><span class="hljs-title">sayBye</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-built_in">super</span>.say(<span class="hljs-string">`Bye <span class="hljs-subst">${<span class="hljs-built_in">this</span>.name}</span>`</span>); <span class="hljs-comment">// (*)</span>
  }
};

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> {
    <span class="hljs-built_in">this</span>.name = name;
  }
}

<span class="hljs-comment">// 拷贝方法</span>
<span class="hljs-built_in">Object</span>.assign(User.prototype, sayHiMixin);

<span class="hljs-comment">// 现在 User 可以打招呼了</span>
<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;Dude&quot;</span>).sayHi(); <span class="hljs-comment">// Hello Dude!</span></code></pre>
<p>请注意，在 <code>sayHiMixin</code> 内部对父类方法 <code>super.say()</code> 的调用（在标有 <code>(*)</code> 的行）会在 mixin 的原型中查找方法，而不是在 class 中查找。</p>
<p>这是示意图（请参见图中右侧部分）：</p>
<p><img src="mixin-inheritance.svg" alt=""></p>
<p>这是因为方法 <code>sayHi</code> 和 <code>sayBye</code> 最初是在 <code>sayHiMixin</code> 中创建的。因此，即使复制了它们，但是它们的 <code>[[HomeObject]]</code> 内部属性仍引用的是 <code>sayHiMixin</code>，如上图所示。</p>
<p>当 <code>super</code> 在 <code>[[HomeObject]].[[Prototype]]</code> 中寻找父方法时，意味着它搜索的是 <code>sayHiMixin.[[Prototype]]</code>，而不是 <code>User.[[Prototype]]</code>。</p>
<h2 id="eventmixin">EventMixin</h2>
<p>现在让我们为实际运用构造一个 mixin。</p>
<p>例如，许多浏览器对象的一个重要功能是它们可以生成事件。事件是向任何有需要的人“广播信息”的好方法。因此，让我们构造一个 mixin，使我们能够轻松地将与事件相关的函数添加到任意 class/object 中。</p>
<ul>
<li>Mixin 将提供 <code>.trigger(name, [...data])</code> 方法，以在发生重要的事情时“生成一个事件”。<code>name</code> 参数（arguments）是事件的名称，<code>[...data]</code> 是可选的带有事件数据的其他参数（arguments）。</li>
<li>此外还有 <code>.on(name, handler)</code> 方法，它为具有给定名称的事件添加了 <code>handler</code> 函数作为监听器（listener）。当具有给定 <code>name</code> 的事件触发时将调用该方法，并从 <code>.trigger</code> 调用中获取参数（arguments）。</li>
<li>……还有 <code>.off(name, handler)</code> 方法，它会删除 <code>handler</code> 监听器（listener）。</li>
</ul>
<p>添加完 mixin 后，对象 <code>user</code> 将能够在访客登录时生成事件 <code>&quot;login&quot;</code>。另一个对象，例如 <code>calendar</code> 可能希望监听此类事件以便为登录的人加载日历。</p>
<p>或者，当一个菜单项被选中时，<code>menu</code> 可以生成 <code>&quot;select&quot;</code> 事件，其他对象可以分配处理程序以对该事件作出反应。诸如此类。</p>
<p>下面是代码：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> eventMixin = {
  <span class="hljs-comment">/**
   * 订阅事件，用法：
   *  menu.on(&#x27;select&#x27;, function(item) { ... }
  */</span>
  <span class="hljs-function"><span class="hljs-title">on</span>(<span class="hljs-params">eventName, handler</span>)</span> {
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>._eventHandlers) <span class="hljs-built_in">this</span>._eventHandlers = {};
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>._eventHandlers[eventName]) {
      <span class="hljs-built_in">this</span>._eventHandlers[eventName] = [];
    }
    <span class="hljs-built_in">this</span>._eventHandlers[eventName].push(handler);
  },

  <span class="hljs-comment">/**
   * 取消订阅，用法：
   *  menu.off(&#x27;select&#x27;, handler)
   */</span>
  <span class="hljs-function"><span class="hljs-title">off</span>(<span class="hljs-params">eventName, handler</span>)</span> {
    <span class="hljs-keyword">let</span> handlers = <span class="hljs-built_in">this</span>._eventHandlers?.[eventName];
    <span class="hljs-keyword">if</span> (!handlers) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; handlers.length; i++) {
      <span class="hljs-keyword">if</span> (handlers[i] === handler) {
        handlers.splice(i--, <span class="hljs-number">1</span>);
      }
    }
  },

  <span class="hljs-comment">/**
   * 生成具有给定名称和数据的事件
   *  this.trigger(&#x27;select&#x27;, data1, data2);
   */</span>
  <span class="hljs-function"><span class="hljs-title">trigger</span>(<span class="hljs-params">eventName, ...args</span>)</span> {
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>._eventHandlers || !<span class="hljs-built_in">this</span>._eventHandlers[eventName]) {
      <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 该事件名称没有对应的事件处理程序（handler）</span>
    }

    <span class="hljs-comment">// 调用事件处理程序（handler）</span>
    <span class="hljs-built_in">this</span>._eventHandlers[eventName].forEach(<span class="hljs-function"><span class="hljs-params">handler</span> =&gt;</span> handler.apply(<span class="hljs-built_in">this</span>, args));
  }
};</code></pre>
<ol>
<li><code>.on(eventName, handler)</code> — 指定函数 <code>handler</code> 以在具有对应名称的事件发生时运行。从技术上讲，这儿有一个用于存储每个事件名称对应的处理程序（handler）的 <code>_eventHandlers</code> 属性，在这儿该属性就会将刚刚指定的这个 <code>handler</code> 添加到列表中。</li>
<li><code>.off(eventName, handler)</code> — 从处理程序列表中删除指定的函数。</li>
<li><code>.trigger(eventName, ...args)</code> — 生成事件：所有 <code>_eventHandlers[eventName]</code> 中的事件处理程序（handler）都被调用，并且 <code>...args</code> 会被作为参数传递给它们。</li>
</ol>
<p>用法：</p>
<pre><code class="language-js"><span class="hljs-comment">// 创建一个 class</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Menu</span> </span>{
  <span class="hljs-function"><span class="hljs-title">choose</span>(<span class="hljs-params">value</span>)</span> {
    <span class="hljs-built_in">this</span>.trigger(<span class="hljs-string">&quot;select&quot;</span>, value);
  }
}
<span class="hljs-comment">// 添加带有事件相关方法的 mixin</span>
<span class="hljs-built_in">Object</span>.assign(Menu.prototype, eventMixin);

<span class="hljs-keyword">let</span> menu = <span class="hljs-keyword">new</span> Menu();

<span class="hljs-comment">// 添加一个事件处理程序（handler），在被选择时被调用：</span>
*!*
menu.on(<span class="hljs-string">&quot;select&quot;</span>, <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> alert(<span class="hljs-string">`Value selected: <span class="hljs-subst">${value}</span>`</span>));
*/!*

<span class="hljs-comment">// 触发事件 =&gt; 运行上述的事件处理程序（handler）并显示：</span>
<span class="hljs-comment">// 被选中的值：123</span>
menu.choose(<span class="hljs-string">&quot;123&quot;</span>);</code></pre>
<p>现在，如果我们希望任何代码对菜单选择作出反应，我们可以使用 <code>menu.on(...)</code> 进行监听。</p>
<p>使用 <code>eventMixin</code> 可以轻松地将此类行为添加到我们想要的多个类中，并且不会影响继承链。</p>
<h2 id="总结">总结</h2>
<p><em>Mixin</em> — 是一个通用的面向对象编程术语：一个包含其他类的方法的类。</p>
<p>一些其它编程语言允许多重继承。JavaScript 不支持多重继承，但是可以通过将方法拷贝到原型中来实现 mixin。</p>
<p>我们可以使用 mixin 作为一种通过添加多种行为（例如上文中所提到的事件处理）来扩充类的方法。</p>
<p>如果 Mixins 意外覆盖了现有类的方法，那么它们可能会成为一个冲突点。因此，通常应该仔细考虑 mixin 的命名方法，以最大程度地降低发生这种冲突的可能性。</p>

      </fieldset>
      
      <fieldset id='_0e1Vxe'>
      <legend>solution</legend>
      <p>当我们看函数中的代码时，差异就变得很明显了。</p>
<p>如果在这儿有“跳出” <code>try..catch</code> 的行为，那么这两种方式的表现就不同了。</p>
<p>例如，当 <code>try..catch</code> 中有 <code>return</code> 时。<code>finally</code> 子句会在 <code>try..catch</code> 的 <strong>任意</strong> 出口处起作用，即使是通过 <code>return</code> 语句退出的也是如此：在 <code>try..catch</code> 刚刚执行完成后，但在调用代码获得控制权之前。</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    alert(<span class="hljs-string">&#x27;start&#x27;</span>);
*!*
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;result&quot;</span>;
*/!*
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-comment">/// ...</span>
  } <span class="hljs-keyword">finally</span> {
    alert(<span class="hljs-string">&#x27;cleanup!&#x27;</span>);
  }
}

f(); <span class="hljs-comment">// cleanup!</span></code></pre>
<p>……或者当有 <code>throw</code> 时，如下所示：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    alert(<span class="hljs-string">&#x27;start&#x27;</span>);
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;an error&quot;</span>);
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params"><span class="hljs-string">&quot;can&#x27;t handle the error&quot;</span></span>)</span> {
*!*
      <span class="hljs-keyword">throw</span> e;
*/!*
    }

  } <span class="hljs-keyword">finally</span> {
    alert(<span class="hljs-string">&#x27;cleanup!&#x27;</span>)
  }
}

f(); <span class="hljs-comment">// cleanup!</span></code></pre>
<p>正是这里的 <code>finally</code> 保证了 cleanup。如果我们只是将代码放在函数 <code>f</code> 的末尾，则在这些情况下它不会运行。</p>

      </fieldset>
      
      <fieldset id='_Ka3vaq'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="使用-finally-还是直接放在代码后面？">使用 finally 还是直接放在代码后面？</h1>
<p>比较下面两个代码片段。</p>
<ol>
<li><p>第一个代码片段，使用 <code>finally</code> 在 <code>try..catch</code> 之后执行代码：</p>
<pre><code class="language-js"><span class="hljs-keyword">try</span> {
  work work
} <span class="hljs-keyword">catch</span> (e) {
  handle errors
} <span class="hljs-keyword">finally</span> {
*!*
  cleanup the working space
*/!*
}</code></pre>
</li>
<li><p>第二个代码片段，将清空工作空间的代码放在了 <code>try..catch</code> 之后：</p>
<pre><code class="language-js"><span class="hljs-keyword">try</span> {
  work work
} <span class="hljs-keyword">catch</span> (e) {
  handle errors
}

*!*
cleanup the working space
*/!*</code></pre>
</li>
</ol>
<p>我们肯定需要在工作后进行清理，无论工作过程中是否有 error 都不影响。</p>
<p>在这儿使用 <code>finally</code> 更有优势，还是说两个代码片段效果一样？如果在这儿有这样的优势，如果需要，请举例说明。</p>

      </fieldset>
      
      <fieldset id='_ioBFzS'>
      <legend>article</legend>
      <h1 id="错误处理，trycatch">错误处理，&quot;try..catch&quot;</h1>
<p>不管你多么精通编程，有时我们的脚本总还是会出现错误。可能是因为我们的编写出错，或是与预期不同的用户输入，或是错误的服务端响应以及其他数千种原因。</p>
<p>通常，如果发生错误，脚本就会“死亡”（立即停止），并在控制台将错误打印出来。</p>
<p>但是有一种语法结构 <code>try..catch</code>，它使我们可以“捕获（catch）”错误，因此脚本可以执行更合理的操作，而不是死掉。</p>
<h2 id="trycatch-语法">&quot;try..catch&quot; 语法</h2>
<p><code>try..catch</code> 结构由两部分组成：<code>try</code> 和 <code>catch</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">try</span> {

  <span class="hljs-comment">// 代码...</span>

} <span class="hljs-keyword">catch</span> (err) {

  <span class="hljs-comment">// 错误捕获</span>

}</code></pre>
<p>它按照以下步骤执行：</p>
<ol>
<li>首先，执行 <code>try {...}</code> 中的代码。</li>
<li>如果这里没有错误，则忽略 <code>catch(err)</code>：执行到 <code>try</code> 的末尾并跳过 <code>catch</code> 继续执行。</li>
<li>如果这里出现错误，则 <code>try</code> 执行停止，控制流转向 <code>catch(err)</code> 的开头。变量 <code>err</code>（我们可以使用任何名称）将包含一个 error 对象，该对象包含了所发生事件的详细信息。</li>
</ol>
<p><img src="try-catch-flow.svg" alt=""></p>
<p>所以，<code>try {…}</code> 块内的错误不会杀死脚本 — 我们有机会在 <code>catch</code> 中处理它。</p>
<p>让我们来看一些例子。</p>
<ul>
<li><p>没有 error 的例子：显示 <code>alert</code> <code>(1)</code> 和 <code>(2)</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">try</span> {

  alert(<span class="hljs-string">&#x27;Start of try runs&#x27;</span>);  <span class="hljs-comment">// *!*(1) &lt;--*/!*</span>

  <span class="hljs-comment">// ...这里没有 error</span>

  alert(<span class="hljs-string">&#x27;End of try runs&#x27;</span>);   <span class="hljs-comment">// *!*(2) &lt;--*/!*</span>

} <span class="hljs-function"><span class="hljs-title">catch</span>(<span class="hljs-params">err</span>)</span> {

  alert(<span class="hljs-string">&#x27;Catch is ignored, because there are no errors&#x27;</span>); <span class="hljs-comment">// (3)</span>

}</code></pre>
</li>
<li><p>包含 error 的例子：显示 <code>(1)</code> 和 <code>(3)</code> 行的 <code>alert</code> 中的内容：</p>
<pre><code class="language-js"><span class="hljs-keyword">try</span> {

  alert(<span class="hljs-string">&#x27;Start of try runs&#x27;</span>);  <span class="hljs-comment">// *!*(1) &lt;--*/!*</span>

*!*
  lalala; <span class="hljs-comment">// Error，变量未定义！</span>
*/!*

  alert(<span class="hljs-string">&#x27;End of try (never reached)&#x27;</span>);  <span class="hljs-comment">// (2)</span>

} <span class="hljs-function"><span class="hljs-title">catch</span>(<span class="hljs-params">err</span>)</span> {

  alert(<span class="hljs-string">`Error has occurred!`</span>); <span class="hljs-comment">// *!*(3) &lt;--*/!*</span>

}</code></pre>
</li>
</ul>
<p>````warn header=&quot;<code>try..catch</code> 仅对运行时的 error 有效&quot;
要使得 <code>try..catch</code> 能工作，代码必须是可执行的。换句话说，它必须是有效的 JavaScript 代码。</p>
<p>如果代码包含语法错误，那么 <code>try..catch</code> 将无法正常工作，例如含有不匹配的花括号：</p>
<pre><code class="language-js"><span class="hljs-keyword">try</span> {
  error
} <span class="hljs-function"><span class="hljs-title">catch</span>(<span class="hljs-params">e</span>)</span> {
  alert(<span class="hljs-string">&quot;The engine can&#x27;t understand this code, it&#x27;s invalid&quot;</span>);
}</code></pre>
<p>JavaScript 引擎首先会读取代码，然后运行它。在读取阶段发生的错误被称为“解析时间（parse-time）”错误，并且无法恢复（从该代码内部）。这是因为引擎无法理解该代码。</p>
<p>所以，<code>try..catch</code> 只能处理有效代码中出现的错误。这类错误被称为“运行时的错误（runtime errors）”，有时被称为“异常（exceptions）”。</p>
<pre><code>

````warn header=&quot;`try..catch` 同步工作&quot;
如果在“计划的（scheduled）”代码中发生异常，例如在 `setTimeout` 中，则 `try..catch` 不会捕获到异常：

```js run
try {
  setTimeout(function() {
    noSuchVariable; // 脚本将在这里停止运行
  }, 1000);
} catch (e) {
  alert( &quot;won&#x27;t work&quot; );
}
```

因为 `try..catch` 包裹了计划要执行的函数，该函数本身要稍后才执行，这时引擎已经离开了 `try..catch` 结构。

为了捕获到计划的（scheduled）函数中的异常，那么 `try..catch` 必须在这个函数内：
```js run
setTimeout(function() {
  try {
    noSuchVariable; // try..catch 处理 error 了！
  } catch {
    alert( &quot;error is caught here!&quot; );
  }
}, 1000);
```</code></pre>
<h2 id="error-对象">Error 对象</h2>
<p>发生错误时，JavaScript 生成一个包含有关其详细信息的对象。然后将该对象作为参数传递给 <code>catch</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">try</span> {
  <span class="hljs-comment">// ...</span>
} <span class="hljs-function"><span class="hljs-title">catch</span>(<span class="hljs-params">err</span>)</span> { <span class="hljs-comment">// &lt;-- “error 对象”，也可以用其他参数名代替 err</span>
  <span class="hljs-comment">// ...</span>
}</code></pre>
<p>对于所有内建的 error，error 对象具有两个主要属性：</p>
<p><code>name</code>
: Error 名称。例如，对于一个未定义的变量，名称是 <code>&quot;ReferenceError&quot;</code>。</p>
<p><code>message</code>
: 关于 error 的详细文字描述。</p>
<p>还有其他非标准的属性在大多数环境中可用。其中被最广泛使用和支持的是：</p>
<p><code>stack</code>
: 当前的调用栈：用于调试目的的一个字符串，其中包含有关导致 error 的嵌套调用序列的信息。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">try</span> {
*!*
  lalala; <span class="hljs-comment">// error, variable is not defined!</span>
*/!*
} <span class="hljs-function"><span class="hljs-title">catch</span>(<span class="hljs-params">err</span>)</span> {
  alert(err.name); <span class="hljs-comment">// ReferenceError</span>
  alert(err.message); <span class="hljs-comment">// lalala is not defined</span>
  alert(err.stack); <span class="hljs-comment">// ReferenceError: lalala is not defined at (...call stack)</span>

  <span class="hljs-comment">// 也可以将一个 error 作为整体显示出来as a whole</span>
  <span class="hljs-comment">// Error 信息被转换为像 &quot;name: message&quot; 这样的字符串</span>
  alert(err); <span class="hljs-comment">// ReferenceError: lalala is not defined</span>
}</code></pre>
<h2 id="可选的-catch-绑定">可选的 &quot;catch&quot; 绑定</h2>
<p>[recent browser=new]</p>
<p>如果我们不需要 error 的详细信息，<code>catch</code> 也可以忽略它：</p>
<pre><code class="language-js"><span class="hljs-keyword">try</span> {
  <span class="hljs-comment">// ...</span>
} <span class="hljs-keyword">catch</span> { <span class="hljs-comment">// &lt;-- 没有 (err)</span>
  <span class="hljs-comment">// ...</span>
}</code></pre>
<h2 id="使用-trycatch">使用 &quot;try..catch&quot;</h2>
<p>让我们一起探究一下真实场景中 <code>try..catch</code> 的用例。</p>
<p>正如我们所知道的，JavaScript 支持 <a href="mdn:js/JSON/parse">JSON.parse(str)</a> 方法来解析 JSON 编码的值。</p>
<p>通常，它被用来解析从网络，从服务器或是从其他来源接收到的数据。</p>
<p>我们收到数据后，然后像下面这样调用 <code>JSON.parse</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> json = <span class="hljs-string">&#x27;{&quot;name&quot;:&quot;John&quot;, &quot;age&quot;: 30}&#x27;</span>; <span class="hljs-comment">// 来自服务器的数据</span>

*!*
<span class="hljs-keyword">let</span> user = <span class="hljs-built_in">JSON</span>.parse(json); <span class="hljs-comment">// 将文本表示转换成 JS 对象</span>
*/!*

<span class="hljs-comment">// 现在 user 是一个解析自 json 字符串的有自己属性的对象</span>
alert( user.name ); <span class="hljs-comment">// John</span>
alert( user.age );  <span class="hljs-comment">// 30</span></code></pre>
<p>你可以在 <a href="info:json">info:json</a> 一章中找到更多关于 JSON 的详细内容。</p>
<p><strong>如果 <code>json</code> 格式错误，<code>JSON.parse</code> 就会生成一个 error，因此脚本就会“死亡”。</strong></p>
<p>我们对此满意吗？当然不！</p>
<p>如果这样做，当拿到的数据出了问题，那么访问者永远都不会知道原因（除非他们打开开发者控制台）。代码执行失败却没有提示信息，这真的是很糟糕的用户体验。</p>
<p>让我们用 <code>try..catch</code> 来处理这个 error：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> json = <span class="hljs-string">&quot;{ bad json }&quot;</span>;

<span class="hljs-keyword">try</span> {

*!*
  <span class="hljs-keyword">let</span> user = <span class="hljs-built_in">JSON</span>.parse(json); <span class="hljs-comment">// &lt;-- 当出现一个 error 时...</span>
*/!*
  alert( user.name ); <span class="hljs-comment">// 不工作</span>

} <span class="hljs-keyword">catch</span> (e) {
*!*
  <span class="hljs-comment">// ...执行会跳转到这里并继续执行</span>
  alert( <span class="hljs-string">&quot;Our apologies, the data has errors, we&#x27;ll try to request it one more time.&quot;</span> );
  alert( e.name );
  alert( e.message );
*/!*
}</code></pre>
<p>在这儿，我们将 <code>catch</code> 块仅仅用于显示信息，但是我们可以做更多的事儿：发送一个新的网络请求，向访问者建议一个替代方案，将有关错误的信息发送给记录日志的设备，……。所有这些都比代码“死掉”好得多。</p>
<h2 id="抛出我们自定义的-error">抛出我们自定义的 error</h2>
<p>如果这个 <code>json</code> 在语法上是正确的，但是没有所必须的 <code>name</code> 属性该怎么办？</p>
<p>像这样：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> json = <span class="hljs-string">&#x27;{ &quot;age&quot;: 30 }&#x27;</span>; <span class="hljs-comment">// 不完整的数据</span>

<span class="hljs-keyword">try</span> {

  <span class="hljs-keyword">let</span> user = <span class="hljs-built_in">JSON</span>.parse(json); <span class="hljs-comment">// &lt;-- 没有 error</span>
*!*
  alert( user.name ); <span class="hljs-comment">// 没有 name！</span>
*/!*

} <span class="hljs-keyword">catch</span> (e) {
  alert( <span class="hljs-string">&quot;doesn&#x27;t execute&quot;</span> );
}</code></pre>
<p>这里 <code>JSON.parse</code> 正常执行，但是缺少 <code>name</code> 属性对我们来说确实是个 error。</p>
<p>为了统一进行 error 处理，我们将使用 <code>throw</code> 操作符。</p>
<h3 id="throw-操作符">&quot;Throw&quot; 操作符</h3>
<p><code>throw</code> 操作符会生成一个 error 对象。</p>
<p>语法如下：</p>
<pre><code class="language-js"><span class="hljs-keyword">throw</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">error</span> <span class="hljs-attr">object</span>&gt;</span></span></code></pre>
<p>技术上讲，我们可以将任何东西用作 error 对象。甚至可以是一个原始类型数据，例如数字或字符串，但最好使用对象，最好使用具有 <code>name</code> 和 <code>message</code> 属性的对象（某种程度上保持与内建 error 的兼容性）。</p>
<p>JavaScript 中有很多内建的标准 error 的构造器：<code>Error</code>，<code>SyntaxError</code>，<code>ReferenceError</code>，<code>TypeError</code> 等。我们也可以使用它们来创建 error 对象。</p>
<p>它们的语法是：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(message);
<span class="hljs-comment">// 或</span>
<span class="hljs-keyword">let</span> error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SyntaxError</span>(message);
<span class="hljs-keyword">let</span> error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ReferenceError</span>(message);
<span class="hljs-comment">// ...</span></code></pre>
<p>对于内建的 error（不是对于其他任何对象，仅仅是对于 error），<code>name</code> 属性刚好就是构造器的名字。<code>message</code> 则来自于参数（argument）。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Things happen o_O&quot;</span>);

alert(error.name); <span class="hljs-comment">// Error</span>
alert(error.message); <span class="hljs-comment">// Things happen o_O</span></code></pre>
<p>让我们来看看 <code>JSON.parse</code> 会生成什么样的 error：</p>
<pre><code class="language-js"><span class="hljs-keyword">try</span> {
  <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">&quot;{ bad json o_O }&quot;</span>);
} <span class="hljs-function"><span class="hljs-title">catch</span>(<span class="hljs-params">e</span>)</span> {
*!*
  alert(e.name); <span class="hljs-comment">// SyntaxError</span>
*/!*
  alert(e.message); <span class="hljs-comment">// Unexpected token b in JSON at position 2</span>
}</code></pre>
<p>正如我们所看到的， 那是一个  <code>SyntaxError</code>。</p>
<p>在我们的示例中，缺少 <code>name</code> 属性就是一个 error，因为用户必须有一个 <code>name</code>。</p>
<p>所以，让我们抛出这个 error。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> json = <span class="hljs-string">&#x27;{ &quot;age&quot;: 30 }&#x27;</span>; <span class="hljs-comment">// 不完整的数据</span>

<span class="hljs-keyword">try</span> {

  <span class="hljs-keyword">let</span> user = <span class="hljs-built_in">JSON</span>.parse(json); <span class="hljs-comment">// &lt;-- 没有 error</span>

  <span class="hljs-keyword">if</span> (!user.name) {
*!*
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">SyntaxError</span>(<span class="hljs-string">&quot;Incomplete data: no name&quot;</span>); <span class="hljs-comment">// (*)</span>
*/!*
  }

  alert( user.name );

} <span class="hljs-function"><span class="hljs-title">catch</span>(<span class="hljs-params">e</span>)</span> {
  alert( <span class="hljs-string">&quot;JSON Error: &quot;</span> + e.message ); <span class="hljs-comment">// JSON Error: Incomplete data: no name</span>
}</code></pre>
<p>在 <code>(*)</code> 标记的这一行，<code>throw</code> 操作符生成了包含着我们所给定的 <code>message</code> 的 <code>SyntaxError</code>，与 JavaScript 自己生成的方式相同。<code>try</code> 的执行立即停止，控制流转向 <code>catch</code> 块。</p>
<p>现在，<code>catch</code> 成为了所有 error 处理的唯一场所：对于 <code>JSON.parse</code> 和其他情况都适用。</p>
<h2 id="再次抛出（rethrowing）">再次抛出（Rethrowing）</h2>
<p>在上面的例子中，我们使用 <code>try..catch</code> 来处理不正确的数据。但是在 <code>try {...}</code> 块中是否可能发生 <strong>另一个预料之外的 error</strong>？例如编程错误（未定义变量）或其他错误，而不仅仅是这种“不正确的数据”。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> json = <span class="hljs-string">&#x27;{ &quot;age&quot;: 30 }&#x27;</span>; <span class="hljs-comment">// 不完整的数据</span>

<span class="hljs-keyword">try</span> {
  user = <span class="hljs-built_in">JSON</span>.parse(json); <span class="hljs-comment">// &lt;-- 忘记在 user 前放置 &quot;let&quot;</span>

  <span class="hljs-comment">// ...</span>
} <span class="hljs-function"><span class="hljs-title">catch</span>(<span class="hljs-params">err</span>)</span> {
  alert(<span class="hljs-string">&quot;JSON Error: &quot;</span> + err); <span class="hljs-comment">// JSON Error: ReferenceError: user is not defined</span>
  <span class="hljs-comment">// (实际上并没有 JSON Error)</span>
}</code></pre>
<p>当然，一切皆有可能！程序员也会犯错。即使是被数百万人使用了几十年的开源项目中 — 也可能突然被发现了一个漏洞，并导致可怕的黑客入侵。</p>
<p>在我们的例子中，<code>try..catch</code> 旨在捕获“数据不正确”的 error。但是实际上，catch 会捕获到 <strong>所有</strong> 来自于 <code>try</code> 的 error。在这儿，它捕获到了一个预料之外的 error，但是仍然抛出的是同样的 <code>&quot;JSON Error&quot;</code> 信息。这是不正确的，并且也会使代码变得更难以调试。</p>
<p>为了避免此类问题，我们可以采用“重新抛出”技术。规则很简单：</p>
<p><strong><code>catch</code> 应该只处理它知道的 error，并“抛出”所有其他 error。</strong></p>
<p>“再次抛出（rethrowing）”技术可以被更详细地解释为：</p>
<ol>
<li>Catch 捕获所有 error。</li>
<li>在 <code>catch(err) {...}</code> 块中，我们对 error 对象 <code>err</code> 进行分析。</li>
<li>如果我们不知道如何处理它，那我们就 <code>throw err</code>。</li>
</ol>
<p>通常，我们可以使用 <code>instanceof</code> 操作符判断错误类型：</p>
<pre><code class="language-js"><span class="hljs-keyword">try</span> {
  user = { <span class="hljs-comment">/*...*/</span> };
} <span class="hljs-function"><span class="hljs-title">catch</span>(<span class="hljs-params">err</span>)</span> {
*!*
  <span class="hljs-keyword">if</span> (err <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">ReferenceError</span>) {
*/!*
    alert(<span class="hljs-string">&#x27;ReferenceError&#x27;</span>); <span class="hljs-comment">// 访问一个未定义（undefined）的变量产生了 &quot;ReferenceError&quot;</span>
  }
}</code></pre>
<p>我们还可以从 <code>err.name</code> 属性中获取错误的类名。所有原生的错误都有这个属性。另一种方式是读取 <code>err.constructor.name</code>。</p>
<p>在下面的代码中，我们使用“再次抛出”，以达到在 <code>catch</code> 中只处理 <code>SyntaxError</code> 的目的：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> json = <span class="hljs-string">&#x27;{ &quot;age&quot;: 30 }&#x27;</span>; <span class="hljs-comment">// 不完整的数据</span>
<span class="hljs-keyword">try</span> {

  <span class="hljs-keyword">let</span> user = <span class="hljs-built_in">JSON</span>.parse(json);

  <span class="hljs-keyword">if</span> (!user.name) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">SyntaxError</span>(<span class="hljs-string">&quot;Incomplete data: no name&quot;</span>);
  }

*!*
  blabla(); <span class="hljs-comment">// 预料之外的 error</span>
*/!*

  alert( user.name );

} <span class="hljs-function"><span class="hljs-title">catch</span>(<span class="hljs-params">e</span>)</span> {

*!*
  <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">SyntaxError</span>) {
    alert( <span class="hljs-string">&quot;JSON Error: &quot;</span> + e.message );
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">throw</span> e; <span class="hljs-comment">// 再次抛出 (*)</span>
  }
*/!*

}</code></pre>
<p>如果 <code>(*)</code> 标记的这行 <code>catch</code> 块中的 error 从 <code>try..catch</code> 中“掉了出来”，那么它也可以被外部的 <code>try..catch</code> 结构（如果存在）捕获到，如果外部不存在这种结构，那么脚本就会被杀死。</p>
<p>所以，<code>catch</code> 块实际上只处理它知道该如何处理的 error，并“跳过”所有其他的 error。</p>
<p>下面这个示例演示了这种类型的 error 是如何被另外一级 <code>try..catch</code> 捕获的：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readData</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> json = <span class="hljs-string">&#x27;{ &quot;age&quot;: 30 }&#x27;</span>;

  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// ...</span>
*!*
    blabla(); <span class="hljs-comment">// error!</span>
*/!*
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">if</span> (!(e <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">SyntaxError</span>)) {
*!*
      <span class="hljs-keyword">throw</span> e; <span class="hljs-comment">// 再次抛出（不知道如何处理它）</span>
*/!*
    }
  }
}

<span class="hljs-keyword">try</span> {
  readData();
} <span class="hljs-keyword">catch</span> (e) {
*!*
  alert( <span class="hljs-string">&quot;External catch got: &quot;</span> + e ); <span class="hljs-comment">// 捕获了它！</span>
*/!*
}</code></pre>
<p>上面这个例子中的 <code>readData</code> 只知道如何处理 <code>SyntaxError</code>，而外部的 <code>try..catch</code> 知道如何处理任意的 error。</p>
<h2 id="trycatchfinally">try..catch..finally</h2>
<p>等一下，以上并不是所有内容。</p>
<p><code>try..catch</code> 结构可能还有一个代码子句（clause）：<code>finally</code>。</p>
<p>如果它存在，它在所有情况下都会被执行：</p>
<ul>
<li><code>try</code> 之后，如果没有 error，</li>
<li><code>catch</code> 之后，如果没有 error。</li>
</ul>
<p>该扩展语法如下所示：</p>
<pre><code class="language-js">*!*<span class="hljs-keyword">try</span>*/!* {
   ... 尝试执行的代码 ...
} *!*<span class="hljs-keyword">catch</span>*/!*(e) {
   ... 处理 error ...
} *!*<span class="hljs-keyword">finally</span>*/!* {
   ... 总是会执行的代码 ...
}</code></pre>
<p>试试运行这段代码：</p>
<pre><code class="language-js"><span class="hljs-keyword">try</span> {
  alert( <span class="hljs-string">&#x27;try&#x27;</span> );
  <span class="hljs-keyword">if</span> (confirm(<span class="hljs-string">&#x27;Make an error?&#x27;</span>)) BAD_CODE();
} <span class="hljs-keyword">catch</span> (e) {
  alert( <span class="hljs-string">&#x27;catch&#x27;</span> );
} <span class="hljs-keyword">finally</span> {
  alert( <span class="hljs-string">&#x27;finally&#x27;</span> );
}</code></pre>
<p>这段代码有两种执行方式：</p>
<ol>
<li>如果你对于 &quot;Make an error?&quot; 的回答是 &quot;Yes&quot;，那么执行 <code>try -&gt; catch -&gt; finally</code>。</li>
<li>如果你的回答是 &quot;No&quot;，那么执行 <code>try -&gt; finally</code>。</li>
</ol>
<p><code>finally</code> 子句（clause）通常用在：当我们开始做某事的时候，希望无论出现什么情况都要完成完成某个任务。</p>
<p>例如，我们想要测量一个斐波那契数字函数 <code>fib(n)</code> 执行所需要花费的时间。通常，我们可以在运行它之前开始测量，并在运行完成时结束测量。但是，如果在该函数调用期间出现 error 该怎么办？特别是，下面这段 <code>fib(n)</code> 的实现代码在遇到负数或非整数数字时会返回一个 error。</p>
<p>无论如何，<code>finally</code> 子句都是一个结束测量的好地方。</p>
<p>在这儿，<code>finally</code> 能够保证在两种情况下都能正确地测量时间 — 成功执行 <code>fib</code> 以及 <code>fib</code> 中出现 error 时：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> num = +prompt(<span class="hljs-string">&quot;Enter a positive integer number?&quot;</span>, <span class="hljs-number">35</span>)

<span class="hljs-keyword">let</span> diff, result;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fib</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span> || <span class="hljs-built_in">Math</span>.trunc(n) != n) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Must not be negative, and also an integer.&quot;</span>);
  }
  <span class="hljs-keyword">return</span> n &lt;= <span class="hljs-number">1</span> ? n : fib(n - <span class="hljs-number">1</span>) + fib(n - <span class="hljs-number">2</span>);
}

<span class="hljs-keyword">let</span> start = <span class="hljs-built_in">Date</span>.now();

<span class="hljs-keyword">try</span> {
  result = fib(num);
} <span class="hljs-keyword">catch</span> (e) {
  result = <span class="hljs-number">0</span>;
*!*
} <span class="hljs-keyword">finally</span> {
  diff = <span class="hljs-built_in">Date</span>.now() - start;
}
*/!*

alert(result || <span class="hljs-string">&quot;error occurred&quot;</span>);

alert( <span class="hljs-string">`execution took <span class="hljs-subst">${diff}</span>ms`</span> );</code></pre>
<p>你可以通过运行上面这段代码并在 <code>prompt</code> 弹窗中输入 <code>35</code> 来进行检查 — 代码运行正常，先执行 <code>try</code> 然后是 <code>finally</code>。如果你输入的是 <code>-1</code> — 将立即出现 error，执行将只花费 <code>0ms</code>。以上两种情况下的时间测量都正确地完成了。</p>
<p>换句话说，函数 <code>fib</code> 以 <code>return</code> 还是 <code>throw</code> 完成都无关紧要。在这两种情况下都会执行 <code>finally</code> 子句。</p>
<p>```smart header=&quot;变量和 <code>try..catch..finally</code> 中的局部变量&quot;
请注意，上面代码中的 <code>result</code> 和 <code>diff</code> 变量都是在 <code>try..catch</code> <strong>之前</strong> 声明的。</p>
<p>否则，如果我们使用 <code>let</code> 在 <code>try</code> 块中声明变量，那么该变量将只在 <code>try</code> 块中可见。</p>
<pre><code>
````smart header=&quot;`finally` 和 `return`&quot;
`finally` 子句适用于 `try..catch` 的 **任何** 出口。这包括显式的 `return`。

在下面这个例子中，在 `try` 中有一个 `return`。在这种情况下，`finally` 会在控制转向外部代码前被执行。

```js run
function func() {

  try {
*!*
    return 1;
*/!*

  } catch (e) {
    /* ... */
  } finally {
*!*
    alert( &#x27;finally&#x27; );
*/!*
  }
}

alert( func() ); // 先执行 finally 中的 alert，然后执行这个 alert</code></pre>
<pre><code>
````smart header=&quot;`try..finally`&quot;

没有 `catch` 子句的 `try..finally` 结构也很有用。当我们不想在这儿处理 error（让它们 fall through），但是需要确保我们启动的处理需要被完成。

```js
function func() {
  // 开始执行需要被完成的操作（比如测量）
  try {
    // ...
  } finally {
    // 完成前面我们需要完成的那件事儿，即使 try 中的执行失败了
  }
}
```
上面的代码中，由于没有 `catch`，所以 `try` 中的 error 总是会使代码执行跳转至函数 `func()` 外。但是，在跳出之前需要执行 `finally` 中的代码。</code></pre>
<h2 id="全局-catch">全局 catch</h2>
<pre><code class="language-warn">这个部分的内容并不是 JavaScript 核心的一部分。</code></pre>
<p>设想一下，在 <code>try..catch</code> 结构外有一个致命的 error，然后脚本死亡了。这个 error 就像编程错误或其他可怕的事儿那样。</p>
<p>有什么办法可以用来应对这种情况吗？我们可能想要记录这个 error，并向用户显示某些内容（通常用户看不到错误信息）等。</p>
<p>规范中没有相关内容，但是代码的执行环境一般会提供这种机制，因为它确实很有用。例如，Node.JS 有 <a href="https://nodejs.org/api/process.html#process_event_uncaughtexception"><code>process.on(&quot;uncaughtException&quot;)</code></a>。在浏览器中，我们可以将将一个函数赋值给特殊的 <a href="mdn:api/GlobalEventHandlers/onerror">window.onerror</a> 属性，该函数将在发生未捕获的 error 时执行。</p>
<p>语法如下：</p>
<pre><code class="language-js"><span class="hljs-built_in">window</span>.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">message, url, line, col, error</span>) </span>{
  <span class="hljs-comment">// ...</span>
};</code></pre>
<p><code>message</code>
: Error 信息。</p>
<p><code>url</code>
: 发生 error 的脚本的 URL。</p>
<p><code>line</code>，<code>col</code>
: 发生 error 处的代码的行号和列号。</p>
<p><code>error</code>
: Error 对象。</p>
<p>例如：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
*!*
  <span class="hljs-built_in">window</span>.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">message, url, line, col, error</span>) </span>{
    alert(<span class="hljs-string">`<span class="hljs-subst">${message}</span>\n At <span class="hljs-subst">${line}</span>:<span class="hljs-subst">${col}</span> of <span class="hljs-subst">${url}</span>`</span>);
  };
*/!*

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readData</span>(<span class="hljs-params"></span>) </span>{
    badFunc(); <span class="hljs-comment">// 啊，出问题了！</span>
  }

  readData();
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>全局错误处理程序 <code>window.onerror</code> 的作用通常不是恢复脚本的执行 — 如果发生编程错误，那这几乎是不可能的，它的作用是将错误信息发送给开发者。</p>
<p>也有针对这种情况提供错误日志的 Web 服务，例如 <a href="https://errorception.com">https://errorception.com</a> 或 <a href="http://www.muscula.com">http://www.muscula.com</a>。</p>
<p>它们会像这样运行：</p>
<ol>
<li>我们注册该服务，并拿到一段 JS 代码（或脚本的 URL），然后插入到页面中。</li>
<li>该 JS 脚本设置了自定义的 <code>window.onerror</code> 函数。</li>
<li>当发生 error 时，它会发送一个此 error  相关的网络请求到服务提供方。</li>
<li>我们可以登录到服务方的 Web 界面来查看这些 error。</li>
</ol>
<h2 id="总结">总结</h2>
<p><code>try..catch</code> 结构允许我们处理执行过程中出现的 error。从字面上看，它允许“尝试”运行代码并“捕获”其中可能发生的错误。</p>
<p>语法如下：</p>
<pre><code class="language-js"><span class="hljs-keyword">try</span> {
  <span class="hljs-comment">// 执行此处代码</span>
} <span class="hljs-function"><span class="hljs-title">catch</span>(<span class="hljs-params">err</span>)</span> {
  <span class="hljs-comment">// 如果发生错误，跳转至此处</span>
  <span class="hljs-comment">// err 是一个 error 对象</span>
} <span class="hljs-keyword">finally</span> {
  <span class="hljs-comment">// 无论怎样都会在 try/catch 之后执行</span>
}</code></pre>
<p>这儿可能会没有 <code>catch</code> 部分或者没有 <code>finally</code>，所以 <code>try..catch</code> 或 <code>try..finally</code> 都是可用的。</p>
<p>Error 对象包含下列属性：</p>
<ul>
<li><code>message</code> — 人类可读的 error 信息。</li>
<li><code>name</code> — 具有 error 名称的字符串（Error 构造器的名称）。</li>
<li><code>stack</code>（没有标准，但得到了很好的支持）— Error 发生时的调用栈。</li>
</ul>
<p>如果我们不需要 error 对象，我们可以通过使用 <code>catch {</code> 而不是 <code>catch(err) {</code> 来省略它。</p>
<p>我们也可以使用 <code>throw</code> 操作符来生成自定义的 error。从技术上讲，<code>throw</code> 的参数可以是任何东西，但通常是继承自内建的 <code>Error</code> 类的 error 对象。下一章我们会详细介绍扩展 error。</p>
<p>再次抛出（rethrowing）是一种错误处理的重要模式：<code>catch</code> 块通常期望并知道如何处理特定的 error 类型，因此它应该再次抛出它不知道的 error。</p>
<p>即使我们没有 <code>try..catch</code>，大多数执行环境也允许我们设置“全局”错误处理程序来捕获“掉出（fall out）”的 error。在浏览器中，就是 <code>window.onerror</code>。</p>

      </fieldset>
      
      <fieldset id='_JeDwek'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FormatError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SyntaxError</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">message</span>)</span> {
    <span class="hljs-built_in">super</span>(message);
    <span class="hljs-built_in">this</span>.name = <span class="hljs-built_in">this</span>.constructor.name;
  }
}

<span class="hljs-keyword">let</span> err = <span class="hljs-keyword">new</span> FormatError(<span class="hljs-string">&quot;formatting error&quot;</span>);

alert( err.message ); <span class="hljs-comment">// formatting error</span>
alert( err.name ); <span class="hljs-comment">// FormatError</span>
alert( err.stack ); <span class="hljs-comment">// stack</span>

alert( err <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">SyntaxError</span> ); <span class="hljs-comment">// true</span></code></pre>

      </fieldset>
      
      <fieldset id='_Z3O7wD'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="继承-syntaxerror">继承 SyntaxError</h1>
<p>创建一个继承自内建类 <code>SyntaxError</code> 的类 <code>FormatError</code>。</p>
<p>它应该支持 <code>message</code>，<code>name</code> 和 <code>stack</code> 属性。</p>
<p>用例：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> err = <span class="hljs-keyword">new</span> FormatError(<span class="hljs-string">&quot;formatting error&quot;</span>);

alert( err.message ); <span class="hljs-comment">// formatting error</span>
alert( err.name ); <span class="hljs-comment">// FormatError</span>
alert( err.stack ); <span class="hljs-comment">// stack</span>

alert( err <span class="hljs-keyword">instanceof</span> FormatError ); <span class="hljs-comment">// true</span>
alert( err <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">SyntaxError</span> ); <span class="hljs-comment">// true（因为它继承自 SyntaxError）</span></code></pre>

      </fieldset>
      
      <fieldset id='_0wHw8y'>
      <legend>article</legend>
      <h1 id="自定义-error，扩展-error">自定义 Error，扩展 Error</h1>
<p>当我们在开发某些东西时，经常会需要我们自己的 error 类来反映在我们的任务中可能出错的特定任务。对于网络操作中的 error，我们需要 <code>HttpError</code>，对于数据库操作中的 error，我们需要 <code>DbError</code>，对于搜索操作中的 error，我们需要 <code>NotFoundError</code>，等等。</p>
<p>我们自定义的 error 应该支持基本的 error 的属性，例如 <code>message</code>，<code>name</code>，并且最好还有 <code>stack</code>。但是它们也可能会有其他属于它们自己的属性，例如，<code>HttpError</code> 对象可能会有一个 <code>statusCode</code> 属性，属性值可能为 <code>404</code>、<code>403</code> 或 <code>500</code> 等。</p>
<p>JavaScript 允许将 <code>throw</code> 与任何参数一起使用，所以从技术上讲，我们自定义的 error 不需要从 <code>Error</code> 中继承。但是，如果我们继承，那么就可以使用 <code>obj instanceof Error</code> 来识别 error 对象。因此，最好继承它。</p>
<p>随着虽开发的应用程序的增长，我们自己的 error 自然会形成形成一个层次结构（hierarchy）。例如，<code>HttpTimeoutError</code> 可能继承自 <code>HttpError</code>，等等。</p>
<h2 id="扩展-error">扩展 Error</h2>
<p>例如，让我们考虑一个函数 <code>readUser(json)</code>，该函数应该读取带有用户数据的 JSON。</p>
<p>这里是一个可用的 <code>json</code> 的例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> json = <span class="hljs-string">`{ &quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30 }`</span>;</code></pre>
<p>在函数内部，我们将使用 <code>JSON.parse</code>。如果它接收到格式不正确的 <code>json</code>，就会抛出 <code>SyntaxError</code>。但是，即使 <code>json</code> 在语法上是正确的，也不意味着该数据是有效的用户数据，对吧？因为它可能丢失了某些必要的数据。例如，对用户来说，必不可少的是 <code>name</code> 和 <code>age</code> 属性。</p>
<p>我们的函数 <code>readUser(json)</code> 不仅会读取 JSON，还会检查（“验证”）数据。如果没有所必须的字段，或者（字段的）格式错误，那么就会出现一个 error。并且这些并不是 <code>SyntaxError</code>，因为这些数据在语法上是正确的，这些是另一种错误。我们称之为 <code>ValidationError</code>，并为之创建一个类。这种类型的错误也应该包含有关违规字段的信息。</p>
<p>我们的 <code>ValidationError</code> 类应该继承自内建的 <code>Error</code> 类。</p>
<p><code>Error</code> 类是内建的，但这是其近似代码，所以我们可以了解我们要扩展的内容：</p>
<pre><code class="language-js"><span class="hljs-comment">// JavaScript 自身定义的内建的 Error 类的“伪代码”</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Error</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">message</span>)</span> {
    <span class="hljs-built_in">this</span>.message = message;
    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&quot;Error&quot;</span>; <span class="hljs-comment">// (不同的内建 error 类有不同的名字)</span>
    <span class="hljs-built_in">this</span>.stack = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">call</span> <span class="hljs-attr">stack</span>&gt;</span>; // 非标准的，但大多数环境都支持它
  }
}</span></code></pre>
<p>现在让我们从其中继承 <code>ValidationError</code>，并尝试进行运行：</p>
<pre><code class="language-js">*!*
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ValidationError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Error</span> </span>{
*/!*
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">message</span>)</span> {
    <span class="hljs-built_in">super</span>(message); <span class="hljs-comment">// (1)</span>
    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&quot;ValidationError&quot;</span>; <span class="hljs-comment">// (2)</span>
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ValidationError(<span class="hljs-string">&quot;Whoops!&quot;</span>);
}

<span class="hljs-keyword">try</span> {
  test();
} <span class="hljs-function"><span class="hljs-title">catch</span>(<span class="hljs-params">err</span>)</span> {
  alert(err.message); <span class="hljs-comment">// Whoops!</span>
  alert(err.name); <span class="hljs-comment">// ValidationError</span>
  alert(err.stack); <span class="hljs-comment">// 一个嵌套调用的列表，每个调用都有对应的行号</span>
}</code></pre>
<p>请注意：在 <code>(1)</code> 行中我们调用了父类的 constructor。JavaScript 要求我们在子类的 constructor 中调用 <code>super</code>，所以这是必须的。父类的 constructor 设置了 <code>message</code> 属性。</p>
<p>父类的 constructor 还将 <code>name</code> 属性的值设置为了 <code>&quot;Error&quot;</code>，所以在 <code>(2)</code> 行中，我们将其重置为了右边的值。</p>
<p>让我们尝试在 <code>readUser(json)</code> 中使用它吧：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ValidationError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Error</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">message</span>)</span> {
    <span class="hljs-built_in">super</span>(message);
    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&quot;ValidationError&quot;</span>;
  }
}

<span class="hljs-comment">// 用法</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readUser</span>(<span class="hljs-params">json</span>) </span>{
  <span class="hljs-keyword">let</span> user = <span class="hljs-built_in">JSON</span>.parse(json);

  <span class="hljs-keyword">if</span> (!user.age) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ValidationError(<span class="hljs-string">&quot;No field: age&quot;</span>);
  }
  <span class="hljs-keyword">if</span> (!user.name) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ValidationError(<span class="hljs-string">&quot;No field: name&quot;</span>);
  }

  <span class="hljs-keyword">return</span> user;
}

<span class="hljs-comment">// try..catch 的工作示例</span>

<span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">let</span> user = readUser(<span class="hljs-string">&#x27;{ &quot;age&quot;: 25 }&#x27;</span>);
} <span class="hljs-keyword">catch</span> (err) {
  <span class="hljs-keyword">if</span> (err <span class="hljs-keyword">instanceof</span> ValidationError) {
*!*
    alert(<span class="hljs-string">&quot;Invalid data: &quot;</span> + err.message); <span class="hljs-comment">// Invalid data: No field: name</span>
*/!*
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (err <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">SyntaxError</span>) { <span class="hljs-comment">// (*)</span>
    alert(<span class="hljs-string">&quot;JSON Syntax Error: &quot;</span> + err.message);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">throw</span> err; <span class="hljs-comment">// 未知的 error，再次抛出 (**)</span>
  }
}</code></pre>
<p>上面代码中的 <code>try..catch</code> 块既处理我们的 <code>ValidationError</code> 又处理来自 <code>JSON.parse</code> 的内建 <code>SyntaxError</code>。</p>
<p>请看一下我们是如何使用 <code>instanceof</code> 来检查 <code>(*)</code> 行中的特定错误类型的。</p>
<p>我们也可以看看 <code>err.name</code>，像这样：</p>
<pre><code class="language-js"><span class="hljs-comment">// ...</span>
<span class="hljs-comment">// instead of (err instanceof SyntaxError)</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (err.name == <span class="hljs-string">&quot;SyntaxError&quot;</span>) { <span class="hljs-comment">// (*)</span>
<span class="hljs-comment">// ...</span></code></pre>
<p>使用 <code>instanceof</code> 的版本要好得多，因为将来我们会对 <code>ValidationError</code> 进行扩展，创建它的子类型，例如 <code>PropertyRequiredError</code>。而 <code>instanceof</code> 检查对于新的继承类也适用。所以这是面向未来的做法。</p>
<p>还有一点很重要，在 <code>catch</code> 遇到了未知的错误，它会在 <code>(**)</code> 行将该错误再次抛出。<code>catch</code> 块只知道如何处理 validation 错误和语法错误，而其他错误（由于代码中的错字或其他未知的错误）应该被扔出（fall through）。</p>
<h2 id="深入继承">深入继承</h2>
<p><code>ValidationError</code> 类是非常通用的。很多东西都可能出错。对象的属性可能缺失或者属性可能有格式错误（例如 <code>age</code> 属性的值为一个字符串）。让我们针对缺少属性的错误来制作一个更具体的 <code>PropertyRequiredError</code> 类。它将携带有关缺少的属性的相关信息。</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ValidationError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Error</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">message</span>)</span> {
    <span class="hljs-built_in">super</span>(message);
    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&quot;ValidationError&quot;</span>;
  }
}

*!*
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PropertyRequiredError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ValidationError</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">property</span>)</span> {
    <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;No property: &quot;</span> + property);
    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&quot;PropertyRequiredError&quot;</span>;
    <span class="hljs-built_in">this</span>.property = property;
  }
}
*/!*

<span class="hljs-comment">// 用法</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readUser</span>(<span class="hljs-params">json</span>) </span>{
  <span class="hljs-keyword">let</span> user = <span class="hljs-built_in">JSON</span>.parse(json);

  <span class="hljs-keyword">if</span> (!user.age) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> PropertyRequiredError(<span class="hljs-string">&quot;age&quot;</span>);
  }
  <span class="hljs-keyword">if</span> (!user.name) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> PropertyRequiredError(<span class="hljs-string">&quot;name&quot;</span>);
  }

  <span class="hljs-keyword">return</span> user;
}

<span class="hljs-comment">// try..catch 的工作示例</span>

<span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">let</span> user = readUser(<span class="hljs-string">&#x27;{ &quot;age&quot;: 25 }&#x27;</span>);
} <span class="hljs-keyword">catch</span> (err) {
  <span class="hljs-keyword">if</span> (err <span class="hljs-keyword">instanceof</span> ValidationError) {
*!*
    alert(<span class="hljs-string">&quot;Invalid data: &quot;</span> + err.message); <span class="hljs-comment">// Invalid data: No property: name</span>
    alert(err.name); <span class="hljs-comment">// PropertyRequiredError</span>
    alert(err.property); <span class="hljs-comment">// name</span>
*/!*
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (err <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">SyntaxError</span>) {
    alert(<span class="hljs-string">&quot;JSON Syntax Error: &quot;</span> + err.message);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">throw</span> err; <span class="hljs-comment">// 为止 error，将其再次抛出</span>
  }
}</code></pre>
<p>这个新的类 <code>PropertyRequiredError</code> 使用起来很简单：我们只需要传递属性名：<code>new PropertyRequiredError(property)</code>。人类可读的 <code>message</code> 是由 constructor 生成的。</p>
<p>请注意，在 <code>PropertyRequiredError</code> constructor 中的 <code>this.name</code> 是通过手动重新赋值的。这可能会变得有些乏味 — 在每个自定义 error 类中都要进行 <code>this.name = &lt;class name&gt;</code> 赋值操作。我们可以通过创建自己的“基础错误（basic error）”类来避免这种情况，该类进行了 <code>this.name = this.constructor.name</code> 赋值。然后让所有我们自定义的 error 都从这个“基础错误”类进行继承。</p>
<p>让我们称之为 <code>MyError</code>。</p>
<p>这是带有 <code>MyError</code> 以及其他自定义的 error 类的代码，已进行简化：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Error</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">message</span>)</span> {
    <span class="hljs-built_in">super</span>(message);
*!*
    <span class="hljs-built_in">this</span>.name = <span class="hljs-built_in">this</span>.constructor.name;
*/!*
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ValidationError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MyError</span> </span>{ }

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PropertyRequiredError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ValidationError</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">property</span>)</span> {
    <span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;No property: &quot;</span> + property);
    <span class="hljs-built_in">this</span>.property = property;
  }
}

<span class="hljs-comment">// name 是对的</span>
alert( <span class="hljs-keyword">new</span> PropertyRequiredError(<span class="hljs-string">&quot;field&quot;</span>).name ); <span class="hljs-comment">// PropertyRequiredError</span></code></pre>
<p>现在自定义的 error 短了很多，特别是 <code>ValidationError</code>，因为我们摆脱了 constructor 中的 <code>&quot;this.name = ...&quot;</code> 这一行。</p>
<h2 id="包装异常">包装异常</h2>
<p>在上面代码中的函数 <code>readUser</code> 的目的就是“读取用户数据”。在这个过程中可能会出现不同类型的 error。目前我们有了 <code>SyntaxError</code> 和 <code>ValidationError</code>，但是将来，函数 <code>readUser</code> 可能会不断壮大，并可能会产生其他类型的 error。</p>
<p>调用 <code>readUser</code> 的代码应该处理这些 error。现在它在 <code>catch</code> 块中使用了多个 <code>if</code> 语句来检查 error 类，处理已知的 error，并再次抛出未知的 error。</p>
<p>该方案是这样的：</p>
<pre><code class="language-js"><span class="hljs-keyword">try</span> {
  ...
  readUser()  <span class="hljs-comment">// 潜在的 error 源</span>
  ...
} <span class="hljs-keyword">catch</span> (err) {
  <span class="hljs-keyword">if</span> (err <span class="hljs-keyword">instanceof</span> ValidationError) {
    <span class="hljs-comment">// 处理 validation error</span>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (err <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">SyntaxError</span>) {
    <span class="hljs-comment">// 处理 syntax error</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">throw</span> err; <span class="hljs-comment">// 未知 error，再次抛出它</span>
  }
}</code></pre>
<p>在上面的代码中，我们可以看到两种类型的 error，但是可以有更多。</p>
<p>如果 <code>readUser</code> 函数会产生多种 error，那么我们应该问问自己：我们是否真的想每次都一一检查所有的 error 类型？</p>
<p>通常答案是 &quot;No&quot;：我们希望能够“比它高一个级别”。我们只想知道这里是否是“数据读取异常” — 为什么发生了这样的 error 通常是无关紧要的（error 信息描述了它）。或者，如果我们有一种方法能够获取 error 的详细信息那就更好了，但前提是我们需要。</p>
<p>我们所描述的这项技术被称为“包装异常”。</p>
<ol>
<li>我们将创建一个新的类 <code>ReadError</code> 来表示一般的“数据读取” error。</li>
<li>函数<code>readUser</code> 将捕获内部发生的数据读取 error，例如 <code>ValidationError</code> 和 <code>SyntaxError</code>，并生成一个 <code>ReadError</code> 来进行替代。</li>
<li>对象 <code>ReadError</code> 会把对原始 error 的引用保存在其 <code>cause</code> 属性中。</li>
</ol>
<p>之后，调用 <code>readUser</code> 的代码只需要检查 <code>ReadError</code>，而不必检查每种数据读取 error。并且，如果需要更多 error 细节，那么可以检查 <code>readUser</code> 的 <code>cause</code> 属性。</p>
<p>下面的代码定义了 <code>ReadError</code>，并在 <code>readUser</code> 和 <code>try..catch</code> 中演示了其用法：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Error</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">message, cause</span>)</span> {
    <span class="hljs-built_in">super</span>(message);
    <span class="hljs-built_in">this</span>.cause = cause;
    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;ReadError&#x27;</span>;
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ValidationError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Error</span> </span>{ <span class="hljs-comment">/*...*/</span> }
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PropertyRequiredError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ValidationError</span> </span>{ <span class="hljs-comment">/* ... */</span> }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validateUser</span>(<span class="hljs-params">user</span>) </span>{
  <span class="hljs-keyword">if</span> (!user.age) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> PropertyRequiredError(<span class="hljs-string">&quot;age&quot;</span>);
  }

  <span class="hljs-keyword">if</span> (!user.name) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> PropertyRequiredError(<span class="hljs-string">&quot;name&quot;</span>);
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readUser</span>(<span class="hljs-params">json</span>) </span>{
  <span class="hljs-keyword">let</span> user;

  <span class="hljs-keyword">try</span> {
    user = <span class="hljs-built_in">JSON</span>.parse(json);
  } <span class="hljs-keyword">catch</span> (err) {
*!*
    <span class="hljs-keyword">if</span> (err <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">SyntaxError</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ReadError(<span class="hljs-string">&quot;Syntax Error&quot;</span>, err);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">throw</span> err;
    }
*/!*
  }

  <span class="hljs-keyword">try</span> {
    validateUser(user);
  } <span class="hljs-keyword">catch</span> (err) {
*!*
    <span class="hljs-keyword">if</span> (err <span class="hljs-keyword">instanceof</span> ValidationError) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ReadError(<span class="hljs-string">&quot;Validation Error&quot;</span>, err);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">throw</span> err;
    }
*/!*
  }

}

<span class="hljs-keyword">try</span> {
  readUser(<span class="hljs-string">&#x27;{bad json}&#x27;</span>);
} <span class="hljs-keyword">catch</span> (e) {
  <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> ReadError) {
*!*
    alert(e);
    <span class="hljs-comment">// Original error: SyntaxError: Unexpected token b in JSON at position 1</span>
    alert(<span class="hljs-string">&quot;Original error: &quot;</span> + e.cause);
*/!*
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">throw</span> e;
  }
}</code></pre>
<p>在上面的代码中，<code>readUser</code> 正如所描述的那样正常工作 — 捕获语法和验证（validation）错误，并抛出 <code>ReadError</code>（对于未知错误将照常再次抛出）。</p>
<p>所以外部代码检查 <code>instanceof ReadError</code>，并且它的确是。不必列出所有可能的 error 类型。</p>
<p>这种方法被称为“包装异常（wrapping exceptions）”，因为我们将“低级别”的异常“包装”到了更抽象的 <code>ReadError</code> 中。它被广泛应用于面向对象的编程中。</p>
<h2 id="总结">总结</h2>
<ul>
<li>我们可以正常地从 <code>Error</code> 和其他内建的 error 类中进行继承，。我们只需要注意 <code>name</code> 属性以及不要忘了调用 <code>super</code>。</li>
<li>我们可以使用 <code>instanceof</code> 来检查特定的 error。但有时我们有来自第三方库的 error 对象，并且在这儿没有简单的方法来获取它的类。那么可以将 <code>name</code> 属性用于这一类的检查。</li>
<li>包装异常是一项广泛应用的技术：用于处理低级别异常并创建高级别 error 而不是各种低级别 error 的函数。在上面的示例中，低级别异常有时会成为该对象的属性，例如 <code>err.cause</code>，但这不是严格要求的。</li>
</ul>

      </fieldset>
      
      <fieldset id='_rFZ4N4'>
      <legend>solution</legend>
      
      </fieldset>
      
      <fieldset id='_153rRp'>
      <legend>task</legend>
      <h1 id="带回调的圆形动画">带回调的圆形动画</h1>
<p>在 <a href="info:task/animate-circle">info:task/animate-circle</a> 任务中，显示了一个逐渐变大的圆形动画。</p>
<p>现在假设我们不仅需要一个圆圈，还需要在其中显示一条消息。该消息应在动画完成后（圆已经完全长大了）<strong>出现</strong>，否则它看起来会很难看。</p>
<p>在此任务的解决方案中，<code>showCircle(cx, cy, radius)</code> 函数画了一个圆，但是无法跟踪圆形是否已经准备好。 </p>
<p>添加一个回调参数：当动画完成时，可以调用 <code>showCircle(cx, cy, radius, callback)</code>。<code>callback</code> 应该接受圆形的 <code>&lt;div&gt;</code> 作为参数。</p>
<p>这是示例：</p>
<pre><code class="language-js">showCircle(<span class="hljs-number">150</span>, <span class="hljs-number">150</span>, <span class="hljs-number">100</span>, <span class="hljs-function"><span class="hljs-params">div</span> =&gt;</span> {
  div.classList.add(<span class="hljs-string">&#x27;message-ball&#x27;</span>);
  div.append(<span class="hljs-string">&quot;Hello, world!&quot;</span>);
});</code></pre>
<p>Demo：</p>
<p>[iframe src=&quot;solution&quot; height=260]</p>
<p>以 <a href="info:task/animate-circle">info:task/animate-circle</a> 任务的答案作为解决本任务的基础。</p>

      </fieldset>
      
      <fieldset id='_FTUwL8'>
      <legend>article</legend>
      <h1 id="简介：回调">简介：回调</h1>
<pre><code class="language-warn">为了演示回调、promise 和其他抽象概念的使用，我们将使用一些浏览器方法：具体地说，是加载脚本和执行简单的文档操作的方法。

如果你不熟悉这些方法，并且对它们在这些示例中的用法感到疑惑，那么你可能需要阅读本教程 [下一部分](/document) 中的几章。

但是，我们会尽全力使讲解变得更加清晰。在这儿不会有浏览器方面的真正复杂的东西。</code></pre>
<p>JavaScript 主机（host）环境提供了许多函数，这些函数允许我们计划 <strong>异步</strong> 行为（action）。换句话说，我们现在开始执行的行为，但它们会在稍后完成。</p>
<p>例如，<code>setTimeout</code> 函数就是一个这样的函数。</p>
<p>这儿有一些实际中的异步行为的示例，例如加载脚本和模块（我们将在后面的章节中介绍）。</p>
<p>让我们看一下函数 <code>loadScript(src)</code>，该函数使用给定的 <code>src</code> 加载脚本：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadScript</span>(<span class="hljs-params">src</span>) </span>{
  <span class="hljs-comment">// 创建一个 &lt;script&gt; 标签，并将其附加到页面</span>
  <span class="hljs-comment">// 这将使得具有给定 src 的脚本开始加载，并在加载完成后运行</span>
  <span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);
  script.src = src;
  <span class="hljs-built_in">document</span>.head.append(script);
}</code></pre>
<p>它将带有给定 <code>src</code> 的新动态创建的标签 <code>&lt;script src=&quot;…&quot;&gt;</code> 附加到文档中。浏览器将自动开始加载它，并在加载完成后执行。</p>
<p>我们可以像这样使用这个函数：</p>
<pre><code class="language-js"><span class="hljs-comment">// 在给定路径下加载并执行脚本</span>
loadScript(<span class="hljs-string">&#x27;/my/script.js&#x27;</span>);</code></pre>
<p>脚本是“异步”调用的，因为它从现在开始加载，但是在这个加载函数执行完成后才运行。</p>
<p>如果在 <code>loadScript(…)</code> 下面有任何其他代码，它们不会等到脚本加载完成才执行。</p>
<pre><code class="language-js">loadScript(<span class="hljs-string">&#x27;/my/script.js&#x27;</span>);
<span class="hljs-comment">// loadScript 下面的代码</span>
<span class="hljs-comment">// 不会等到脚本加载完成才执行</span>
<span class="hljs-comment">// ...</span></code></pre>
<p>假设我们需要在新脚本加载后立即使用它。它声明了新函数，我们想运行它们。</p>
<p>但如果我们在 <code>loadScript(…)</code> 调用后立即执行此操作，这将不会有效。</p>
<pre><code class="language-js">loadScript(<span class="hljs-string">&#x27;/my/script.js&#x27;</span>); <span class="hljs-comment">// 这个脚本有 &quot;function newFunction() {…}&quot;</span>

*!*
newFunction(); <span class="hljs-comment">// 没有这个函数！</span>
*/!*</code></pre>
<p>自然情况下，浏览器可能没有时间加载脚本。到目前为止，<code>loadScript</code> 函数并没有提供跟踪加载完成的方法。脚本加载并最终运行，仅此而已。但我们希望了解脚本何时加载完成，以使用其中的新函数和变量。</p>
<p>让我们添加一个 <code>callback</code> 函数作为 <code>loadScript</code> 的第二个参数，该函数应在脚本加载完成时执行：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadScript</span>(<span class="hljs-params">src, *!*callback*/!*</span>) </span>{
  <span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);
  script.src = src;

*!*
  script.onload = <span class="hljs-function">() =&gt;</span> callback(script);
*/!*

  <span class="hljs-built_in">document</span>.head.append(script);
}</code></pre>
<p>现在，如果我们想调用该脚本中的新函数，我们应该将其写在回调函数中：</p>
<pre><code class="language-js">loadScript(<span class="hljs-string">&#x27;/my/script.js&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// 在脚本加载完成后，回调函数才会执行</span>
  newFunction(); <span class="hljs-comment">// 现在它工作了</span>
  ...
});</code></pre>
<p>这是我们的想法：第二个参数是一个函数（通常是匿名函数），该函数会在行为（action）完成时运行。</p>
<p>这是一个带有真实脚本的可运行的示例：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadScript</span>(<span class="hljs-params">src, callback</span>) </span>{
  <span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);
  script.src = src;
  script.onload = <span class="hljs-function">() =&gt;</span> callback(script);
  <span class="hljs-built_in">document</span>.head.append(script);
}

*!*
loadScript(<span class="hljs-string">&#x27;https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js&#x27;</span>, <span class="hljs-function"><span class="hljs-params">script</span> =&gt;</span> {
  alert(<span class="hljs-string">`Cool, the script <span class="hljs-subst">${script.src}</span> is loaded`</span>);
  alert( _ ); <span class="hljs-comment">// 所加载的脚本中声明的函数</span>
});
*/!*</code></pre>
<p>这被称为“基于回调”的异步编程风格。异步执行某项功能的函数应该提供一个 <code>callback</code> 参数用于在相应事件完成时调用。（译注：上面这个例子中的相应事件是指脚本加载）</p>
<p>这里我们在 <code>loadScript</code> 中就是这么做的，但当然这是一种通用方法。</p>
<h2 id="在回调中回调">在回调中回调</h2>
<p>我们如何依次加载两个脚本：第一个，然后是第二个？</p>
<p>自然的解决方案是将第二个 <code>loadScript</code> 调用放入回调中，如下所示：</p>
<pre><code class="language-js">loadScript(<span class="hljs-string">&#x27;/my/script.js&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">script</span>) </span>{

  alert(<span class="hljs-string">`Cool, the <span class="hljs-subst">${script.src}</span> is loaded, let&#x27;s load one more`</span>);

*!*
  loadScript(<span class="hljs-string">&#x27;/my/script2.js&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">script</span>) </span>{
    alert(<span class="hljs-string">`Cool, the second script is loaded`</span>);
  });
*/!*

});</code></pre>
<p>在外部 <code>loadScript</code> 执行完成时，内部回调就会被回调。</p>
<p>如果我们还想要一个脚本呢？</p>
<pre><code class="language-js">loadScript(<span class="hljs-string">&#x27;/my/script.js&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">script</span>) </span>{

  loadScript(<span class="hljs-string">&#x27;/my/script2.js&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">script</span>) </span>{

*!*
    loadScript(<span class="hljs-string">&#x27;/my/script3.js&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">script</span>) </span>{
      <span class="hljs-comment">// ...加载完所有脚本后继续</span>
    });
*/!*

  })

});</code></pre>
<p>因此，每一个新行为（action）都在回调内部。这对于几个行为来说还好，但对于许多行为来说就不好了，所以我们很快就会看到其他变体。 </p>
<h2 id="处理-error">处理 Error</h2>
<p>在上述示例中，我们并没有考虑出现 error 的情况。如果脚本加载失败怎么办？我们的回调应该能够对此作出反应。</p>
<p>这是 <code>loadScript</code> 的改进版本，可以跟踪加载错误：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadScript</span>(<span class="hljs-params">src, callback</span>) </span>{
  <span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);
  script.src = src;

*!*
  script.onload = <span class="hljs-function">() =&gt;</span> callback(<span class="hljs-literal">null</span>, script);
  script.onerror = <span class="hljs-function">() =&gt;</span> callback(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Script load error for <span class="hljs-subst">${src}</span>`</span>));
*/!*

  <span class="hljs-built_in">document</span>.head.append(script);
}</code></pre>
<p>加载成功时，它会调用 <code>callback(null, script)</code>，否则调用 <code>callback(error)</code>。</p>
<p>用法：</p>
<pre><code class="language-js">loadScript(<span class="hljs-string">&#x27;/my/script.js&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, script</span>) </span>{
  <span class="hljs-keyword">if</span> (error) {
    <span class="hljs-comment">// 处理 error</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 脚本加载成功</span>
  }
});</code></pre>
<p>再次强调，我们在 <code>loadScript</code> 中所使用的方案其实很普遍。它被称为“Error 优先回调（error-first callback）”风格。</p>
<p>约定是：</p>
<ol>
<li><code>callback</code> 的第一个参数是为 error 而保留的。一旦出现 error，<code>callback(err)</code> 就会被调用。</li>
<li>第二个参数（和下一个参数，如果需要的话）用于成功的结果。此时 <code>callback(null, result1, result2…)</code> 就会被调用。</li>
</ol>
<p>因此，单一的 <code>callback</code> 函数可以同时具有报告 error 和传递返回结果的作用。</p>
<h2 id="厄运金字塔">厄运金字塔</h2>
<p>乍一看，这是一种可行的异步编程方式。的确如此，对于一个或两个嵌套的调用看起来还不错。</p>
<p>但对于一个接一个的多个异步行为，代码将会变成这样：</p>
<pre><code class="language-js">loadScript(<span class="hljs-string">&#x27;1.js&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, script</span>) </span>{

  <span class="hljs-keyword">if</span> (error) {
    handleError(error);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// ...</span>
    loadScript(<span class="hljs-string">&#x27;2.js&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, script</span>) </span>{
      <span class="hljs-keyword">if</span> (error) {
        handleError(error);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// ...</span>
        loadScript(<span class="hljs-string">&#x27;3.js&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, script</span>) </span>{
          <span class="hljs-keyword">if</span> (error) {
            handleError(error);
          } <span class="hljs-keyword">else</span> {
  *!*
            <span class="hljs-comment">// ...加载完所有脚本后继续 (*)</span>
  */!*
          }
        });

      }
    })
  }
});</code></pre>
<p>在上面这段代码中：</p>
<ol>
<li>我们加载 <code>1.js</code>，如果没有发生错误。</li>
<li>我们加载 <code>2.js</code>，如果没有发生错误。</li>
<li>我们加载 <code>3.js</code>，如果没有发生错误 — 做其他操作 <code>(*)</code>。</li>
</ol>
<p>如果调用嵌套的增加，代码层次变得更深，维护难度也随之增加，尤其是我们使用的是可能包含了很多循环和条件语句的真实代码，而不是例子中的 <code>...</code>。</p>
<p>有时这些被称为“回调地狱”或“厄运金字塔”。</p>
<!--
loadScript('1.js', function(error, script) {
  if (error) {
    handleError(error);
  } else {
    // ...
    loadScript('2.js', function(error, script) {
      if (error) {
        handleError(error);
      } else {
        // ...
        loadScript('3.js', function(error, script) {
          if (error) {
            handleError(error);
          } else {
            // ...
          }
        });
      }
    })
  }
});
-->

<p><img src="callback-hell.svg" alt=""></p>
<p>嵌套调用的“金字塔”随着每个异步行为会向右增长。很快它就失控了。</p>
<p>所以这种编码方式不是很好。</p>
<p>我们可以通过使每个行为都成为一个独立的函数来尝试减轻这种问题，如下所示：</p>
<pre><code class="language-js">loadScript(<span class="hljs-string">&#x27;1.js&#x27;</span>, step1);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">step1</span>(<span class="hljs-params">error, script</span>) </span>{
  <span class="hljs-keyword">if</span> (error) {
    handleError(error);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// ...</span>
    loadScript(<span class="hljs-string">&#x27;2.js&#x27;</span>, step2);
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">step2</span>(<span class="hljs-params">error, script</span>) </span>{
  <span class="hljs-keyword">if</span> (error) {
    handleError(error);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// ...</span>
    loadScript(<span class="hljs-string">&#x27;3.js&#x27;</span>, step3);
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">step3</span>(<span class="hljs-params">error, script</span>) </span>{
  <span class="hljs-keyword">if</span> (error) {
    handleError(error);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// ...加载完所有脚本后继续 (*)</span>
  }
};</code></pre>
<p>看到了吗？它的作用相同，但是没有深层的嵌套了，因为我们将每个行为都编写成了一个独立的顶层函数。</p>
<p>它可以工作，但是代码看起来就像是一个被撕裂的表格。你可能已经注意到了，它的可读性很差，在阅读时你需要在各个代码块之间跳转。这很不方便，特别是如果读者对代码不熟悉，他们甚至不知道应该跳转到什么地方。</p>
<p>此外，名为 <code>step*</code> 的函数都是一次性使用的，创建它们就是为了避免“厄运金字塔”。没有人会在行为链之外重用它们。因此，这里的命名空间有点混乱。</p>
<p>我们希望还有更好的方法。</p>
<p>幸运的是，有其他方法可以避免此类金字塔。最好的方法之一就是 &quot;promise&quot;，我们将在下一章中介绍它。</p>

      </fieldset>
      
      <fieldset id='_FsriLl'>
      <legend>solution</legend>
      <p>输出为：<code>1</code>。</p>
<p>第二个对 <code>resolve</code> 的调用会被忽略，因为只有第一次对 <code>reject/resolve</code> 的调用才会被处理。进一步的调用都会被忽略。</p>

      </fieldset>
      
      <fieldset id='_ZcSdnp'>
      <legend>task</legend>
      <h1 id="用-promise-重新解决？">用 promise 重新解决？</h1>
<p>下列这段代码会输出什么？</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{
  resolve(<span class="hljs-number">1</span>);

  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> resolve(<span class="hljs-number">2</span>), <span class="hljs-number">1000</span>);
});

promise.then(alert);</code></pre>

      </fieldset>
      
      <fieldset id='_B6DS3u'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delay</span>(<span class="hljs-params">ms</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, ms));
}

delay(<span class="hljs-number">3000</span>).then(<span class="hljs-function">() =&gt;</span> alert(<span class="hljs-string">&#x27;runs after 3 seconds&#x27;</span>));</code></pre>
<p>请注意，在此任务中 <code>resolve</code> 是不带参数调用的。我们不从 <code>delay</code> 中返回任何值，只是确保延迟即可。</p>

      </fieldset>
      
      <fieldset id='_Du8bue'>
      <legend>task</legend>
      <h1 id="基于-promise-的延时">基于 promise 的延时</h1>
<p>内建函数 <code>setTimeout</code> 使用了回调函数。请创建一个基于 promise 的替代方案。</p>
<p>函数 <code>delay(ms)</code> 应该返回一个 promise。这个 promise 应该在 <code>ms</code> 毫秒后被 resolve，所以我们可以向其中添加 <code>.then</code>，像这样：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delay</span>(<span class="hljs-params">ms</span>) </span>{
  <span class="hljs-comment">// 你的代码</span>
}

delay(<span class="hljs-number">3000</span>).then(<span class="hljs-function">() =&gt;</span> alert(<span class="hljs-string">&#x27;runs after 3 seconds&#x27;</span>));</code></pre>

      </fieldset>
      
      <fieldset id='_8jZZ29'>
      <legend>solution</legend>
      
      </fieldset>
      
      <fieldset id='_tub8Lx'>
      <legend>task</legend>
      <h1 id="带有-promise-的圆形动画">带有 promise 的圆形动画</h1>
<p>重写任务 <a href="info:task/animate-circle-callback">info:task/animate-circle-callback</a> 的解决方案中的 <code>showCircle</code> 函数，以使其返回一个 promise，而不接受回调。</p>
<p>新的用法：</p>
<pre><code class="language-js">showCircle(<span class="hljs-number">150</span>, <span class="hljs-number">150</span>, <span class="hljs-number">100</span>).then(<span class="hljs-function"><span class="hljs-params">div</span> =&gt;</span> {
  div.classList.add(<span class="hljs-string">&#x27;message-ball&#x27;</span>);
  div.append(<span class="hljs-string">&quot;Hello, world!&quot;</span>);
});</code></pre>
<p>以任务 <a href="info:task/animate-circle-callback">info:task/animate-circle-callback</a> 的解决方案为基础。</p>

      </fieldset>
      
      <fieldset id='_B1Whbw'>
      <legend>article</legend>
      <h1 id="promise">Promise</h1>
<p>想象一下，你是一位顶尖歌手，粉丝没日没夜地询问你下个单曲什么时候发。</p>
<p>为了从中解放，你承诺（promise）会在单曲发布的第一时间发给他们。你给了粉丝们一个列表。他们可以在上面填写他们的电子邮件地址，以便当歌曲发布后，让所有订阅了的人能够立即收到。即便遇到不测，例如录音室发生了火灾，以致你无法发布新歌，他们也能及时收到相关通知。</p>
<p>每个人都很开心：你不会被任何人催促，粉丝们也不用担心错过单曲发行。</p>
<p>这是我们在编程中经常遇到的事儿与真实生活的类比：</p>
<ol>
<li>“生产者代码（producing code）”会做一些事儿，并且会需要一些时间。例如，通过网络加载数据的代码。它就像一位“歌手”。</li>
<li>“消费者代码（consuming code）”想要在“生产者代码”完成工作的第一时间就能获得其工作成果。许多函数可能都需要这个结果。这些就是“粉丝”。</li>
<li><strong>Promise</strong> 是将“生产者代码”和“消费者代码”连接在一起的一个特殊的 JavaScript 对象。用我们的类比来说：这就是就像是“订阅列表”。“生产者代码”花费它所需的任意长度时间来产出所承诺的结果，而 &quot;promise&quot; 将在它（译注：指的是“生产者代码”，也就是下文所说的 executor）准备好时，将结果向所有订阅了的代码开放。</li>
</ol>
<p>这种类比并不十分准确，因为 JavaScipt 的 promise 比简单的订阅列表更加复杂：它们还拥有其他的功能和局限性。但以此开始挺好的。</p>
<p>Promise 对象的构造器（constructor）语法如下：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{
  <span class="hljs-comment">// executor（生产者代码，“歌手”）</span>
});</code></pre>
<p>传递给 <code>new Promise</code> 的函数被称为 <strong>executor</strong>。当 <code>new Promise</code> 被创建，executor 会自动运行。它包含最终应产出结果的生产者代码。按照上面的类比：executor 就是“歌手”。</p>
<p>它的参数 <code>resolve</code> 和 <code>reject</code> 是由 JavaScript 自身提供的回调。我们的代码仅在 executor 的内部。</p>
<p>当 executor 获得了结果，无论是早还是晚都没关系，它应该调用以下回调之一：</p>
<ul>
<li><code>resolve(value)</code> — 如果任务成功完成并带有结果 <code>value</code>。</li>
<li><code>reject(error)</code> — 如果出现了 error，<code>error</code> 即为 error 对象。</li>
</ul>
<p>所以总结一下就是：executor 会自动运行并尝试执行一项工作。尝试结束后，如果成功则调用 <code>resolve</code>，如果出现 error 则调用 <code>reject</code>。</p>
<p>由 <code>new Promise</code> 构造器返回的 <code>promise</code> 对象具有以下内部属性：</p>
<ul>
<li><code>state</code> — 最初是 <code>&quot;pending&quot;</code>，然后在 <code>resolve</code> 被调用时变为 <code>&quot;fulfilled&quot;</code>，或者在 <code>reject</code> 被调用时变为 <code>&quot;rejected&quot;</code>。</li>
<li><code>result</code> — 最初是 <code>undefined</code>，然后在 <code>resolve(value)</code> 被调用时变为 <code>value</code>，或者在 <code>reject(error)</code> 被调用时变为 <code>error</code>。</li>
</ul>
<p>所以，executor 最终将 <code>promise</code> 移至以下状态之一：</p>
<p><img src="promise-resolve-reject.svg" alt=""></p>
<p>稍后我们将看到“粉丝”如何订阅这些更改。</p>
<p>下面是一个 promise 构造器和一个简单的 executor 函数，该 executor 函数具有包含时间（即 <code>setTimeout</code>）的“生产者代码”：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{
  <span class="hljs-comment">// 当 promise 被构造完成时，自动执行此函数</span>

  <span class="hljs-comment">// 1 秒后发出工作已经被完成的信号，并带有结果 &quot;done&quot;</span>
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> *!*resolve(<span class="hljs-string">&quot;done&quot;</span>)*/!*, <span class="hljs-number">1000</span>);
});</code></pre>
<p>通过运行上面的代码，我们可以看到两件事儿：</p>
<ol>
<li><p>executor 被自动且立即调用（通过 <code>new Promise</code>）。</p>
</li>
<li><p>executor 接受两个参数：<code>resolve</code> 和 <code>reject</code>。这些函数由 JavaScipt 引擎预先定义，因此我们不需要创建它们。我们只需要在准备好（译注：指的是 executor 准备好）时调用其中之一即可。</p>
<p> 经过 1 秒的“处理”后，executor 调用 <code>resolve(&quot;done&quot;)</code> 来产生结果。这将改变 <code>promise</code> 对象的状态：</p>
<p> <img src="promise-resolve-1.svg" alt=""></p>
</li>
</ol>
<p>这是一个成功完成任务的例子，一个“成功实现了的诺言”。</p>
<p>现在的则是一个 executor 以 error 拒绝 promise 的示例：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{
  <span class="hljs-comment">// 1 秒后发出工作已经被完成的信号，并带有 error</span>
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> *!*reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Whoops!&quot;</span>))*/!*, <span class="hljs-number">1000</span>);
});</code></pre>
<p>对 <code>reject(...)</code> 的调用将 promise 对象的状态移至 <code>&quot;rejected&quot;</code>：</p>
<p><img src="promise-reject-1.svg" alt=""></p>
<p>总而言之，executor 应该执行一项工作（通常是需要花费一些时间的事儿），然后调用 <code>resolve</code> 或 <code>reject</code> 来改变对应的 promise 对象的状态。</p>
<p>与最初的 &quot;pending&quot; promise 相反，一个 resolved 或 rejected 的 promise 都会被称为 &quot;settled&quot;。</p>
<pre><code class="language-smart">executor 只能调用一个 `resolve` 或一个 `reject`。任何状态的更改都是最终的。

所有其他的再对 `resolve` 和 `reject` 的调用都会被忽略：

```js
let promise = new Promise(function(resolve, reject) {
*!*
  resolve(&quot;done&quot;);
*/!*

  reject(new Error(&quot;…&quot;)); // 被忽略
  setTimeout(() =&gt; resolve(&quot;…&quot;)); // 被忽略
});
```

这儿的宗旨是，一个被 executor 完成的工作只能有一个结果或一个 error。

并且，`resolve/reject` 只需要一个参数（或不包含任何参数），并且将忽略额外的参数。</code></pre>
<p>```smart header=&quot;以 <code>Error</code> 对象 reject&quot;
如果什么东西出了问题， executor 应该调用 <code>reject</code>。这可以使用任何类型的参数来完成（就像 <code>resolve</code> 一样）。但是建议使用 <code>Error</code> 对象（或继承自 <code>Error</code> 的对象）。这样做的理由很快就会显而易见。</p>
<pre><code>
````smart header=&quot;Resolve/reject 可以立即进行&quot;
实际上，executor 通常是异步执行某些操作，并在一段时间后调用 `resolve/reject`，但这不是必须的。我们还可以立即调用 `resolve` 或 `reject`，就像这样：

```js
let promise = new Promise(function(resolve, reject) {
  // 不花时间去做这项工作
  resolve(123); // 立即给出结果：123
});</code></pre>
<p>例如，当我们开始做一个任务时，但随后看到一切都已经完成并已被缓存时，可能就会发生这种情况。</p>
<p>这挺好。我们立即就有了一个 resolved 的 promise。</p>
<pre><code>
```smart header=&quot;`state` 和 `result` 都是内部的&quot;
Promise 对象的 `state` 和 `result` 属性都是内部的。我们无法直接访问它们。但我们可以对它们使用 `.then`/`.catch`/`.finally` 方法。我们在下面对这些方法进行了描述。
```

## 消费者：then，catch，finally

Promise 对象充当的是 executor（“生产者代码”或“歌手”）和消费函数（“粉丝”）之间的连接，后者将接收结果或 error。可以通过使用 `.then`、`.catch` 和 `.finally` 方法为消费函数进行注册。

### then

最重要最基础的一个就是 `.then`。

语法如下：

```js
promise.then(
  function(result) { *!*/* handle a successful result */*/!* },
  function(error) { *!*/* handle an error */*/!* }
);
```

`.then` 的第一个参数是一个函数，该函数将在 promise resolved 后运行并接收结果。

`.then` 的第二个参数也是一个函数，该函数将在 promise rejected 后运行并接收 error。

例如，以下是对成功 resolved 的 promise 做出的反应：

```js run
let promise = new Promise(function(resolve, reject) {
  setTimeout(() =&gt; resolve(&quot;done!&quot;), 1000);
});

// resolve 运行 .then 中的第一个函数
promise.then(
*!*
  result =&gt; alert(result), // 1 秒后显示 &quot;done!&quot;
*/!*
  error =&gt; alert(error) // 不运行
);
```

第一个函数被运行了。

在 reject 的情况下，运行第二个：

```js run
let promise = new Promise(function(resolve, reject) {
  setTimeout(() =&gt; reject(new Error(&quot;Whoops!&quot;)), 1000);
});

// reject 运行 .then 中的第二个函数
promise.then(
  result =&gt; alert(result), // 不运行
*!*
  error =&gt; alert(error) // 1 秒后显示 &quot;Error: Whoops!&quot;
*/!*
);
```

如果我们只对成功完成的情况感兴趣，那么我们可以只为 `.then` 提供一个函数参数：

```js run
let promise = new Promise(resolve =&gt; {
  setTimeout(() =&gt; resolve(&quot;done!&quot;), 1000);
});

*!*
promise.then(alert); // 1 秒后显示 &quot;done!&quot;
*/!*
```

### catch

如果我们只对 error 感兴趣，那么我们可以使用 `null` 作为第一个参数：`.then(null, errorHandlingFunction)`。或者我们也可以使用 `.catch(errorHandlingFunction)`，其实是一样的：


```js run
let promise = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; reject(new Error(&quot;Whoops!&quot;)), 1000);
});

*!*
// .catch(f) 与 promise.then(null, f) 一样
promise.catch(alert); // 1 秒后显示 &quot;Error: Whoops!&quot;
*/!*
```

`.catch(f)` 调用是 `.then(null, f)` 的完全的模拟，它只是一个简写形式。

### finally

就像常规 `try {...} catch {...}` 中的 `finally` 子句一样，promise 中也有 `finally`。

`.finally(f)` 调用与 `.then(f, f)` 类似，在某种意义上，`f` 总是在 promise 被 settled 时运行：即 promise 被 resolve 或 reject。

`finally` 是执行清理（cleanup）的很好的处理程序（handler），例如无论结果如何，都停止使用不再需要的加载指示符（indicator）。

像这样：

```js
new Promise((resolve, reject) =&gt; {
  /* 做一些需要时间的事儿，然后调用 resolve/reject */
})
*!*
  // 在 promise 被 settled 时运行，无论成功与否
  .finally(() =&gt; stop loading indicator)
*/!*
  .then(result =&gt; show result, err =&gt; show error)
```

不过，它并不是 `then(f,f)` 的别名。它们之间有几个重要的区别：

1. `finally` 处理程序（handler）没有参数。在 `finally` 中，我们不知道 promise 是否成功。没关系，因为我们的任务通常是执行“常规”的定稿程序（finalizing procedures）。
2. `finally` 处理程序将结果和 error 传递给下一个处理程序。

    例如，在这儿结果被从 `finally` 传递给了 `then`：
    ```js run
    new Promise((resolve, reject) =&gt; {
      setTimeout(() =&gt; resolve(&quot;result&quot;), 2000)
    })
      .finally(() =&gt; alert(&quot;Promise ready&quot;))
      .then(result =&gt; alert(result)); // &lt;-- .then 对结果进行处理
    ```

    在这儿，promise 中有一个 error，这个 error 被从 `finally` 传递给了 `catch`：

    ```js run
    new Promise((resolve, reject) =&gt; {
      throw new Error(&quot;error&quot;);
    })
      .finally(() =&gt; alert(&quot;Promise ready&quot;))
      .catch(err =&gt; alert(err));  // &lt;-- .catch 对 error 对象进行处理
    ```

    这非常方便，因为 `finally` 并不是意味着要处理 promise 的结果。所以它将结果传递了下去。

    在下一章中，我们将详细讨论 promise 链以及处理程序（handler）之间的结果传递。

3. 最后，但并非最不重要的一点是，`.finally(f)` 是比 `.then(f, f)` 更为方便的语法：无需重复函数 `f`。

````smart header=&quot;在 settled 的 promise 上，`then` 会立即运行&quot;
如果 promise 为 pending 状态，`.then/catch/finally` 处理程序（handler）将等待它。否则，如果 promise 已经是 settled 状态，它们就会立即执行：

```js run
// the promise becomes resolved immediately upon creation
let promise = new Promise(resolve =&gt; resolve(&quot;done!&quot;));

promise.then(alert); // done!（现在显示）
```

请注意，这和现实生活中的类比是不同的，并且比现实生活中的“订阅列表”方案强大得多。如果歌手已经发布了他们的单曲，然后某个人在订阅列表上进行了注册，则他们很可能不会收到该单曲。实际生活中的订阅必须在活动开始之前进行。

Promise 则更加灵活。我们可以随时添加处理程序（handler）：如果结果已经在了，我们的处理程序便会立即获得这个结果。</code></pre>
<p>接下来，让我们看一下关于 promise 如何帮助我们编写异步代码的更多实际示例。</p>
<h2 id="示例：loadscript-loadscript">示例：loadScript [#loadscript]</h2>
<p>我们从上一章获得了用于加载脚本的 <code>loadScript</code> 函数。</p>
<p>这是基于回调函数的变体，记住它：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadScript</span>(<span class="hljs-params">src, callback</span>) </span>{
  <span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);
  script.src = src;

  script.onload = <span class="hljs-function">() =&gt;</span> callback(<span class="hljs-literal">null</span>, script);
  script.onerror = <span class="hljs-function">() =&gt;</span> callback(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Script load error for <span class="hljs-subst">${src}</span>`</span>));

  <span class="hljs-built_in">document</span>.head.append(script);
}</code></pre>
<p>让我们用 promise 重写它。</p>
<p>新函数 <code>loadScript</code> 将不需要回调。取而代之的是，它将创建并返回一个在加载完成时解析（resolve）的 promise 对象。外部代码可以使用 <code>.then</code> 向其添加处理程序（订阅函数）：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadScript</span>(<span class="hljs-params">src</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{
    <span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);
    script.src = src;

    script.onload = <span class="hljs-function">() =&gt;</span> resolve(script);
    script.onerror = <span class="hljs-function">() =&gt;</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Script load error for <span class="hljs-subst">${src}</span>`</span>));

    <span class="hljs-built_in">document</span>.head.append(script);
  });
}</code></pre>
<p>用法：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> promise = loadScript(<span class="hljs-string">&quot;https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js&quot;</span>);

promise.then(
  <span class="hljs-function"><span class="hljs-params">script</span> =&gt;</span> alert(<span class="hljs-string">`<span class="hljs-subst">${script.src}</span> is loaded!`</span>),
  <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> alert(<span class="hljs-string">`Error: <span class="hljs-subst">${error.message}</span>`</span>)
);

promise.then(<span class="hljs-function"><span class="hljs-params">script</span> =&gt;</span> alert(<span class="hljs-string">&#x27;Another handler...&#x27;</span>));</code></pre>
<p>我们立刻就能发现 promise 相较于基于回调的模式的一些好处：</p>
<table>
<thead>
<tr>
<th>Promises</th>
<th>Callbacks</th>
</tr>
</thead>
<tbody><tr>
<td>Promises 允许我们按照自然顺序进行编码。首先，我们运行 <code>loadScript</code> 和 <code>.then</code> 来处理结果。</td>
<td>在调用 <code>loadScript(script, callback)</code> 时，在我们处理的地方（disposal）必须有一个 <code>callback</code> 函数。换句话说，在调用 <code>loadScript</code> <strong>之前</strong>，我们必须知道如何处理结果。</td>
</tr>
<tr>
<td>我们可以根据需要，在 promise 上多次调用 <code>.then</code>。每次调用，我们都会在“订阅列表”中添加一个新的“分析”，一个新的订阅函数。在下一章将对此内容进行详细介绍：<a href="info:promise-chaining"></a>。</td>
<td>只能有一个回调。</td>
</tr>
</tbody></table>
<p>因此，promise 为我们提供了更好的代码流和灵活性。但其实还有更多相关内容。我们将在下一章看到。</p>

      </fieldset>
      
      <fieldset id='_a6ZSHx'>
      <legend>solution</legend>
      <p>简要回答就是：<strong>不，它们不相等</strong>：</p>
<p>不同之处在于，如果 <code>f1</code> 中出现 error，那么在这儿它会被 <code>.catch</code> 处理：</p>
<pre><code class="language-js">promise
  .then(f1)
  .catch(f2);</code></pre>
<p>……在这儿则不会：</p>
<pre><code class="language-js">promise
  .then(f1, f2);</code></pre>
<p>这是因为 error 是沿着链传递的，而在第二段代码中，<code>f1</code> 下面没有链。</p>
<p>换句话说，<code>.then</code> 将 result/error 传递给下一个 <code>.then/.catch</code>。所以在第一个例子中，在下面有一个 <code>catch</code>，而在第二个例子中并没有 <code>catch</code>，所以 error 未被处理。</p>

      </fieldset>
      
      <fieldset id='_IamoU8'>
      <legend>task</legend>
      <h1 id="promise：then-对比-catch">Promise：then 对比 catch</h1>
<p>这两个代码片段是否相等？换句话说，对于任何处理程序（handler），它们在任何情况下的行为都相同吗？</p>
<pre><code class="language-js">promise.then(f1).catch(f2);</code></pre>
<p>对比：</p>
<pre><code class="language-js">promise.then(f1, f2);</code></pre>

      </fieldset>
      
      <fieldset id='_5hdPxa'>
      <legend>article</legend>
      <h1 id="promise-链">Promise 链</h1>
<p>我们回顾一下 <a href="info:callbacks">info:callbacks</a> 一章中提到的问题：我们有一系列的异步任务要一个接一个地执行 — 例如，加载脚本。我们如何写出更好的代码呢？</p>
<p>Promise 提供了一些方案来做到这一点。</p>
<p>在本章中，我们将一起学习 promise 链。</p>
<p>它看起来就像这样：</p>
<pre><code class="language-js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{

  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> resolve(<span class="hljs-number">1</span>), <span class="hljs-number">1000</span>); <span class="hljs-comment">// (*)</span>

}).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) </span>{ <span class="hljs-comment">// (**)</span>

  alert(result); <span class="hljs-comment">// 1</span>
  <span class="hljs-keyword">return</span> result * <span class="hljs-number">2</span>;

}).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) </span>{ <span class="hljs-comment">// (***)</span>

  alert(result); <span class="hljs-comment">// 2</span>
  <span class="hljs-keyword">return</span> result * <span class="hljs-number">2</span>;

}).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) </span>{

  alert(result); <span class="hljs-comment">// 4</span>
  <span class="hljs-keyword">return</span> result * <span class="hljs-number">2</span>;

});</code></pre>
<p>它的理念是将 result 通过 <code>.then</code> 处理程序（handler）链进行传递。</p>
<p>运行流程如下：</p>
<ol>
<li>初始 promise 在 1 秒后进行 resolve <code>(*)</code>，</li>
<li>然后 <code>.then</code> 处理程序（handler）被调用 <code>(**)</code>。</li>
<li>它返回的值被传入下一个 <code>.then</code> 处理程序（handler）<code>(***)</code></li>
<li>……依此类推。</li>
</ol>
<p>随着 result 在处理程序（handler）链中传递，我们可以看到一系列的 <code>alert</code> 调用：<code>1</code> -&gt; <code>2</code> -&gt; <code>4</code>。</p>
<p><img src="promise-then-chain.svg" alt=""></p>
<p>之所以这么运行，是因为对 <code>promise.then</code> 的调用会返回了一个 promise，所以我们可以在其之上调用下一个 <code>.then</code>。</p>
<p>当处理程序（handler）返回一个值时，它将成为该 promise 的 result，所以将使用它调用下一个 <code>.then</code>。</p>
<p><strong>新手常犯的一个经典错误：从技术上讲，我们也可以将多个 <code>.then</code> 添加到一个 promise 上。但这并不是 promise 链（chaining）。</strong></p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> resolve(<span class="hljs-number">1</span>), <span class="hljs-number">1000</span>);
});

promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) </span>{
  alert(result); <span class="hljs-comment">// 1</span>
  <span class="hljs-keyword">return</span> result * <span class="hljs-number">2</span>;
});

promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) </span>{
  alert(result); <span class="hljs-comment">// 1</span>
  <span class="hljs-keyword">return</span> result * <span class="hljs-number">2</span>;
});

promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) </span>{
  alert(result); <span class="hljs-comment">// 1</span>
  <span class="hljs-keyword">return</span> result * <span class="hljs-number">2</span>;
});</code></pre>
<p>我们在这里所做的只是一个 promise 的几个处理程序（handler）。它们不会相互传递 result；相反，它们之间彼此独立运行处理任务。</p>
<p>这里它的一张示意图（你可以将其与上面的链式调用做一下比较）：</p>
<p><img src="promise-then-many.svg" alt=""></p>
<p>在同一个 promise 上的所有 <code>.then</code> 获得的结果都相同 — 该 promise 的结果。所以，在上面的代码中，所有 <code>alert</code> 都显示相同的内容：<code>1</code>。</p>
<p>实际上我们极少遇到一个 promise 需要多处理程序（handler）的情况。使用链式调用的频率更高。</p>
<h2 id="返回-promise">返回 promise</h2>
<p><code>.then(handler)</code> 中所使用的处理程序（handler）可以创建并返回一个 promise。</p>
<p>在这种情况下，其他的处理程序（handler）将等待它 settled 后再获得其结果（result）。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{

  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> resolve(<span class="hljs-number">1</span>), <span class="hljs-number">1000</span>);

}).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) </span>{

  alert(result); <span class="hljs-comment">// 1</span>

*!*
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> { <span class="hljs-comment">// (*)</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> resolve(result * <span class="hljs-number">2</span>), <span class="hljs-number">1000</span>);
  });
*/!*

}).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) </span>{ <span class="hljs-comment">// (**)</span>

  alert(result); <span class="hljs-comment">// 2</span>

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> resolve(result * <span class="hljs-number">2</span>), <span class="hljs-number">1000</span>);
  });

}).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) </span>{

  alert(result); <span class="hljs-comment">// 4</span>

});</code></pre>
<p>这里第一个 <code>.then</code> 显示 <code>1</code> 并在 <code>(*)</code> 行返回 <code>new Promise(…)</code>。1 秒后它会进行 resolve，然后 result（<code>resolve</code> 的参数，在这里它是 <code>result*2</code>）被传递给第二个 <code>.then</code> 的处理程序（handler）。这个处理程序（handler）位于 <code>(**)</code> 行，它显示 <code>2</code>，并执行相同的动作（action）。</p>
<p>所以输出与前面的示例相同：1 -&gt; 2 -&gt; 4，但是现在在每次 <code>alert</code> 调用之间会有 1 秒钟的延迟。</p>
<p>返回 promise 使我们能够构建异步行为链。</p>
<h2 id="示例：loadscript">示例：loadScript</h2>
<p>让我们将本章所讲的这个特性与在 <a href="info:promise-basics#loadscript">上一章</a> 中定义的 promise 化的 <code>loadScript</code> 结合使用，按顺序依次加载脚本：</p>
<pre><code class="language-js">loadScript(<span class="hljs-string">&quot;/article/promise-chaining/one.js&quot;</span>)
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">script</span>) </span>{
    <span class="hljs-keyword">return</span> loadScript(<span class="hljs-string">&quot;/article/promise-chaining/two.js&quot;</span>);
  })
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">script</span>) </span>{
    <span class="hljs-keyword">return</span> loadScript(<span class="hljs-string">&quot;/article/promise-chaining/three.js&quot;</span>);
  })
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">script</span>) </span>{
    <span class="hljs-comment">// 使用在脚本中声明的函数</span>
    <span class="hljs-comment">// 以证明脚本确实被加载完成了</span>
    one();
    two();
    three();
  });</code></pre>
<p>我们可以用箭头函数来重写代码，让其变得简短一些：</p>
<pre><code class="language-js">loadScript(<span class="hljs-string">&quot;/article/promise-chaining/one.js&quot;</span>)
  .then(<span class="hljs-function"><span class="hljs-params">script</span> =&gt;</span> loadScript(<span class="hljs-string">&quot;/article/promise-chaining/two.js&quot;</span>))
  .then(<span class="hljs-function"><span class="hljs-params">script</span> =&gt;</span> loadScript(<span class="hljs-string">&quot;/article/promise-chaining/three.js&quot;</span>))
  .then(<span class="hljs-function"><span class="hljs-params">script</span> =&gt;</span> {
    <span class="hljs-comment">// 脚本加载完成，我们可以在这儿使用脚本中声明的函数</span>
    one();
    two();
    three();
  });</code></pre>
<p>在这儿，每个 <code>loadScript</code> 调用都返回一个 promise，并且在它 resolve 时下一个 <code>.then</code> 开始运行。然后，它启动下一个脚本的加载。所以，脚本是一个接一个地加载的。</p>
<p>我们可以向链中添加更多的异步行为（action）。请注意，代码仍然是“扁平”的 — 它向下增长，而不是向右。这里没有“厄运金字塔”的迹象。</p>
<p>从技术上讲，我们可以向每个 <code>loadScript</code> 直接添加 <code>.then</code>，就像这样：</p>
<pre><code class="language-js">loadScript(<span class="hljs-string">&quot;/article/promise-chaining/one.js&quot;</span>).then(<span class="hljs-function"><span class="hljs-params">script1</span> =&gt;</span> {
  loadScript(<span class="hljs-string">&quot;/article/promise-chaining/two.js&quot;</span>).then(<span class="hljs-function"><span class="hljs-params">script2</span> =&gt;</span> {
    loadScript(<span class="hljs-string">&quot;/article/promise-chaining/three.js&quot;</span>).then(<span class="hljs-function"><span class="hljs-params">script3</span> =&gt;</span> {
      <span class="hljs-comment">// 此函数可以访问变量 script1，script2 和 script3</span>
      one();
      two();
      three();
    });
  });
});</code></pre>
<p>这段代码做了相同的事儿：按顺序加载 3 个脚本。但它是“向右增长”的。所以会有和使用回调函数一样的问题。</p>
<p>刚开始使用 promise 的人可能不知道 promise 链，所以他们就这样写了。通常，链式是首选。</p>
<p>有时候直接写 <code>.then</code> 也是可以的，因为嵌套的函数可以访问外部作用域。在上面的例子中，嵌套在最深层的那个回调（callback）可以访问所有变量 <code>script1</code>，<code>script2</code> 和 <code>script3</code>。但这是一个例外，而不是一条规则。</p>
<pre><code class="language-smart">确切地说，处理程序（handler）返回的不完全是一个 promise，而是返回的被称为 &quot;thenable&quot; 对象 — 一个具有方法 `.then` 的任意对象。它会被当做一个 promise 来对待。

这个想法是，第三方库可以实现自己的“promise 兼容（promise-compatible）”对象。它们可以具有扩展的方法集，但也与原生的 promise 兼容，因为它们实现了 `.then` 方法。

这是一个 thenable 对象的示例：

```js run
class Thenable {
  constructor(num) {
    this.num = num;
  }
  then(resolve, reject) {
    alert(resolve); // function() { native code }
    // 1 秒后使用 this.num*2 进行 resolve
    setTimeout(() =&gt; resolve(this.num * 2), 1000); // (**)
  }
}

new Promise(resolve =&gt; resolve(1))
  .then(result =&gt; {
*!*
    return new Thenable(result); // (*)
*/!*
  })
  .then(alert); // 1000ms 后显示 2
```

JavaScript 检查在 `(*)` 行中由 `.then` 处理程序（handler）返回的对象：如果它具有名为 `then` 的可调用方法，那么它将调用该方法并提供原生的函数 `resolve` 和 `reject` 作为参数（类似于 executor），并等待直到其中一个函数被调用。在上面的示例中，`resolve(2)` 在 1 秒后被调用 `(**)`。然后，result 会被进一步沿着链向下传递。

这个特性允许我们将自定义的对象与 promise 链集成在一起，而不必继承自 `Promise`。</code></pre>
<h2 id="更复杂的示例：fetch">更复杂的示例：fetch</h2>
<p>在前端编程中，promise 通常被用于网络请求。那么，让我们一起来看一个相关的扩展示例吧。</p>
<p>我们将使用 <a href="info:fetch">fetch</a> 方法从远程服务器加载用户信息。它有很多可选的参数，我们在 <a href="info:fetch">单独的一章</a> 中对其进行了详细介绍，但是基本语法很简单：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> promise = fetch(url);</code></pre>
<p>执行这条语句，向 <code>url</code> 发出网络请求并返回一个 promise。当远程服务器返回 header（是在 <strong>全部响应加载完成前</strong>）时，该 promise 使用一个 <code>response</code> 对象来进行 resolve。</p>
<p>为了读取完整的响应，我们应该调用 <code>response.text()</code> 方法：当全部文字（full text）内容从远程服务器下载完成后，它会返回一个 promise，该 promise 以刚刚下载完成的这个文本作为 result 进行 resolve。</p>
<p>下面这段代码向 <code>user.json</code> 发送请求，并从服务器加载该文本：</p>
<pre><code class="language-js">fetch(<span class="hljs-string">&#x27;/article/promise-chaining/user.json&#x27;</span>)
  <span class="hljs-comment">// 当远程服务器响应时，下面的 .then 开始执行</span>
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) </span>{
    <span class="hljs-comment">// 当 user.json 加载完成时，response.text() 会返回一个新的 promise</span>
    <span class="hljs-comment">// 该 promise 以加载的 user.json 为 result 进行 resolve</span>
    <span class="hljs-keyword">return</span> response.text();
  })
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">text</span>) </span>{
    <span class="hljs-comment">// ...这是远程文件的内容</span>
    alert(text); <span class="hljs-comment">// {&quot;name&quot;: &quot;iliakan&quot;, &quot;isAdmin&quot;: true}</span>
  });</code></pre>
<p>从 <code>fetch</code> 返回的 <code>response</code> 对象还包括 <code>response.json()</code> 方法，该方法读取远程数据并将其解析为 JSON。在我们的例子中，这更加方便，所以让我们切换到这个方法。</p>
<p>为了简洁，我们还将使用箭头函数：</p>
<pre><code class="language-js"><span class="hljs-comment">// 同上，但是使用 response.json() 将远程内容解析为 JSON</span>
fetch(<span class="hljs-string">&#x27;/article/promise-chaining/user.json&#x27;</span>)
  .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())
  .then(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> alert(user.name)); <span class="hljs-comment">// iliakan, got user name</span></code></pre>
<p>现在，让我们用加载好的用户信息搞点事情。</p>
<p>例如，我们可以多发一个到 GitHub 的请求，加载用户个人资料并显示头像：</p>
<pre><code class="language-js"><span class="hljs-comment">// 发送一个对 user.json 的请求</span>
fetch(<span class="hljs-string">&#x27;/article/promise-chaining/user.json&#x27;</span>)
  <span class="hljs-comment">// 将其加载为 JSON</span>
  .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())
  <span class="hljs-comment">// 发送一个到 GitHub 的请求</span>
  .then(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> fetch(<span class="hljs-string">`https://api.github.com/users/<span class="hljs-subst">${user.name}</span>`</span>))
  <span class="hljs-comment">// 将响应加载为 JSON</span>
  .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())
  <span class="hljs-comment">// 显示头像图片（githubUser.avatar_url）3 秒（也可以加上动画效果）</span>
  .then(<span class="hljs-function"><span class="hljs-params">githubUser</span> =&gt;</span> {
    <span class="hljs-keyword">let</span> img = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;img&#x27;</span>);
    img.src = githubUser.avatar_url;
    img.className = <span class="hljs-string">&quot;promise-avatar-example&quot;</span>;
    <span class="hljs-built_in">document</span>.body.append(img);

    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> img.remove(), <span class="hljs-number">3000</span>); <span class="hljs-comment">// (*)</span>
  });</code></pre>
<p>这段代码可以工作，具体细节请看注释。但是，这儿有一个潜在的问题，一个新手使用 promise 的典型问题。</p>
<p>请看 <code>(*)</code> 行：我们如何能在头像显示结束并被移除 <strong>之后</strong> 做点什么？例如，我们想显示一个用于编辑该用户或者其他内容的表单。就目前而言，是做不到的。</p>
<p>为了使链可扩展，我们需要返回一个在头像显示结束时进行 resolve 的 promise。</p>
<p>就像这样：</p>
<pre><code class="language-js">fetch(<span class="hljs-string">&#x27;/article/promise-chaining/user.json&#x27;</span>)
  .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())
  .then(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> fetch(<span class="hljs-string">`https://api.github.com/users/<span class="hljs-subst">${user.name}</span>`</span>))
  .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())
*!*
  .then(<span class="hljs-function"><span class="hljs-params">githubUser</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{ <span class="hljs-comment">// (*)</span>
*/!*
    <span class="hljs-keyword">let</span> img = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;img&#x27;</span>);
    img.src = githubUser.avatar_url;
    img.className = <span class="hljs-string">&quot;promise-avatar-example&quot;</span>;
    <span class="hljs-built_in">document</span>.body.append(img);

    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      img.remove();
*!*
      resolve(githubUser); <span class="hljs-comment">// (**)</span>
*/!*
    }, <span class="hljs-number">3000</span>);
  }))
  <span class="hljs-comment">// 3 秒后触发</span>
  .then(<span class="hljs-function"><span class="hljs-params">githubUser</span> =&gt;</span> alert(<span class="hljs-string">`Finished showing <span class="hljs-subst">${githubUser.name}</span>`</span>));</code></pre>
<p>也就是说，第 <code>(*)</code> 行的 <code>.then</code> 处理程序（handler）现在返回一个 <code>new Promise</code>，只有在 <code>setTimeout</code> 中的 <code>resolve(githubUser)</code> <code>(**)</code> 被调用后才会变为 settled。链中的下一个 <code>.then</code> 将一直等待这一时刻的到来。</p>
<p>作为一个好的做法，异步行为应该始终返回一个 promise。这样就可以使得之后我们计划后续的行为成为可能。即使我们现在不打算对链进行扩展，但我们之后可能会需要。</p>
<p>最后，我们可以将代码拆分为可重用的函数：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadJson</span>(<span class="hljs-params">url</span>) </span>{
  <span class="hljs-keyword">return</span> fetch(url)
    .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json());
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadGithubUser</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">return</span> fetch(<span class="hljs-string">`https://api.github.com/users/<span class="hljs-subst">${name}</span>`</span>)
    .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json());
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showAvatar</span>(<span class="hljs-params">githubUser</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{
    <span class="hljs-keyword">let</span> img = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;img&#x27;</span>);
    img.src = githubUser.avatar_url;
    img.className = <span class="hljs-string">&quot;promise-avatar-example&quot;</span>;
    <span class="hljs-built_in">document</span>.body.append(img);

    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      img.remove();
      resolve(githubUser);
    }, <span class="hljs-number">3000</span>);
  });
}

<span class="hljs-comment">// 使用它们：</span>
loadJson(<span class="hljs-string">&#x27;/article/promise-chaining/user.json&#x27;</span>)
  .then(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> loadGithubUser(user.name))
  .then(showAvatar)
  .then(<span class="hljs-function"><span class="hljs-params">githubUser</span> =&gt;</span> alert(<span class="hljs-string">`Finished showing <span class="hljs-subst">${githubUser.name}</span>`</span>));
  <span class="hljs-comment">// ...</span></code></pre>
<h2 id="总结">总结</h2>
<p>如果 <code>.then</code>（或 <code>catch/finally</code> 都可以）处理程序（handler）返回一个 promise，那么链的其余部分将会等待，直到它状态变为 settled。当它被 settled 后，其 result（或 error）将被进一步传递下去。</p>
<p>这是一个完整的流程图：</p>
<p><img src="promise-handler-variants.svg" alt=""></p>

      </fieldset>
      
      <fieldset id='_4EiQXP'>
      <legend>solution</legend>
      <p>答案是：<strong>不，它不会被触发</strong>：</p>
<pre><code class="language-js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Whoops!&quot;</span>);
  }, <span class="hljs-number">1000</span>);
}).catch(alert);</code></pre>
<p>正如本章所讲，函数代码周围有个“隐式的 <code>try..catch</code>”。所以，所有同步错误都会得到处理。</p>
<p>但是这里的错误并不是在 executor 运行时生成的，而是在稍后生成的。因此，promise 无法处理它。</p>

      </fieldset>
      
      <fieldset id='_y0P1Fv'>
      <legend>task</legend>
      <h1 id="settimeout-中的错误">setTimeout 中的错误</h1>
<p>你怎么看？<code>.catch</code> 会被触发么？解释你的答案。</p>
<pre><code class="language-js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>{
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Whoops!&quot;</span>);
  }, <span class="hljs-number">1000</span>);
}).catch(alert);</code></pre>

      </fieldset>
      
      <fieldset id='_GO90M2'>
      <legend>article</legend>
      <h1 id="使用-promise-进行错误处理">使用 promise 进行错误处理</h1>
<p>Promise 链在错误（error）处理中十分强大。当一个 promise 被 reject 时，控制权将移交至最近的 rejection 处理程序（handler）。这在实际开发中非常方便。</p>
<p>例如，下面代码中所 <code>fetch</code> 的 URL 是错的（没有这个网站），<code>.catch</code> 对这个 error 进行了处理：</p>
<pre><code class="language-js">*!*
fetch(<span class="hljs-string">&#x27;https://no-such-server.blabla&#x27;</span>) <span class="hljs-comment">// rejects</span>
*/!*
  .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())
  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> alert(err)) <span class="hljs-comment">// TypeError: failed to fetch（这里的文字可能有所不同）</span></code></pre>
<p>正如你所看到的，<code>.catch</code> 不必是立即的。它可能在一个或多个 <code>.then</code> 之后出现。</p>
<p>或者，可能该网站一切正常，但响应不是有效的 JSON。捕获所有 error 的最简单的方法是，将 <code>.catch</code> 附加到链的末尾：</p>
<pre><code class="language-js">fetch(<span class="hljs-string">&#x27;/article/promise-chaining/user.json&#x27;</span>)
  .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())
  .then(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> fetch(<span class="hljs-string">`https://api.github.com/users/<span class="hljs-subst">${user.name}</span>`</span>))
  .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())
  .then(<span class="hljs-function"><span class="hljs-params">githubUser</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-keyword">let</span> img = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;img&#x27;</span>);
    img.src = githubUser.avatar_url;
    img.className = <span class="hljs-string">&quot;promise-avatar-example&quot;</span>;
    <span class="hljs-built_in">document</span>.body.append(img);

    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      img.remove();
      resolve(githubUser);
    }, <span class="hljs-number">3000</span>);
  }))
*!*
  .catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> alert(error.message));
*/!*</code></pre>
<p>通常情况下，这样的 <code>.catch</code> 根本不会被触发。但是如果上述任意一个 promise 被 reject（网络问题或者无效的 json 或其他），<code>.catch</code> 就会捕获它。</p>
<h2 id="隐式-trycatch">隐式 try..catch</h2>
<p>Promise 的执行者（executor）和 promise 的处理程序（handler）周围有一个“隐式的 <code>try..catch</code>”。如果发生异常，它（译注：指异常）就会被捕获，并被视为 rejection 进行处理。</p>
<p>例如，下面这段代码：</p>
<pre><code class="language-js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
*!*
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Whoops!&quot;</span>);
*/!*
}).catch(alert); <span class="hljs-comment">// Error: Whoops!</span></code></pre>
<p>……与下面这段代码工作上完全相同：</p>
<pre><code class="language-js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
*!*
  reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Whoops!&quot;</span>));
*/!*
}).catch(alert); <span class="hljs-comment">// Error: Whoops!</span></code></pre>
<p>在 executor 周围的“隐式 <code>try..catch</code>”自动捕获了 error，并将其变为 rejected promise。</p>
<p>这不仅仅发生在 executor 函数中，同样也发生在其 handler 中。如果我们在 <code>.then</code> 处理程序（handler）中 <code>throw</code>，这意味着 promise 被 rejected，因此控制权移交至最近的 error 处理程序（handler）。</p>
<p>这是一个例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  resolve(<span class="hljs-string">&quot;ok&quot;</span>);
}).then(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> {
*!*
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Whoops!&quot;</span>); <span class="hljs-comment">// reject 这个 promise</span>
*/!*
}).catch(alert); <span class="hljs-comment">// Error: Whoops!</span></code></pre>
<p>对于所有的 error 都会发生这种情况，而不仅仅是由 <code>throw</code> 语句导致的这些 error。例如，一个编程错误：</p>
<pre><code class="language-js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  resolve(<span class="hljs-string">&quot;ok&quot;</span>);
}).then(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> {
*!*
  blabla(); <span class="hljs-comment">// 没有这个函数</span>
*/!*
}).catch(alert); <span class="hljs-comment">// ReferenceError: blabla is not defined</span></code></pre>
<p>最后的 <code>.catch</code> 不仅会捕获显式的 rejection，还会捕获它上面的处理程序（handler）中意外出现的 error。</p>
<h2 id="再次抛出（rethrowing）">再次抛出（Rethrowing）</h2>
<p>正如我们已经注意到的，链尾端的 <code>.catch</code> 的表现有点像 <code>try..catch</code>。我们可能有许多个 <code>.then</code> 处理程序（handler），然后在尾端使用一个 <code>.catch</code> 处理上面的所有 error。</p>
<p>在常规的 <code>try..catch</code> 中，我们可以分析错误（error），如果我们无法处理它，可以将其再次抛出。对于 promise 来说，这也是可以的。</p>
<p>如果我们在 <code>.catch</code> 中 <code>throw</code>，那么控制权就会被移交到下一个最近的 error 处理程序（handler）。如果我们处理该 error 并正常完成，那么它将继续到最近的成功的 <code>.then</code> 处理程序（handler）。</p>
<p>在下面这个例子中，<code>.catch</code> 成功处理了 error：</p>
<pre><code class="language-js"><span class="hljs-comment">// 执行流：catch -&gt; then</span>
<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {

  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Whoops!&quot;</span>);

}).catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>{

  alert(<span class="hljs-string">&quot;The error is handled, continue normally&quot;</span>);

}).then(<span class="hljs-function">() =&gt;</span> alert(<span class="hljs-string">&quot;Next successful handler runs&quot;</span>));</code></pre>
<p>这里 <code>.catch</code> 块正常完成。所以下一个成功的 <code>.then</code> 处理程序（handler）就会被调用。</p>
<p>在下面的例子中，我们可以看到 <code>.catch</code> 的另一种情况。<code>(*)</code> 行的处理程序（handler）捕获了 error，但无法处理它（例如，它只知道如何处理 <code>URIError</code>），所以它将其再次抛出：</p>
<pre><code class="language-js"><span class="hljs-comment">// 执行流：catch -&gt; catch</span>
<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {

  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Whoops!&quot;</span>);

}).catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>{ <span class="hljs-comment">// (*)</span>

  <span class="hljs-keyword">if</span> (error <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">URIError</span>) {
    <span class="hljs-comment">// 处理它</span>
  } <span class="hljs-keyword">else</span> {
    alert(<span class="hljs-string">&quot;Can&#x27;t handle such error&quot;</span>);

*!*
    <span class="hljs-keyword">throw</span> error; <span class="hljs-comment">// 再次抛出此 error 或另外一个 error，执行将跳转至下一个 catch</span>
*/!*
  }

}).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">/* 不在这里运行 */</span>
}).catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> { <span class="hljs-comment">// (**)</span>

  alert(<span class="hljs-string">`The unknown error has occurred: <span class="hljs-subst">${error}</span>`</span>);
  <span class="hljs-comment">// 不会返回任何内容 =&gt; 执行正常进行</span>

});</code></pre>
<p>执行从第一个 <code>.catch</code> <code>(*)</code> 沿着链跳转至下一个 <code>(**)</code>。</p>
<h2 id="未处理的-rejection">未处理的 rejection</h2>
<p>当一个 error 没有被处理会发生什么？例如，我们忘了在链的尾端附加 <code>.catch</code>，像这样：</p>
<pre><code class="language-js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  noSuchFunction(); <span class="hljs-comment">// 这里出现 error（没有这个函数）</span>
})
  .then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 一个或多个成功的 promise 处理程序（handler）</span>
  }); <span class="hljs-comment">// 尾端没有 .catch！</span></code></pre>
<p>如果出现 error，promise 的状态将变为 &quot;rejected&quot;，然后执行应该跳转至最近的 rejection 处理程序（handler）。但是上面这个例子中并没有这样的处理程序（handler）。因此 error 会“卡住（stuck）”。没有代码来处理它。</p>
<p>在实际开发中，就像代码中常规的未处理的 error 一样，这意味着某些东西出了问题。</p>
<p>当发生一个常规的错误（error）并且未被 <code>try..catch</code> 捕获时会发生什么？脚本死了，并在控制台（console）中留下了一个信息。对于在 promise 中未被处理的 rejection，也会发生类似的事儿。</p>
<p>JavaScript 引擎会跟踪此类 rejection，在这种情况下会生成一个全局的 error。如果你运行上面这个代码，你可以在控制台（console）中看到。</p>
<p>在浏览器中，我们可以使用 <code>unhandledrejection</code> 事件来捕获这类 error：</p>
<pre><code class="language-js">*!*
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;unhandledrejection&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
  <span class="hljs-comment">// 这个事件对象有两个特殊的属性：</span>
  alert(event.promise); <span class="hljs-comment">// [object Promise] - 生成该全局 error 的 promise</span>
  alert(event.reason); <span class="hljs-comment">// Error: Whoops! - 未处理的 error 对象</span>
});
*/!*

<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Whoops!&quot;</span>);
}); <span class="hljs-comment">// 没有用来处理 error 的 catch</span></code></pre>
<p>这个事件是 <a href="https://html.spec.whatwg.org/multipage/webappapis.html#unhandled-promise-rejections">HTML 标准</a> 的一部分。</p>
<p>如果出现了一个 error，并且在这儿没有 <code>.catch</code>，那么 <code>unhandledrejection</code> 处理程序（handler）就会被触发，并获取具有 error 相关信息的 <code>event</code> 对象，所以我们就能做一些后续处理了。</p>
<p>通常此类 error 是无法恢复的，所以我们最好的解决方案是将问题告知用户，并且可以将事件报告给服务器。</p>
<p>在 Node.js 等非浏览器环境中，有其他用于跟踪未处理的 error 的方法。</p>
<h2 id="总结">总结</h2>
<ul>
<li><code>.catch</code> 处理 promise 中的各种 error：在 <code>reject()</code> 调用中的，或者在处理程序（handler）中抛出的（thrown）error。</li>
<li>我们应该将 <code>.catch</code> 准确地放到我们想要处理 error，并知道如何处理这些 error 的地方。处理程序应该分析 error（可以自定义 error 类来帮助分析）并再次抛出未知的 error（可能它们是编程错误）。</li>
<li>如果没有办法从 error 中恢复的话，不使用 <code>.catch</code> 也可以。</li>
<li>在任何情况下我们都应该有 <code>unhandledrejection</code> 事件处理程序（用于浏览器，以及其他环境的模拟），以跟踪未处理的 error 并告知用户（可能还有我们的服务器）有关信息，以使我们的应用程序永远不会“死掉”。</li>
</ul>
<h2 id="补充内容">补充内容</h2>
<pre><code class="language-smart">为了更清晰地讲解 promise，本文经过大幅重写，以下内容是重写时被优化掉的内容，译者认为还是很有学习价值的，遂保留下来供大家学习。</code></pre>
<h3 id="fetch-错误处理示例">Fetch 错误处理示例</h3>
<p>让我们改进用户加载（user-loading）示例的错误处理。</p>
<p>当请求无法发出时，<a href="mdn:api/WindowOrWorkerGlobalScope/fetch">fetch</a> reject 会返回 promise。例如，远程服务器无法访问，或者 URL 异常。但是如果远程服务器返回响应错误 404，甚至是错误 500，这些都被认为是合法的响应。</p>
<p>如果在 <code>(*)</code> 行，服务器返回一个错误 500 的非 JSON（non-JSON）页面该怎么办？如果没有这个用户，GitHub 返回错误 404 的页面又该怎么办呢？</p>
<pre><code class="language-js">fetch(<span class="hljs-string">&#x27;no-such-user.json&#x27;</span>) <span class="hljs-comment">// (*)</span>
  .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())
  .then(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> fetch(<span class="hljs-string">`https://api.github.com/users/<span class="hljs-subst">${user.name}</span>`</span>)) <span class="hljs-comment">// (**)</span>
  .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())
  .catch(alert); <span class="hljs-comment">// SyntaxError: Unexpected token &lt; in JSON at position 0</span>
  <span class="hljs-comment">// ...</span></code></pre>
<p>到目前为止，代码试图以 JSON 格式加载响应数据，但无论如何都会因为语法错误而失败。你可以通过执行上述例子来查看相关信息，因为文件 <code>no-such-user.json</code> 不存在。</p>
<p>这有点糟糕，因为错误只是落在链上，并没有相关细节信息：什么失败了，在哪里失败的。</p>
<p>因此我们多添加一步：我们应该检查具有 HTTP 状态的 <code>response.status</code> 属性，如果不是 200 就抛出错误。</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Error</span> </span>{ <span class="hljs-comment">// (1)</span>
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">response</span>)</span> {
    <span class="hljs-built_in">super</span>(<span class="hljs-string">`<span class="hljs-subst">${response.status}</span> for <span class="hljs-subst">${response.url}</span>`</span>);
    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;HttpError&#x27;</span>;
    <span class="hljs-built_in">this</span>.response = response;
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadJson</span>(<span class="hljs-params">url</span>) </span>{ <span class="hljs-comment">// (2)</span>
  <span class="hljs-keyword">return</span> fetch(url)
    .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
      <span class="hljs-keyword">if</span> (response.status == <span class="hljs-number">200</span>) {
        <span class="hljs-keyword">return</span> response.json();
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> HttpError(response);
      }
    })
}

loadJson(<span class="hljs-string">&#x27;no-such-user.json&#x27;</span>) <span class="hljs-comment">// (3)</span>
  .catch(alert); <span class="hljs-comment">// HttpError: 404 for .../no-such-user.json</span></code></pre>
<ol>
<li>我们为 HTTP 错误创建一个自定义类用于区分 HTTP 错误和其他类型错误。此外，新的类有一个 constructor，它接受 <code>response</code> 对象，并将其保存到 error 中。因此，错误处理（error-handling）代码就能够获得响应数据了。</li>
<li>然后我们将请求（requesting）和错误处理代码包装进一个函数，它能够 fetch <code>url</code> <strong>并</strong> 将所有状态码不是 200 视为错误。这很方便，因为我们通常需要这样的逻辑。</li>
<li>现在 <code>alert</code> 显示更多有用的描述信息。</li>
</ol>
<p>拥有我们自己的错误处理类的好处是我们可以使用 <code>instanceof</code> 很容易地在错误处理代码中检查错误。</p>
<p>例如，我们可以创建请求，如果我们得到 404 就可以告知用户修改信息。</p>
<p>下面的代码从 GitHub 加载给定名称的用户。如果没有这个用户，它将告知用户填写正确的名称：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">demoGithubUser</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> name = prompt(<span class="hljs-string">&quot;Enter a name?&quot;</span>, <span class="hljs-string">&quot;iliakan&quot;</span>);

  <span class="hljs-keyword">return</span> loadJson(<span class="hljs-string">`https://api.github.com/users/<span class="hljs-subst">${name}</span>`</span>)
    .then(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> {
      alert(<span class="hljs-string">`Full name: <span class="hljs-subst">${user.name}</span>.`</span>);
      <span class="hljs-keyword">return</span> user;
    })
    .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
*!*
      <span class="hljs-keyword">if</span> (err <span class="hljs-keyword">instanceof</span> HttpError &amp;&amp; err.response.status == <span class="hljs-number">404</span>) {
*/!*
        alert(<span class="hljs-string">&quot;No such user, please reenter.&quot;</span>);
        <span class="hljs-keyword">return</span> demoGithubUser();
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> err; <span class="hljs-comment">// (*)</span>
      }
    });
}

demoGithubUser();</code></pre>
<p>请注意：这里的 <code>.catch</code> 会捕获所有错误，但是它仅仅“知道如何处理” <code>HttpError 404</code>。在那种特殊情况下，它意味着没有这样的用户，而 <code>.catch</code> 仅仅在这种情况下重试。</p>
<p>对于其他错误，它不知道会出现什么问题。可能是编程错误或者其他错误。所以它仅仅是在 <code>(*)</code> 行再次抛出。</p>
<h3 id="其他">其他</h3>
<p>如果我们有加载指示（load-indication），<code>.finally</code> 是一个很好的处理程序（handler），在 fetch 完成时停止它：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">demoGithubUser</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> name = prompt(<span class="hljs-string">&quot;Enter a name?&quot;</span>, <span class="hljs-string">&quot;iliakan&quot;</span>);

*!*
  <span class="hljs-built_in">document</span>.body.style.opacity = <span class="hljs-number">0.3</span>; <span class="hljs-comment">// (1) 开始指示（indication）</span>
*/!*

  <span class="hljs-keyword">return</span> loadJson(<span class="hljs-string">`https://api.github.com/users/<span class="hljs-subst">${name}</span>`</span>)
*!*
    .finally(<span class="hljs-function">() =&gt;</span> { <span class="hljs-comment">// (2) 停止指示（indication）</span>
      <span class="hljs-built_in">document</span>.body.style.opacity = <span class="hljs-string">&#x27;&#x27;</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve)); <span class="hljs-comment">// (*)</span>
    })
*/!*
    .then(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> {
      alert(<span class="hljs-string">`Full name: <span class="hljs-subst">${user.name}</span>.`</span>);
      <span class="hljs-keyword">return</span> user;
    })
    .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
      <span class="hljs-keyword">if</span> (err <span class="hljs-keyword">instanceof</span> HttpError &amp;&amp; err.response.status == <span class="hljs-number">404</span>) {
        alert(<span class="hljs-string">&quot;No such user, please reenter.&quot;</span>);
        <span class="hljs-keyword">return</span> demoGithubUser();
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> err;
      }
    });
}

demoGithubUser();</code></pre>
<p>此处的 <code>(1)</code> 行，我们通过调暗文档来指示加载。指示方法没有什么问题，可以使用任何类型的指示来代替。</p>
<p>当 promise 得以解决，fetch 可以是成功或者错误，<code>finally</code> 在 <code>(2)</code> 行触发并终止加载指示。</p>
<p>有一个浏览器技巧，<code>(*)</code> 是从 <code>finally</code> 返回零延时（zero-timeout）的 promise。这是因为一些浏览器（比如 Chrome）需要“一点时间”外的 promise 处理程序来绘制文档的更改。因此它确保在进入链下一步之前，指示在视觉上是停止的。</p>

      </fieldset>
      
      <fieldset id='_der34G'>
      <legend>article</legend>
      <h1 id="promise-api">Promise API</h1>
<p>在 <code>Promise</code> 类中，有 5 种静态方法。我们在这里简单介绍下它们的使用场景。</p>
<h2 id="promiseall">Promise.all</h2>
<p>假设我们希望并行执行多个 promise，并等待所有 promise 都准备就绪。</p>
<p>例如，并行下载几个 URL，并等到所有内容都下载完毕后再对它们进行处理。</p>
<p>这就是 <code>Promise.all</code> 的用途。</p>
<p>语法：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> promise = <span class="hljs-built_in">Promise</span>.all([...promises...]);</code></pre>
<p><code>Promise.all</code> 接受一个 promise 数组作为参数（从技术上讲，它可以是任何可迭代的，但通常是一个数组）并返回一个新的 promise。</p>
<p>当所有给定的 promise 都被 settled 时，新的 promise 才会 resolve，并且其结果数组将成为新的 promise 的结果。</p>
<p>例如，下面的 <code>Promise.all</code> 在 3 秒之后被 settled，然后它的结果就是一个 <code>[1, 2, 3]</code> 数组：</p>
<pre><code class="language-js"><span class="hljs-built_in">Promise</span>.all([
  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> resolve(<span class="hljs-number">1</span>), <span class="hljs-number">3000</span>)), <span class="hljs-comment">// 1</span>
  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> resolve(<span class="hljs-number">2</span>), <span class="hljs-number">2000</span>)), <span class="hljs-comment">// 2</span>
  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> resolve(<span class="hljs-number">3</span>), <span class="hljs-number">1000</span>))  <span class="hljs-comment">// 3</span>
]).then(alert); <span class="hljs-comment">// 1,2,3 当上面这些 promise 准备好时：每个 promise 都贡献了数组中的一个元素</span></code></pre>
<p>请注意，结果数组中元素的顺序与其在源 promise 中的顺序相同。即使第一个 promise 花费了最长的时间才 resolve，但它仍是结果数组中的第一个。</p>
<p>一个常见的技巧是，将一个任务数据数组映射（map）到一个 promise 数组，然后将其包装到 <code>Promise.all</code>。</p>
<p>例如，如果我们有一个存储 URL 的数组，我们可以像这样 fetch 它们：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> urls = [
  <span class="hljs-string">&#x27;https://api.github.com/users/iliakan&#x27;</span>,
  <span class="hljs-string">&#x27;https://api.github.com/users/remy&#x27;</span>,
  <span class="hljs-string">&#x27;https://api.github.com/users/jeresig&#x27;</span>
];

<span class="hljs-comment">// 将每个 url 映射（map）到 fetch 的 promise 中</span>
<span class="hljs-keyword">let</span> requests = urls.map(<span class="hljs-function"><span class="hljs-params">url</span> =&gt;</span> fetch(url));

<span class="hljs-comment">// Promise.all 等待所有任务都 resolved</span>
<span class="hljs-built_in">Promise</span>.all(requests)
  .then(<span class="hljs-function"><span class="hljs-params">responses</span> =&gt;</span> responses.forEach(
    <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> alert(<span class="hljs-string">`<span class="hljs-subst">${response.url}</span>: <span class="hljs-subst">${response.status}</span>`</span>)
  ));</code></pre>
<p>一个更真实的示例，通过 GitHub 用户名来获取一个 GitHub 用户数组中用户的信息（我们也可以通过商品 id 来获取商品数组中的商品信息，逻辑都是一样的）：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> names = [<span class="hljs-string">&#x27;iliakan&#x27;</span>, <span class="hljs-string">&#x27;remy&#x27;</span>, <span class="hljs-string">&#x27;jeresig&#x27;</span>];

<span class="hljs-keyword">let</span> requests = names.map(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> fetch(<span class="hljs-string">`https://api.github.com/users/<span class="hljs-subst">${name}</span>`</span>));

<span class="hljs-built_in">Promise</span>.all(requests)
  .then(<span class="hljs-function"><span class="hljs-params">responses</span> =&gt;</span> {
    <span class="hljs-comment">// 所有响应都被成功 resolved</span>
    <span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> response <span class="hljs-keyword">of</span> responses</span>)</span> {
      alert(<span class="hljs-string">`<span class="hljs-subst">${response.url}</span>: <span class="hljs-subst">${response.status}</span>`</span>); <span class="hljs-comment">// 对应每个 url 都显示 200</span>
    }

    <span class="hljs-keyword">return</span> responses;
  })
  <span class="hljs-comment">// 将响应数组映射（map）到 response.json() 数组中以读取它们的内容</span>
  .then(<span class="hljs-function"><span class="hljs-params">responses</span> =&gt;</span> <span class="hljs-built_in">Promise</span>.all(responses.map(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> r.json())))
  <span class="hljs-comment">// 所有 JSON 结果都被解析：&quot;users&quot; 是它们的数组</span>
  .then(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> users.forEach(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> alert(user.name)));</code></pre>
<p><strong>如果任意一个 promise 被 reject，由 <code>Promise.all</code> 返回的 promise 就会立即 reject，并且带有的就是这个 error。</strong></p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-built_in">Promise</span>.all([
  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> resolve(<span class="hljs-number">1</span>), <span class="hljs-number">1000</span>)),
*!*
  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Whoops!&quot;</span>)), <span class="hljs-number">2000</span>)),
*/!*
  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> resolve(<span class="hljs-number">3</span>), <span class="hljs-number">3000</span>))
]).catch(alert); <span class="hljs-comment">// Error: Whoops!</span></code></pre>
<p>这里的第二个 promise 在两秒后 reject。这立即导致了 <code>Promise.all</code> 的 reject，因此 <code>.catch</code> 执行了：被 reject 的 error 成为了整个 <code>Promise.all</code> 的结果。</p>
<pre><code class="language-warn">如果其中一个 promise 被 reject，`Promise.all` 就会立即被 reject，完全忽略列表中其他的 promise。它们的结果也被忽略。

例如，像上面那个例子，如果有多个同时进行的 `fetch` 调用，其中一个失败，其他的 `fetch` 操作仍然会继续执行，但是 `Promise.all` 将不会再关心（watch）它们。它们可能会 settle，但是它们的结果将被忽略。

`Promise.all` 没有采取任何措施来取消它们，因为 promise 中没有“取消”的概念。在 [另一个章节](info:fetch-abort) 中，我们将介绍可以帮助我们解决这个问题（译注：指的是“取消” promise）的 `AbortController`，但它不是 Promise API 的一部分。</code></pre>
<p>````smart header=&quot;<code>Promise.all(iterable)</code> 允许在 <code>iterable</code> 中使用 non-promise 的“常规”值&quot;
通常，<code>Promise.all(...)</code> 接受可迭代对象（iterable）的 promise（大多数情况下是数组）。但是，如果这些对象中的任意一个都不是 promise，那么它将被“按原样”传递给结果数组。</p>
<p>例如，这里的结果是 <code>[1, 2, 3]</code>：</p>
<pre><code class="language-js"><span class="hljs-built_in">Promise</span>.all([
  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> resolve(<span class="hljs-number">1</span>), <span class="hljs-number">1000</span>)
  }),
  <span class="hljs-number">2</span>,
  <span class="hljs-number">3</span>
]).then(alert); <span class="hljs-comment">// 1, 2, 3</span></code></pre>
<p>所以我们可以在方便的地方将准备好的值传递给 <code>Promise.all</code>。</p>
<pre><code>
## Promise.allSettled

[recent browser=&quot;new&quot;]

如果任意的 promise reject，则 `Promise.all` 整个将会 reject。当我们需要 **所有** 结果都成功时，它对这种“全有或全无”的情况很有用：

```js
Promise.all([
  fetch(&#x27;/template.html&#x27;),
  fetch(&#x27;/style.css&#x27;),
  fetch(&#x27;/data.json&#x27;)
]).then(render); // render 方法需要所有 fetch 的数据
```

`Promise.allSettled` 等待所有的 promise 都被 settle，无论结果如何。结果数组具有：

- `{status:&quot;fulfilled&quot;, value:result}` 对于成功的响应，
- `{status:&quot;rejected&quot;, reason:error}` 对于 error。

例如，我们想要获取（fetch）多个用户的信息。即使其中一个请求失败，我们仍然对其他的感兴趣。

让我们使用 `Promise.allSettled`：

```js run
let urls = [
  &#x27;https://api.github.com/users/iliakan&#x27;,
  &#x27;https://api.github.com/users/remy&#x27;,
  &#x27;https://no-such-url&#x27;
];

Promise.allSettled(urls.map(url =&gt; fetch(url)))
  .then(results =&gt; { // (*)
    results.forEach((result, num) =&gt; {
      if (result.status == &quot;fulfilled&quot;) {
        alert(`${urls[num]}: ${result.value.status}`);
      }
      if (result.status == &quot;rejected&quot;) {
        alert(`${urls[num]}: ${result.reason}`);
      }
    });
  });
```

上面的 `(*)` 行中的 `results` 将会是：
```js
[
  {status: &#x27;fulfilled&#x27;, value: ...response...},
  {status: &#x27;fulfilled&#x27;, value: ...response...},
  {status: &#x27;rejected&#x27;, reason: ...error object...}
]
```

所以，对于每个 promise，我们都得到了其状态（status）和 `value/reason`。

### Polyfill

如果浏览器不支持 `Promise.allSettled`，很容易进行 polyfill：

```js
if(!Promise.allSettled) {
  Promise.allSettled = function(promises) {
    return Promise.all(promises.map(p =&gt; Promise.resolve(p).then(value =&gt; ({
      status: &#x27;fulfilled&#x27;,
      value
    }), reason =&gt; ({
      status: &#x27;rejected&#x27;,
      reason
    }))));
  };
}
```

在这段代码中，`promises.map` 获取输入值，并通过 `p =&gt; Promise.resolve(p)` 将输入值转换为 promise（以防传递了 non-promise），然后向每一个 promise 都添加 `.then` 处理程序（handler）。

这个处理程序（handler）将成功的结果 `value` 转换为 `{status:&#x27;fulfilled&#x27;, value}`，将 error `reason` 转换为 `{status:&#x27;rejected&#x27;, reason}`。这正是 `Promise.allSettled` 的格式。

然后我们就可以使用 `Promise.allSettled` 来获取 **所有** 给定的 promise 的结果，即使其中一些被 reject。

## Promise.race

与 `Promise.all` 类似，但只等待第一个 settled 的 promise 并获取其结果（或 error）。

语法：

```js
let promise = Promise.race(iterable);
```

例如，这里的结果将是 `1`：

```js run
Promise.race([
  new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(1), 1000)),
  new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new Error(&quot;Whoops!&quot;)), 2000)),
  new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(3), 3000))
]).then(alert); // 1
```

这里第一个 promise 最快，所以它变成了结果。第一个 settled 的 promise “赢得了比赛”之后，所有进一步的 result/error 都会被忽略。


## Promise.resolve/reject

在现代的代码中，很少需要使用 `Promise.resolve` 和 `Promise.reject` 方法，因为 `async/await` 语法（我们会在 [稍后](info:async-await) 讲到）使它们变得有些过时了。

完整起见，以及考虑到那些出于某些原因而无法使用 `async/await` 的人，我们在这里对它们进行介绍。

### Promise.resolve

`Promise.resolve(value)` 用结果 `value` 创建一个 resolved 的 promise。

如同：

```js
let promise = new Promise(resolve =&gt; resolve(value));
```

当一个函数被期望返回一个 promise 时，这个方法用于兼容性。（译注：这里的兼容性是指，我们直接从缓存中获取了当前操作的结果 `value`，但是期望返回的是一个 promise，所以可以使用 `Promise.resolve(value)` 将 `value` “封装”进 promise，以满足期望返回一个 promise 的这个需求。）

例如，下面的 `loadCached` 函数获取（fetch）一个 URL 并记住其内容。以便将来对使用相同 URL 的调用，它能立即从缓存中获取先前的内容，但使用 `Promise.resolve` 创建了一个该内容的 promise，所以返回的值始终是一个 promise。

```js
let cache = new Map();

function loadCached(url) {
  if (cache.has(url)) {
*!*
    return Promise.resolve(cache.get(url)); // (*)
*/!*
  }

  return fetch(url)
    .then(response =&gt; response.text())
    .then(text =&gt; {
      cache.set(url,text);
      return text;
    });
}
```

我们可以使用 `loadCached(url).then(…)`，因为该函数保证了会返回一个 promise。我们就可以放心地在 `loadCached` 后面使用 `.then`。这就是 `(*)` 行中 `Promise.resolve` 的目的。

### Promise.reject

`Promise.reject(error)` 用 `error` 创建一个 rejected 的 promise。

如同：

```js
let promise = new Promise((resolve, reject) =&gt; reject(error));
```

实际上，这个方法几乎从未被使用过。

## 总结

`Promise` 类有 5 种静态方法：

1. `Promise.all(promises)` —— 等待所有 promise 都 resolve 时，返回存放它们结果的数组。如果给定的任意一个 promise 为 reject，那么它就会变成 `Promise.all` 的 error，所有其他 promise 的结果都会被忽略。
2. `Promise.allSettled(promises)`（ES2020 新增方法）—— 等待所有 promise 都 settle 时，并以包含以下内容的对象数组的形式返回它们的结果：
    - `status`: `&quot;fulfilled&quot;` 或 `&quot;rejected&quot;`
    - `value`（如果 fulfilled）或 `reason`（如果 rejected）。
3. `Promise.race(promises)` —— 等待第一个 settle 的 promise，并将其 result/error 作为结果。
4. `Promise.resolve(value)` —— 使用给定 value 创建一个 resolved 的 promise。
5. `Promise.reject(error)` —— 使用给定 error 创建一个 rejected 的 promise。

这五个方法中，`Promise.all` 可能是在实战中使用最多的。</code></pre>

      </fieldset>
      
      <fieldset id='_2D0JFc'>
      <legend>article</legend>
      <h1 id="promisification">Promisification</h1>
<p>&quot;Promisification&quot; 是用于一个简单转换的一个长单词。它指将一个接受回调的函数转换为一个返回 promise 的函数。</p>
<p>由于许多函数和库都是基于回调的，因此，在实际开发中经常会需要进行这种转换。因为使用 promise 更加方便，所以将基于回调的函数和库 promisify 是有意义的。（译注：promisify 即指 promise 化）</p>
<p>例如，在 <a href="info:callbacks">info:callbacks</a> 一章中我们有 <code>loadScript(src, callback)</code>。</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadScript</span>(<span class="hljs-params">src, callback</span>) </span>{
  <span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);
  script.src = src;

  script.onload = <span class="hljs-function">() =&gt;</span> callback(<span class="hljs-literal">null</span>, script);
  script.onerror = <span class="hljs-function">() =&gt;</span> callback(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Script load error for <span class="hljs-subst">${src}</span>`</span>));

  <span class="hljs-built_in">document</span>.head.append(script);
}

<span class="hljs-comment">// 用法：</span>
<span class="hljs-comment">// loadScript(&#x27;path/script.js&#x27;, (err, script) =&gt; {...})</span></code></pre>
<p>让我们将其 promisify 吧。新的 <code>loadScriptPromise(src)</code> 将会达到同样的结果，但它只接受 <code>src</code>（没有回调）并返回 promise。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> loadScriptPromise = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">src</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    loadScript(src, <span class="hljs-function">(<span class="hljs-params">err, script</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (err) reject(err)
      <span class="hljs-keyword">else</span> resolve(script);
    });
  })
}

<span class="hljs-comment">// 用法：</span>
<span class="hljs-comment">// loadScriptPromise(&#x27;path/script.js&#x27;).then(...)</span></code></pre>
<p>现在，<code>loadScriptPromise</code> 非常适合基于 promise 的代码。</p>
<p>正如我们所看到的，它将所有工作都委托给原始的 <code>loadScript</code>，并提供了转换成 promise <code>resolve/reject</code> 的自己的回调。</p>
<p>在实际开发中，我们可能需要 promisify 很多函数，所以使用一个 helper 很有意义。我们将其称为 <code>promisify(f)</code>：它接受一个需要被 promisify 的函数 <code>f</code>，并返回一个包装（wrapper）函数。</p>
<p>该包装（wrapper）函数的功能和上面的代码相同：返回一个 promise，将调用传递给原始的函数 <code>f</code>，并在自定义的回调中跟踪结果：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">promisify</span>(<span class="hljs-params">f</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) </span>{ <span class="hljs-comment">// 返回一个包装函数（wrapper-function）</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params">err, result</span>) </span>{ <span class="hljs-comment">// 我们对 f 的自定义的回调</span>
        <span class="hljs-keyword">if</span> (err) {
          reject(err);
        } <span class="hljs-keyword">else</span> {
          resolve(result);
        }
      }

      args.push(callback); <span class="hljs-comment">// 将我们的自定义的回调附加到 f 参数（arguments）的末尾</span>

      f.call(<span class="hljs-built_in">this</span>, ...args); <span class="hljs-comment">// 调用原始的函数</span>
    });
  };
};

<span class="hljs-comment">// 用法：</span>
<span class="hljs-keyword">let</span> loadScriptPromise = promisify(loadScript);
loadScriptPromise(...).then(...);</code></pre>
<p>这里我们假设，原始的函数期望一个带有两个参数 <code>(err, result)</code> 的回调。这就是我们最常遇到的形式。那么我们的自定义回调的格式完全正确，并且 <code>promisify</code> 在这种情况下非常有用。</p>
<p>但是如果原始的 <code>f</code> 期望一个带有更多参数的回调 <code>callback(err, res1, res2, ...)</code>，该怎么办呢？</p>
<p>下面是 <code>promisify</code> 的更高级的版本：如果像这样进行调用 <code>promisify(f, true)</code>，那么 promise 的结果将是回调结果的数组 <code>[res1, res2, ...]</code>：</p>
<pre><code class="language-js">// promisify(f, true) 来获取结果数组
function promisify(f, manyArgs = false) {
  return function (...args) {
    return new Promise((resolve, reject) =&gt; {
      function *!*callback(err, ...results*/!*) { // 我们自定义的 f 的回调
        if (err) {
          reject(err);
        } else {
          // 如果 manyArgs 被指定，则使用所有回调的结果 resolve
          *!*resolve(manyArgs ? results : results[0]);*/!*
        }
      }

      args.push(callback);

      f.call(this, ...args);
    });
  };
};

// 用法：
f = promisify(f, true);
f(...).then(arrayOfResults =&gt; ..., err =&gt; ...)</code></pre>
<p>对于一些更奇特的回调格式，例如根本没有 <code>err</code> 的格式：<code>callback(result)</code>，我们可以手动 promisify 这样的函数，而不使用 helper。</p>
<p>也有一些具有更灵活一点的 promisification 函数的模块（module），例如 <a href="https://github.com/digitaldesignlabs/es6-promisify">es6-promisify</a>。在 Node.js 中，有一个内建的 promisify 函数 <code>util.promisify</code>。</p>
<pre><code class="language-smart">Promisification 是一种很好的方法，特别是在你使用 `async/await` 的时候（请看下一章），但不是回调的完全替代。

请记住，一个 promise 可能只有一个结果，但从技术上讲，一个回调可能被调用很多次。

因此，promisification 仅适用于调用一次回调的函数。进一步的调用将被忽略。</code></pre>

      </fieldset>
      
      <fieldset id='_rlRdvX'>
      <legend>article</legend>
      <h1 id="微任务（microtask）">微任务（Microtask）</h1>
<p>Promise 的处理程序（handlers）<code>.then</code>、<code>.catch</code> 和 <code>.finally</code> 都是异步的。</p>
<p>即便一个 promise 立即被 resolve，<code>.then</code>、<code>.catch</code> 和 <code>.finally</code> <strong>下面</strong> 的代码也会在这些处理程序（handler）之前被执行。</p>
<p>示例代码如下：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> promise = <span class="hljs-built_in">Promise</span>.resolve();

promise.then(<span class="hljs-function">() =&gt;</span> alert(<span class="hljs-string">&quot;promise done!&quot;</span>));

alert(<span class="hljs-string">&quot;code finished&quot;</span>); <span class="hljs-comment">// 这个 alert 先显示</span></code></pre>
<p>如果你运行它，你会首先看到 <code>code finished</code>，然后才是 <code>promise done</code>。</p>
<p>这很奇怪，因为这个 promise 肯定是一开始就完成的。</p>
<p>为什么 <code>.then</code> 会在之后才被触发？这是怎么回事？</p>
<h2 id="微任务队列（microtask-queue）">微任务队列（Microtask queue）</h2>
<p>异步任务需要适当的管理。为此，ECMA 标准规定了一个内部队列 <code>PromiseJobs</code>，通常被称为“微任务队列（microtask queue）”（ES8 术语）。</p>
<p>如 <a href="https://tc39.github.io/ecma262/#sec-jobs-and-job-queues">规范</a> 中所述：</p>
<ul>
<li>队列（queue）是先进先出的：首先进入队列的任务会首先运行。</li>
<li>只有在 JavaScript 引擎中没有其它任务在运行时，才开始执行任务队列中的任务。</li>
</ul>
<p>或者，简单地说，当一个 promise 准备就绪时，它的 <code>.then/catch/finally</code> 处理程序（handler）就会被放入队列中：但是它们不会立即被执行。当 JavaScript 引擎执行完当前的代码，它会从队列中获取任务并执行它。</p>
<p>这就是为什么在上面那个示例中 &quot;code finished&quot; 会先显示。</p>
<p><img src="promiseQueue.svg" alt=""></p>
<p>Promise 的处理程序（handler）总是会经过这个内部队列。</p>
<p>如果有一个包含多个 <code>.then/catch/finally</code> 的链，那么它们中的每一个都是异步执行的。也就是说，它会首先进入队列，然后在当前代码执行完成并且先前排队的处理程序（handler）都完成时才会被执行。</p>
<p><strong>如果执行顺序对我们很重要该怎么办？我们怎么才能让 <code>code finished</code> 在 <code>promise done</code> 之后运行呢？</strong></p>
<p>很简单，只需要像下面这样使用 <code>.then</code> 将其放入队列：</p>
<pre><code class="language-js"><span class="hljs-built_in">Promise</span>.resolve()
  .then(<span class="hljs-function">() =&gt;</span> alert(<span class="hljs-string">&quot;promise done!&quot;</span>))
  .then(<span class="hljs-function">() =&gt;</span> alert(<span class="hljs-string">&quot;code finished&quot;</span>));</code></pre>
<p>现在代码就是按照预期执行的。</p>
<h2 id="未处理的-rejection">未处理的 rejection</h2>
<p>还记得 <a href="info:promise-error-handling">info:promise-error-handling</a> 一章中的 <code>unhandledrejection</code> 事件吗？</p>
<p>现在，我们可以确切地看到 JavaScript 是如何发现未处理的 rejection 的。</p>
<p><strong>如果一个 promise 的 error 未被在微任务队列的末尾进行处理，则会出现“未处理的 rejection”。</strong></p>
<p>正常来说，如果我们预期可能会发生错误，我们会在 promise 链上添加 <code>.catch</code> 来处理 error：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> promise = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Promise Failed!&quot;</span>));
*!*
promise.catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> alert(<span class="hljs-string">&#x27;caught&#x27;</span>));
*/!*

<span class="hljs-comment">// 不会运行：error 已经被处理</span>
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;unhandledrejection&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> alert(event.reason));</code></pre>
<p>但是如果我们忘记添加 <code>.catch</code>，那么，微任务队列清空后，JavaScript 引擎会触发下面这事件：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> promise = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Promise Failed!&quot;</span>));

<span class="hljs-comment">// Promise Failed!</span>
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;unhandledrejection&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> alert(event.reason));</code></pre>
<p>如果我们迟一点再处理这个 error 会怎样？例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> promise = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Promise Failed!&quot;</span>));
*!*
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> promise.catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> alert(<span class="hljs-string">&#x27;caught&#x27;</span>)), <span class="hljs-number">1000</span>);
*/!*

<span class="hljs-comment">// Error: Promise Failed!</span>
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;unhandledrejection&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> alert(event.reason));</code></pre>
<p>现在，如果我们运行上面这段代码，我们会先看到 <code>Promise Failed!</code>，然后才是 <code>caught</code>。</p>
<p>如果我们并不了解微任务队列，我们可能会想：“为什么 <code>unhandledrejection</code> 处理程序（handler）会运行？我们已经捕获（catch）并处理了 error！”</p>
<p>但是现在我们知道了，当微任务队列中的任务都完成时，才会生成 <code>unhandledrejection</code>：引擎会检查 promise，如果 promise 中的任意一个出现 &quot;rejected&quot; 状态，<code>unhandledrejection</code> 事件就会被触发。</p>
<p>在上面这个例子中，被添加到 <code>setTimeout</code> 中的 <code>.catch</code> 也会被触发。只是会在 <code>unhandledrejection</code> 事件出现之后才会被触发，所以它并没有改变什么（没有发挥作用）。</p>
<h2 id="总结">总结</h2>
<p>Promise 处理始终是异步的，因为所有 promise 行为都会通过内部的 &quot;promise jobs&quot; 队列，也被称为“微任务队列”（ES8 术语）。</p>
<p>因此，<code>.then/catch/finally</code> 处理程序（handler）总是在当前代码完成后才会被调用。</p>
<p>如果我们需要确保一段代码在 <code>.then/catch/finally</code> 之后被执行，我们可以将它添加到链式调用的 <code>.then</code> 中。</p>
<p>在大多数 JavaScript 引擎中（包括浏览器和 Node.js），微任务（microtask）的概念与“事件循环（event loop）”和“宏任务（macrotasks）”紧密相关。由于这些概念跟 promise 没有直接关系，所以我们将在本教程另外一部分的 <a href="info:event-loop">info:event-loop</a> 一章中对它们进行介绍。</p>

      </fieldset>
      
      <fieldset id='_J94pyF'>
      <legend>solution</legend>
      <p>解析在代码下面：</p>
<pre><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadJson</span>(<span class="hljs-params">url</span>) </span>{ <span class="hljs-comment">// (1)</span>
  <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> fetch(url); <span class="hljs-comment">// (2)</span>

  <span class="hljs-keyword">if</span> (response.status == <span class="hljs-number">200</span>) {
    <span class="hljs-keyword">let</span> json = <span class="hljs-keyword">await</span> response.json(); <span class="hljs-comment">// (3)</span>
    <span class="hljs-keyword">return</span> json;
  }

  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(response.status);
}

loadJson(<span class="hljs-string">&#x27;no-such-user.json&#x27;</span>)
  .catch(alert); <span class="hljs-comment">// Error: 404 (4)</span></code></pre>
<p>解析：</p>
<ol>
<li><p>将函数 <code>loadJson</code> 变为 <code>async</code>。</p>
</li>
<li><p>将函数中所有的 <code>.then</code> 都替换为 <code>await</code>。</p>
</li>
<li><p>我们可以返回 <code>return response.json()</code> 而不用等待它，像这样:</p>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (response.status == <span class="hljs-number">200</span>) {
  <span class="hljs-keyword">return</span> response.json(); <span class="hljs-comment">// (3)</span>
}</code></pre>
<p> 然后外部的代码就必须 <code>await</code> 这个 promise resolve。在本例中它无关紧要。</p>
</li>
<li><p><code>loadJson</code> 抛出的 error 被 <code>.catch</code> 处理了。在这儿我们我们不能使用 <code>await loadJson(…)</code>，因为我们不是在一个 <code>async</code> 函数中。</p>
</li>
</ol>

      </fieldset>
      
      <fieldset id='_ass6IP'>
      <legend>task</legend>
      <h1 id="用-asyncawait-来重写">用 async/await 来重写</h1>
<p>重写下面这个来自 <a href="info:promise-chaining">info:promise-chaining</a> 一章的示例代码，使用 <code>async/await</code> 而不是 <code>.then/catch</code>：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadJson</span>(<span class="hljs-params">url</span>) </span>{
  <span class="hljs-keyword">return</span> fetch(url)
    .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
      <span class="hljs-keyword">if</span> (response.status == <span class="hljs-number">200</span>) {
        <span class="hljs-keyword">return</span> response.json();
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(response.status);
      }
    })
}

loadJson(<span class="hljs-string">&#x27;no-such-user.json&#x27;</span>)
  .catch(alert); <span class="hljs-comment">// Error: 404</span></code></pre>

      </fieldset>
      
      <fieldset id='_fAfVJr'>
      <legend>solution</legend>
      <p>这里没有什么技巧。只需要将 <code>demoGithubUser</code> 中的 <code>.catch</code> 替换为 <code>try...catch</code>，然后在需要的地方加上 <code>async/await</code> 即可：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Error</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">response</span>)</span> {
    <span class="hljs-built_in">super</span>(<span class="hljs-string">`<span class="hljs-subst">${response.status}</span> for <span class="hljs-subst">${response.url}</span>`</span>);
    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;HttpError&#x27;</span>;
    <span class="hljs-built_in">this</span>.response = response;
  }
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadJson</span>(<span class="hljs-params">url</span>) </span>{
  <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> fetch(url);
  <span class="hljs-keyword">if</span> (response.status == <span class="hljs-number">200</span>) {
    <span class="hljs-keyword">return</span> response.json();
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> HttpError(response);
  }
}

<span class="hljs-comment">// 询问用户名，直到 github 返回一个合法的用户</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">demoGithubUser</span>(<span class="hljs-params"></span>) </span>{

  <span class="hljs-keyword">let</span> user;
  <span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-params"><span class="hljs-literal">true</span></span>)</span> {
    <span class="hljs-keyword">let</span> name = prompt(<span class="hljs-string">&quot;Enter a name?&quot;</span>, <span class="hljs-string">&quot;iliakan&quot;</span>);

    <span class="hljs-keyword">try</span> {
      user = <span class="hljs-keyword">await</span> loadJson(<span class="hljs-string">`https://api.github.com/users/<span class="hljs-subst">${name}</span>`</span>);
      <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 没有 error，退出循环</span>
    } <span class="hljs-function"><span class="hljs-title">catch</span>(<span class="hljs-params">err</span>)</span> {
      <span class="hljs-keyword">if</span> (err <span class="hljs-keyword">instanceof</span> HttpError &amp;&amp; err.response.status == <span class="hljs-number">404</span>) {
        <span class="hljs-comment">// 循环将在 alert 后继续</span>
        alert(<span class="hljs-string">&quot;No such user, please reenter.&quot;</span>);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 未知的 error，再次抛出（rethrow）</span>
        <span class="hljs-keyword">throw</span> err;
      }
    }      
  }


  alert(<span class="hljs-string">`Full name: <span class="hljs-subst">${user.name}</span>.`</span>);
  <span class="hljs-keyword">return</span> user;
}

demoGithubUser();</code></pre>

      </fieldset>
      
      <fieldset id='_edMza1'>
      <legend>task</legend>
      <h1 id="使用-asyncawait-重写-rethrow">使用 async/await 重写 &quot;rethrow&quot;</h1>
<p>下面你可以看到来自 <a href="info:promise-chaining">info:promise-chaining</a> 一章的 &quot;rethrow&quot; 例子。让我们来用 <code>async/await</code> 重写它，而不是使用 <code>.then/catch</code>。</p>
<p>同时，我们可以在 <code>demoGithubUser</code> 中使用循环以摆脱递归：在 <code>async/await</code> 的帮助下很容易实现。</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpError</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Error</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">response</span>)</span> {
    <span class="hljs-built_in">super</span>(<span class="hljs-string">`<span class="hljs-subst">${response.status}</span> for <span class="hljs-subst">${response.url}</span>`</span>);
    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;HttpError&#x27;</span>;
    <span class="hljs-built_in">this</span>.response = response;
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadJson</span>(<span class="hljs-params">url</span>) </span>{
  <span class="hljs-keyword">return</span> fetch(url)
    .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
      <span class="hljs-keyword">if</span> (response.status == <span class="hljs-number">200</span>) {
        <span class="hljs-keyword">return</span> response.json();
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> HttpError(response);
      }
    })
}

<span class="hljs-comment">// 询问用户名，直到 github 返回一个合法的用户</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">demoGithubUser</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> name = prompt(<span class="hljs-string">&quot;Enter a name?&quot;</span>, <span class="hljs-string">&quot;iliakan&quot;</span>);

  <span class="hljs-keyword">return</span> loadJson(<span class="hljs-string">`https://api.github.com/users/<span class="hljs-subst">${name}</span>`</span>)
    .then(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> {
      alert(<span class="hljs-string">`Full name: <span class="hljs-subst">${user.name}</span>.`</span>);
      <span class="hljs-keyword">return</span> user;
    })
    .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
      <span class="hljs-keyword">if</span> (err <span class="hljs-keyword">instanceof</span> HttpError &amp;&amp; err.response.status == <span class="hljs-number">404</span>) {
        alert(<span class="hljs-string">&quot;No such user, please reenter.&quot;</span>);
        <span class="hljs-keyword">return</span> demoGithubUser();
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> err;
      }
    });
}

demoGithubUser();</code></pre>

      </fieldset>
      
      <fieldset id='_dkb0Z4'>
      <legend>solution</legend>
      <p>在这种情况下，知道其内部工作原理会很有帮助。</p>
<p>只需要把 <code>async</code> 调用当作 promise 对待，并在它的后面加上 <code>.then</code> 即可：</p>
<pre><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wait</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>));

  <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// 1 秒后显示 10</span>
*!*
  wait().then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> alert(result));
*/!*
}

f();</code></pre>

      </fieldset>
      
      <fieldset id='_YFR40B'>
      <legend>task</legend>
      <h1 id="在非-async-函数中调用-async-函数">在非 async 函数中调用 async 函数</h1>
<p>我们有一个“普通”函数。如何在这个函数中调用 <code>async</code> 函数并使用其结果？</p>
<pre><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wait</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>));

  <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// ...这里怎么写？</span>
  <span class="hljs-comment">// 我们需要调用 async wait() 并等待以拿到结果 10</span>
  <span class="hljs-comment">// 记住，我们不能使用 &quot;await&quot;</span>
}</code></pre>
<p>P.S. 这个任务其实很简单，但是对于 async/await 新手开发者来说，这个问题却很常见。</p>

      </fieldset>
      
      <fieldset id='_Jd6g7l'>
      <legend>article</legend>
      <h1 id="asyncawait">Async/await</h1>
<p>Async/await 是以更舒适的方式使用 promise 的一种特殊语法，同时它也非常易于理解和使用。</p>
<h2 id="async-function">Async function</h2>
<p>让我们以 <code>async</code> 这个关键字开始。它可以被放置在一个函数前面，如下所示：</p>
<pre><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}</code></pre>
<p>在函数前面的 &quot;async&quot; 这个单词表达了一个简单的事情：即这个函数总是返回一个 promise。其他值将自动被包装在一个 resolved 的 promise 中。</p>
<p>例如，下面这个函数返回一个结果为 <code>1</code> 的 resolved promise，让我们测试一下：</p>
<pre><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

f().then(alert); <span class="hljs-comment">// 1</span></code></pre>
<p>……我们也可以显式地返回一个 promise，结果是一样的：</p>
<pre><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>);
}

f().then(alert); <span class="hljs-comment">// 1</span></code></pre>
<p>所以说，<code>async</code> 确保了函数返回一个 promise，也会将非 promise 的值包装进去。很简单，对吧？但不仅仅这些。还有另外一个叫 <code>await</code> 的关键词，它只在 <code>async</code> 函数内工作，也非常酷。</p>
<h2 id="await">Await</h2>
<p>语法如下：</p>
<pre><code class="language-js"><span class="hljs-comment">// 只在 async 函数内工作</span>
<span class="hljs-keyword">let</span> value = <span class="hljs-keyword">await</span> promise;</code></pre>
<p>关键字 <code>await</code> 让 JavaScript 引擎等待直到 promise 完成（settle）并返回结果。</p>
<p>这里的例子就是一个 1 秒后 resolve 的 promise：</p>
<pre><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{

  <span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> resolve(<span class="hljs-string">&quot;done!&quot;</span>), <span class="hljs-number">1000</span>)
  });

*!*
  <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> promise; <span class="hljs-comment">// 等待，直到 promise resolve (*)</span>
*/!*

  alert(result); <span class="hljs-comment">// &quot;done!&quot;</span>
}

f();</code></pre>
<p>这个函数在执行的时候，“暂停”在了 <code>(*)</code> 那一行，并在 promise settle 时，拿到 <code>result</code> 作为结果继续往下执行。所以上面这段代码在一秒后显示 &quot;done!&quot;。</p>
<p>让我们强调一下：<code>await</code> 字面的意思就是让 JavaScript 引擎等待直到 promise settle，然后以 promise 的结果继续执行。这个行为不会耗费任何 CPU 资源，因为引擎可以同时处理其他任务：执行其他脚本，处理事件等。</p>
<p>相比于 <code>promise.then</code>，它只是获取 promise 的结果的一个更优雅的语法，同时也更易于读写。</p>
<p>````warn header=&quot;不能在普通函数中使用 <code>await</code>&quot;
如果我们尝试在非 async 函数中使用 <code>await</code> 的话，就会报语法错误：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> promise = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>);
*!*
  <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> promise; <span class="hljs-comment">// Syntax error</span>
*/!*
}</code></pre>
<p>如果函数前面没有 <code>async</code> 关键字，我们就会得到一个语法错误。就像前面说的，<code>await</code> 只在 <code>async 函数</code> 中有效。</p>
<pre><code>
让我们拿 &lt;info:promise-chaining&gt; 那一章的 `showAvatar()` 例子，并将其改写成 `async/await` 的形式：

1. 我们需要用 `await` 替换掉 `.then` 的调用。
2. 另外，我们需要在函数前面加上 `async` 关键字，以使它们能工作。

```js run
async function showAvatar() {

  // 读取我们的 JSON
  let response = await fetch(&#x27;/article/promise-chaining/user.json&#x27;);
  let user = await response.json();

  // 读取 github 用户信息
  let githubResponse = await fetch(`https://api.github.com/users/${user.name}`);
  let githubUser = await githubResponse.json();

  // 显示头像
  let img = document.createElement(&#x27;img&#x27;);
  img.src = githubUser.avatar_url;
  img.className = &quot;promise-avatar-example&quot;;
  document.body.append(img);

  // 等待 3 秒
  await new Promise((resolve, reject) =&gt; setTimeout(resolve, 3000));

  img.remove();

  return githubUser;
}

showAvatar();
```

简洁明了，是吧？比之前可强多了。

````smart header=&quot;`await` 不能在顶层代码运行&quot;
刚开始使用 `await` 的人常常会忘记 `await` 不能用在顶层代码中。例如，下面这样就不行：

```js run
// 用在顶层代码中会报语法错误
let response = await fetch(&#x27;/article/promise-chaining/user.json&#x27;);
let user = await response.json();
```

但我们可以将其包裹在一个匿名 async 函数中，如下所示：

```js
(async () =&gt; {
  let response = await fetch(&#x27;/article/promise-chaining/user.json&#x27;);
  let user = await response.json();
  ...
})();
```

</code></pre>
<p>````smart header=&quot;<code>await</code> 接受 &quot;thenables&quot;&quot;
像 <code>promise.then</code> 那样，<code>await</code> 允许我们使用 thenable 对象（那些具有可调用的 <code>then</code> 方法的对象）。这里的想法是，第三方对象可能不是一个 promise，但却是 promise 兼容的：如果这些对象支持 <code>.then</code>，那么就可以对它们使用 <code>await</code>。</p>
<p>这有一个用于演示的 <code>Thenable</code> 类，下面的 <code>await</code> 接受了该类的实例：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thenable</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">num</span>)</span> {
    <span class="hljs-built_in">this</span>.num = num;
  }
  <span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">resolve, reject</span>)</span> {
    alert(resolve);
    <span class="hljs-comment">// 1000ms 后使用 this.num*2 进行 resolve</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> resolve(<span class="hljs-built_in">this</span>.num * <span class="hljs-number">2</span>), <span class="hljs-number">1000</span>); <span class="hljs-comment">// (*)</span>
  }
};

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// 等待 1 秒，之后 result 变为 2</span>
  <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> Thenable(<span class="hljs-number">1</span>);
  alert(result);
}

f();</code></pre>
<p>如果 <code>await</code> 接收了一个非 promise 的但是提供了 <code>.then</code> 方法的对象，它就会调用这个 <code>.then</code> 方法，并将内建的函数 <code>resolve</code> 和 <code>reject</code> 作为参数传入（就像它对待一个常规的 <code>Promise</code> executor 时一样）。然后 <code>await</code> 等待直到这两个函数中的某个被调用（在上面这个例子中发生在 <code>(*)</code> 行），然后使用得到的结果继续执行后续任务。</p>
<pre><code>
````smart header=&quot;Class 中的 async 方法&quot;
要声明一个 class 中的 async 方法，只需在对应方法前面加上 `async` 即可：

```js run
class Waiter {
*!*
  async wait() {
*/!*
    return await Promise.resolve(1);
  }
}

new Waiter()
  .wait()
  .then(alert); // 1
```
这里的含义是一样的：它确保了方法的返回值是一个 promise 并且可以在方法中使用 `await`。
</code></pre>
<h2 id="error-处理">Error 处理</h2>
<p>如果一个 promise 正常 resolve，<code>await promise</code> 返回的就是其结果。但是如果 promise 被 reject，它将 throw 这个 error，就像在这一行有一个 <code>throw</code> 语句那样。</p>
<p>这个代码：</p>
<pre><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
*!*
  <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Whoops!&quot;</span>));
*/!*
}</code></pre>
<p>……和下面是一样的：</p>
<pre><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
*!*
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Whoops!&quot;</span>);
*/!*
}</code></pre>
<p>在真实开发中，promise 可能需要一点时间后才 reject。在这种情况下，在 <code>await</code> 抛出（throw）一个 error 之前会有一个延时。</p>
<p>我们可以用 <code>try..catch</code> 来捕获上面提到的那个 error，与常规的 <code>throw</code> 使用的是一样的方式：</p>
<pre><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;http://no-such-url&#x27;</span>);
  } <span class="hljs-function"><span class="hljs-title">catch</span>(<span class="hljs-params">err</span>)</span> {
*!*
    alert(err); <span class="hljs-comment">// TypeError: failed to fetch</span>
*/!*
  }
}

f();</code></pre>
<p>如果有 error 发生，执行控制权马上就会被移交至 <code>catch</code> 块。我们也可以用 <code>try</code> 包装多行 <code>await</code> 代码：</p>
<pre><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;/no-user-here&#x27;</span>);
    <span class="hljs-keyword">let</span> user = <span class="hljs-keyword">await</span> response.json();
  } <span class="hljs-function"><span class="hljs-title">catch</span>(<span class="hljs-params">err</span>)</span> {
    <span class="hljs-comment">// 捕获到 fetch 和 response.json 中的错误</span>
    alert(err);
  }
}

f();</code></pre>
<p>如果我们没有 <code>try..catch</code>，那么由异步函数 <code>f()</code> 的调用生成的 promise 将变为 rejected。我们可以在函数调用后面添加 <code>.catch</code> 来处理这个 error：</p>
<pre><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;http://no-such-url&#x27;</span>);
}

<span class="hljs-comment">// f() 变成了一个 rejected 的 promise</span>
*!*
f().catch(alert); <span class="hljs-comment">// TypeError: failed to fetch // (*)</span>
*/!*</code></pre>
<p>如果我们忘了在这添加 <code>.catch</code>，那么我们就会得到一个未处理的 promise error（可以在控制台中查看）。我们可以使用在 <a href="info:promise-error-handling">info:promise-error-handling</a> 一章中所讲的全局事件处理程序 <code>unhandledrejection</code> 来捕获这类 error。</p>
<p>```smart header=&quot;<code>async/await</code> 和 <code>promise.then/catch</code>&quot;
当我们使用 <code>async/await</code> 时，几乎就不会用到 <code>.then</code> 了，因为 <code>await</code> 为我们处理了等待。并且我们使用常规的 <code>try..catch</code> 而不是 <code>.catch</code>。这通常（但不总是）更加方便。</p>
<p>但是当我们在代码的顶层时，也就是在所有 <code>async</code> 函数之外，我们在语法上就不能使用 <code>await</code> 了，所以这时候通常的做法是添加 <code>.then/catch</code> 来处理最终的结果（result）或掉出来的（falling-through）error，例如像上面那个例子中的 <code>(*)</code> 行那样。</p>
<pre><code>
````smart header=&quot;`async/await` 可以和 `Promise.all` 一起使用&quot;
当我们需要同时等待多个 promise 时，我们可以用 `Promise.all` 把它们包装起来，然后使用 `await`：

```js
// 等待结果数组
let results = await Promise.all([
  fetch(url1),
  fetch(url2),
  ...
]);</code></pre>
<p>如果出现 error，也会正常传递，从失败了的 promise 传到 <code>Promise.all</code>，然后变成我们能通过使用 <code>try..catch</code> 在调用周围捕获到的异常（exception）。</p>
<pre><code>
## 总结

函数前面的关键字 `async` 有两个作用：

1. 让这个函数总是返回一个 promise。
2. 允许在该函数内使用 `await`。

Promise 前的关键字 `await` 使 JavaScript 引擎等待该 promise settle，然后：

1. 如果有 error，就会抛出异常 — 就像那里调用了 `throw error` 一样。
2. 否则，就返回结果。

这两个关键字一起提供了一个很好的用来编写异步代码的框架，这种代码易于阅读也易于编写。

有了 `async/await` 之后，我们就几乎不需要使用 `promise.then/catch`，但是不要忘了它们是基于 promise 的，因为有些时候（例如在最外层作用域）我们不得不使用这些方法。并且，当我们需要同时等待需要任务时，`Promise.all` 是很好用的。</code></pre>

      </fieldset>
      
      <fieldset id='_bPGEfc'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">pseudoRandom</span>(<span class="hljs-params">seed</span>) </span>{
  <span class="hljs-keyword">let</span> value = seed;

  <span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-params"><span class="hljs-literal">true</span></span>)</span> {
    value = value * <span class="hljs-number">16807</span> % <span class="hljs-number">2147483647</span>
    <span class="hljs-keyword">yield</span> value;
  }

};

<span class="hljs-keyword">let</span> generator = pseudoRandom(<span class="hljs-number">1</span>);

alert(generator.next().value); <span class="hljs-comment">// 16807</span>
alert(generator.next().value); <span class="hljs-comment">// 282475249</span>
alert(generator.next().value); <span class="hljs-comment">// 1622650073</span></code></pre>
<p>请注意，也可以使用常规函数来完成相同的操作，就像这样：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pseudoRandom</span>(<span class="hljs-params">seed</span>) </span>{
  <span class="hljs-keyword">let</span> value = seed;

  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    value = value * <span class="hljs-number">16807</span> % <span class="hljs-number">2147483647</span>;
    <span class="hljs-keyword">return</span> value;
  }
}

<span class="hljs-keyword">let</span> generator = pseudoRandom(<span class="hljs-number">1</span>);

alert(generator()); <span class="hljs-comment">// 16807</span>
alert(generator()); <span class="hljs-comment">// 282475249</span>
alert(generator()); <span class="hljs-comment">// 1622650073</span></code></pre>
<p>这也可以工作。但是这样我们就失去了使用 <code>for..of</code> 来进行迭代以及使用 generator 组合（composition）的能力，这些可能在其他地方很有用。</p>

      </fieldset>
      
      <fieldset id='_IXxJsz'>
      <legend>task</legend>
      <h1 id="伪随机-generator">伪随机 generator</h1>
<p>在很多地方我们都需要随机数据。</p>
<p>其中之一就是测试。我们可能需要随机数据：文本，数字等，以便很好地进行测试。</p>
<p>在 JavaScript 中，我们可以使用 <code>Math.random()</code>。但是如果什么地方出现了问题，我们希望能使用完全相同的数据进行重复测试。</p>
<p>为此，我们可以使用所谓的“种子伪随机（seeded pseudo-random）generator”。它们将“种子（seed）”作为第一个值，然后使用公式生成下一个值。以便相同的种子（seed）可以产出（yield）相同的序列，因此整个数据流很容易复现。我们只需要记住种子并重复它即可。</p>
<p>这样的公式的一个示例如下，它可以生成一些均匀分布的值：</p>
<pre><code>next = previous * 16807 % 2147483647</code></pre>
<p>如果我们使用 <code>1</code> 作为种子，生成的值将会是：</p>
<ol>
<li><code>16807</code></li>
<li><code>282475249</code></li>
<li><code>1622650073</code></li>
<li>……等……</li>
</ol>
<p>这里的任务是创建一个 generator 函数 <code>pseudoRandom(seed)</code>，它将 <code>seed</code> 作为参数并使用此公式创建 generator。</p>
<p>使用范例：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> generator = pseudoRandom(<span class="hljs-number">1</span>);

alert(generator.next().value); <span class="hljs-comment">// 16807</span>
alert(generator.next().value); <span class="hljs-comment">// 282475249</span>
alert(generator.next().value); <span class="hljs-comment">// 1622650073</span></code></pre>

      </fieldset>
      
      <fieldset id='_kxcHGr'>
      <legend>article</legend>
      <h1 id="generator">Generator</h1>
<p>常规函数只会返回一个单一值（或者不返回任何值）。</p>
<p>而 Generator 可以按需一个接一个地返回（&quot;yield&quot;）多个值。它们可与 <a href="info:iterable">iterable</a> 完美配合使用，从而可以轻松地创建数据流。</p>
<h2 id="generator-函数">Generator 函数</h2>
<p>要创建一个 generator，我们需要一个特殊的语法结构：<code>function*</code>，即所谓的 &quot;generator function&quot;。</p>
<p>它看起来像这样：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">generateSequence</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
}</code></pre>
<p>Generator 函数与常规函数的行为不同。在此类函数被调用时，它不会运行其代码。而是返回一个被称为 &quot;generator object&quot; 的特殊对象，来管理执行流程。</p>
<p>我们来看一个例子：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">generateSequence</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
}

<span class="hljs-comment">// &quot;generator function&quot; 创建了一个 &quot;generator object&quot;</span>
<span class="hljs-keyword">let</span> generator = generateSequence();
*!*
alert(generator); <span class="hljs-comment">// [object Generator]</span>
*/!*</code></pre>
<p>到目前为止，上面这段代码中的 <strong>函数体</strong> 代码还没有开始执行：</p>
<p><img src="generateSequence-1.svg" alt=""></p>
<p>一个 generator 的主要方法就是 <code>next()</code>。当被调用时（译注：指 <code>next()</code> 方法），它会恢复上图所示的运行，执行直到最近的 <code>yield &lt;value&gt;</code> 语句（<code>value</code> 可以被省略，默认为 <code>undefined</code>）。然后函数执行暂停，并将产出的（yielded）值返回到外部代码。</p>
<p><code>next()</code> 的结果始终是一个具有两个属性的对象：</p>
<ul>
<li><code>value</code>: 产出的（yielded）的值。</li>
<li><code>done</code>: 如果 generator 函数已执行完成则为 <code>true</code>，否则为 <code>false</code>。</li>
</ul>
<p>例如，我们可以创建一个 generator 并获取其第一个产出的（yielded）值：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">generateSequence</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
}

<span class="hljs-keyword">let</span> generator = generateSequence();

*!*
<span class="hljs-keyword">let</span> one = generator.next();
*/!*

alert(<span class="hljs-built_in">JSON</span>.stringify(one)); <span class="hljs-comment">// {value: 1, done: false}</span></code></pre>
<p>截至目前，我们只获得了第一个值，现在函数执行处在第二行：</p>
<p><img src="generateSequence-2.svg" alt=""></p>
<p>让我们再次调用 <code>generator.next()</code>。代码恢复执行并返回下一个 <code>yield</code> 的值：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> two = generator.next();

alert(<span class="hljs-built_in">JSON</span>.stringify(two)); <span class="hljs-comment">// {value: 2, done: false}</span></code></pre>
<p><img src="generateSequence-3.svg" alt=""></p>
<p>如果我们第三次调用 <code>generator.next()</code>，代码将会执行到 <code>return</code> 语句，此时就完成这个函数的执行：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> three = generator.next();

alert(<span class="hljs-built_in">JSON</span>.stringify(three)); <span class="hljs-comment">// {value: 3, *!*done: true*/!*}</span></code></pre>
<p><img src="generateSequence-4.svg" alt=""></p>
<p>现在 generator 执行完成。我们通过 <code>done:true</code> 可以看出来这一点，并且将 <code>value:3</code> 处理为最终结果。</p>
<p>再对 <code>generator.next()</code> 进行新的调用不再有任何意义。如果我们这样做，它将返回相同的对象：<code>{done: true}</code>。</p>
<p>```smart header=&quot;<code>function* f(…)</code> 或 <code>function *f(…)</code>？&quot;
这两种语法都是对的。</p>
<p>但是通常更倾向于第一种语法，因为星号 <code>*</code> 表示它是一个 generator 函数，它描述的是函数种类而不是名称，因此 <code>*</code> 应该和 <code>function</code> 关键字紧贴一起。</p>
<pre><code>
## Generator 是可迭代的

当你看到 `next()` 方法，或许你已经猜到了 generator 是 [可迭代（iterable）](info:iterable)的。（译注：`next()` 是 iterator 的必要方法）

我们可以使用 `for..of` 循环遍历它所有的值：

```js run
function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}

let generator = generateSequence();

for(let value of generator) {
  alert(value); // 1，然后是 2
}</code></pre>
<p><code>for..of</code> 写法是不是看起来比 <code>.next().value</code> 优雅多了？</p>
<p>……但是请注意：上面这个例子会先显示 <code>1</code>，然后是 <code>2</code>，然后就没了。它不会显示 <code>3</code>！</p>
<p>这是因为当 <code>done: true</code> 时，<code>for..of</code> 循环会忽略最后一个 <code>value</code>。因此，如果我们想要通过 <code>for..of</code> 循环显示所有的结果，我们必须使用 <code>yield</code> 返回它们：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">generateSequence</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;
*!*
  <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;
*/!*
}

<span class="hljs-keyword">let</span> generator = generateSequence();

<span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> generator</span>)</span> {
  alert(value); <span class="hljs-comment">// 1，然后是 2，然后是 3</span>
}</code></pre>
<p>因为 generator 是可迭代的，我们可以使用 iterator 的所有相关功能，例如：spread 语法 <code>...</code>：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">generateSequence</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;
}

<span class="hljs-keyword">let</span> sequence = [<span class="hljs-number">0</span>, ...generateSequence()];

alert(sequence); <span class="hljs-comment">// 0, 1, 2, 3</span></code></pre>
<p>在上面这段代码中，<code>...generateSequence()</code> 将可迭代的 generator 对象转换为了一个数组（关于 spread 语法的更多细节请见 <a href="info:rest-parameters-spread#spread-syntax"></a>）。</p>
<h2 id="使用-generator-进行迭代">使用 generator 进行迭代</h2>
<p>在前面的 <a href="info:iterable"></a> 一章中，我们创建了一个可迭代的 <code>range</code> 对象，它返回 <code>from..to</code> 的值。</p>
<p>现在，我们回忆一下代码：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> range = {
  <span class="hljs-attr">from</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">to</span>: <span class="hljs-number">5</span>,

  <span class="hljs-comment">// for..of range 在一开始就调用一次这个方法</span>
  [<span class="hljs-built_in">Symbol</span>.iterator]() {
    <span class="hljs-comment">// ...它返回 iterator object：</span>
    <span class="hljs-comment">// 后续的操作中，for..of 将只针对这个对象，并使用 next() 向它请求下一个值</span>
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">current</span>: <span class="hljs-built_in">this</span>.from,
      <span class="hljs-attr">last</span>: <span class="hljs-built_in">this</span>.to,

      <span class="hljs-comment">// for..of 循环在每次迭代时都会调用 next()</span>
      <span class="hljs-function"><span class="hljs-title">next</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-comment">// 它应该以对象 {done:.., value :...} 的形式返回值</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.current &lt;= <span class="hljs-built_in">this</span>.last) {
          <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: <span class="hljs-built_in">this</span>.current++ };
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> };
        }
      }
    };
  }
};

<span class="hljs-comment">// 迭代整个 range 对象，返回从 `range.from` 到 `range.to` 范围的所有数字</span>
alert([...range]); <span class="hljs-comment">// 1,2,3,4,5</span></code></pre>
<p>我们可以通过提供一个 generator 函数作为 <code>Symbol.iterator</code>，来使用 generator 进行迭代：</p>
<p>下面是一个相同的 <code>range</code>，但紧凑得多：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> range = {
  <span class="hljs-attr">from</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">to</span>: <span class="hljs-number">5</span>,

  *[<span class="hljs-built_in">Symbol</span>.iterator]() { <span class="hljs-comment">// [Symbol.iterator]: function*() 的简写形式</span>
    <span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> value = <span class="hljs-built_in">this</span>.<span class="hljs-keyword">from</span>; value &lt;= <span class="hljs-built_in">this</span>.to; value++</span>)</span> {
      <span class="hljs-keyword">yield</span> value;
    }
  }
};

alert( [...range] ); <span class="hljs-comment">// 1,2,3,4,5</span></code></pre>
<p>之所以代码正常工作，是因为 <code>range[Symbol.iterator]()</code> 现在返回一个 generator，而 generator 方法正是 <code>for..of</code> 所期望的：</p>
<ul>
<li>它具有 <code>.next()</code> 方法</li>
<li>它以 <code>{value: ..., done: true/false}</code> 的形式返回值</li>
</ul>
<p>当然，这不是巧合。Generator 被添加到 JavaScript 语言中是有对 iterator 的考量的，以便更容易地实现 iterator。</p>
<p>带有 generator 的变体比原来的 <code>range</code> 迭代代码简洁得多，并且保持了相同的功能。</p>
<pre><code class="language-smart">在上面的示例中，我们生成了有限序列，但是我们也可以创建一个生成无限序列的 generator，它可以一直产出（yield）值。例如，无序的伪随机数序列。

这种情况下肯定需要在 generator 的 `for..of` 循环中添加一个 `break`（或者 `return`）。否则循环将永远重复下去并挂起。</code></pre>
<h2 id="generator-组合">Generator 组合</h2>
<p>Generator 组合（composition）是 generator 的一个特殊功能，它允许透明地（transparently）将 generator 彼此“嵌入（embed）”到一起。</p>
<p>例如，我们有一个生成数字序列的函数：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">generateSequence</span>(<span class="hljs-params">start, end</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt;= end; i++) <span class="hljs-keyword">yield</span> i;
}</code></pre>
<p>现在，我们想重用它来生成一个更复杂的序列：</p>
<ul>
<li>首先是数字 <code>0..9</code>（字符代码为 48..57），</li>
<li>接下来是大写字母 <code>A..Z</code>（字符代码为 65..90）</li>
<li>接下来是小写字母 <code>a...z</code>（字符代码为 97..122）</li>
</ul>
<p>我们可以对这个序列进行应用，例如，我们可以从这个序列中选择字符来创建密码（也可以添加语法字符），但让我们先生成它。</p>
<p>在常规函数中，要合并其他多个函数的结果，我们需要调用它们，存储它们的结果，最后再将它们合并到一起。</p>
<p>对于 generator 而言，我们可以使用 <code>yield*</code> 这个特殊的语法来将一个 generator “嵌入”（组合）到另一个 generator 中：</p>
<p>组合的 generator 的例子：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">generateSequence</span>(<span class="hljs-params">start, end</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt;= end; i++) <span class="hljs-keyword">yield</span> i;
}

<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">generatePasswordCodes</span>(<span class="hljs-params"></span>) </span>{

*!*
  <span class="hljs-comment">// 0..9</span>
  <span class="hljs-keyword">yield</span>* generateSequence(<span class="hljs-number">48</span>, <span class="hljs-number">57</span>);

  <span class="hljs-comment">// A..Z</span>
  <span class="hljs-keyword">yield</span>* generateSequence(<span class="hljs-number">65</span>, <span class="hljs-number">90</span>);

  <span class="hljs-comment">// a..z</span>
  <span class="hljs-keyword">yield</span>* generateSequence(<span class="hljs-number">97</span>, <span class="hljs-number">122</span>);
*/!*

}

<span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;&#x27;</span>;

<span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> code <span class="hljs-keyword">of</span> generatePasswordCodes()</span>)</span> {
  str += <span class="hljs-built_in">String</span>.fromCharCode(code);
}

alert(str); <span class="hljs-comment">// 0..9A..Za..z</span></code></pre>
<p><code>yield*</code> 指令将执行 <strong>委托</strong> 给另一个 generator。这个术语意味着 <code>yield* gen</code> 在 generator <code>gen</code> 上进行迭代，并将其产出（yield）的值透明地（transparently）转发到外部。就好像这些值就是由外部的 generator yield 的一样。</p>
<p>执行结果与我们内联嵌套 generator 中的代码获得的结果相同：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">generateSequence</span>(<span class="hljs-params">start, end</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt;= end; i++) <span class="hljs-keyword">yield</span> i;
}

<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">generateAlphaNum</span>(<span class="hljs-params"></span>) </span>{

*!*
  <span class="hljs-comment">// yield* generateSequence(48, 57);</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">48</span>; i &lt;= <span class="hljs-number">57</span>; i++) <span class="hljs-keyword">yield</span> i;

  <span class="hljs-comment">// yield* generateSequence(65, 90);</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">65</span>; i &lt;= <span class="hljs-number">90</span>; i++) <span class="hljs-keyword">yield</span> i;

  <span class="hljs-comment">// yield* generateSequence(97, 122);</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">97</span>; i &lt;= <span class="hljs-number">122</span>; i++) <span class="hljs-keyword">yield</span> i;
*/!*

}

<span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;&#x27;</span>;

<span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> code <span class="hljs-keyword">of</span> generateAlphaNum()</span>)</span> {
  str += <span class="hljs-built_in">String</span>.fromCharCode(code);
}

alert(str); <span class="hljs-comment">// 0..9A..Za..z</span></code></pre>
<p>Generator 组合（composition）是将一个 generator 流插入到另一个 generator 流的自然的方式。它不需要使用额外的内存来存储中间结果。</p>
<h2 id="yield-是一条双向路">&quot;yield&quot; 是一条双向路</h2>
<p>目前看来，generator 和可迭代对象类似，都具有用来生成值的特殊语法。但实际上，generator 更加强大且灵活。</p>
<p>这是因为 <code>yield</code> 是一条双向路（two-way street）：它不仅可以向外返回结果，而且还可以将外部的值传递到 generator 内。</p>
<p>调用 <code>generator.next(arg)</code>，我们就能将参数 <code>arg</code> 传递到 generator 内部。这个 <code>arg</code> 参数会变成 <code>yield</code> 的结果。</p>
<p>我们来看一个例子：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gen</span>(<span class="hljs-params"></span>) </span>{
*!*
  <span class="hljs-comment">// 向外部代码传递一个问题并等待答案</span>
  <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;2 + 2 = ?&quot;</span>; <span class="hljs-comment">// (*)</span>
*/!*

  alert(result);
}

<span class="hljs-keyword">let</span> generator = gen();

<span class="hljs-keyword">let</span> question = generator.next().value; <span class="hljs-comment">// &lt;-- yield 返回的 value</span>

generator.next(<span class="hljs-number">4</span>); <span class="hljs-comment">// --&gt; 将结果传递到 generator 中  </span></code></pre>
<p><img src="genYield2.svg" alt=""></p>
<ol>
<li>第一次调用 <code>generator.next()</code> 应该是不带参数的（如果带参数，那么该参数会被忽略）。它开始执行并返回第一个 <code>yield &quot;2 + 2 = ?&quot;</code> 的结果。此时，generator 执行暂停，而停留在 <code>(*)</code> 行上。</li>
<li>然后，正如上面图片中显示的那样，<code>yield</code> 的结果进入调用代码中的 <code>question</code> 变量。</li>
<li>在 <code>generator.next(4)</code>，generator 恢复执行，并获得了 <code>4</code> 作为结果：<code>let result = 4</code>。</li>
</ol>
<p>请注意，外部代码不必立即调用 <code>next(4)</code>。外部代码可能需要一些时间。这没问题：generator 将等待它。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-comment">// 一段时间后恢复 generator</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> generator.next(<span class="hljs-number">4</span>), <span class="hljs-number">1000</span>);</code></pre>
<p>我们可以看到，与常规函数不同，generator 和调用 generator 的代码可以通过在 <code>next/yield</code> 中传递值来交换结果。</p>
<p>为了讲得更浅显易懂，我们来看另一个例子，其中包含了许多调用：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gen</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> ask1 = <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;2 + 2 = ?&quot;</span>;

  alert(ask1); <span class="hljs-comment">// 4</span>

  <span class="hljs-keyword">let</span> ask2 = <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;3 * 3 = ?&quot;</span>

  alert(ask2); <span class="hljs-comment">// 9</span>
}

<span class="hljs-keyword">let</span> generator = gen();

alert( generator.next().value ); <span class="hljs-comment">// &quot;2 + 2 = ?&quot;</span>

alert( generator.next(<span class="hljs-number">4</span>).value ); <span class="hljs-comment">// &quot;3 * 3 = ?&quot;</span>

alert( generator.next(<span class="hljs-number">9</span>).done ); <span class="hljs-comment">// true</span></code></pre>
<p>执行图：</p>
<p><img src="genYield2-2.svg" alt=""></p>
<ol>
<li>第一个 <code>.next()</code> 启动了 generator 的执行……执行到达第一个 <code>yield</code>。</li>
<li>结果被返回到外部代码中。</li>
<li>第二个 <code>.next(4)</code> 将 <code>4</code> 作为第一个 <code>yield</code> 的结果传递回 generator 并恢复 generator 的执行。</li>
<li>……执行到达第二个 <code>yield</code>，它变成了 generator 调用的结果。</li>
<li>第三个 <code>next(9)</code> 将 <code>9</code> 作为第二个 <code>yield</code> 的结果传入 generator 并恢复 generator 的执行，执行现在到达了函数的最底部，所以返回 <code>done: true</code>。</li>
</ol>
<p>这个过程就像“乒乓球”游戏。每个 <code>next(value)</code>（除了第一个）传递一个值到 generator 中，该值变成了当前 <code>yield</code> 的结果，然后获取下一个 <code>yield</code> 的结果。</p>
<h2 id="generatorthrow">generator.throw</h2>
<p>正如我们在上面的例子中观察到的那样，外部代码可能会将一个值传递到 generator，作为 <code>yield</code> 的结果。</p>
<p>……但是它也可以在那里发起（抛出）一个 error。这很自然，因为 error 本身也是一种结果。</p>
<p>要向 <code>yield</code> 传递一个 error，我们应该调用 <code>generator.throw(err)</code>。在这种情况下，<code>err</code> 将被抛到对应的 <code>yield</code> 所在的那一行。</p>
<p>例如，<code>&quot;2 + 2?&quot;</code> 的 yield 导致了一个 error：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gen</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;2 + 2 = ?&quot;</span>; <span class="hljs-comment">// (1)</span>

    alert(<span class="hljs-string">&quot;The execution does not reach here, because the exception is thrown above&quot;</span>);
  } <span class="hljs-function"><span class="hljs-title">catch</span>(<span class="hljs-params">e</span>)</span> {
    alert(e); <span class="hljs-comment">// 显示这个 error</span>
  }
}

<span class="hljs-keyword">let</span> generator = gen();

<span class="hljs-keyword">let</span> question = generator.next().value;

*!*
generator.throw(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;The answer is not found in my database&quot;</span>)); <span class="hljs-comment">// (2)</span>
*/!*</code></pre>
<p>在 <code>(2)</code> 行引入到 generator 的 error 导致了在 <code>(1)</code> 行中的 <code>yield</code> 出现了一个异常。在上面这个例子中，<code>try..catch</code> 捕获并显示了这个 error。</p>
<p>如果我们没有捕获它，那么就会像其他的异常一样，它将从 generator “掉出”到调用代码中。</p>
<p>调用代码的当前行是 <code>generator.throw</code> 所在的那一行，标记为 <code>(2)</code>。所以我们可以在这里捕获它，就像这样：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">generate</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;2 + 2 = ?&quot;</span>; <span class="hljs-comment">// 这行出现 error</span>
}

<span class="hljs-keyword">let</span> generator = generate();

<span class="hljs-keyword">let</span> question = generator.next().value;

*!*
<span class="hljs-keyword">try</span> {
  generator.throw(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;The answer is not found in my database&quot;</span>));
} <span class="hljs-function"><span class="hljs-title">catch</span>(<span class="hljs-params">e</span>)</span> {
  alert(e); <span class="hljs-comment">// 显示这个 error</span>
}
*/!*</code></pre>
<p>如果我们没有在那里捕获这个 error，那么，通常，它会掉入外部调用代码（如果有），如果在外部也没有被捕获，则会杀死脚本。</p>
<h2 id="总结">总结</h2>
<ul>
<li>Generator 是通过 generator 函数 <code>function* f(…) {…}</code> 创建的。</li>
<li>在 generator（仅在）内部，存在 <code>yield</code> 操作。</li>
<li>外部代码和 generator 可能会通过 <code>next/yield</code> 调用交换结果。</li>
</ul>
<p>在现代 JavaScript 中，generator 很少被使用。但有时它们会派上用场，因为函数在执行过程中与调用代码交换数据的能力是非常独特的。而且，当然，它们非常适合创建可迭代对象。</p>
<p>并且，在下一章我们将会学习 async generator，它们被用于在 <code>for await ... of</code> 循环中读取异步生成的数据流（例如，通过网络分页提取 (paginated fetches over a network)）。</p>
<p>在 Web 编程中，我们经常使用数据流，因此这是另一个非常重要的使用场景。</p>

      </fieldset>
      
      <fieldset id='_QBuHBA'>
      <legend>article</legend>
      <h1 id="async-iterator-和-generator">Async iterator 和 generator</h1>
<p>异步迭代器（iterator）允许我们对按需通过异步请求而得到的数据进行迭代。例如，我们通过网络分段（chunk-by-chunk）下载数据时。异步生成器（generator）使这一步骤更加方便。</p>
<p>首先，让我们来看一个简单的示例以掌握语法，然后再看一个实际用例。</p>
<h2 id="async-iterator">Async iterator</h2>
<p>异步迭代器（async iterator）与常规的迭代器类似，不过语法上有一点区别。</p>
<p>一个“常规的”可迭代对象，即我们在 <a href="info:iterable">info:iterable</a> 一章中提到的，看起来像这样：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> range = {
  <span class="hljs-attr">from</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">to</span>: <span class="hljs-number">5</span>,

  <span class="hljs-comment">// 在刚使用 for..of 循环时，for..of 就会调用一次这个方法</span>
*!*
  [<span class="hljs-built_in">Symbol</span>.iterator]() {
*/!*
    <span class="hljs-comment">// ...它返回 iterator object：</span>
    <span class="hljs-comment">// 后续的操作中，for..of 将只针对这个对象</span>
    <span class="hljs-comment">// 并使用 next() 向它请求下一个值</span>
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">current</span>: <span class="hljs-built_in">this</span>.from,
      <span class="hljs-attr">last</span>: <span class="hljs-built_in">this</span>.to,

      <span class="hljs-comment">// for..of 循环在每次迭代时都会调用 next()</span>
*!*
      <span class="hljs-function"><span class="hljs-title">next</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-comment">// (2)</span>
        <span class="hljs-comment">// 它应该以对象 {done:.., value :...} 的形式返回值</span>
*/!*
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.current &lt;= <span class="hljs-built_in">this</span>.last) {
          <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: <span class="hljs-built_in">this</span>.current++ };
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> };
        }
      }
    };
  }
};

<span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> range</span>)</span> {
  alert(value); <span class="hljs-comment">// 1，然后 2，然后 3，然后 4，然后 5</span>
}</code></pre>
<p>有需要的话，你可以返回 <a href="info:iterable">info:iterable</a> 一章学习关于常规迭代器（iterator）的详细内容。</p>
<p>为了使对象可以异步迭代：</p>
<ol>
<li>我们需要使用 <code>Symbol.asyncIterator</code> 取代 <code>Symbol.iterator</code>。</li>
<li><code>next()</code> 方法应该返回一个 <code>promise</code>。</li>
<li>我们应该使用 <code>for await (let item of iterable)</code> 循环来迭代这样的对象</li>
</ol>
<p>接下来，让我们创建一个类似于之前的，可迭代的 <code>range</code> 对象，不过现在它会按照每秒一个的速度，异步地返回值：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> range = {
  <span class="hljs-attr">from</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">to</span>: <span class="hljs-number">5</span>,

  <span class="hljs-comment">// 在刚使用 for await..of 循环时，for await..of 就会调用一次这个方法</span>
*!*
  [<span class="hljs-built_in">Symbol</span>.asyncIterator]() { <span class="hljs-comment">// (1)</span>
*/!*
    <span class="hljs-comment">// ...它返回 iterator object：</span>
    <span class="hljs-comment">// 后续的操作中，for await..of 将只针对这个对象</span>
    <span class="hljs-comment">// 并使用 next() 向它请求下一个值</span>
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">current</span>: <span class="hljs-built_in">this</span>.from,
      <span class="hljs-attr">last</span>: <span class="hljs-built_in">this</span>.to,

      <span class="hljs-comment">// for await..of 循环在每次迭代时都会调用 next()</span>
*!*
      <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">next</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-comment">// (2)</span>
        <span class="hljs-comment">// 它应该以对象 {done:.., value :...} 的形式返回值</span>
        <span class="hljs-comment">// (会被 async 自动包装成一个 promise)</span>
*/!*

*!*
        <span class="hljs-comment">// 可以在内部使用 await，执行异步任务：</span>
        <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>)); <span class="hljs-comment">// (3)</span>
*/!*

        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.current &lt;= <span class="hljs-built_in">this</span>.last) {
          <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: <span class="hljs-built_in">this</span>.current++ };
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> };
        }
      }
    };
  }
};

(<span class="hljs-keyword">async</span> () =&gt; {

*!*
  <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> range) { <span class="hljs-comment">// (4)</span>
    alert(value); <span class="hljs-comment">// 1,2,3,4,5</span>
  }
*/!*

})()</code></pre>
<p>正如我们所看到的，其结构与常规的 iterator 类似:</p>
<ol>
<li>为了使一个对象可以异步迭代，它必须具有方法 <code>Symbol.asyncIterator</code> <code>(1)</code>。</li>
<li>这个方法必须返回一个带有 <code>next()</code> 方法的对象，<code>next()</code> 方法会返回一个 promise <code>(2)</code>。</li>
<li>这个 <code>next()</code> 方法可以不是 <code>async</code> 的，它可以是一个返回值是一个 <code>promise</code> 的常规的方法，但是使用 <code>async</code> 关键字可以允许我们在方法内部使用 <code>await</code>，所以会更加方便。这里我们只是用于延迟 1 秒的操作 <code>(3)</code>。</li>
<li>我们使用 <code>for await(let value of range)</code> <code>(4)</code> 来进行迭代，也就是在 <code>for</code> 后面添加 <code>await</code>。它会调用一次 <code>range[Symbol.asyncIterator]()</code> 方法一次，然后调用它的 <code>next()</code> 方法获取值。</li>
</ol>
<p>这是一个小备忘单：</p>
<table>
<thead>
<tr>
<th></th>
<th>Iterator</th>
<th>Async iterator</th>
</tr>
</thead>
<tbody><tr>
<td>提供 iterator 的对象方法</td>
<td><code>Symbol.iterator</code></td>
<td><code>Symbol.asyncIterator</code></td>
</tr>
<tr>
<td><code>next()</code> 返回的值是</td>
<td>任意值</td>
<td><code>Promise</code></td>
</tr>
<tr>
<td>要进行循环，使用</td>
<td><code>for..of</code></td>
<td><code>for await..of</code></td>
</tr>
</tbody></table>
<p>````warn header=&quot;Spread 语法 <code>...</code> 无法异步工作&quot;
需要常规的同步 iterator 的功能，无法与异步 iterator 一起使用。</p>
<p>例如，spread 语法无法工作：</p>
<pre><code class="language-js">alert( [...range] ); <span class="hljs-comment">// Error, no Symbol.iterator</span></code></pre>
<p>这很正常，因为它期望找到 <code>Symbol.iterator</code>，跟 <code>for..of</code> 没有 <code>await</code> 一样。并非 <code>Symbol.asyncIterator</code>。</p>
<pre><code>
## Async generator

正如我们所知，JavaScript 也支持生成器（generator），并且它们也是可迭代的。

让我们回顾一下 &lt;info:generators&gt; 一章的序列生成器（generator）。它生成从 `start` 到 `end` 的一系列值：

```js run
function* generateSequence(start, end) {
  for (let i = start; i &lt;= end; i++) {
    yield i;
  }
}

for(let value of generateSequence(1, 5)) {
  alert(value); // 1，然后 2，然后 3，然后 4，然后 5
}
```

在常规的 generator 中，我们无法使用 `await`。所有的值都必须同步获得：`for..of` 中没有延时的地方，它是一个同步结构。

但是，如果我们需要在 `generator` 内使用 `await` 该怎么办呢？我们以执行网络请求为例子。

没问题，只需要在它前面加上 `async` 即可，就像这样：

```js run
*!*async*/!* function* generateSequence(start, end) {

  for (let i = start; i &lt;= end; i++) {

*!*
    // 耶，可以使用 await 了！
    await new Promise(resolve =&gt; setTimeout(resolve, 1000));
*/!*

    yield i;
  }

}

(async () =&gt; {

  let generator = generateSequence(1, 5);
  for *!*await*/!* (let value of generator) {
    alert(value); // 1，然后 2，然后 3，然后 4，然后 5
  }

})();
```

现在，我们有了 async generator，可以使用 `for await...of` 进行迭代。

这确实非常简单。我们加了 `async` 关键字，然后我们就能在 generator 内部使用 `await` 了，依赖于 `promise` 和其他异步函数。

从技术上来讲，async generator 的另一个不同之处在于，它的 `generatr.next()` 方法现在也是异步的，它返回 promise。

在一个常规的 generator 中，我们使用 `result = generator.next()` 来获得值。但在一个 `async generator` 中，我们应该添加 `await` 关键字，像这样：

```js
result = await generator.next(); // result = {value: ..., done: true/false}
```

## Async iterable

正如我们所知道的，要使一个对象可迭代，我们需要给它添加 `Symbol.iterator`。

```js
let range = {
  from: 1,
  to: 5,
*!*
  [Symbol.iterator]() {
    return &lt;object with next to make range iterable&gt;
  }
*/!*
}
```

对于 `Symbol.iterator` 来说，一个通常的做法是返回一个 generator，而不是像前面的例子中那样返回一个带有 `next()` 方法的普通对象。

让我们回顾一下来自之前 [](info:generators) 一章中的一个示例：

```js run
let range = {
  from: 1,
  to: 5,

  *[Symbol.iterator]() { // [Symbol.iterator]: function*() 的简写形式
    for(let value = this.from; value &lt;= this.to; value++) {
      yield value;
    }
  }
};

for(let value of range) {
  alert(value); // 1，然后 2，然后 3，然后 4，然后 5
}
```

这有一个自定义的对象 `range`，它是可迭代的，并且它的 generator `*[Symbol.iterator]` 实现了列出值的逻辑。

如果们想要给 generator 加上异步行为，那么我们应该将 `Symbol.iterator` 替换成异步的 `Symbol.asyncIterator`：

```js run
let range = {
  from: 1,
  to: 5,

*!*
  async *[Symbol.asyncIterator]() { // 等价于 [Symbol.asyncIterator]: async function*()
*/!*
    for(let value = this.from; value &lt;= this.to; value++) {

      // 在 value 之间暂停一会儿，等待一些东西
      await new Promise(resolve =&gt; setTimeout(resolve, 1000));

      yield value;
    }
  }
};

(async () =&gt; {

  for *!*await*/!* (let value of range) {
    alert(value); // 1，然后 2，然后 3，然后 4，然后 5
  }

})();
```

现在，value 之间的延迟为 1 秒。

## 实际的例子

到目前为止，我们为了获得基础的了解，看到的都是简单的例子。接下来，我们来看一个实际的用例。

目前，有很多在线服务都是发送的分页数据（paginated data）。例如，当我们需要一个用户列表时，一个请求只返回一个预定义数量的用户（例如 100 个用户）— “一页”，并提供了指向下一页的 URL。

这种模式非常常见。不仅可用于获取用户列表，这种模式还可以用于任意东西。例如，GitHub 允许使用相同的分页提交（paginated fashion）的方式找回 commit：

- 我们应该提交一个请求到这种格式的 URL：`https://api.github.com/repos/&lt;repo&gt;/commits`。
- 它返回一个包含 30 条 commit 的 JSON，并在返回的 `Link` header 中提供了指向下一页的链接。
- 然后我们可以将该链接用于下一个请求，以获取更多 commit，以此类推。

但是我们希望有一个更简单的 API：具有 commit 的可迭代对象，然后我们就可以像这样来遍历它们：

```js
let repo = &#x27;javascript-tutorial/en.javascript.info&#x27;; // 用于获取 commit 的 GitHub 仓库

for await (let commit of fetchCommits(repo)) {
  // 处理 commit
}
```

我们想创建一个函数 `fetchCommits(repo)`，用来在任何我们有需要的时候发出请求，来为我们获取 commit。并且让它关注于所有分页的数据。对于我们来说，它就是一个简单的 `for await..of`。

通过使用 async generator，我们可以很容易地实现它：

```js
async function* fetchCommits(repo) {
  let url = `https://api.github.com/repos/${repo}/commits`;

  while (url) {
    const response = await fetch(url, { // (1)
      headers: {&#x27;User-Agent&#x27;: &#x27;Our script&#x27;}, // github 要求 user-agent header
    });

    const body = await response.json(); // (2) 响应的是 JSON（array of commits）

    // (3) 前往下一页的 URL 在 header 中，提取它
    let nextPage = response.headers.get(&#x27;Link&#x27;).match(/&lt;(.*?)&gt;; rel=&quot;next&quot;/);
    nextPage = nextPage?.[1];

    url = nextPage;

    for(let commit of body) { // (4) 一个接一个地 yield commit，直到最后一页
      yield commit;
    }
  }
}
```

1. 我们使用浏览器的 [fetch](info:fetch) 方法从远程 URL 下载数据。它允许我们提供授权和其他 header，如果需要 — 这里 GitHub 需要的是 `User-Agent`。
2. `fetch` 的结果被解析为 JSON。这又是 `fetch` 特定的方法。
3. 我们应该从响应（response）的 `Link` header 中获取前往下一页的 URL。它有一个特殊的格式，所以我们对它使用正则表达式（regexp）。前往下一页的 URL 看起来就像这样 `https://api.github.com/repositories/93253246/commits?page=2`。这是由 GitHub 自己生成的。
4. 然后我们将接收到的所有 commit 都 yield 出来，当它 yield 完成时，将触发下一个 `while(url)` 迭代，并发出下一个请求。

这是一个使用示例（在控制台中显示 commit 的作者）

```js run
(async () =&gt; {

  let count = 0;

  for await (const commit of fetchCommits(&#x27;javascript-tutorial/en.javascript.info&#x27;)) {

    console.log(commit.author.login);

    if (++count == 100) { // 让我们在获取了 100 个 commit 时停止
      break;
    }
  }

})();
```

这就是我们想要的。从外部看不到分页请求（paginated requests）的内部机制。对我们来说，它只是一个返回 commit 的 async generator。

## 总结

常规的 iterator 和 generator 可以很好地处理那些不需要花费时间来生成的的数据。

当我们期望异步地，有延迟地获取数据时，可以使用它们的 async counterpart，并且使用 `for await..of` 替代 `for..of`。

Async iterator 与常规 iterator 在语法上的区别：

|       | Iterable  | Async Iterable |
|-------|-----------|-----------------|
| 提供 iterator 的对象方法 | `Symbol.iterator` | `Symbol.asyncIterator` |
| `next()` 返回的值是     | `{value:…, done: true/false}`             | resolve 成 `{value:…, done: true/false}` 的 `Promise` |

Async generator 与常规 generator 在语法上的区别：

|       | Generator | Async generator |
|-------|-----------|-----------------|
| 声明方式 | `function*` | `async function*` |
| `next()` 返回的值是          | `{value:…, done: true/false}`         | resolve 成 `{value:…, done: true/false}` 的 `Promise`  |

在 Web 开发中，我们经常会遇到数据流，它们分段流动（flows chunk-by-chunk）。例如，下载或上传大文件。

我们可以使用 async generator 来处理此类数据。值得注意的是，在一些环境，例如浏览器环境下，还有另一个被称为 Streams 的 API，它提供了特殊的接口来处理此类数据流，转换数据并将数据从一个数据流传递到另一个数据流（例如，从一个地方下载并立即发送到其他地方）。</code></pre>

      </fieldset>
      
      <fieldset id='_m9xV5R'>
      <legend>article</legend>
      <h1 id="模块-module-简介">模块 (Module) 简介</h1>
<p>随着我们的应用越来越大，我们想要将其拆分成多个文件，即所谓的“模块（module）”。一个模块可以包含用于特定目的的类或函数库。</p>
<p>很长一段时间，JavaScript 都没有语言级（language-level）的模块语法。这不是一个问题，因为最初的脚本又小又简单，所以没必要将其模块化。</p>
<p>但是最终脚本变得越来越复杂，因此社区发明了许多种方法来将代码组织到模块中，使用特殊的库按需加载模块。</p>
<p>列举一些（出于历史原因）：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Asynchronous_module_definition">AMD</a> —— 最古老的模块系统之一，最初由 <a href="http://requirejs.org/">require.js</a> 库实现。</li>
<li><a href="http://wiki.commonjs.org/wiki/Modules/1.1">CommonJS</a> —— 为 Node.js 服务器创建的模块系统。</li>
<li><a href="https://github.com/umdjs/umd">UMD</a> —— 另外一个模块系统，建议作为通用的模块系统，它与 AMD 和 CommonJS 都兼容。</li>
</ul>
<p>现在，它们都在慢慢成为历史的一部分，但我们仍然可以在旧脚本中找到它们。</p>
<p>语言级的模块系统在 2015 年的时候出现在了标准（ES6）中，此后逐渐发展，现在已经得到了所有主流浏览器和 Node.js 的支持。因此，我们将从现在开始学习现代 JavaScript 模块（module）。</p>
<h2 id="什么是模块？">什么是模块？</h2>
<p>一个模块（module）就是一个文件。一个脚本就是一个模块。就这么简单。</p>
<p>模块可以相互加载，并可以使用特殊的指令 <code>export</code> 和 <code>import</code> 来交换功能，从另一个模块调用一个模块的函数：</p>
<ul>
<li><code>export</code> 关键字标记了可以从当前模块外部访问的变量和函数。</li>
<li><code>import</code> 关键字允许从其他模块导入功能。</li>
</ul>
<p>例如，我们有一个 <code>sayHi.js</code> 文件导出了一个函数：</p>
<pre><code class="language-js"><span class="hljs-comment">// 📁 sayHi.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params">user</span>) </span>{
  alert(<span class="hljs-string">`Hello, <span class="hljs-subst">${user}</span>!`</span>);
}</code></pre>
<p>……然后另一个文件可能导入并使用了这个函数：</p>
<pre><code class="language-js"><span class="hljs-comment">// 📁 main.js</span>
<span class="hljs-keyword">import</span> {sayHi} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./sayHi.js&#x27;</span>;

alert(sayHi); <span class="hljs-comment">// function...</span>
sayHi(<span class="hljs-string">&#x27;John&#x27;</span>); <span class="hljs-comment">// Hello, John!</span></code></pre>
<p><code>import</code> 指令通过相对于当前文件的路径 <code>./sayHi.js</code> 加载模块，并将导入的函数 <code>sayHi</code> 分配（assign）给相应的变量。</p>
<p>让我们在浏览器中运行一下这个示例。</p>
<p>由于模块支持特殊的关键字和功能，因此我们必须通过使用 <code>&lt;script type=&quot;module&quot;&gt;</code> 特性（attribute）来告诉浏览器，此脚本应该被当作模块（module）来对待。</p>
<p>像这样：</p>
<p>[codetabs src=&quot;say&quot; height=&quot;140&quot; current=&quot;index.html&quot;]</p>
<p>浏览器会自动获取并解析（evaluate）导入的模块（如果需要，还可以分析该模块的导入），然后运行该脚本。</p>
<pre><code class="language-warn">如果你尝试通过 `file://` 协议在本地打开一个网页，你会发现 `import/export` 指令不起作用。你可以使用本地 Web 服务器，例如 [static-server](https://www.npmjs.com/package/static-server#getting-started)，或者使用编辑器的“实时服务器”功能，例如 VS Code 的 [Live Server Extension](https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer) 来测试模块。</code></pre>
<h2 id="模块核心功能">模块核心功能</h2>
<p>与“常规”脚本相比，模块有什么不同呢？</p>
<p>下面是一些核心的功能，对浏览器和服务端的 JavaScript 来说都有效。</p>
<h3 id="始终使用-use-strict">始终使用 &quot;use strict&quot;</h3>
<p>模块始终默认使用 <code>use strict</code>，例如，对一个未声明的变量赋值将产生错误（译注：在浏览器控制台可以看到 error 信息）。</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="javascript">
  a = <span class="hljs-number">5</span>; <span class="hljs-comment">// error</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h3 id="模块级作用域">模块级作用域</h3>
<p>每个模块都有自己的顶级作用域（top-level scope）。换句话说，一个模块中的顶级作用域变量和函数在其他脚本中是不可见的。</p>
<p>在下面这个例子中，我们导入了两个脚本，<code>hello.js</code> 尝试使用在 <code>user.js</code> 中声明的变量 <code>user</code>，失败了：</p>
<p>[codetabs src=&quot;scopes&quot; height=&quot;140&quot; current=&quot;index.html&quot;]</p>
<p>模块期望 <code>export</code> 它们想要被外部访问的内容，并 <code>import</code> 它们所需要的内容。</p>
<p>所以，我们应该将 <code>user.js</code> 导入到 <code>hello.js</code> 中，并从中获取所需的功能，而不要依赖于全局变量。</p>
<p>这是正确的变体：</p>
<p>[codetabs src=&quot;scopes-working&quot; height=&quot;140&quot; current=&quot;hello.js&quot;]</p>
<p>在浏览器中，每个 <code>&lt;script type=&quot;module&quot;&gt;</code> 也存在独立的顶级作用域（译注：在浏览器控制台可以看到 error 信息）。</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="javascript">
  <span class="hljs-comment">// 变量仅在这个 module script 内可见</span>
  <span class="hljs-keyword">let</span> user = <span class="hljs-string">&quot;John&quot;</span>;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="javascript">
  *!*
  alert(user); <span class="hljs-comment">// Error: user is not defined</span>
  */!*
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>如果我们真的需要创建一个 window-level 的全局变量，我们可以将其明确地赋值给 <code>window</code>，并以 <code>window.user</code> 来访问它。但是这需要你有足够充分的理由，否则就不要这样做。</p>
<h3 id="模块代码仅在第一次导入时被解析">模块代码仅在第一次导入时被解析</h3>
<p>如果同一个模块被导入到多个其他位置，那么它的代码仅会在第一次导入时执行，然后将导出（export）的内容提供给所有的导入（importer）。</p>
<p>这有很重要的影响。让我们通过示例来看一下：</p>
<p>首先，如果执行一个模块中的代码会带来副作用（side-effect），例如显示一条消息，那么多次导入它只会触发一次显示 —— 即第一次：</p>
<pre><code class="language-js"><span class="hljs-comment">// 📁 alert.js</span>
alert(<span class="hljs-string">&quot;Module is evaluated!&quot;</span>);</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// 在不同的文件中导入相同的模块</span>

<span class="hljs-comment">// 📁 1.js</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">`./alert.js`</span>; <span class="hljs-comment">// Module is evaluated!</span>

<span class="hljs-comment">// 📁 2.js</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">`./alert.js`</span>; <span class="hljs-comment">// (什么都不显示)</span></code></pre>
<p>在实际开发中，顶级模块代码主要用于初始化，内部数据结构的创建，并且如果我们希望某些东西可以重用 — 请导出它。</p>
<p>下面是一个高级点的例子。</p>
<p>我们假设一个模块导出了一个对象：</p>
<pre><code class="language-js"><span class="hljs-comment">// 📁 admin.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> admin = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>
};</code></pre>
<p>如果这个模块被导入到多个文件中，模块仅在第一次被导入时被解析，并创建 <code>admin</code> 对象，然后将其传入到所有的导入。</p>
<p>所有的导入都只获得了一个唯一的 <code>admin</code> 对象：</p>
<pre><code class="language-js"><span class="hljs-comment">// 📁 1.js</span>
<span class="hljs-keyword">import</span> {admin} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./admin.js&#x27;</span>;
admin.name = <span class="hljs-string">&quot;Pete&quot;</span>;

<span class="hljs-comment">// 📁 2.js</span>
<span class="hljs-keyword">import</span> {admin} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./admin.js&#x27;</span>;
alert(admin.name); <span class="hljs-comment">// Pete</span>

*!*
<span class="hljs-comment">// 1.js 和 2.js 导入的是同一个对象</span>
<span class="hljs-comment">// 在 1.js 中对对象做的更改，在 2.js 中也是可见的</span>
*/!*</code></pre>
<p>所以，让我们重申一下 —— 模块只被执行一次。生成导出，然后它被分享给所有对其的导入，所以如果某个地方修改了 <code>admin</code> 对象，其他的模块也能看到这个修改。</p>
<p>这种行为让我们可以在首次导入时 <strong>设置</strong> 模块。我们只需要设置其属性一次，然后在进一步的导入中就都可以直接使用了。</p>
<p>例如，下面的 <code>admin.js</code> 模块可能提供了特定的功能，但是希望凭证（credential）从外部进入 <code>admin</code> 对象：</p>
<pre><code class="language-js"><span class="hljs-comment">// 📁 admin.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> admin = { };

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-string">`Ready to serve, <span class="hljs-subst">${admin.name}</span>!`</span>);
}</code></pre>
<p>在 <code>init.js</code> 中 —— 我们 APP 的第一个脚本，设置了 <code>admin.name</code>。现在每个位置都能看到它，包括在 <code>admin.js</code> 内部的调用。</p>
<pre><code class="language-js"><span class="hljs-comment">// 📁 init.js</span>
<span class="hljs-keyword">import</span> {admin} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./admin.js&#x27;</span>;
admin.name = <span class="hljs-string">&quot;Pete&quot;</span>;</code></pre>
<p>另一个模块也可以看到 <code>admin.name</code>：</p>
<pre><code class="language-js"><span class="hljs-comment">// 📁 other.js</span>
<span class="hljs-keyword">import</span> {admin, sayHi} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./admin.js&#x27;</span>;

alert(admin.name); <span class="hljs-comment">// *!*Pete*/!*</span>

sayHi(); <span class="hljs-comment">// Ready to serve, *!*Pete*/!*!</span></code></pre>
<h3 id="importmeta">import.meta</h3>
<p><code>import.meta</code> 对象包含关于当前模块的信息。</p>
<p>它的内容取决于其所在的环境。在浏览器环境中，它包含当前脚本的 URL，或者如果它是在 HTML 中的话，则包含当前页面的 URL。</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="javascript">
  alert(<span class="hljs-keyword">import</span>.meta.url); <span class="hljs-comment">// 脚本的 URL（对于内嵌脚本来说，则是当前 HTML 页面的 URL）</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h3 id="在一个模块中，this-是-undefined">在一个模块中，&quot;this&quot; 是 undefined</h3>
<p>这是一个小功能，但为了完整性，我们应该提到它。</p>
<p>在一个模块中，顶级 <code>this</code> 是 undefined。</p>
<p>将其与非模块脚本进行比较会发现，非模块脚本的顶级 <code>this</code> 是全局对象：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  alert(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// window</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="javascript">
  alert(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// undefined</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h2 id="浏览器特定功能">浏览器特定功能</h2>
<p>与常规脚本相比，拥有 <code>type=&quot;module&quot;</code> 标识的脚本有一些特定于浏览器的差异。</p>
<p>如果你是第一次阅读或者你不打算在浏览器中使用 JavaScript，那么你可以跳过本节内容。</p>
<h3 id="模块脚本是延迟的">模块脚本是延迟的</h3>
<p>模块脚本 <strong>总是</strong> 被延迟的，与 <code>defer</code> 特性（在 <a href="info:script-async-defer"></a> 一章中描述的）对外部脚本和内联脚本（inline script）的影响相同。</p>
<p>也就是说：</p>
<ul>
<li>下载外部模块脚本 <code>&lt;script type=&quot;module&quot; src=&quot;...&quot;&gt;</code> 不会阻塞 HTML 的处理，它们会与其他资源并行加载。</li>
<li>模块脚本会等到 HTML 文档完全准备就绪（即使它们很小并且比 HTML 加载速度更快），然后才会运行。</li>
<li>保持脚本的相对顺序：在文档中排在前面的脚本先执行。</li>
</ul>
<p>它的一个副作用是，模块脚本总是会“看到”已完全加载的 HTML 页面，包括在它们下方的 HTML 元素。</p>
<p>例如：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="javascript">
*!*
  alert(<span class="hljs-keyword">typeof</span> button); <span class="hljs-comment">// object：脚本可以“看见”下面的 button</span>
*/!*
  <span class="hljs-comment">// 因为模块是被延迟的（deferred，所以模块脚本会在整个页面加载完成后才运行</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

相较于下面这个常规脚本：

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
*!*
  alert(<span class="hljs-keyword">typeof</span> button); <span class="hljs-comment">// Error: button is undefined，脚本看不到下面的元素</span>
*/!*
  <span class="hljs-comment">// 常规脚本会立即运行，常规脚本的运行是在在处理页面的其余部分之前进行的</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>Button<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre>
<p>请注意：上面的第二个脚本实际上要先于前一个脚本运行！所以我们会先看到 <code>undefined</code>，然后才是 <code>object</code>。</p>
<p>这是因为模块脚本是被延迟的，所以要等到 HTML 文档被处理完成才会执行它。而常规脚本则会立即运行，所以我们会先看到常规脚本的输出。</p>
<p>当使用模块脚本时，我们应该知道 HTML 页面在加载时就会显示出来，在 HTML 页面加载完成后才会执行 JavaScript 模块，因此用户可能会在 JavaScript 应用程序准备好之前看到该页面。某些功能那时可能还无法正使用。我们应该放置“加载指示器（loading indicator）”，否则，请确保不会使用户感到困惑。</p>
<h3 id="async-适用于内联脚本（inline-script）">Async 适用于内联脚本（inline script）</h3>
<p>对于非模块脚本，<code>async</code> 特性（attribute）仅适用于外部脚本。异步脚本会在准备好后立即运行，独立于其他脚本或 HTML 文档。</p>
<p>对于模块脚本，它也适用于内联脚本。</p>
<p>例如，下面的内联脚本具有 <code>async</code> 特性，因此它不会等待任何东西。</p>
<p>它执行导入（fetch <code>./analytics.js</code>），并在准备导入完成时运行，即使 HTML 文档还未完成，或者其他脚本仍在等待处理中。</p>
<p>这对于不依赖任何其他东西的功能来说是非常棒的，例如计数器，广告，文档级事件监听器。</p>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 所有依赖都获取完成（analytics.js）然后脚本开始运行 --&gt;</span>
<span class="hljs-comment">&lt;!-- 不会等待 HTML 文档或者其他 &lt;script&gt; 标签 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> *!*<span class="hljs-attr">async</span>*/!* <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">import</span> {counter} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./analytics.js&#x27;</span>;

  counter.count();
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h3 id="外部脚本">外部脚本</h3>
<p>具有 <code>type=&quot;module&quot;</code> 的外部脚本（external script）在两个方面有所不同：</p>
<ol>
<li><p>具有相同 <code>src</code> 的外部脚本仅运行一次：</p>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 脚本 my.js 被加载完成（fetched）并只被运行一次 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;my.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;my.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
</li>
<li><p>从另一个源（例如另一个网站）获取的外部脚本需要 <a href="mdn:Web/HTTP/CORS">CORS</a> header，如我们在 <a href="info:fetch-crossorigin">info:fetch-crossorigin</a> 一章中所讲的那样。换句话说，如果一个模块脚本是从另一个源获取的，则远程服务器必须提供表示允许获取的 header <code>Access-Control-Allow-Origin</code>。</p>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- another-site.com 必须提供 Access-Control-Allow-Origin --&gt;</span>
<span class="hljs-comment">&lt;!-- 否则，脚本将无法执行 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;*!*http://another-site.com/their.js*/!*&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p> 默认这样做可以确保更好的安全性。</p>
</li>
</ol>
<h3 id="不允许裸模块（bare-module）">不允许裸模块（&quot;bare&quot; module）</h3>
<p>在浏览器中，<code>import</code> 必须给出相对或绝对的 URL 路径。没有任何路径的模块被称为“裸（bare）”模块。在 <code>import</code> 中不允许这种模块。</p>
<p>例如，下面这个 <code>import</code> 是无效的：</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> {sayHi} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;sayHi&#x27;</span>; <span class="hljs-comment">// Error，“裸”模块</span>
<span class="hljs-comment">// 模块必须有一个路径，例如 &#x27;./sayHi.js&#x27; 或者其他任何路径</span></code></pre>
<p>某些环境，像 Node.js 或者打包工具（bundle tool）允许没有任何路径的裸模块，因为它们有自己的查找模块的方法和钩子（hook）来对它们进行微调。但是浏览器尚不支持裸模块。</p>
<h3 id="兼容性，nomodule">兼容性，&quot;nomodule&quot;</h3>
<p>旧时的浏览器不理解 <code>type=&quot;module&quot;</code>。未知类型的脚本会被忽略。对此，我们可以使用 <code>nomodule</code> 特性来提供一个后备：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="javascript">
  alert(<span class="hljs-string">&quot;Runs in modern browsers&quot;</span>);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">nomodule</span>&gt;</span><span class="javascript">
  alert(<span class="hljs-string">&quot;Modern browsers know both type=module and nomodule, so skip this&quot;</span>)
  alert(<span class="hljs-string">&quot;Old browsers ignore script with unknown type=module, but execute this.&quot;</span>);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h2 id="构建工具">构建工具</h2>
<p>在实际开发中，浏览器模块很少被以“原始”形式进行使用。通常，我们会使用一些特殊工具，例如 <a href="https://webpack.js.org/">Webpack</a>，将它们打包在一起，然后部署到生产环境的服务器。</p>
<p>使用打包工具的一个好处是 —— 它们可以更好地控制模块的解析方式，允许我们使用裸模块和更多的功能，例如 CSS/HTML 模块等。</p>
<p>构建工具做以下这些事儿：</p>
<ol>
<li>从一个打算放在 HTML 中的 <code>&lt;script type=&quot;module&quot;&gt;</code> “主”模块开始。</li>
<li>分析它的依赖：它的导入，以及它的导入的导入等。</li>
<li>使用所有模块构建一个文件（或者多个文件，这是可调的），并用打包函数（bundler function）替代原生的 <code>import</code> 调用，以使其正常工作。还支持像 HTML/CSS 模块等“特殊”的模块类型。</li>
<li>在处理过程中，可能会应用其他转换和优化：<ul>
<li>删除无法访问的代码。</li>
<li>删除未使用的导出（&quot;tree-shaking&quot;）。</li>
<li>删除特定于开发的像 <code>console</code> 和 <code>debugger</code> 这样的语句。</li>
<li>可以使用 <a href="https://babeljs.io/">Babel</a> 将前沿的现代的 JavaScript 语法转换为具有类似功能的旧的 JavaScript 语法。</li>
<li>压缩生成的文件（删除空格，用短的名字替换变量等）。</li>
</ul>
</li>
</ol>
<p>如果我们使用打包工具，那么脚本会被打包进一个单一文件（或者几个文件），在这些脚本中的 <code>import/export</code> 语句会被替换成特殊的打包函数（bundler function）。因此，最终打包好的脚本中不包含任何 <code>import/export</code>，它也不需要 <code>type=&quot;module&quot;</code>，我们可以将其放入常规的 <code>&lt;script&gt;</code>：</p>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 假设我们从诸如 Webpack 这类的打包工具中获得了 &quot;bundle.js&quot; 脚本 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;bundle.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>也就是说，原生模块也是可以使用的。所以，我们在这儿将不会使用 Webpack：你可以稍后再配置它。</p>
<h2 id="总结">总结</h2>
<p>下面总结一下模块的核心概念：</p>
<ol>
<li>一个模块就是一个文件。浏览器需要使用 <code>&lt;script type=&quot;module&quot;&gt;</code> 以使 <code>import/export</code> 可以工作。模块（译注：相较于常规脚本）有几点差别：<ul>
<li>默认是延迟解析的（deferred）。</li>
<li>Async 可用于内联脚本。</li>
<li>要从另一个源（域/协议/端口）加载外部脚本，需要 CORS header。</li>
<li>重复的外部脚本会被忽略</li>
</ul>
</li>
<li>模块具有自己的本地顶级作用域，并可以通过 <code>import/export</code> 交换功能。</li>
<li>模块始终使用 <code>use strict</code>。</li>
<li>模块代码只执行一次。导出仅创建一次，然后会在导入之间共享。</li>
</ol>
<p>当我们使用模块时，每个模块都会实现特定功能并将其导出。然后我们使用 <code>import</code> 将其直接导入到需要的地方即可。浏览器会自动加载并解析脚本。</p>
<p>在生产环境中，出于性能和其他原因，开发者经常使用诸如 <a href="https://webpack.js.org">Webpack</a> 之类的打包工具将模块打包到一起。</p>
<p>在下一章里，我们将会看到更多关于模块的例子，以及如何进行导入/导出。</p>

      </fieldset>
      
      <fieldset id='_4Y84gv'>
      <legend>article</legend>
      <h1 id="导出和导入">导出和导入</h1>
<p>导出（export）和导入（import）指令有几种语法变体。</p>
<p>在上一节，我们看到了一个简单的用法，现在让我们来探索更多示例吧。</p>
<h2 id="在声明前导出">在声明前导出</h2>
<p>我们可以通过在声明之前放置 <code>export</code> 来标记任意声明为导出，无论声明的是变量，函数还是类都可以。</p>
<p>例如，这里的所有导出均有效：</p>
<pre><code class="language-js"><span class="hljs-comment">// 导出数组</span>
*!*<span class="hljs-keyword">export</span>*/!* <span class="hljs-keyword">let</span> months = [<span class="hljs-string">&#x27;Jan&#x27;</span>, <span class="hljs-string">&#x27;Feb&#x27;</span>, <span class="hljs-string">&#x27;Mar&#x27;</span>,<span class="hljs-string">&#x27;Apr&#x27;</span>, <span class="hljs-string">&#x27;Aug&#x27;</span>, <span class="hljs-string">&#x27;Sep&#x27;</span>, <span class="hljs-string">&#x27;Oct&#x27;</span>, <span class="hljs-string">&#x27;Nov&#x27;</span>, <span class="hljs-string">&#x27;Dec&#x27;</span>];

<span class="hljs-comment">// 导出 const 声明的变量</span>
*!*<span class="hljs-keyword">export</span>*/!* <span class="hljs-keyword">const</span> MODULES_BECAME_STANDARD_YEAR = <span class="hljs-number">2015</span>;

<span class="hljs-comment">// 导出类</span>
*!*<span class="hljs-keyword">export</span>*/!* <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> {
    <span class="hljs-built_in">this</span>.name = name;
  }
}</code></pre>
<pre><code class="language-smart">注意，在类或者函数前的 `export` 不会让它们变成 [函数表达式](info:function-expressions)。尽管被导出了，但它仍然是一个函数声明。

大部分 JavaScript 样式指南都不建议在函数和类声明后使用分号。

这就是为什么在 `export class` 和 `export function` 的末尾不需要加分号：

```js
export function sayHi(user) {
  alert(`Hello, ${user}!`);
} *!* // 在这里没有分号 ; */!*
```
</code></pre>
<h2 id="导出与声明分开">导出与声明分开</h2>
<p>另外，我们还可以将 <code>export</code> 分开放置。</p>
<p>下面的例子中，我们先声明函数，然后再导出它们：</p>
<pre><code class="language-js"><span class="hljs-comment">// 📁 say.js</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params">user</span>) </span>{
  alert(<span class="hljs-string">`Hello, <span class="hljs-subst">${user}</span>!`</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayBye</span>(<span class="hljs-params">user</span>) </span>{
  alert(<span class="hljs-string">`Bye, <span class="hljs-subst">${user}</span>!`</span>);
}

*!*
<span class="hljs-keyword">export</span> {sayHi, sayBye}; <span class="hljs-comment">// 导出变量列表</span>
*/!*</code></pre>
<p>……从技术上讲，我们也可以把 <code>export</code> 放在函数上面。</p>
<h2 id="import-">Import *</h2>
<p>通常，我们把要导入的东西列在花括号 <code>import {...}</code> 中，就像这样：</p>
<pre><code class="language-js"><span class="hljs-comment">// 📁 main.js</span>
*!*
<span class="hljs-keyword">import</span> {sayHi, sayBye} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./say.js&#x27;</span>;
*/!*

sayHi(<span class="hljs-string">&#x27;John&#x27;</span>); <span class="hljs-comment">// Hello, John!</span>
sayBye(<span class="hljs-string">&#x27;John&#x27;</span>); <span class="hljs-comment">// Bye, John!</span></code></pre>
<p>但是如果有很多要导入的内容，我们可以使用 <code>import * as &lt;obj&gt;</code> 将所有内容导入为一个对象，例如：</p>
<pre><code class="language-js"><span class="hljs-comment">// 📁 main.js</span>
*!*
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> say <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./say.js&#x27;</span>;
*/!*

say.sayHi(<span class="hljs-string">&#x27;John&#x27;</span>);
say.sayBye(<span class="hljs-string">&#x27;John&#x27;</span>);</code></pre>
<p>乍一看，“通通导入”看起来很酷，写起来也很短，但是我们通常为什么要明确列出我们需要导入的内容？</p>
<p>这里有几个原因。</p>
<ol>
<li><p>现代的构建工具（<a href="http://webpack.github.io">webpack</a> 和其他工具）将模块打包到一起并对其进行优化，以加快加载速度并删除未使用的代码。</p>
<p> 比如说，我们向我们的项目里添加一个第三方库 <code>say.js</code>，它具有许多函数：</p>
<pre><code class="language-js"><span class="hljs-comment">// 📁 say.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>{ ... }
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayBye</span>(<span class="hljs-params"></span>) </span>{ ... }
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">becomeSilent</span>(<span class="hljs-params"></span>) </span>{ ... }</code></pre>
<p> 现在，如果我们只在我们的项目里使用了 <code>say.js</code> 中的一个函数：</p>
<pre><code class="language-js"><span class="hljs-comment">// 📁 main.js</span>
<span class="hljs-keyword">import</span> {sayHi} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./say.js&#x27;</span>;</code></pre>
<p> ……那么，优化器（optimizer）就会检测到它，并从打包好的代码中删除那些未被使用的函数，从而使构建更小。这就是所谓的“摇树（tree-shaking）”。</p>
</li>
<li><p>明确列出要导入的内容会使得名称较短：<code>sayHi()</code> 而不是 <code>say.sayHi()</code>。</p>
</li>
<li><p>导入的显式列表可以更好地概述代码结构：使用的内容和位置。它使得代码支持重构，并且重构起来更容易。</p>
</li>
</ol>
<h2 id="import-as">Import &quot;as&quot;</h2>
<p>我们也可以使用 <code>as</code> 让导入具有不同的名字。</p>
<p>例如，简洁起见，我们将 <code>sayHi</code> 导入到局部变量 <code>hi</code>，将 <code>sayBye</code> 导入到 <code>bye</code>：</p>
<pre><code class="language-js"><span class="hljs-comment">// 📁 main.js</span>
*!*
<span class="hljs-keyword">import</span> {sayHi <span class="hljs-keyword">as</span> hi, sayBye <span class="hljs-keyword">as</span> bye} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./say.js&#x27;</span>;
*/!*

hi(<span class="hljs-string">&#x27;John&#x27;</span>); <span class="hljs-comment">// Hello, John!</span>
bye(<span class="hljs-string">&#x27;John&#x27;</span>); <span class="hljs-comment">// Bye, John!</span></code></pre>
<h2 id="export-as">Export &quot;as&quot;</h2>
<p>导出也具有类似的语法。</p>
<p>我们将函数导出为 <code>hi</code> 和 <code>bye</code>：</p>
<pre><code class="language-js"><span class="hljs-comment">// 📁 say.js</span>
...
<span class="hljs-keyword">export</span> {sayHi <span class="hljs-keyword">as</span> hi, sayBye <span class="hljs-keyword">as</span> bye};</code></pre>
<p>现在 <code>hi</code> 和 <code>bye</code> 是在外面使用时的正式名称：</p>
<pre><code class="language-js">// 📁 main.js
import * as say from &#x27;./say.js&#x27;;

say.*!*hi*/!*(&#x27;John&#x27;); // Hello, John!
say.*!*bye*/!*(&#x27;John&#x27;); // Bye, John!</code></pre>
<h2 id="export-default">Export default</h2>
<p>在实际中，主要有两种模块。</p>
<ul>
<li>包含库或函数包的模块，像上面的 <code>say.js</code>。</li>
<li>声明单个实体的模块，例如模块 <code>user.js</code> 仅导出 <code>class User</code>。</li>
</ul>
<p>大部分情况下，开发者倾向于使用第二种方式，以便每个“东西”都存在于它自己的模块中。</p>
<p>当然，这需要大量文件，因为每个东西都需要自己的模块，但这根本不是问题。实际上，如果文件具有良好的命名，并且文件夹结构得当，那么代码导航（navigation）会变得更容易。</p>
<p>模块提供了一个特殊的默认导出 <code>export default</code> 语法，以使“一个模块只做一件事”的方式看起来更好。</p>
<p>将 <code>export default</code> 放在要导出的实体前：</p>
<pre><code class="language-js">// 📁 user.js
export *!*default*/!* class User { // 只需要添加 &quot;default&quot; 即可
  constructor(name) {
    this.name = name;
  }
}</code></pre>
<p>每个文件可能只有一个 <code>export default</code>：</p>
<p>……然后将其导入而不需要花括号：</p>
<pre><code class="language-js">// 📁 main.js
import *!*User*/!* from &#x27;./user.js&#x27;; // 不需要花括号 {User}，只需要写成 User 即可

new User(&#x27;John&#x27;);</code></pre>
<p>不用花括号的导入看起来很酷。刚开始使用模块时，一个常见的错误就是忘记写花括号。所以，请记住，<code>import</code> 命名的导出时需要花括号，而 <code>import</code> 默认的导出时不需要花括号。</p>
<table>
<thead>
<tr>
<th>命名的导出</th>
<th>默认的导出</th>
</tr>
</thead>
<tbody><tr>
<td><code>export class User {...}</code></td>
<td><code>export default class User {...}</code></td>
</tr>
<tr>
<td><code>import {User} from ...</code></td>
<td><code>import User from ...</code></td>
</tr>
</tbody></table>
<p>从技术上讲，我们可以在一个模块中同时有默认的导出和命名的导出，但是实际上人们通常不会混合使用它们。模块要么是命名的导出要么是默认的导出。</p>
<p>由于每个文件最多只能有一个默认的导出，因此导出的实体可能没有名称。</p>
<p>例如，下面这些都是完全有效的默认的导出：</p>
<pre><code class="language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> </span>{ <span class="hljs-comment">// 没有类名</span>
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> { ... }
}</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">user</span>) </span>{ <span class="hljs-comment">// 没有函数名</span>
  alert(<span class="hljs-string">`Hello, <span class="hljs-subst">${user}</span>!`</span>);
}</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// 导出单个值，而不使用变量</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> [<span class="hljs-string">&#x27;Jan&#x27;</span>, <span class="hljs-string">&#x27;Feb&#x27;</span>, <span class="hljs-string">&#x27;Mar&#x27;</span>,<span class="hljs-string">&#x27;Apr&#x27;</span>, <span class="hljs-string">&#x27;Aug&#x27;</span>, <span class="hljs-string">&#x27;Sep&#x27;</span>, <span class="hljs-string">&#x27;Oct&#x27;</span>, <span class="hljs-string">&#x27;Nov&#x27;</span>, <span class="hljs-string">&#x27;Dec&#x27;</span>];</code></pre>
<p>不指定名称是可以的，因为每个文件只有一个 <code>export default</code>，因此不带花括号的 <code>import</code> 知道要导入的内容是什么。</p>
<p>如果没有 <code>default</code>，这样的导出将会出错：</p>
<pre><code class="language-js"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> </span>{ <span class="hljs-comment">// Error!（非默认的导出需要名称）</span>
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {}
}</code></pre>
<h3 id="default-名称">&quot;default&quot; 名称</h3>
<p>在某些情况下，<code>default</code> 关键词被用于引用默认的导出。</p>
<p>例如，要将函数与其定义分开导出：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params">user</span>) </span>{
  alert(<span class="hljs-string">`Hello, <span class="hljs-subst">${user}</span>!`</span>);
}

<span class="hljs-comment">// 就像我们在函数之前添加了 &quot;export default&quot; 一样</span>
<span class="hljs-keyword">export</span> {sayHi <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span>};</code></pre>
<p>或者，另一种情况，假设模块 <code>user.js</code> 导出了一个主要的默认的导出和一些命名的导出（这种情况很少见，但确实会发生）：</p>
<pre><code class="language-js"><span class="hljs-comment">// 📁 user.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> {
    <span class="hljs-built_in">this</span>.name = name;
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params">user</span>) </span>{
  alert(<span class="hljs-string">`Hello, <span class="hljs-subst">${user}</span>!`</span>);
}</code></pre>
<p>这是导入默认的导出以及命名的导出的方法：</p>
<pre><code class="language-js">// 📁 main.js
import {*!*default as User*/!*, sayHi} from &#x27;./user.js&#x27;;

new User(&#x27;John&#x27;);</code></pre>
<p>如果我们将所有东西 <code>*</code> 作为一个对象导入，那么 <code>default</code> 属性正是默认的导出：</p>
<pre><code class="language-js"><span class="hljs-comment">// 📁 main.js</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> user <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./user.js&#x27;</span>;

<span class="hljs-keyword">let</span> User = user.default; <span class="hljs-comment">// 默认的导出</span>
<span class="hljs-keyword">new</span> User(<span class="hljs-string">&#x27;John&#x27;</span>);</code></pre>
<h3 id="我应该使用默认的导出吗？">我应该使用默认的导出吗？</h3>
<p>命名的导出是明确的。它们确切地命名了它们要导出的内容，因此我们能从它们获得这些信息，这是一件好事。</p>
<p>命名的导出会强制我们使用正确的名称进行导入：</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> {User} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./user.js&#x27;</span>;
<span class="hljs-comment">// 导入 {MyUser} 不起作用，导入名字必须为 {User}</span></code></pre>
<p>……对于默认的导出，我们总是在导入时选择名称：</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> User <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./user.js&#x27;</span>; <span class="hljs-comment">// 有效</span>
<span class="hljs-keyword">import</span> MyUser <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./user.js&#x27;</span>; <span class="hljs-comment">// 也有效</span>
<span class="hljs-comment">// 使用任何名称导入都没有问题</span></code></pre>
<p>因此，团队成员可能会使用不同的名称来导入相同的内容，这不好。</p>
<p>通常，为了避免这种情况并使代码保持一致，可以遵从这条规则，即导入的变量应与文件名相对应，例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> User <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./user.js&#x27;</span>;
<span class="hljs-keyword">import</span> LoginForm <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./loginForm.js&#x27;</span>;
<span class="hljs-keyword">import</span> func <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;/path/to/func.js&#x27;</span>;
...</code></pre>
<p>但是，一些团队仍然认为这是默认的导出的严重缺陷。因此，他们更倾向于始终使用命名的导出。即使只导出一个东西，也仍然使用命名的导出，而不是默认的导出。</p>
<p>这也使得重新导出（见下文）更容易。</p>
<h2 id="重新导出">重新导出</h2>
<p>“重新导出（Re-export）”语法 <code>export ... from ...</code> 允许导入内容，并立即将其导出（可能是用的是其他的名字），就像这样：</p>
<pre><code class="language-js"><span class="hljs-keyword">export</span> {sayHi} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./say.js&#x27;</span>; <span class="hljs-comment">// 重新导出 sayHi</span>

<span class="hljs-keyword">export</span> {<span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> User} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./user.js&#x27;</span>; <span class="hljs-comment">// 重新导出 default</span></code></pre>
<p>为什么要这样做？我们看一个实际开发中的用例。</p>
<p>想象一下，我们正在编写一个 &quot;package&quot;：一个包含大量模块的文件夹，其中一些功能是导出到外部的（像 NPM 这样的工具允许我们发布和分发这样的 package），并且其中一些模块仅仅是供其他 package 中的模块内部使用的 &quot;helpers&quot;。</p>
<p>文件结构可能是这样的：</p>
<pre><code>auth/
    index.js  
    user.js
    helpers.js
    tests/
        login.js
    providers/
        github.js
        facebook.js
        ...</code></pre>
<p>我们想通过单个入口，即“主文件” <code>auth/index.js</code> 来公开 package 的功能，进而可以像下面这样使用我们的 package：</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> {login, logout} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;auth/index.js&#x27;</span></code></pre>
<p>我们的想法是，使用我们 package 的开发者，不应该干预其内部结构，不应该搜索我们 package 的文件夹中的文件。我们只在 <code>auth/index.js</code> 中导出必须的内容，并保持其他内容“不可见”。</p>
<p>由于实际导出的功能分散在 package 中，所以我们可以将它们导入到 <code>auth/index.js</code>，然后再从中导出它们：</p>
<pre><code class="language-js"><span class="hljs-comment">// 📁 auth/index.js</span>

<span class="hljs-comment">// 导入 login/logout 然后立即导出它们</span>
<span class="hljs-keyword">import</span> {login, logout} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./helpers.js&#x27;</span>;
<span class="hljs-keyword">export</span> {login, logout};

<span class="hljs-comment">// 将默认导出导入为 User，然后导出它</span>
<span class="hljs-keyword">import</span> User <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./user.js&#x27;</span>;
<span class="hljs-keyword">export</span> {User};
...</code></pre>
<p>现在使用我们 package 的人可以 <code>import {login} from &quot;auth/index.js&quot;</code>。</p>
<p>语法 <code>export ... from ...</code> 只是下面这种导入-导出的简写：</p>
<pre><code class="language-js"><span class="hljs-comment">// 📁 auth/index.js</span>
<span class="hljs-comment">// 导入 login/logout 然后立即导出它们</span>
<span class="hljs-keyword">export</span> {login, logout} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./helpers.js&#x27;</span>;

<span class="hljs-comment">// 将默认导出导入为 User，然后导出它</span>
<span class="hljs-keyword">export</span> {<span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> User} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./user.js&#x27;</span>;
...</code></pre>
<h3 id="重新导出默认导出">重新导出默认导出</h3>
<p>重新导出时，默认导出需要单独处理。</p>
<p>假设我们有 <code>user.js</code>，我们想从中重新导出类 <code>User</code>：</p>
<pre><code class="language-js"><span class="hljs-comment">// 📁 user.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
  <span class="hljs-comment">// ...</span>
}</code></pre>
<ol>
<li><p><code>export User from &#39;./user.js&#39;</code> 无效。什么出了问题？这实际上是一个语法错误。</p>
<p> 要重新导出默认导出，我们必须明确写出 <code>export {default as User}</code>，就像上面的例子中那样。</p>
</li>
<li><p><code>export * from &#39;./user.js&#39;</code> 重新导出只导出了命名的导出，但是忽略了默认的导出。</p>
<p> 如果我们想将命名的导出和默认的导出都重新导出，那么需要两条语句：</p>
<pre><code class="language-js"><span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./user.js&#x27;</span>; <span class="hljs-comment">// 重新导出命名的导出</span>
<span class="hljs-keyword">export</span> {<span class="hljs-keyword">default</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./user.js&#x27;</span>; <span class="hljs-comment">// 重新导出默认的导出</span></code></pre>
</li>
</ol>
<p>重新导出默认的导出的这种奇怪现象是某些开发者不喜欢它们的原因之一。</p>
<h2 id="总结">总结</h2>
<p>这是我们在本节和前面章节中介绍的所有 <code>export</code> 类型：</p>
<p>你可以阅读并回忆它们的含义来进行自查：</p>
<ul>
<li>在声明一个 class/function/.. 之前：<ul>
<li><code>export [default] class/function/variable ...</code></li>
</ul>
</li>
<li>独立的导出：<ul>
<li><code>export {x [as y], ...}</code>.</li>
</ul>
</li>
<li>重新导出：<ul>
<li><code>export {x [as y], ...} from &quot;module&quot;</code></li>
<li><code>export * from &quot;module&quot;</code>（不会重新导出默认的导出）。</li>
<li><code>export {default [as y]} from &quot;module&quot;</code>（重新导出默认的导出）。</li>
</ul>
</li>
</ul>
<p>导入：</p>
<ul>
<li>模块中命名的导出：<ul>
<li><code>import {x [as y], ...} from &quot;module&quot;</code></li>
</ul>
</li>
<li>默认的导出：<ul>
<li><code>import x from &quot;module&quot;</code></li>
<li><code>import {default as x} from &quot;module&quot;</code></li>
</ul>
</li>
<li>所有：<ul>
<li><code>import * as obj from &quot;module&quot;</code></li>
</ul>
</li>
<li>导入模块（它的代码，并运行），但不要将其赋值给变量：<ul>
<li><code>import &quot;module&quot;</code></li>
</ul>
</li>
</ul>
<p>我们把 <code>import/export</code> 语句放在脚本的顶部或底部，都没关系。</p>
<p>因此，从技术上讲，下面这样的代码没有问题：</p>
<pre><code class="language-js">sayHi();

<span class="hljs-comment">// ...</span>

<span class="hljs-keyword">import</span> {sayHi} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./say.js&#x27;</span>; <span class="hljs-comment">// 在文件底部导入</span></code></pre>
<p>在实际开发中，导入通常位于文件的开头，但是这只是为了更加方便。</p>
<p><strong>请注意在 <code>{...}</code> 中的 import/export 语句无效。</strong></p>
<p>像这样的有条件的导入是无效的：</p>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (something) {
  <span class="hljs-keyword">import</span> {sayHi} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./say.js&quot;</span>; <span class="hljs-comment">// Error: import must be at top level</span>
}</code></pre>
<p>……但是，如果我们真的需要根据某些条件来进行导入呢？或者在某些合适的时间？例如，根据请求（request）加载模块，什么时候才是真正需要呢？</p>
<p>我们将在下一章节中学习动态导入。</p>

      </fieldset>
      
      <fieldset id='_lvhtP5'>
      <legend>article</legend>
      <h1 id="动态导入">动态导入</h1>
<p>我们在前面章节中介绍的导出和导入语句称为“静态”导入。语法非常简单且严格。</p>
<p>首先，我们不能动态生成 <code>import</code> 的任何参数。</p>
<p>模块路径必须是原始类型字符串，不能是函数调用，下面这样的 <code>import</code> 行不通：</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> ... <span class="hljs-keyword">from</span> *!*getModuleName()*<span class="hljs-regexp">/!*; /</span><span class="hljs-regexp">/ Error, only from &quot;string&quot; is allowed</span></code></pre>
<p>其次，我们无法根据条件或者在运行时导入：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">...</span>)</span> {
  <span class="hljs-keyword">import</span> ...; <span class="hljs-comment">// Error, not allowed!</span>
}

{
  <span class="hljs-keyword">import</span> ...; <span class="hljs-comment">// Error, we can&#x27;t put import in any block</span>
}</code></pre>
<p>这是因为 <code>import</code>/<code>export</code> 旨在提供代码结构的主干。这是非常好的事儿，因为这样便于分析代码结构，可以收集模块，可以使用特殊工具将收集的模块打包到一个文件中，可以删除未使用的导出（&quot;tree-shaken&quot;）。这些只有在 <code>import</code>/<code>export</code> 结构简单且固定的情况下才能够实现。</p>
<p>但是，我们如何才能动态地按需导入模块呢？</p>
<h2 id="import-表达式">import() 表达式</h2>
<p><code>import(module)</code> 表达式加载模块并返回一个 promise，该 promise resolve 为一个包含其所有导出的模块对象。我们可以在代码中的任意位置调用这个表达式。</p>
<p>我们可以在代码中的任意位置动态地使用它。例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> modulePath = prompt(<span class="hljs-string">&quot;Which module to load?&quot;</span>);

<span class="hljs-keyword">import</span>(modulePath)
  .then(<span class="hljs-function"><span class="hljs-params">obj</span> =&gt;</span> &lt;module object&gt;)
  .catch(err =&gt; &lt;loading error, e.g. if no such module&gt;)</code></pre>
<p>或者，如果在异步函数中，我们可以使用 <code>let module = await import(modulePath)</code>。</p>
<p>例如，如果我们有以下模块 <code>say.js</code>：</p>
<pre><code class="language-js"><span class="hljs-comment">// 📁 say.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hi</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-string">`Hello`</span>);
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bye</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-string">`Bye`</span>);
}</code></pre>
<p>……那么，可以想像下面这样进行动态导入：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> {hi, bye} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./say.js&#x27;</span>);

hi();
bye();</code></pre>
<p>或者，如果 <code>say.js</code> 有默认的导出：</p>
<pre><code class="language-js"><span class="hljs-comment">// 📁 say.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-string">&quot;Module loaded (export default)!&quot;</span>);
}</code></pre>
<p>……那么，为了访问它，我们可以使用模块对象的 <code>default</code> 属性：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./say.js&#x27;</span>);
<span class="hljs-keyword">let</span> say = obj.default;
<span class="hljs-comment">// or, in one line: let {default: say} = await import(&#x27;./say.js&#x27;);</span>

say();</code></pre>
<p>这是一个完整的示例：</p>
<p>[codetabs src=&quot;say&quot; current=&quot;index.html&quot;]</p>
<pre><code class="language-smart">动态导入在常规脚本中工作时，它们不需要 `script type=&quot;module&quot;`.</code></pre>
<pre><code class="language-smart">尽管 `import()` 看起来像一个函数调用，但它只是一种特殊语法，只是恰好使用了括号（类似于 `super()`）。

因此，我们不能将 `import` 复制到一个变量中，或者对其使用 `call/apply`。因为它不是一个函数。</code></pre>

      </fieldset>
      
      <fieldset id='_8wk2G5'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrap</span>(<span class="hljs-params">target</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, {
    <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">target, prop, receiver</span>)</span> {
      <span class="hljs-keyword">if</span> (prop <span class="hljs-keyword">in</span> target) {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, prop, receiver);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ReferenceError</span>(<span class="hljs-string">`Property doesn&#x27;t exist: &quot;<span class="hljs-subst">${prop}</span>&quot;`</span>)
      }
    }
  });
}

user = wrap(user);

alert(user.name); <span class="hljs-comment">// John</span>
alert(user.age); <span class="hljs-comment">// ReferenceError: Property doesn&#x27;t exist &quot;age&quot;</span></code></pre>

      </fieldset>
      
      <fieldset id='_gbSXtd'>
      <legend>task</legend>
      <h1 id="读取不存在的属性时出错">读取不存在的属性时出错</h1>
<p>通常，尝试读取不存在的属性会返回 <code>undefined</code>。</p>
<p>创建一个代理，在尝试读取不存在的属性时，该代理抛出一个错误。</p>
<p>这可以帮助及早发现编程错误。</p>
<p>编写一个函数 <code>wrap(target)</code>，该函数接受一个 <code>target</code> 对象，并返回添加此方面功能的代理（proxy）。</p>
<p>其工作方式应如下：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrap</span>(<span class="hljs-params">target</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, {
*!*
      <span class="hljs-comment">/* 你的代码 */</span>
*/!*
  });
}

user = wrap(user);

alert(user.name); <span class="hljs-comment">// John</span>
*!*
alert(user.age); <span class="hljs-comment">// ReferenceError: Property doesn&#x27;t exist &quot;age&quot;</span>
*/!*</code></pre>

      </fieldset>
      
      <fieldset id='_L7MXCw'>
      <legend>solution</legend>
      <pre><code class="language-js"><span class="hljs-keyword">let</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];

array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(array, {
  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">target, prop, receiver</span>)</span> {
    <span class="hljs-keyword">if</span> (prop &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// 即使我们像 arr[1] 这样访问它</span>
      <span class="hljs-comment">// prop 是一个字符串，所以我们需要将其转换成数字</span>
      prop = +prop + target.length;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, prop, receiver);
  }
});


alert(array[-<span class="hljs-number">1</span>]); <span class="hljs-comment">// 3</span>
alert(array[-<span class="hljs-number">2</span>]); <span class="hljs-comment">// 2</span></code></pre>

      </fieldset>
      
      <fieldset id='_Y4nQiH'>
      <legend>task</legend>
      <h1 id="访问-array-1">访问 array[-1]</h1>
<p>在某些编程语言中，我们可以使用从尾端算起的负值索引访问数组元素。</p>
<p>像这样：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];

array[-<span class="hljs-number">1</span>]; <span class="hljs-comment">// 3，最后一个元素</span>
array[-<span class="hljs-number">2</span>]; <span class="hljs-comment">// 2，从尾端开始向前移动一步</span>
array[-<span class="hljs-number">3</span>]; <span class="hljs-comment">// 1，从尾端开始向前移动两步</span></code></pre>
<p>换句话说，<code>array[-N]</code> 与 <code>array[array.length - N]</code> 相同。</p>
<p>创建一个 proxy 来实现该行为。</p>
<p>其工作方式应如下：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];

array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(array, {
  <span class="hljs-comment">/* 你的代码 */</span>
});

alert( array[-<span class="hljs-number">1</span>] ); <span class="hljs-comment">// 3</span>
alert( array[-<span class="hljs-number">2</span>] ); <span class="hljs-comment">// 2</span>

<span class="hljs-comment">// 其他数组功能应保持“原样”</span></code></pre>

      </fieldset>
      
      <fieldset id='_Vw0GhL'>
      <legend>solution</legend>
      <p>该解决方案包括两部分：</p>
<ol>
<li>无论 <code>.observe(handler)</code> 何时被调用，我们都需要在某个地方记住 handler，以便以后可以调用它。我们可以使用 Symbol 作为属性键，将 handler 直接存储在对象中。</li>
<li>我们需要一个带有 <code>set</code> 陷阱的 proxy 来在发生任何更改时调用 handler。 </li>
</ol>
<pre><code class="language-js"><span class="hljs-keyword">let</span> handlers = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;handlers&#x27;</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeObservable</span>(<span class="hljs-params">target</span>) </span>{
  <span class="hljs-comment">// 1. 初始化 handler 存储</span>
  target[handlers] = [];

  <span class="hljs-comment">// 将 handler 函数存储到数组中，以便于之后调用</span>
  target.observe = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">handler</span>) </span>{
    <span class="hljs-built_in">this</span>[handlers].push(handler);
  };

  <span class="hljs-comment">// 2. 创建一个 proxy 以处理更改</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, {
    <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">target, property, value, receiver</span>)</span> {
      <span class="hljs-keyword">let</span> success = <span class="hljs-built_in">Reflect</span>.set(...arguments); <span class="hljs-comment">// 将操作转发给对象</span>
      <span class="hljs-keyword">if</span> (success) { <span class="hljs-comment">// 如果在设置属性时没有出现 error</span>
        <span class="hljs-comment">// 调用所有 handler</span>
        target[handlers].forEach(<span class="hljs-function"><span class="hljs-params">handler</span> =&gt;</span> handler(property, value));
      }
      <span class="hljs-keyword">return</span> success;
    }
  });
}

<span class="hljs-keyword">let</span> user = {};

user = makeObservable(user);

user.observe(<span class="hljs-function">(<span class="hljs-params">key, value</span>) =&gt;</span> {
  alert(<span class="hljs-string">`SET <span class="hljs-subst">${key}</span>=<span class="hljs-subst">${value}</span>`</span>);
});

user.name = <span class="hljs-string">&quot;John&quot;</span>;</code></pre>

      </fieldset>
      
      <fieldset id='_6eIY1s'>
      <legend>task</legend>
      <h1 id="可观察的（observable）">可观察的（Observable）</h1>
<p>创建一个函数 <code>makeObservable(target)</code>，该函数通过返回一个代理“使得对象可观察”。</p>
<p>其工作方式如下：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeObservable</span>(<span class="hljs-params">target</span>) </span>{
  <span class="hljs-comment">/* 你的代码 */</span>
}

<span class="hljs-keyword">let</span> user = {};
user = makeObservable(user);

user.observe(<span class="hljs-function">(<span class="hljs-params">key, value</span>) =&gt;</span> {
  alert(<span class="hljs-string">`SET <span class="hljs-subst">${key}</span>=<span class="hljs-subst">${value}</span>`</span>);
});

user.name = <span class="hljs-string">&quot;John&quot;</span>; <span class="hljs-comment">// alerts: SET name=John</span></code></pre>
<p>换句话说，<code>makeObservable</code> 返回的对象就像原始对象一样，但是具有 <code>observe(handler)</code> 方法，该方法可以将 <code>handler</code> 函数设置为在任何属性被更改时，都会被调用的函数。</p>
<p>每当有属性被更改时，都会使用属性的名称和属性值调用 <code>handler(key, value)</code> 函数。</p>
<p>P.S. 在本任务中，你可以只关注属性写入。其他的操作可以通过类似的方式实现。</p>

      </fieldset>
      
      <fieldset id='_sMOOAi'>
      <legend>article</legend>
      <h1 id="proxy-和-reflect">Proxy 和 Reflect</h1>
<p>一个 <code>Proxy</code> 对象包装另一个对象并拦截诸如读取/写入属性和其他操作，可以选择自行处理它们，或者透明地允许该对象处理它们。</p>
<p>Proxy 被用于了许多库和某些浏览器框架。在本文中，我们将看到许多实际应用。</p>
<h2 id="proxy">Proxy</h2>
<p>语法：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler)</code></pre>
<ul>
<li><code>target</code> —— 是要包装的对象，可以是任何东西，包括函数。</li>
<li><code>handler</code> —— 代理配置：带有“捕捉器”（&quot;traps&quot;，即拦截操作的方法）的对象。比如 <code>get</code> 捕捉器用于读取 <code>target</code> 的属性，<code>set</code> 捕捉器用于写入 <code>target</code> 的属性，等等。</li>
</ul>
<p>对 <code>proxy</code> 进行操作，如果在 <code>handler</code> 中存在相应的捕捉器，则它将运行，并且 Proxy 有机会对其进行处理，否则将直接对 target 进行处理。</p>
<p>首先，让我们创建一个没有任何捕捉器的代理（Proxy）：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> target = {};
<span class="hljs-keyword">let</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, {}); <span class="hljs-comment">// 空的 handler 对象</span>

proxy.test = <span class="hljs-number">5</span>; <span class="hljs-comment">// 写入 proxy 对象 (1)</span>
alert(target.test); <span class="hljs-comment">// 5，test 属性出现在了 target 中！</span>

alert(proxy.test); <span class="hljs-comment">// 5，我们也可以从 proxy 对象读取它 (2)</span>

<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> proxy) alert(key); <span class="hljs-comment">// test，迭代也正常工作 (3)</span></code></pre>
<p>由于没有捕捉器，所有对 <code>proxy</code> 的操作都直接转发给了 <code>target</code>。</p>
<ol>
<li>写入操作 <code>proxy.test=</code> 会将值写入 <code>target</code>。</li>
<li>读取操作 <code>proxy.test</code> 会从 <code>target</code> 返回对应的值。</li>
<li>迭代 <code>proxy</code> 会从 <code>target</code> 返回对应的值。</li>
</ol>
<p>我们可以看到，没有任何捕捉器，<code>proxy</code> 是一个 <code>target</code> 的透明包装器（wrapper）。</p>
<p><img src="proxy.svg" alt=""></p>
<p><code>Proxy</code> 是一种特殊的“奇异对象（exotic object）”。它没有自己的属性。如果 <code>handler</code> 为空，则透明地将操作转发给 <code>target</code>。</p>
<p>要激活更多功能，让我们添加捕捉器。</p>
<p>我们可以用它们拦截什么？</p>
<p>对于对象的大多数操作，JavaScript 规范中有一个所谓的“内部方法”，它描述了最底层的工作方式。例如 <code>[[Get]]</code>，用于读取属性的内部方法，<code>[[Set]]</code>，用于写入属性的内部方法，等等。这些方法仅在规范中使用，我们不能直接通过方法名调用它们。</p>
<p>Proxy 捕捉器会拦截这些方法的调用。它们在 <a href="https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots">proxy 规范</a> 和下表中被列出。</p>
<p>对于每个内部方法，此表中都有一个捕捉器：可用于添加到 <code>new Proxy</code> 的 <code>handler</code> 参数中以拦截操作的方法名称：</p>
<table>
<thead>
<tr>
<th>内部方法</th>
<th>Handler 方法</th>
<th>何时触发</th>
</tr>
</thead>
<tbody><tr>
<td><code>[[Get]]</code></td>
<td><code>get</code></td>
<td>读取属性</td>
</tr>
<tr>
<td><code>[[Set]]</code></td>
<td><code>set</code></td>
<td>写入属性</td>
</tr>
<tr>
<td><code>[[HasProperty]]</code></td>
<td><code>has</code></td>
<td><code>in</code> 操作符</td>
</tr>
<tr>
<td><code>[[Delete]]</code></td>
<td><code>deleteProperty</code></td>
<td><code>delete</code> 操作符</td>
</tr>
<tr>
<td><code>[[Call]]</code></td>
<td><code>apply</code></td>
<td>函数调用</td>
</tr>
<tr>
<td><code>[[Construct]]</code></td>
<td><code>construct</code></td>
<td><code>new</code> 操作符</td>
</tr>
<tr>
<td><code>[[GetPrototypeOf]]</code></td>
<td><code>getPrototypeOf</code></td>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf">Object.getPrototypeOf</a></td>
</tr>
<tr>
<td><code>[[SetPrototypeOf]]</code></td>
<td><code>setPrototypeOf</code></td>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf">Object.setPrototypeOf</a></td>
</tr>
<tr>
<td><code>[[IsExtensible]]</code></td>
<td><code>isExtensible</code></td>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible">Object.isExtensible</a></td>
</tr>
<tr>
<td><code>[[PreventExtensions]]</code></td>
<td><code>preventExtensions</code></td>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions">Object.preventExtensions</a></td>
</tr>
<tr>
<td><code>[[DefineOwnProperty]]</code></td>
<td><code>defineProperty</code></td>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties">Object.defineProperties</a></td>
</tr>
<tr>
<td><code>[[GetOwnProperty]]</code></td>
<td><code>getOwnPropertyDescriptor</code></td>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor">Object.getOwnPropertyDescriptor</a>, <code>for..in</code>, <code>Object.keys/values/entries</code></td>
</tr>
<tr>
<td><code>[[OwnPropertyKeys]]</code></td>
<td><code>ownKeys</code></td>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames">Object.getOwnPropertyNames</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols">Object.getOwnPropertySymbols</a>, <code>for..in</code>, <code>Object/keys/values/entries</code></td>
</tr>
</tbody></table>
<pre><code class="language-warn">JavaScript 强制执行某些不变量 — 内部方法和捕捉器必须满足的条件。

其中大多数用于返回值：
- `[[Set]]` 如果值已成功写入，则必须返回 `true`，否则返回 `false`。
- `[[Delete]]` 如果已成功删除该值，则必须返回 `true`，否则返回 `false`。
- ……依此类推，我们将在下面的示例中看到更多内容。

还有其他一些不变量，例如：
- 应用于代理（proxy）对象的 `[[GetPrototypeOf]]`，必须返回与应用于被代理对象的 `[[GetPrototypeOf]]` 相同的值。换句话说，读取代理对象的原型必须始终返回被代理对象的原型。

捕捉器可以拦截这些操作，但是必须遵循下面这些规则。

不变量确保语言功能的正确和一致的行为。完整的不变量列表在 [规范](https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots) 中。如果你不做奇怪的事情，你可能就不会违反它们。</code></pre>
<p>让我们来看看它们是如何在实际示例中工作的。</p>
<h2 id="带有-get-捕捉器的默认值">带有 &quot;get&quot; 捕捉器的默认值</h2>
<p>最常见的捕捉器是用于读取/写入的属性。</p>
<p>要拦截读取操作，<code>handler</code> 应该有 <code>get(target, property, receiver)</code> 方法。</p>
<p>读取属性时触发该方法，参数如下：</p>
<ul>
<li><code>target</code> —— 是目标对象，该对象被作为第一个参数传递给 <code>new Proxy</code>，</li>
<li><code>property</code> —— 目标属性名，</li>
<li><code>receiver</code> —— 如果目标属性是一个 getter 访问器属性，则 <code>receiver</code> 就是本次读取属性所在的 <code>this</code> 对象。通常，这就是 <code>proxy</code> 对象本身（或者，如果我们从 proxy 继承，则是从该 proxy 继承的对象）。现在我们不需要此参数，因此稍后我们将对其进行详细介绍。</li>
</ul>
<p>让我们用 <code>get</code> 来实现一个对象的默认值。</p>
<p>我们将创建一个对不存在的数组项返回 <code>0</code> 的数组。</p>
<p>通常，当人们尝试获取不存在的数组项时，他们会得到 <code>undefined</code>，但是我们在这将常规数组包装到代理（proxy）中，以捕获读取操作，并在没有要读取的属性的时返回 <code>0</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> numbers = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];

numbers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(numbers, {
  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">target, prop</span>)</span> {
    <span class="hljs-keyword">if</span> (prop <span class="hljs-keyword">in</span> target) {
      <span class="hljs-keyword">return</span> target[prop];
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 默认值</span>
    }
  }
});

*!*
alert( numbers[<span class="hljs-number">1</span>] ); <span class="hljs-comment">// 1</span>
alert( numbers[<span class="hljs-number">123</span>] ); <span class="hljs-comment">// 0（没有这个数组项）</span>
*/!*</code></pre>
<p>正如我们所看到的，使用 <code>get</code> 捕捉器很容易实现。</p>
<p>我们可以用 <code>Proxy</code> 来实现“默认”值的任何逻辑。</p>
<p>想象一下，我们有一本词典，上面有短语及其翻译：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> dictionary = {
  <span class="hljs-string">&#x27;Hello&#x27;</span>: <span class="hljs-string">&#x27;Hola&#x27;</span>,
  <span class="hljs-string">&#x27;Bye&#x27;</span>: <span class="hljs-string">&#x27;Adiós&#x27;</span>
};

alert( dictionary[<span class="hljs-string">&#x27;Hello&#x27;</span>] ); <span class="hljs-comment">// Hola</span>
alert( dictionary[<span class="hljs-string">&#x27;Welcome&#x27;</span>] ); <span class="hljs-comment">// undefined</span></code></pre>
<p>现在，如果没有我们要读取的短语，那么从 <code>dictionary</code> 读取它将返回 <code>undefined</code>。但实际上，返回一个未翻译的短语通常比 <code>undefined</code> 要好。因此，让我们在这种情况下返回一个未翻译的短语来替代 <code>undefined</code>。</p>
<p>为此，我们将把 <code>dictionary</code> 包装进一个拦截读取操作的代理：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> dictionary = {
  <span class="hljs-string">&#x27;Hello&#x27;</span>: <span class="hljs-string">&#x27;Hola&#x27;</span>,
  <span class="hljs-string">&#x27;Bye&#x27;</span>: <span class="hljs-string">&#x27;Adiós&#x27;</span>
};

dictionary = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(dictionary, {
*!*
  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">target, phrase</span>)</span> { <span class="hljs-comment">// 拦截读取属性操作</span>
*/!*
    <span class="hljs-keyword">if</span> (phrase <span class="hljs-keyword">in</span> target) { <span class="hljs-comment">//如果词典中有该短语</span>
      <span class="hljs-keyword">return</span> target[phrase]; <span class="hljs-comment">// 返回其翻译</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 否则返回未翻译的短语</span>
      <span class="hljs-keyword">return</span> phrase;
    }
  }
});

<span class="hljs-comment">// 在词典中查找任意短语！</span>
<span class="hljs-comment">// 最坏的情况也只是它们没有被翻译。</span>
alert( dictionary[<span class="hljs-string">&#x27;Hello&#x27;</span>] ); <span class="hljs-comment">// Hola</span>
*!*
alert( dictionary[<span class="hljs-string">&#x27;Welcome to Proxy&#x27;</span>]); <span class="hljs-comment">// Welcome to Proxy（没有被翻译）</span>
*/!*</code></pre>
<pre><code class="language-smart">请注意代理如何覆盖变量：

```js
dictionary = new Proxy(dictionary, ...);
```

代理应该在所有地方都完全替代目标对象。目标对象被代理后，任何人都不应该再引用目标对象。否则很容易搞砸。</code></pre>
<h2 id="使用-set-捕捉器进行验证">使用 &quot;set&quot; 捕捉器进行验证</h2>
<p>假设我们想要一个专门用于数字的数组。如果添加了其他类型的值，则应该抛出一个错误。</p>
<p>当写入属性时 <code>set</code> 捕捉器被触发。</p>
<p><code>set(target, property, value, receiver)</code>：</p>
<ul>
<li><code>target</code> —— 是目标对象，该对象被作为第一个参数传递给 <code>new Proxy</code>，</li>
<li><code>property</code> —— 目标属性名称，</li>
<li><code>value</code> —— 目标属性的值，</li>
<li><code>receiver</code> —— 与 <code>get</code> 捕捉器类似，仅与 setter 访问器属性相关。</li>
</ul>
<p>如果写入操作（setting）成功，<code>set</code> 捕捉器应该返回 <code>true</code>，否则返回 <code>false</code>（触发 <code>TypeError</code>）。</p>
<p>让我们用它来验证新值：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> numbers = [];

numbers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(numbers, { <span class="hljs-comment">// (*)</span>
*!*
  <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">target, prop, val</span>)</span> { <span class="hljs-comment">// 拦截写入属性操作</span>
*/!*
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> val == <span class="hljs-string">&#x27;number&#x27;</span>) {
      target[prop] = val;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
  }
});

numbers.push(<span class="hljs-number">1</span>); <span class="hljs-comment">// 添加成功</span>
numbers.push(<span class="hljs-number">2</span>); <span class="hljs-comment">// 添加成功</span>
alert(<span class="hljs-string">&quot;Length is: &quot;</span> + numbers.length); <span class="hljs-comment">// 2</span>

*!*
numbers.push(<span class="hljs-string">&quot;test&quot;</span>); <span class="hljs-comment">// TypeError（proxy 的 &#x27;set&#x27; 返回 false）</span>
*/!*

alert(<span class="hljs-string">&quot;This line is never reached (error in the line above)&quot;</span>);</code></pre>
<p>请注意：数组的内建方法依然有效！值被使用 <code>push</code> 方法添加到数组。当值被添加到数组后，数组的 <code>length</code> 属性会自动增加。我们的代理对象 proxy 不会破坏任何东西。</p>
<p>我们不必重写诸如 <code>push</code> 和 <code>unshift</code> 等添加元素的数组方法，就可以在其中添加检查，因为在内部它们使用代理所拦截的 <code>[[Set]]</code> 操作。</p>
<p>因此，代码简洁明了。</p>
<p>```warn header=&quot;别忘了返回 <code>true</code>&quot;
如上所述，要保持不变量。</p>
<p>对于 <code>set</code> 操作，它必须在成功写入时返回 <code>true</code>。</p>
<p>如果我们忘记这样做，或返回任何假（falsy）值，则该操作将触发 <code>TypeError</code>。</p>
<pre><code>
## 使用 &quot;ownKeys&quot; 和 &quot;getOwnPropertyDescriptor&quot; 进行迭代

`Object.keys`，`for..in` 循环和大多数其他遍历对象属性的方法都使用内部方法 `[[OwnPropertyKeys]]`（由 `ownKeys` 捕捉器拦截) 来获取属性列表。

这些方法在细节上有所不同：
- `Object.getOwnPropertyNames(obj)` 返回非 Symbol 键。
- `Object.getOwnPropertySymbols(obj)` 返回 Symbol 键。
- `Object.keys/values()` 返回带有 `enumerable` 标志的非 Symbol 键/值（属性标志在 &lt;info:property-descriptors&gt; 一章有详细讲解)。
- `for..in` 循环遍历所有带有 `enumerable` 标志的非 Symbol 键，以及原型对象的键。

……但是所有这些都从该列表开始。

在下面这个示例中，我们使用 `ownKeys` 捕捉器拦截 `for..in` 对 `user` 的遍历，并使用 `Object.keys` 和 `Object.values` 来跳过以下划线 `_` 开头的属性：

```js run
let user = {
  name: &quot;John&quot;,
  age: 30,
  _password: &quot;***&quot;
};

user = new Proxy(user, {
*!*
  ownKeys(target) {
*/!*
    return Object.keys(target).filter(key =&gt; !key.startsWith(&#x27;_&#x27;));
  }
});

// &quot;ownKeys&quot; 过滤掉了 _password
for(let key in user) alert(key); // name，然后是 age

// 对这些方法的效果相同：
alert( Object.keys(user) ); // name,age
alert( Object.values(user) ); // John,30</code></pre>
<p>到目前为止，它仍然有效。</p>
<p>尽管如此，但如果我们返回对象中不存在的键，<code>Object.keys</code> 并不会列出这些键：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = { };

user = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(user, {
*!*
  <span class="hljs-function"><span class="hljs-title">ownKeys</span>(<span class="hljs-params">target</span>)</span> {
*/!*
    <span class="hljs-keyword">return</span> [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];
  }
});

alert( <span class="hljs-built_in">Object</span>.keys(user) ); <span class="hljs-comment">// &lt;empty&gt;</span></code></pre>
<p>为什么？原因很简单：<code>Object.keys</code> 仅返回带有 <code>enumerable</code> 标志的属性。为了检查它，该方法会对每个属性调用内部方法 <code>[[GetOwnProperty]]</code> 来获取 <a href="info:property-descriptors">它的描述符（descriptor）</a>。在这里，由于没有属性，其描述符为空，没有 <code>enumerable</code> 标志，因此它被略过。</p>
<p>为了让 <code>Object.keys</code> 返回一个属性，我们要么需要它要么存在于带有 <code>enumerable</code> 标志的对象，要么我们可以拦截对 <code>[[GetOwnProperty]]</code> 的调用（捕捉器 <code>getOwnPropertyDescriptor</code> 可以做到这一点)，并返回带有 <code>enumerable: true</code> 的描述符。</p>
<p>这是关于此的一个例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = { };

user = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(user, {
  <span class="hljs-function"><span class="hljs-title">ownKeys</span>(<span class="hljs-params">target</span>)</span> { <span class="hljs-comment">// 一旦要获取属性列表就会被调用</span>
    <span class="hljs-keyword">return</span> [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];
  },

  <span class="hljs-function"><span class="hljs-title">getOwnPropertyDescriptor</span>(<span class="hljs-params">target, prop</span>)</span> { <span class="hljs-comment">// 被每个属性调用</span>
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>
      <span class="hljs-comment">/* ...其他标志，可能是 &quot;value:...&quot; */</span>
    };
  }

});

alert( <span class="hljs-built_in">Object</span>.keys(user) ); <span class="hljs-comment">// a, b, c</span></code></pre>
<p>让我们再次注意：如果该属性在对象中不存在，那么我们只需要拦截 <code>[[GetOwnProperty]]</code>。</p>
<h2 id="具有-deleteproperty-和其他捕捉器的受保护属性">具有 &quot;deleteProperty&quot; 和其他捕捉器的受保护属性</h2>
<p>有一个普遍的约定，即以下划线 <code>_</code> 开头的属性和方法是内部的。不应从对象外部访问它们。</p>
<p>从技术上讲，我们也是能访问到这样的属性的：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">_password</span>: <span class="hljs-string">&quot;secret&quot;</span>
};

alert(user._password); <span class="hljs-comment">// secret</span></code></pre>
<p>让我们使用代理来防止对以 <code>_</code> 开头的属性的任何访问。</p>
<p>我们将需要以下捕捉器：</p>
<ul>
<li><code>get</code> 读取此类属性时抛出错误，</li>
<li><code>set</code> 写入属性时抛出错误，</li>
<li><code>deleteProperty</code> 删除属性时抛出错误，</li>
<li><code>ownKeys</code> 在使用 <code>for..in</code> 和像 <code>Object.keys</code> 这样的的方法时排除以 <code>_</code> 开头的属性。</li>
</ul>
<p>代码如下：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">_password</span>: <span class="hljs-string">&quot;***&quot;</span>
};

user = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(user, {
*!*
  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">target, prop</span>)</span> {
*/!*
    <span class="hljs-keyword">if</span> (prop.startsWith(<span class="hljs-string">&#x27;_&#x27;</span>)) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Access denied&quot;</span>);
    }
    <span class="hljs-keyword">let</span> value = target[prop];
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;function&#x27;</span>) ? value.bind(target) : value; <span class="hljs-comment">// (*)</span>
  },
*!*
  <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">target, prop, val</span>)</span> { <span class="hljs-comment">// 拦截属性写入</span>
*/!*
    <span class="hljs-keyword">if</span> (prop.startsWith(<span class="hljs-string">&#x27;_&#x27;</span>)) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Access denied&quot;</span>);
    } <span class="hljs-keyword">else</span> {
      target[prop] = val;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
  },
*!*
  <span class="hljs-function"><span class="hljs-title">deleteProperty</span>(<span class="hljs-params">target, prop</span>)</span> { <span class="hljs-comment">// 拦截属性删除</span>
*/!*
    <span class="hljs-keyword">if</span> (prop.startsWith(<span class="hljs-string">&#x27;_&#x27;</span>)) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Access denied&quot;</span>);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">delete</span> target[prop];
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
  },
*!*
  <span class="hljs-function"><span class="hljs-title">ownKeys</span>(<span class="hljs-params">target</span>)</span> { <span class="hljs-comment">// 拦截读取属性列表</span>
*/!*
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(target).filter(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> !key.startsWith(<span class="hljs-string">&#x27;_&#x27;</span>));
  }
});

<span class="hljs-comment">// &quot;get&quot; 不允许读取 _password</span>
<span class="hljs-keyword">try</span> {
  alert(user._password); <span class="hljs-comment">// Error: Access denied</span>
} <span class="hljs-function"><span class="hljs-title">catch</span>(<span class="hljs-params">e</span>)</span> { alert(e.message); }

<span class="hljs-comment">// &quot;set&quot; 不允许写入 _password</span>
<span class="hljs-keyword">try</span> {
  user._password = <span class="hljs-string">&quot;test&quot;</span>; <span class="hljs-comment">// Error: Access denied</span>
} <span class="hljs-function"><span class="hljs-title">catch</span>(<span class="hljs-params">e</span>)</span> { alert(e.message); }

<span class="hljs-comment">// &quot;deleteProperty&quot; 不允许删除 _password</span>
<span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">delete</span> user._password; <span class="hljs-comment">// Error: Access denied</span>
} <span class="hljs-function"><span class="hljs-title">catch</span>(<span class="hljs-params">e</span>)</span> { alert(e.message); }

<span class="hljs-comment">// &quot;ownKeys&quot; 将 _password 过滤出去</span>
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> user) alert(key); <span class="hljs-comment">// name</span></code></pre>
<p>请注意在 <code>(*)</code> 行中 <code>get</code> 捕捉器的重要细节：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">target, prop</span>)</span> {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">let</span> value = target[prop];
*!*
  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;function&#x27;</span>) ? value.bind(target) : value; <span class="hljs-comment">// (*)</span>
*/!*
}</code></pre>
<p>为什么我们需要一个函数去调用 <code>value.bind(target)</code>？</p>
<p>原因是对象方法（例如 <code>user.checkPassword()</code>）必须能够访问 <code>_password</code>：</p>
<pre><code class="language-js">user = {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-function"><span class="hljs-title">checkPassword</span>(<span class="hljs-params">value</span>)</span> {
    <span class="hljs-comment">//对象方法必须能读取 _password</span>
    <span class="hljs-keyword">return</span> value === <span class="hljs-built_in">this</span>._password;
  }
}</code></pre>
<p>对 <code>user.checkPassword()</code> 的调用会调用被代理的对象 <code>user</code> 作为 <code>this</code>（点符号之前的对象会成为 <code>this</code>），因此，当它尝试访问 <code>this._password</code> 时，<code>get</code> 捕捉器将激活（在任何属性读取时，它都会被触发）并抛出错误。</p>
<p>因此，我们在 <code>(*)</code> 行中将对象方法的上下文绑定到原始对象 <code>target</code>。然后，它们将来的调用将使用 <code>target</code> 作为 <code>this</code>，不会触发任何捕捉器。</p>
<p>该解决方案通常可行，但并不理想，因为一个方法可能会将未被代理的对象传递到其他地方，然后我们就会陷入困境：原始对象在哪里，被代理的对象在哪里？</p>
<p>此外，一个对象可能会被代理多次（多个代理可能会对该对象添加不同的“调整”），并且如果我们将未包装的对象传递给方法，则可能会产生意想不到的后果。</p>
<p>因此，在任何地方都不应使用这种代理。</p>
<pre><code class="language-smart">现代 JavaScript 引擎原生支持 class 中的私有属性，这些私有属性以 `#` 为前缀。它们在 &lt;info:private-protected-properties-methods&gt; 一章中有详细描述。无需代理（proxy）。

但是，此类属性有其自身的问题。特别是，它们是不可继承的。</code></pre>
<h2 id="带有-has-捕捉器-的-in-range">带有 &quot;has&quot; 捕捉器 的 &quot;in range&quot;</h2>
<p>让我们来看更多示例。</p>
<p>我们有一个 range 对象：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> range = {
  <span class="hljs-attr">start</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">end</span>: <span class="hljs-number">10</span>
};</code></pre>
<p>我们想使用 <code>in</code> 操作符来检查一个数字是否在 <code>range</code> 范围内。</p>
<p><code>has</code> 捕捉器会拦截 <code>in</code> 调用。</p>
<p><code>has(target, property)</code></p>
<ul>
<li><code>target</code> —— 是目标对象，被作为第一个参数传递给 <code>new Proxy</code>，</li>
<li><code>property</code> —— 属性名称。</li>
</ul>
<p>示例如下</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> range = {
  <span class="hljs-attr">start</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">end</span>: <span class="hljs-number">10</span>
};

range = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(range, {
*!*
  <span class="hljs-function"><span class="hljs-title">has</span>(<span class="hljs-params">target, prop</span>)</span> {
*/!*
    <span class="hljs-keyword">return</span> prop &gt;= target.start &amp;&amp; prop &lt;= target.end;
  }
});

*!*
alert(<span class="hljs-number">5</span> <span class="hljs-keyword">in</span> range); <span class="hljs-comment">// true</span>
alert(<span class="hljs-number">50</span> <span class="hljs-keyword">in</span> range); <span class="hljs-comment">// false</span>
*/!*</code></pre>
<p>漂亮的语法糖，不是吗？而且实现起来非常简单。</p>
<h2 id="包装函数：apply-proxy-apply">包装函数：&quot;apply&quot; [#proxy-apply]</h2>
<p>我们也可以将代理（proxy）包装在函数周围。</p>
<p><code>apply(target, thisArg, args)</code> 捕捉器能使代理以函数的方式被调用：</p>
<ul>
<li><code>target</code> 是目标对象（在 JavaScript 中，函数就是一个对象），</li>
<li><code>thisArg</code> 是 <code>this</code> 的值。</li>
<li><code>args</code> 是参数列表。</li>
</ul>
<p>例如，让我们回忆一下我们在 <a href="info:call-apply-decorators">info:call-apply-decorators</a> 一章中所讲的 <code>delay(f, ms)</code> 装饰器。</p>
<p>在该章中，我们没有用 proxy 来实现它。调用 <code>delay(f, ms)</code> 会返回一个函数，该函数会在 <code>ms</code> 毫秒后把所有调用转发给 <code>f</code>。</p>
<p>这是以前的基于函数的实现：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delay</span>(<span class="hljs-params">f, ms</span>) </span>{
  <span class="hljs-comment">// 返回一个包装器（wrapper），该包装器将在时间到了的时候将调用转发给函数 f</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// (*)</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> f.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>), ms);
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params">user</span>) </span>{
  alert(<span class="hljs-string">`Hello, <span class="hljs-subst">${user}</span>!`</span>);
}

<span class="hljs-comment">// 在进行这个包装后，sayHi 函数会被延迟 3 秒后被调用</span>
sayHi = delay(sayHi, <span class="hljs-number">3000</span>);

sayHi(<span class="hljs-string">&quot;John&quot;</span>); <span class="hljs-comment">// Hello, John! (after 3 seconds)</span></code></pre>
<p>正如我们所看到的那样，大多数情况下它都是可行的。包装函数 <code>(*)</code> 在到达延迟的时间后后执行调用。</p>
<p>但是包装函数不会转发属性读取/写入操作或者任何其他操作。进行包装后，就失去了对原始函数属性的访问，例如 <code>name</code>，<code>length</code> 和其他属性：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delay</span>(<span class="hljs-params">f, ms</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> f.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>), ms);
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params">user</span>) </span>{
  alert(<span class="hljs-string">`Hello, <span class="hljs-subst">${user}</span>!`</span>);
}

*!*
alert(sayHi.length); <span class="hljs-comment">// 1（函数的 length 是函数声明中的参数个数）</span>
*/!*

sayHi = delay(sayHi, <span class="hljs-number">3000</span>);

*!*
alert(sayHi.length); <span class="hljs-comment">// 0（在包装器声明中，参数个数为 0)</span>
*/!*</code></pre>
<p><code>Proxy</code> 的功能要强大得多，因为它可以将所有东西转发到目标对象。</p>
<p>让我们使用 <code>Proxy</code> 来替换掉包装函数：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delay</span>(<span class="hljs-params">f, ms</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(f, {
    <span class="hljs-function"><span class="hljs-title">apply</span>(<span class="hljs-params">target, thisArg, args</span>)</span> {
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> target.apply(thisArg, args), ms);
    }
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params">user</span>) </span>{
  alert(<span class="hljs-string">`Hello, <span class="hljs-subst">${user}</span>!`</span>);
}

sayHi = delay(sayHi, <span class="hljs-number">3000</span>);

*!*
alert(sayHi.length); <span class="hljs-comment">// 1 (*) proxy 将“获取 length”的操作转发给目标对象</span>
*/!*

sayHi(<span class="hljs-string">&quot;John&quot;</span>); <span class="hljs-comment">// Hello, John!（3 秒后）</span></code></pre>
<p>结果是相同的，但现在不仅仅调用，而且代理上的所有操作都能被转发到原始函数。所以在 <code>(*)</code> 行包装后的 <code>sayHi.length</code> 会返回正确的结果。</p>
<p>我们得到了一个“更丰富”的包装器。</p>
<p>还存在其他捕捉器：完整列表在本文的开头。它们的使用模式与上述类似。</p>
<h2 id="reflect">Reflect</h2>
<p><code>Reflect</code> 是一个内建对象，可简化 <code>Proxy</code> 的创建。</p>
<p>前面所讲过的内部方法，例如 <code>[[Get]]</code> 和 <code>[[Set]]</code> 等，都只是规范性的，不能直接调用。</p>
<p><code>Reflect</code> 对象使调用这些内部方法成为了可能。它的方法是内部方法的最小包装。</p>
<p>以下是执行相同操作和 <code>Reflect</code> 调用的示例：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th><code>Reflect</code> 调用</th>
<th>内部方法</th>
</tr>
</thead>
<tbody><tr>
<td><code>obj[prop]</code></td>
<td><code>Reflect.get(obj, prop)</code></td>
<td><code>[[Get]]</code></td>
</tr>
<tr>
<td><code>obj[prop] = value</code></td>
<td><code>Reflect.set(obj, prop, value)</code></td>
<td><code>[[Set]]</code></td>
</tr>
<tr>
<td><code>delete obj[prop]</code></td>
<td><code>Reflect.deleteProperty(obj, prop)</code></td>
<td><code>[[Delete]]</code></td>
</tr>
<tr>
<td><code>new F(value)</code></td>
<td><code>Reflect.construct(F, value)</code></td>
<td><code>[[Construct]]</code></td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody></table>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {};

<span class="hljs-built_in">Reflect</span>.set(user, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;John&#x27;</span>);

alert(user.name); <span class="hljs-comment">// John</span></code></pre>
<p>尤其是，<code>Reflect</code> 允许我们将操作符（<code>new</code>，<code>delete</code>，……）作为函数（<code>Reflect.construct</code>，<code>Reflect.deleteProperty</code>，……）执行调用。这是一个有趣的功能，但是这里还有一点很重要。</p>
<p><strong>对于每个可被 <code>Proxy</code> 捕获的内部方法，在 <code>Reflect</code> 中都有一个对应的方法，其名称和参数与 <code>Proxy</code> 捕捉器相同。</strong></p>
<p>所以，我们可以使用 <code>Reflect</code> 来将操作转发给原始对象。</p>
<p>在下面这个示例中，捕捉器 <code>get</code> 和 <code>set</code> 均透明地（好像它们都不存在一样）将读取/写入操作转发到对象，并显示一条消息：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
};

user = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(user, {
  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">target, prop, receiver</span>)</span> {
    alert(<span class="hljs-string">`GET <span class="hljs-subst">${prop}</span>`</span>);
*!*
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, prop, receiver); <span class="hljs-comment">// (1)</span>
*/!*
  },
  <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">target, prop, val, receiver</span>)</span> {
    alert(<span class="hljs-string">`SET <span class="hljs-subst">${prop}</span>=<span class="hljs-subst">${val}</span>`</span>);
*!*
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.set(target, prop, val, receiver); <span class="hljs-comment">// (2)</span>
*/!*
  }
});

<span class="hljs-keyword">let</span> name = user.name; <span class="hljs-comment">// 显示 &quot;GET name&quot;</span>
user.name = <span class="hljs-string">&quot;Pete&quot;</span>; <span class="hljs-comment">// 显示 &quot;SET name=Pete&quot;</span></code></pre>
<p>这里：</p>
<ul>
<li><code>Reflect.get</code> 读取一个对象属性。</li>
<li><code>Reflect.set</code> 写入一个对象属性，如果写入成功则返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ul>
<p>这样，一切都很简单：如果一个捕捉器想要将调用转发给对象，则只需使用相同的参数调用 <code>Reflect.&lt;method&gt;</code> 就足够了。</p>
<p>在大多数情况下，我们可以不使用 <code>Reflect</code> 完成相同的事情，例如，用于读取属性的 <code>Reflect.get(target, prop, receiver)</code> 可以被替换为 <code>target[prop]</code>。尽管有一些细微的差别。</p>
<h3 id="代理一个-getter">代理一个 getter</h3>
<p>让我们看一个示例，来说明为什么 <code>Reflect.get</code> 更好。此外，我们还将看到为什么 <code>get/set</code> 有第三个参数 <code>receiver</code>，而且我们之前从来没有使用过它。</p>
<p>我们有一个带有 <code>_name</code> 属性和 getter 的对象 <code>user</code>。</p>
<p>这是对 <code>user</code> 对象对一个代理（proxy）：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">_name</span>: <span class="hljs-string">&quot;Guest&quot;</span>,
  <span class="hljs-keyword">get</span> <span class="hljs-title">name</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._name;
  }
};

*!*
<span class="hljs-keyword">let</span> userProxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(user, {
  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">target, prop, receiver</span>)</span> {
    <span class="hljs-keyword">return</span> target[prop];
  }
});
*/!*

alert(userProxy.name); <span class="hljs-comment">// Guest</span></code></pre>
<p>其 <code>get</code> 捕捉器在这里是“透明的”，它返回原来的属性，不会做任何其他的事。这对于我们的示例而言就足够了。</p>
<p>一切似乎都很好。但是让我们将示例变得稍微复杂一点。</p>
<p>另一个对象 <code>admin</code> 从 <code>user</code> 继承后，我们可以观察到错误的行为：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">_name</span>: <span class="hljs-string">&quot;Guest&quot;</span>,
  <span class="hljs-keyword">get</span> <span class="hljs-title">name</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._name;
  }
};

<span class="hljs-keyword">let</span> userProxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(user, {
  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">target, prop, receiver</span>)</span> {
    <span class="hljs-keyword">return</span> target[prop]; <span class="hljs-comment">// (*) target = user</span>
  }
});

*!*
<span class="hljs-keyword">let</span> admin = {
  <span class="hljs-attr">__proto__</span>: userProxy,
  <span class="hljs-attr">_name</span>: <span class="hljs-string">&quot;Admin&quot;</span>
};

<span class="hljs-comment">// 期望输出：Admin</span>
alert(admin.name); <span class="hljs-comment">// 输出：Guest (?!?)</span>
*/!*</code></pre>
<p>读取 <code>admin.name</code> 应该返回 <code>&quot;Admin&quot;</code>，而不是 <code>&quot;Guest&quot;</code>！</p>
<p>发生了什么？或许我们在继承方面做错了什么？</p>
<p>但是，如果我们移除代理，那么一切都会按预期进行。</p>
<p>问题实际上出在代理中，在 <code>(*)</code> 行。</p>
<ol>
<li><p>当我们读取 <code>admin.name</code> 时，由于 <code>admin</code> 对象自身没有对应的的属性，搜索将转到其原型。</p>
</li>
<li><p>原型是 <code>userProxy</code>。</p>
</li>
<li><p>从代理读取 <code>name</code> 属性时，<code>get</code> 捕捉器会被触发，并从原始对象返回 <code>target[prop]</code> 属性，在 <code>(*)</code> 行。</p>
<p> 当调用 <code>target[prop]</code> 时，若 <code>prop</code> 是一个 getter，它将在 <code>this=target</code> 上下文中运行其代码。因此，结果是来自原始对象 <code>target</code> 的 <code>this._name</code>，即来自 <code>user</code>。</p>
</li>
</ol>
<p>为了解决这种情况，我们需要 <code>get</code> 捕捉器的第三个参数 <code>receiver</code>。它保证将正确的 <code>this</code> 传递给 getter。在我们的例子中是 <code>admin</code>。</p>
<p>如何把上下文传递给 getter？对于一个常规函数，我们可以使用 <code>call/apply</code>，但这是一个 getter，它不能“被调用”，只能被访问。</p>
<p><code>Reflect.get</code> 可以做到。如果我们使用它，一切都会正常运行。</p>
<p>这是更正后的变体：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">_name</span>: <span class="hljs-string">&quot;Guest&quot;</span>,
  <span class="hljs-keyword">get</span> <span class="hljs-title">name</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._name;
  }
};

<span class="hljs-keyword">let</span> userProxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(user, {
  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">target, prop, receiver</span>)</span> { <span class="hljs-comment">// receiver = admin</span>
*!*
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, prop, receiver); <span class="hljs-comment">// (*)</span>
*/!*
  }
});


<span class="hljs-keyword">let</span> admin = {
  <span class="hljs-attr">__proto__</span>: userProxy,
  <span class="hljs-attr">_name</span>: <span class="hljs-string">&quot;Admin&quot;</span>
};

*!*
alert(admin.name); <span class="hljs-comment">// Admin</span>
*/!*</code></pre>
<p>现在 <code>receiver</code> 保留了对正确 <code>this</code> 的引用（即 <code>admin</code>），该引用是在 <code>(*)</code> 行中被通过 <code>Reflect.get</code> 传递给 getter 的。</p>
<p>我们可以把捕捉器重写得更短：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">target, prop, receiver</span>)</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(*!*...arguments*/!*);
}</code></pre>
<p><code>Reflect</code> 调用的命名与捕捉器的命名完全相同，并且接受相同的参数。它们是以这种方式专门设计的。</p>
<p>因此，<code>return Reflect...</code> 提供了一个安全的方式，可以轻松地转发操作，并确保我们不会忘记与此相关的任何内容。</p>
<h2 id="proxy-的局限性">Proxy 的局限性</h2>
<p>代理提供了一种独特的方法，可以在最底层更改或调整现有对象的行为。但是，它并不完美。有局限性。</p>
<h3 id="内建对象：内部插槽（internal-slot）">内建对象：内部插槽（Internal slot）</h3>
<p>许多内建对象，例如 <code>Map</code>，<code>Set</code>，<code>Date</code>，<code>Promise</code> 等，都使用了所谓的“内部插槽”。</p>
<p>它们类似于属性，但仅限于内部使用，仅用于规范目的。例如，<code>Map</code> 将项目（item）存储在 <code>[[MapData]]</code> 中。内建方法可以直接访问它们，而不通过 <code>[[Get]]/[[Set]]</code> 内部方法。所以 <code>Proxy</code> 无法拦截它们。</p>
<p>为什么要在意这些呢？毕竟它们是内部的！</p>
<p>好吧，问题在这儿。在类似这样的内建对象被代理后，代理对象没有这些内部插槽，因此内建方法将会失败。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

<span class="hljs-keyword">let</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(map, {});

*!*
proxy.set(<span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// Error</span>
*/!*</code></pre>
<p>在内部，一个 <code>Map</code> 将所有数据存储在其 <code>[[MapData]]</code> 内部插槽中。代理对象没有这样的插槽。<a href="https://tc39.es/ecma262/#sec-map.prototype.set">内建方法 <code>Map.prototype.set</code></a> 方法试图访问内部属性 <code>this.[[MapData]]</code>，但由于 <code>this=proxy</code>，在 <code>proxy</code> 中无法找到它，只能失败。</p>
<p>幸运的是，这儿有一种解决方法：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

<span class="hljs-keyword">let</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(map, {
  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">target, prop, receiver</span>)</span> {
    <span class="hljs-keyword">let</span> value = <span class="hljs-built_in">Reflect</span>.get(...arguments);
*!*
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value == <span class="hljs-string">&#x27;function&#x27;</span> ? value.bind(target) : value;
*/!*
  }
});

proxy.set(<span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-number">1</span>);
alert(proxy.get(<span class="hljs-string">&#x27;test&#x27;</span>)); <span class="hljs-comment">// 1（工作了！）</span></code></pre>
<p>现在它正常工作了，因为 <code>get</code> 捕捉器将函数属性（例如 <code>map.set</code>）绑定到了目标对象（<code>map</code>）本身。</p>
<p>与前面的示例不同，<code>proxy.set(...)</code> 内部 <code>this</code> 的值并不是 <code>proxy</code>，而是原始的 <code>map</code>。因此，当<code>set</code> 捕捉器的内部实现尝试访问 <code>this.[[MapData]]</code> 内部插槽时，它会成功。</p>
<p>```smart header=&quot;<code>Array</code> 没有内部插槽&quot;
一个值得注意的例外：内建 <code>Array</code> 没有使用内部插槽。那是出于历史原因，因为它出现于很久以前。</p>
<p>所以，代理数组时没有这种问题。</p>
<pre><code>
### 私有字段

类的私有字段也会发生类似的情况。

例如，`getName()` 方法访问私有的 `#name` 属性，并在代理后中断（break）：

```js run
class User {
  #name = &quot;Guest&quot;;

  getName() {
    return this.#name;
  }
}

let user = new User();

user = new Proxy(user, {});

*!*
alert(user.getName()); // Error
*/!*</code></pre>
<p>原因是私有字段是通过内部插槽实现的。JavaScript 在访问它们时不使用 <code>[[Get]]/[[Set]]</code>。</p>
<p>在调用 <code>getName()</code> 时，<code>this</code> 的值是代理后的 <code>user</code>，它没有带有私有字段的插槽。</p>
<p>再次，带有 <code>bind</code> 方法的解决方案使它恢复正常：</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
  #name = <span class="hljs-string">&quot;Guest&quot;</span>;

  <span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.#name;
  }
}

<span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> User();

user = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(user, {
  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">target, prop, receiver</span>)</span> {
    <span class="hljs-keyword">let</span> value = <span class="hljs-built_in">Reflect</span>.get(...arguments);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value == <span class="hljs-string">&#x27;function&#x27;</span> ? value.bind(target) : value;
  }
});

alert(user.getName()); <span class="hljs-comment">// Guest</span></code></pre>
<p>如前所述，该解决方案也有缺点：它将原始对象暴露给该方法，可能使其进一步传递并破坏其他代理功能。</p>
<h3 id="proxy--target">Proxy != target</h3>
<p>代理和原始对象是不同的对象。这很自然，对吧？</p>
<p>所以，如果我们使用原始对象作为键，然后对其进行代理，之后却无法找到代理了：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> allUsers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> {
    <span class="hljs-built_in">this</span>.name = name;
    allUsers.add(<span class="hljs-built_in">this</span>);
  }
}

<span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;John&quot;</span>);

alert(allUsers.has(user)); <span class="hljs-comment">// true</span>

user = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(user, {});

*!*
alert(allUsers.has(user)); <span class="hljs-comment">// false</span>
*/!*</code></pre>
<p>如我们所见，进行代理后，我们在 <code>allUsers</code> 中找不到 <code>user</code>，因为代理是一个不同的对象。</p>
<p>```warn header=&quot;Proxy 无法拦截严格相等性检查 <code>===</code>&quot;
Proxy 可以拦截许多操作符，例如 <code>new</code>（使用 <code>construct</code>），<code>in</code>（使用 <code>has</code>），<code>delete</code>（使用 <code>deleteProperty</code>）等。</p>
<p>但是没有办法拦截对于对象的严格相等性检查。一个对象只严格等于其自身，没有其他值。</p>
<p>因此，比较对象是否相等的所有操作和内建类都会区分对象和代理。这里没有透明的替代品。</p>
<pre><code>
## 可撤销 Proxy

一个 **可撤销** 的代理是可以被禁用的代理。

假设我们有一个资源，并且想随时关闭对该资源的访问。

我们可以做的是将它包装成可一个撤销的代理，没有任何捕捉器。这样的代理会将操作转发给对象，并且我们可以随时将其禁用。

语法为：

```js
let {proxy, revoke} = Proxy.revocable(target, handler)</code></pre>
<p>该调用返回一个带有 <code>proxy</code> 和 <code>revoke</code> 函数的对象以将其禁用。</p>
<p>这是一个例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> object = {
  <span class="hljs-attr">data</span>: <span class="hljs-string">&quot;Valuable data&quot;</span>
};

<span class="hljs-keyword">let</span> {proxy, revoke} = <span class="hljs-built_in">Proxy</span>.revocable(object, {});

<span class="hljs-comment">// 将 proxy 传递到其他某处，而不是对象...</span>
alert(proxy.data); <span class="hljs-comment">// Valuable data</span>

<span class="hljs-comment">// 稍后，在我们的代码中</span>
revoke();

<span class="hljs-comment">// proxy 不再工作（revoked）</span>
alert(proxy.data); <span class="hljs-comment">// Error</span></code></pre>
<p>调用 <code>revoke()</code> 会从代理中删除对目标对象的所有内部引用，因此它们之间再无连接。之后可以对目标对象进行垃圾回收。</p>
<p>我们还可以将 <code>revoke</code> 存储在 <code>WeakMap</code> 中，以更便于通过代理对象轻松找到它：</p>
<pre><code class="language-js">*!*
<span class="hljs-keyword">let</span> revokes = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();
*/!*

<span class="hljs-keyword">let</span> object = {
  <span class="hljs-attr">data</span>: <span class="hljs-string">&quot;Valuable data&quot;</span>
};

<span class="hljs-keyword">let</span> {proxy, revoke} = <span class="hljs-built_in">Proxy</span>.revocable(object, {});

revokes.set(proxy, revoke);

<span class="hljs-comment">// ...稍后，在我们的代码中...</span>
revoke = revokes.get(proxy);
revoke();

alert(proxy.data); <span class="hljs-comment">// Error（revoked）</span></code></pre>
<p>这种方法的好处是，我们不必再随身携带 <code>revoke</code>。我们可以在有需要时通过 <code>proxy</code> 从 map 上获取它。</p>
<p>此处我们使用 <code>WeakMap</code> 而不是 <code>Map</code>，因为它不会阻止垃圾回收。如果一个代理对象变得“不可访问”（例如，没有变量再引用它），则 <code>WeakMap</code> 允许将其与它的 <code>revoke</code> 一起从内存中清除，因为我们不再需要它了。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>规范：<a href="https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots">Proxy</a>。</li>
<li>MDN：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a>。</li>
</ul>
<h2 id="总结">总结</h2>
<p><code>Proxy</code> 是对象的包装器，将代理上的操作转发到对象，并可以选择捕获其中一些操作。</p>
<p>它可以包装任何类型的对象，包括类和函数。</p>
<p>语法为：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, {
  <span class="hljs-comment">/* trap */</span>
});</code></pre>
<p>……然后，我们应该在所有地方使用 <code>proxy</code> 而不是 <code>target</code>。代理没有自己的属性或方法。如果提供了捕捉器（trap），它将捕获操作，否则会将其转发给 <code>target</code> 对象。</p>
<p>我们可以捕获：</p>
<ul>
<li>读取（<code>get</code>），写入（<code>set</code>），删除（<code>deleteProperty</code>）属性（甚至是不存在的属性）。</li>
<li>函数调用（<code>apply</code> 捕捉器）。</li>
<li><code>new</code> 操作（<code>construct</code> 捕捉器）。</li>
<li>许多其他操作（完整列表请见本文开头部分和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">docs</a>）。</li>
</ul>
<p>这使我们能够创建“虚拟”属性和方法，实现默认值，可观察对象，函数装饰器等。</p>
<p>我们还可以将对象多次包装在不同的代理中，并用多个各个方面的功能对其进行装饰。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect">Reflect</a> API 旨在补充 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a>。对于任意 <code>Proxy</code> 捕捉器，都有一个带有相同参数的 <code>Reflect</code> 调用。我们应该使用它们将调用转发给目标对象。</p>
<p>Proxy 有一些局限性：</p>
<ul>
<li>内建对象具有“内部插槽”，对这些对象的访问无法被代理。请参阅上文中的解决方法。</li>
<li>私有类字段也是如此，因为它们也是在内部使用插槽实现的。因此，代理方法的调用必须具有目标对象作为 <code>this</code> 才能访问它们。</li>
<li>对象的严格相等性检查 <code>===</code> 无法被拦截。</li>
<li>性能：基准测试（benchmark）取决于引擎，但通常使用最简单的代理访问属性所需的时间也要长几倍。实际上，这仅对某些“瓶颈”对象来说才重要。</li>
</ul>

      </fieldset>
      
      <fieldset id='_hYvUlp'>
      <legend>solution</legend>
      <p>让我们使用 <code>eval</code> 来计算数学表达式：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> expr = prompt(<span class="hljs-string">&quot;Type an arithmetic expression?&quot;</span>, <span class="hljs-string">&#x27;2*3+2&#x27;</span>);

alert( <span class="hljs-built_in">eval</span>(expr) );</code></pre>
<p>用户可以输入任意文本或代码。</p>
<p>安全起见，并限制其仅进行算术运算，我们可以使用 <a href="info:regular-expressions">正则表达式</a> 来检查 <code>expr</code>，以限制输入的内容只能包含数字和运算符。</p>

      </fieldset>
      
      <fieldset id='_hqWBoK'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="eval-计算器">Eval-计算器</h1>
<p>创建一个计算器，提示用户输入一个算术表达式，并返回其计算结果。</p>
<p>在本题中，你不需要检查表达式是否正确。只需要计算并返回结果。</p>
<p>[demo]</p>

      </fieldset>
      
      <fieldset id='_J8fmyV'>
      <legend>article</legend>
      <h1 id="eval：执行代码字符串">Eval：执行代码字符串</h1>
<p>内建函数 <code>eval</code> 函数允许执行一个代码字符串。</p>
<p>语法如下：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> result = <span class="hljs-built_in">eval</span>(code);</code></pre>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> code = <span class="hljs-string">&#x27;alert(&quot;Hello&quot;)&#x27;</span>;
<span class="hljs-built_in">eval</span>(code); <span class="hljs-comment">// Hello</span></code></pre>
<p>代码字符串可能会比较长，包含换行符、函数声明和变量等。</p>
<p><code>eval</code> 的结果是最后一条语句的结果。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> value = <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;1+1&#x27;</span>);
alert(value); <span class="hljs-comment">// 2</span></code></pre>
<pre><code class="language-js"><span class="hljs-keyword">let</span> value = <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;let i = 0; ++i&#x27;</span>);
alert(value); <span class="hljs-comment">// 1</span></code></pre>
<p><code>eval</code> 内的代码在当前词法环境（lexical environment）中执行，因此它能访问外部变量：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> a = <span class="hljs-number">2</span>;

*!*
  <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;alert(a)&#x27;</span>); <span class="hljs-comment">// 2</span>
*/!*
}

f();</code></pre>
<p>它也可以更改外部变量：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;
<span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;x = 10&quot;</span>);
alert(x); <span class="hljs-comment">// 10，值被更改了</span></code></pre>
<p>严格模式下，<code>eval</code> 有属于自己的词法环境。因此我们不能从外部访问在 <code>eval</code> 中声明的函数和变量：</p>
<pre><code class="language-js"><span class="hljs-comment">// 提示：本教程所有可运行的示例都默认启用了严格模式 &#x27;use strict&#x27;</span>

<span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;let x = 5; function f() {}&quot;</span>);

alert(<span class="hljs-keyword">typeof</span> x); <span class="hljs-comment">// undefined（没有这个变量）</span>
<span class="hljs-comment">// 函数 f 也不可从外部进行访问</span></code></pre>
<p>如果不启用严格模式，<code>eval</code> 没有属于自己的词法环境，因此我们可以从外部访问变量 <code>x</code> 和函数 <code>f</code>。</p>
<h2 id="使用-eval">使用 &quot;eval&quot;</h2>
<p>现代编程中，已经很少使用 <code>eval</code> 了。人们经常说“eval 是魔鬼”。</p>
<p>原因很简单：很久很久以前，JavaScript 是一种非常弱的语言，很多东西只能通过 <code>eval</code> 来完成。不过那已经是十年前的事了。</p>
<p>如今几乎找不到使用 <code>eval</code> 的理由了。如果有人在使用它，那这是一个很好的使用现代语言结构或 <a href="info:modules">JavaScript Module</a> 来替换它们的机会。</p>
<p>请注意，<code>eval</code> 访问外部变量的能力会产生副作用。</p>
<p>代码压缩工具（在把 JS 投入生产环境前对其进行压缩的工具）将局部变量重命名为更短的变量（例如 <code>a</code> 和 <code>b</code> 等），以使代码体积更小。这通常是安全的，但在使用了 <code>eval</code> 的情况下就不一样了，因为局部变量可能会被 <code>eval</code> 中的代码访问到。因此压缩工具不会对所有可能会被从 <code>eval</code> 中访问的变量进行重命名。这样会导致代码压缩率降低。</p>
<p>在 <code>eval</code> 中使用外部局部变量也被认为是一个坏的编程习惯，因为这会使代码维护变得更加困难。</p>
<p>有两种方法可以完全避免此类问题。</p>
<p><strong>如果 <code>eval</code> 中的代码没有使用外部变量，请以 <code>window.eval(...)</code> 的形式调用 <code>eval</code>：</strong> </p>
<p>通过这种方式，该代码便会在全局作用域内执行：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;
{
  <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;
  <span class="hljs-built_in">window</span>.eval(<span class="hljs-string">&#x27;alert(x)&#x27;</span>); <span class="hljs-comment">// 1（全局变量）</span>
}</code></pre>
<p><strong>如果 <code>eval</code> 中的代码需要访问局部变量，我们可以使用 <code>new Function</code> 替代 <code>eval</code>，并将它们作为参数传递：</strong> </p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> f = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;alert(a)&#x27;</span>);

f(<span class="hljs-number">5</span>); <span class="hljs-comment">// 5</span></code></pre>
<p>我们在 <a href="info:new-function">info:new-function</a> 一章中对 <code>new Function</code> 构造器进行了详细说明。<code>new Function</code> 从字符串创建一个函数，并且也是在全局作用域中的。所以它无法访问局部变量。但是，正如上面的示例一样，将它们作为参数进行显式传递要清晰得多。</p>
<h2 id="总结">总结</h2>
<p>调用 <code>eval(code)</code> 会运行代码字符串，并返回最后一条语句的结果。</p>
<ul>
<li>在现代 JavaScript 编程中，很少使用它，通常也不需要使用它。</li>
<li>可以访问外部局部变量。这被认为是一个不好的编程习惯。</li>
<li>要在全局作用域中 <code>eval</code> 代码，可以使用 <code>window.eval(code)</code> 进行替代。</li>
<li>此外，如果你的代码需要从外部作用域获取数据，请使用 <code>new Function</code>，并将数据作为参数传递给函数。</li>
</ul>

      </fieldset>
      
      <fieldset id='_0lX4Fc'>
      <legend>article</legend>
      <p>libs:</p>
<ul>
<li>lodash</li>
</ul>
<hr>
<h1 id="柯里化（currying）">柯里化（Currying）</h1>
<p><a href="https://en.wikipedia.org/wiki/Currying">柯里化（Currying）</a>是一种关于函数的高阶技术。它不仅被用于 JavaScript，还被用于其他编程语言。</p>
<p>柯里化是一种函数的转换，它是指将一个函数从可调用的 <code>f(a, b, c)</code> 转换为可调用的 <code>f(a)(b)(c)</code>。</p>
<p>柯里化不会调用函数。它只是对函数进行转换。</p>
<p>让我们先来看一个例子，以更好地理解我们正在讲的内容，然后再进行一个实际应用。</p>
<p>我们将创建一个辅助函数 <code>curry(f)</code>，该函数将对两个参数的函数 <code>f</code> 执行柯里化。换句话说，对于两个参数的函数 <code>f(a, b)</code> 执行 <code>curry(f)</code> 会将其转换为以 <code>f(a)(b)</code> 形式运行的函数：</p>
<pre><code class="language-js">*!*
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">f</span>) </span>{ <span class="hljs-comment">// curry(f) 执行柯里化转换</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">b</span>) </span>{
      <span class="hljs-keyword">return</span> f(a, b);
    };
  };
}
*/!*

<span class="hljs-comment">// 用法</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-keyword">let</span> curriedSum = curry(sum);

alert( curriedSum(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>) ); <span class="hljs-comment">// 3</span></code></pre>
<p>正如你所看到的，实现非常简单：只有两个包装器（wrapper）。</p>
<ul>
<li><code>curry(func)</code> 的结果就是一个包装器 <code>function(a)</code>。</li>
<li>当它被像 <code>curriedSum(1)</code> 这样调用时，它的参数会被保存在词法环境中，然后返回一个新的包装器 <code>function(b)</code>。</li>
<li>然后这个包装器被以 <code>2</code> 为参数调用，并且，它将该调用传递给原始的 <code>sum</code> 函数。</li>
</ul>
<p>柯里化更高级的实现，例如 lodash 库的 <a href="https://lodash.com/docs#curry">_.curry</a>，会返回一个包装器，该包装器允许函数被正常调用或者以偏函数（partial）的方式调用：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-keyword">let</span> curriedSum = _.curry(sum); <span class="hljs-comment">// 使用来自 lodash 库的 _.curry</span>

alert( curriedSum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) ); <span class="hljs-comment">// 3，仍可正常调用</span>
alert( curriedSum(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>) ); <span class="hljs-comment">// 3，以偏函数的方式调用</span></code></pre>
<h2 id="柯里化？目的是什么？">柯里化？目的是什么？</h2>
<p>要了解它的好处，我们需要一个实际中的例子。</p>
<p>例如，我们有一个用于格式化和输出信息的日志（logging）函数 <code>log(date, importance, message)</code>。在实际项目中，此类函数具有很多有用的功能，例如通过网络发送日志（log），在这儿我们仅使用 <code>alert</code>：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">log</span>(<span class="hljs-params">date, importance, message</span>) </span>{
  alert(<span class="hljs-string">`[<span class="hljs-subst">${date.getHours()}</span>:<span class="hljs-subst">${date.getMinutes()}</span>] [<span class="hljs-subst">${importance}</span>] <span class="hljs-subst">${message}</span>`</span>);
}</code></pre>
<p>让我们将它柯里化！</p>
<pre><code class="language-js">log = _.curry(log);</code></pre>
<p>柯里化之后，<code>log</code> 仍正常运行：</p>
<pre><code class="language-js">log(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(), <span class="hljs-string">&quot;DEBUG&quot;</span>, <span class="hljs-string">&quot;some debug&quot;</span>); <span class="hljs-comment">// log(a, b, c)</span></code></pre>
<p>……但是也可以以柯里化形式运行：</p>
<pre><code class="language-js">log(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>())(<span class="hljs-string">&quot;DEBUG&quot;</span>)(<span class="hljs-string">&quot;some debug&quot;</span>); <span class="hljs-comment">// log(a)(b)(c)</span></code></pre>
<p>现在，我们可以轻松地为当前日志创建便捷函数：</p>
<pre><code class="language-js"><span class="hljs-comment">// logNow 会是带有固定第一个参数的日志的偏函数</span>
<span class="hljs-keyword">let</span> logNow = log(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>());

<span class="hljs-comment">// 使用它</span>
logNow(<span class="hljs-string">&quot;INFO&quot;</span>, <span class="hljs-string">&quot;message&quot;</span>); <span class="hljs-comment">// [HH:mm] INFO message</span></code></pre>
<p>现在，<code>logNow</code> 是具有固定第一个参数的 <code>log</code>，换句话说，就是更简短的“偏应用函数（partially applied function）”或“偏函数（partial）”。</p>
<p>我们可以更进一步，为当前的调试日志（debug log）提供便捷函数：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> debugNow = logNow(<span class="hljs-string">&quot;DEBUG&quot;</span>);

debugNow(<span class="hljs-string">&quot;message&quot;</span>); <span class="hljs-comment">// [HH:mm] DEBUG message</span></code></pre>
<p>所以：</p>
<ol>
<li>柯里化之后，我们没有丢失任何东西：<code>log</code> 依然可以被正常调用。</li>
<li>我们可以轻松地生成偏函数，例如用于生成今天的日志的偏函数。</li>
</ol>
<h2 id="高级柯里化实现">高级柯里化实现</h2>
<p>如果你想了解更多细节，下面是用于多参数函数的“高级”柯里化实现，我们也可以把它用于上面的示例。</p>
<p>它非常短：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">func</span>) </span>{

  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curried</span>(<span class="hljs-params">...args</span>) </span>{
    <span class="hljs-keyword">if</span> (args.length &gt;= func.length) {
      <span class="hljs-keyword">return</span> func.apply(<span class="hljs-built_in">this</span>, args);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args2</span>) </span>{
        <span class="hljs-keyword">return</span> curried.apply(<span class="hljs-built_in">this</span>, args.concat(args2));
      }
    }
  };

}</code></pre>
<p>用例：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a, b, c</span>) </span>{
  <span class="hljs-keyword">return</span> a + b + c;
}

<span class="hljs-keyword">let</span> curriedSum = curry(sum);

alert( curriedSum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) ); <span class="hljs-comment">// 6，仍然可以被正常调用</span>
alert( curriedSum(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>) ); <span class="hljs-comment">// 6，对第一个参数的柯里化</span>
alert( curriedSum(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>) ); <span class="hljs-comment">// 6，全柯里化</span></code></pre>
<p>新的 <code>curry</code> 可能看上去有点复杂，但是它很容易理解。</p>
<p><code>curry(func)</code> 调用的结果是如下所示的包装器 <code>curried</code>：</p>
<pre><code class="language-js"><span class="hljs-comment">// func 是要转换的函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curried</span>(<span class="hljs-params">...args</span>) </span>{
  <span class="hljs-keyword">if</span> (args.length &gt;= func.length) { <span class="hljs-comment">// (1)</span>
    <span class="hljs-keyword">return</span> func.apply(<span class="hljs-built_in">this</span>, args);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pass</span>(<span class="hljs-params">...args2</span>) </span>{ <span class="hljs-comment">// (2)</span>
      <span class="hljs-keyword">return</span> curried.apply(<span class="hljs-built_in">this</span>, args.concat(args2));
    }
  }
};</code></pre>
<p>当我们运行它时，这里有两个 <code>if</code> 执行分支：</p>
<ol>
<li>现在调用：如果传入的 <code>args</code> 长度与原始函数所定义的（<code>func.length</code>）相同或者更长，那么只需要将调用传递给它即可。</li>
<li>获取一个偏函数：否则，<code>func</code> 还没有被调用。取而代之的是，返回另一个包装器 <code>pass</code>，它将重新应用 <code>curried</code>，将之前传入的参数与新的参数一起传入。然后，在一个新的调用中，再次，我们将获得一个新的偏函数（如果参数不足的话），或者最终的结果。</li>
</ol>
<p>例如，让我们看看 <code>sum(a, b, c)</code> 这个例子。它有三个参数，所以 <code>sum.length = 3</code>。</p>
<p>对于调用 <code>curried(1)(2)(3)</code>：</p>
<ol>
<li>第一个调用 <code>curried(1)</code> 将 <code>1</code> 保存在词法环境中，然后返回一个包装器 <code>pass</code>。</li>
<li>包装器 <code>pass</code> 被调用，参数为 <code>(2)</code>：它会获取之前的参数 <code>(1)</code>，将它与得到的 <code>(2)</code> 连在一起，并一起调用 <code>curried(1, 2)</code>。由于参数数量仍小于 3，<code>curry</code> 函数依然会返回 <code>pass</code>。</li>
<li>包装器 <code>pass</code> 再次被调用，参数为 <code>(3)</code>，在接下来的调用中，<code>pass(3)</code> 会获取之前的参数 (<code>1</code>, <code>2</code>) 并将 <code>3</code> 与之合并，执行调用 <code>curried(1, 2, 3)</code> — 最终有 <code>3</code> 个参数，它们被传入最原始的函数中。</li>
</ol>
<p>如果这还不够清楚，那你可以把函数调用顺序在你的脑海中或者在纸上过一遍。</p>
<pre><code class="language-smart">柯里化要求函数具有固定数量的参数。

使用 rest 参数的函数，例如 `f(...args)`，不能以这种方式进行柯里化。</code></pre>
<pre><code class="language-smart">根据定义，柯里化应该将 `sum(a, b, c)` 转换为 `sum(a)(b)(c)`。

但是，如前所述，JavaScript 中大多数的柯里化实现都是高级版的：它们使得函数可以被多参数变体调用。</code></pre>
<h2 id="总结">总结</h2>
<p><strong>柯里化</strong> 是一种转换，将 <code>f(a,b,c)</code> 转换为可以被以 <code>f(a)(b)(c)</code> 的形式进行调用。JavaScript 实现通常都保持该函数可以被正常调用，并且如果参数数量不足，则返回偏函数。</p>
<p>柯里化让我们能够更容易地获取偏函数。就像我们在日志记录示例中看到的那样，普通函数 <code>log(date, importance, message)</code> 在被柯里化之后，当我们调用它的时候传入一个参数（如 <code>log(date)</code>）或两个参数（<code>log(date, importance)</code>）时，它会返回偏函数。</p>

      </fieldset>
      
      <fieldset id='_ITYSX7'>
      <legend>solution</legend>
      <p><strong>错误</strong>!</p>
<p>试一下：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">go</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ alert(<span class="hljs-built_in">this</span>.name) }
}

(user.go)() <span class="hljs-comment">// error!</span></code></pre>
<p>大多数浏览器中的错误信息并不能说明是什么出现了问题。</p>
<p><strong>出现此错误是因为在 <code>user = {...}</code> 后面漏了一个分号。</strong></p>
<p>JavaScript 不会在括号 <code>(user.go)()</code> 前自动插入分号，所以解析的代码如下：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = { <span class="hljs-attr">go</span>:... }(user.go)()</code></pre>
<p>然后我们还可以看到，这样的联合表达式在语法上是将对象 <code>{ go: ... }</code> 作为参数为 <code>(user.go)</code> 的函数。这发生在 <code>let user</code> 的同一行上，因此 <code>user</code> 对象是甚至还没有被定义，因此出现了错误。</p>
<p>如果我们插入该分号，一切都变得正常：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">go</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ alert(<span class="hljs-built_in">this</span>.name) }
}*!*;*/!*

(user.go)() <span class="hljs-comment">// John</span></code></pre>
<p>要注意的是，<code>(user.go)</code> 外边这层括号在这没有任何作用。通常用它们来设置操作的顺序，但在这里点符号 <code>.</code> 总是会先执行，所以并没有什么影响。分号是唯一重要的。</p>

      </fieldset>
      
      <fieldset id='_bFq39v'>
      <legend>task</legend>
      <p>importance: 2</p>
<hr>
<h1 id="检查语法">检查语法</h1>
<p>这段代码的结果是什么？</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">go</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ alert(<span class="hljs-built_in">this</span>.name) }
}

(user.go)()</code></pre>
<p>提示：有一个陷阱哦 :)</p>

      </fieldset>
      
      <fieldset id='_hESzcV'>
      <legend>solution</legend>
      <p>这里是解析。</p>
<ol>
<li><p>它是一个常规的方法调用。</p>
</li>
<li><p>同样，括号没有改变执行的顺序，点符号总是先执行。</p>
</li>
<li><p>这里我们有一个更复杂的 <code>(expression).method()</code> 调用。这个调用就像被分成了两行（代码）一样：</p>
<pre><code class="language-js">f = obj.go; <span class="hljs-comment">// 计算函数表达式</span>
f();        <span class="hljs-comment">// 调用</span></code></pre>
<p>   这里的 <code>f()</code> 是作为一个没有（设定）<code>this</code> 的函数执行的。</p>
</li>
<li><p>与 <code>(3)</code> 相类似，在点符号 <code>.</code> 的左边也有一个表达式。</p>
</li>
</ol>
<p>要解释 <code>(3)</code> 和 <code>(4)</code> 得到这种结果的原因，我们需要回顾一下属性访问器（点符号或方括号）返回的是引用类型的值。</p>
<p>除了方法调用之外的任何操作（如赋值 <code>=</code> 或 <code>||</code>），都会把它转换为一个不包含允许设置 <code>this</code> 信息的普通值。</p>

      </fieldset>
      
      <fieldset id='_5vjb84'>
      <legend>task</legend>
      <p>importance: 3</p>
<hr>
<h1 id="解释-this-的值">解释 &quot;this&quot; 的值</h1>
<p>在下面的代码中，我们试图连续调用 <code>obj.go()</code> 方法 4 次。</p>
<p>但是前两次和后两次调用的结果不同，为什么呢？</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> obj, method;

obj = {
  <span class="hljs-attr">go</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ alert(<span class="hljs-built_in">this</span>); }
};

obj.go();               <span class="hljs-comment">// (1) [object Object]</span>

(obj.go)();             <span class="hljs-comment">// (2) [object Object]</span>

(method = obj.go)();    <span class="hljs-comment">// (3) undefined</span>

(obj.go || obj.stop)(); <span class="hljs-comment">// (4) undefined</span></code></pre>

      </fieldset>
      
      <fieldset id='_9P6uyl'>
      <legend>article</legend>
      <h1 id="reference-type">Reference Type</h1>
<pre><code class="language-warn">本文所讲的是一个高阶主题，能帮你更好地理解一些边缘情况。

这仅是锦上添花。许多经验丰富的的开发者不甚了了也过得不错。如果你想了解代码运行的本质，那就继续读下去吧。</code></pre>
<p>一个动态执行的方法调用可能会丢失 <code>this</code>。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-function"><span class="hljs-title">hi</span>(<span class="hljs-params"></span>)</span> { alert(<span class="hljs-built_in">this</span>.name); },
  <span class="hljs-function"><span class="hljs-title">bye</span>(<span class="hljs-params"></span>)</span> { alert(<span class="hljs-string">&quot;Bye&quot;</span>); }
};

user.hi(); <span class="hljs-comment">// 正常运行</span>

<span class="hljs-comment">// 现在让我们基于 name 来选择调用 user.hi 或 user.bye</span>
*!*
(user.name == <span class="hljs-string">&quot;John&quot;</span> ? user.hi : user.bye)(); <span class="hljs-comment">// Error!</span>
*/!*</code></pre>
<p>在最后一行有个在 <code>user.hi</code> 和 <code>user.bye</code> 中做选择的条件（三元）运算符。当前情形下的结果是 <code>user.hi</code>。</p>
<p>接着该方法被通过 <code>()</code> 立刻调用。但是并不能正常工作！</p>
<p>如你所见，此处调用导致了一个错误，因为在该调用中 <code>&quot;this&quot;</code> 的值变成了 <code>undefined</code>。</p>
<p>这样是能工作的（对象.方法）：</p>
<pre><code class="language-js">user.hi();</code></pre>
<p>这就无法工作了（被评估的方法）：</p>
<pre><code class="language-js">(user.name == <span class="hljs-string">&quot;John&quot;</span> ? user.hi : user.bye)(); <span class="hljs-comment">// Error!</span></code></pre>
<p>为什么呢？欲知缘何，且让我们深入 <code>obj.method()</code> 调用运行的本质。</p>
<h2 id="reference-type-解读">Reference type 解读</h2>
<p>仔细看的话，我们可能注意到 <code>obj.method()</code> 语句中的两个操作：</p>
<ol>
<li>首先，点 <code>&#39;.&#39;</code> 取了属性 <code>obj.method</code> 的值。</li>
<li>接着 <code>()</code> 执行了它。</li>
</ol>
<p>那么，<code>this</code> 的信息是怎么从第一部分传递到第二部分的呢？</p>
<p>如果我们将这些操作放在不同的行，<code>this</code> 必定是会丢失的：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-function"><span class="hljs-title">hi</span>(<span class="hljs-params"></span>)</span> { alert(<span class="hljs-built_in">this</span>.name); }
}

*!*
<span class="hljs-comment">// 把获取方法和调用方法拆成两行</span>
<span class="hljs-keyword">let</span> hi = user.hi;
hi(); <span class="hljs-comment">// 报错了，因为 this 的值是 undefined</span>
*/!*</code></pre>
<p>这里 <code>hi = user.hi</code> 把函数赋值给了一个变量，接下来在最后一行它是完全独立的，所以这里没有 <code>this</code>。</p>
<p><strong>为确保 <code>user.hi()</code> 调用正常运行，JavaScript 玩了个小把戏 —— 点 <code>&#39;.&#39;</code> 返回的不是一个函数，而是一个特殊的 <a href="https://tc39.github.io/ecma262/#sec-reference-specification-type">Reference Type</a> 的值。</strong></p>
<p>Reference Type 是 ECMA 中的一个“规范类型”。我们不能直接使用它，但它被用在 JavaScript 语言内部。</p>
<p>Reference Type 的值是一个三个值的组合 <code>(base, name, strict)</code>，其中：</p>
<ul>
<li><code>base</code> 是对象。</li>
<li><code>name</code> 是属性名。</li>
<li><code>strict</code> 在 <code>use strict</code> 模式下为 true。</li>
</ul>
<p>对属性 <code>user.hi</code> 访问的结果不是一个函数，而是一个 Reference Type 的值。对于 <code>user.hi</code>，在严格模式下是：</p>
<pre><code class="language-js"><span class="hljs-comment">// Reference Type 的值</span>
(user, <span class="hljs-string">&quot;hi&quot;</span>, <span class="hljs-literal">true</span>)</code></pre>
<p>当 <code>()</code> 被在 Reference Type 上调用时，它们会接收到关于对象和对象的方法的完整信息，然后可以设置正确的 <code>this</code>（在此处 <code>=user</code>）。</p>
<p>Reference Type 是一个特殊的“中间人”内部类型，目的是从 <code>.</code> 传递信息给 <code>()</code> 调用。</p>
<p>任何例如赋值 <code>hi = user.hi</code> 等其他的操作，都会将 Reference Type 作为一个整体丢弃掉，而会取 <code>user.hi</code>（一个函数）的值并继续传递。所以任何后续操作都“丢失”了 <code>this</code>。</p>
<p>因此，<code>this</code> 的值仅在函数直接被通过点符号 <code>obj.method()</code> 或方括号 <code>obj[&#39;method&#39;]()</code> 语法（此处它们作用相同）调用时才被正确传递。在本教程的后续章节，我们会学习多种解决这个问题的方式，例如 <a href="/bind#solution-2-bind">func.bind()</a>。</p>
<h2 id="总结">总结</h2>
<p>Reference Type 是语言内部的一个类型。</p>
<p>读取一个属性，例如在 <code>obj.method()</code> 中，<code>.</code> 返回的准确来说不是属性的值，而是一个特殊的 &quot;Reference Type&quot; 值，其中储存着属性的值和它的来源对象。</p>
<p>这是为了随后的方法调用 <code>()</code> 获取来源对象，然后将 <code>this</code> 设为它。</p>
<p>对于所有其它操作，Reference Type 会自动变成属性的值（在我们这个情况下是一个函数）。</p>
<p>这整个机理对我们是不可见的。它仅在一些微妙的情形下才重要，例如一个方法是通过表达式从对象动态获取的。</p>

      </fieldset>
      
      <fieldset id='_003RpC'>
      <legend>article</legend>
      <h1 id="bigint">BigInt</h1>
<p>[recent caniuse=&quot;bigint&quot;]</p>
<p><code>BigInt</code> 是一种特殊的数字类型，它提供了对任意长度整数的支持。</p>
<p>创建 bigint 的方式有两种：在一个整数字面量后面加 <code>n</code> 或者调用 <code>BigInt</code> 函数，该函数从字符串、数字等中生成 bigint。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> bigint = <span class="hljs-number">1234567890123456789012345678901234567890n</span>;

<span class="hljs-keyword">const</span> sameBigint = BigInt(<span class="hljs-string">&quot;1234567890123456789012345678901234567890&quot;</span>);

<span class="hljs-keyword">const</span> bigintFromNumber = BigInt(<span class="hljs-number">10</span>); <span class="hljs-comment">// 与 10n 相同</span></code></pre>
<h2 id="数学运算符">数学运算符</h2>
<p><code>BigInt</code> 大多数情况下可以像常规数字类型一样使用，例如：</p>
<pre><code class="language-js">alert(<span class="hljs-number">1n</span> + <span class="hljs-number">2n</span>); <span class="hljs-comment">// 3</span>

alert(<span class="hljs-number">5n</span> / <span class="hljs-number">2n</span>); <span class="hljs-comment">// 2</span></code></pre>
<p>请注意：除法 <code>5/2</code> 的结果向零进行舍入，舍入后得到的结果没有了小数部分。对 bigint 的所有操作，返回的结果也是 bigint。</p>
<p>我们不可以把 bigint 和常规数字类型混合使用：</p>
<pre><code class="language-js">alert(<span class="hljs-number">1n</span> + <span class="hljs-number">2</span>); <span class="hljs-comment">// Error: Cannot mix BigInt and other types</span></code></pre>
<p>如果有需要，我们应该显式地转换它们：使用 <code>BigInt()</code> 或者 <code>Number()</code>，像这样：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> bigint = <span class="hljs-number">1n</span>;
<span class="hljs-keyword">let</span> number = <span class="hljs-number">2</span>;

<span class="hljs-comment">// 将 number 转换为 bigint</span>
alert(bigint + BigInt(number)); <span class="hljs-comment">// 3</span>

<span class="hljs-comment">// 将 bigint 转换为 number</span>
alert(<span class="hljs-built_in">Number</span>(bigint) + number); <span class="hljs-comment">// 3</span></code></pre>
<p>转换操作始终是静默的，绝不会报错，但是如果 bigint 太大而数字类型无法容纳，则会截断多余的位，因此我们应该谨慎进行此类转换。</p>
<pre><code class="language-smart">一元加法运算符 `+value`，是大家熟知的将 `value` 转换成数字类型的方法。

为了避免混淆，在 bigint 中不支持一元加法：
```js run
let bigint = 1n;

alert( +bigint ); // error
```
所以我们应该用 `Number()` 来将一个 bigint 转换成一个数字类型。</code></pre>
<h2 id="比较运算符">比较运算符</h2>
<p>比较运算符，例如 <code>&lt;</code> 和 <code>&gt;</code>，使用它们来对 bigint 和 number 类型的数字进行比较没有问题：</p>
<pre><code class="language-js">alert( <span class="hljs-number">2n</span> &gt; <span class="hljs-number">1n</span> ); <span class="hljs-comment">// true</span>

alert( <span class="hljs-number">2n</span> &gt; <span class="hljs-number">1</span> ); <span class="hljs-comment">// true</span></code></pre>
<p>但是请注意，由于 number 和 bigint 属于不同类型，它们可能在进行 <code>==</code> 比较时相等，但在进行 <code>===</code>（严格相等）比较时不相等：</p>
<pre><code class="language-js">alert( <span class="hljs-number">1</span> == <span class="hljs-number">1n</span> ); <span class="hljs-comment">// true</span>

alert( <span class="hljs-number">1</span> === <span class="hljs-number">1n</span> ); <span class="hljs-comment">// false</span></code></pre>
<h2 id="布尔运算">布尔运算</h2>
<p>当在 <code>if</code> 或其他布尔运算中时，bigint 的行为类似于 number。</p>
<p>例如，在 <code>if</code> 中，bigint <code>0n</code> 为 <code>false</code>，其他值为 <code>true</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (<span class="hljs-number">0n</span>) {
  <span class="hljs-comment">// 永远不会执行</span>
}</code></pre>
<p>布尔运算符，例如 <code>||</code>，<code>&amp;&amp;</code> 和其他运算符，处理 bigint 的方式也类似于 number：</p>
<pre><code class="language-js">alert( <span class="hljs-number">1n</span> || <span class="hljs-number">2</span> ); <span class="hljs-comment">// 1（1n 被认为是 true）</span>

alert( <span class="hljs-number">0n</span> || <span class="hljs-number">2</span> ); <span class="hljs-comment">// 2（0n 被认为是 false）</span></code></pre>
<h2 id="polyfill">Polyfill</h2>
<p>Polyfilling bigint 比较棘手。原因是许多 JavaScript 运算符，比如 <code>+</code> 和 <code>-</code> 等，在对待 bigint 的行为上与常规 number 相比有所不同。</p>
<p>例如，bigint 的除法总是返回 bigint（如果需要，会进行舍入）。</p>
<p>想要模拟这种行为，polyfill 需要分析代码，并用其函数替换所有此类运算符。但是这样做很麻烦，并且会耗费很多性能。</p>
<p>所以，目前并没有一个众所周知的好用的 polyfill。</p>
<p>不过，<a href="https://github.com/GoogleChromeLabs/jsbi">JSBI</a> 库的开发者提出了另一种解决方案。</p>
<p>该库使用自己的方法实现了大的数字。我们可以使用它们替代原生的 bigint：</p>
<table>
<thead>
<tr>
<th>运算</th>
<th>原生 <code>BigInt</code></th>
<th>JSBI</th>
</tr>
</thead>
<tbody><tr>
<td>从 Number 创建</td>
<td><code>a = BigInt(789)</code></td>
<td><code>a = JSBI.BigInt(789)</code></td>
</tr>
<tr>
<td>加法</td>
<td><code>c = a + b</code></td>
<td><code>c = JSBI.add(a, b)</code></td>
</tr>
<tr>
<td>减法</td>
<td><code>c = a - b</code></td>
<td><code>c = JSBI.subtract(a, b)</code></td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody></table>
<p>……然后，对于那些支持 bigint 的浏览器，可以使用 polyfill（Babel 插件）将 JSBI 调用转换为原生的 bigint。</p>
<p>换句话说，这个方法建议我们在写代码时使用 JSBI 替代原生的 bigint。但是 JSBI 在内部像使用 bigint 一样使用 number，并最大程度按照规范进行模拟，所以代码已经是准备好转换成 bigint 的了（bigint-ready）。</p>
<p>对于不支持 bigint 的引擎，我们可以“按原样”使用此类 JSBI 代码，对于那些支持 bigint 的引擎 — polyfill 会将调用转换为原生的 bigint。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt">MDN 文档对 BigInt 的介绍</a>。</li>
<li><a href="https://tc39.es/ecma262/#sec-bigint-objects">ECMA262 规范</a>。</li>
</ul>

      </fieldset>
      </div><div id="nav"><div style="margin-left:0em"><strong>getting-started</strong><br/></div><div style="margin-left:1em"><strong>intro</strong><br/></div><div style="margin-left:2em"><a href="#_oiRHn1">article</a><br/></div><div style="margin-left:1em"><strong>manuals-specifications</strong><br/></div><div style="margin-left:2em"><a href="#_Yn0r2M">article</a><br/></div><div style="margin-left:1em"><strong>code-editors</strong><br/></div><div style="margin-left:2em"><a href="#_yBIy7W">article</a><br/></div><div style="margin-left:1em"><strong>devtools</strong><br/></div><div style="margin-left:2em"><a href="#_pHVq7J">article</a><br/></div><div style="margin-left:0em"><strong>first-steps</strong><br/></div><div style="margin-left:1em"><strong>hello-world</strong><br/></div><div style="margin-left:2em"><strong>hello-alert</strong><br/></div><div style="margin-left:3em"><a href="#_4XHcUl">solution</a><br/></div><div style="margin-left:3em"><a href="#_CmLl2P">task</a><br/></div><div style="margin-left:2em"><strong>hello-alert-ext</strong><br/></div><div style="margin-left:3em"><a href="#_8cqsrc">solution</a><br/></div><div style="margin-left:3em"><a href="#_FrQqkA">task</a><br/></div><div style="margin-left:2em"><a href="#_Ejegqu">article</a><br/></div><div style="margin-left:1em"><strong>structure</strong><br/></div><div style="margin-left:2em"><a href="#_50X1Ao">article</a><br/></div><div style="margin-left:1em"><strong>strict-mode</strong><br/></div><div style="margin-left:2em"><a href="#_ilpsYV">article</a><br/></div><div style="margin-left:1em"><strong>variables</strong><br/></div><div style="margin-left:2em"><strong>hello-variables</strong><br/></div><div style="margin-left:3em"><a href="#_w6kC9c">solution</a><br/></div><div style="margin-left:3em"><a href="#_68ZRR1">task</a><br/></div><div style="margin-left:2em"><strong>declare-variables</strong><br/></div><div style="margin-left:3em"><a href="#_m9s1nB">solution</a><br/></div><div style="margin-left:3em"><a href="#_RnK6y7">task</a><br/></div><div style="margin-left:2em"><strong>uppercast-constant</strong><br/></div><div style="margin-left:3em"><a href="#_V270cr">solution</a><br/></div><div style="margin-left:3em"><a href="#_l0mUC8">task</a><br/></div><div style="margin-left:2em"><a href="#_8rshcv">article</a><br/></div><div style="margin-left:1em"><strong>types</strong><br/></div><div style="margin-left:2em"><strong>string-quotes</strong><br/></div><div style="margin-left:3em"><a href="#_vMBmUD">solution</a><br/></div><div style="margin-left:3em"><a href="#_SORW9X">task</a><br/></div><div style="margin-left:2em"><a href="#_tVvOhQ">article</a><br/></div><div style="margin-left:1em"><strong>alert-prompt-confirm</strong><br/></div><div style="margin-left:2em"><strong>simple-page</strong><br/></div><div style="margin-left:3em"><a href="#_9fF1hv">solution</a><br/></div><div style="margin-left:3em"><a href="#_8uCN7h">task</a><br/></div><div style="margin-left:2em"><a href="#_8f1K8U">article</a><br/></div><div style="margin-left:1em"><strong>type-conversions</strong><br/></div><div style="margin-left:2em"><a href="#_y8MyRC">article</a><br/></div><div style="margin-left:1em"><strong>operators</strong><br/></div><div style="margin-left:2em"><strong>increment-order</strong><br/></div><div style="margin-left:3em"><a href="#_NZNRKZ">solution</a><br/></div><div style="margin-left:3em"><a href="#_B0PlKf">task</a><br/></div><div style="margin-left:2em"><strong>assignment-result</strong><br/></div><div style="margin-left:3em"><a href="#_HyH0xt">solution</a><br/></div><div style="margin-left:3em"><a href="#_88oiGN">task</a><br/></div><div style="margin-left:2em"><strong>primitive-conversions-questions</strong><br/></div><div style="margin-left:3em"><a href="#_Q9Rky1">solution</a><br/></div><div style="margin-left:3em"><a href="#_IGZXiZ">task</a><br/></div><div style="margin-left:2em"><strong>fix-prompt</strong><br/></div><div style="margin-left:3em"><a href="#_911s06">solution</a><br/></div><div style="margin-left:3em"><a href="#_ayoYcn">task</a><br/></div><div style="margin-left:2em"><a href="#_o7ERDQ">article</a><br/></div><div style="margin-left:1em"><strong>comparison</strong><br/></div><div style="margin-left:2em"><strong>comparison-questions</strong><br/></div><div style="margin-left:3em"><a href="#_cKj2rW">solution</a><br/></div><div style="margin-left:3em"><a href="#_92L5AQ">task</a><br/></div><div style="margin-left:2em"><a href="#_AzJTmQ">article</a><br/></div><div style="margin-left:1em"><strong>ifelse</strong><br/></div><div style="margin-left:2em"><strong>if-zero-string</strong><br/></div><div style="margin-left:3em"><a href="#_4fqtfC">solution</a><br/></div><div style="margin-left:3em"><a href="#_1lbmPd">task</a><br/></div><div style="margin-left:2em"><strong>check-standard</strong><br/></div><div style="margin-left:3em"><strong>ifelse_task2</strong><br/></div><div style="margin-left:3em"><a href="#_gxTunO">solution</a><br/></div><div style="margin-left:3em"><a href="#_O736GF">task</a><br/></div><div style="margin-left:2em"><strong>sign</strong><br/></div><div style="margin-left:3em"><strong>if_sign</strong><br/></div><div style="margin-left:3em"><a href="#_MbBmj9">solution</a><br/></div><div style="margin-left:3em"><a href="#_qjDjC8">task</a><br/></div><div style="margin-left:2em"><strong>rewrite-if-question</strong><br/></div><div style="margin-left:3em"><a href="#_qFb7XY">solution</a><br/></div><div style="margin-left:3em"><a href="#_DzikgU">task</a><br/></div><div style="margin-left:2em"><strong>rewrite-if-else-question</strong><br/></div><div style="margin-left:3em"><a href="#_2GtWnS">solution</a><br/></div><div style="margin-left:3em"><a href="#_7IrjKj">task</a><br/></div><div style="margin-left:2em"><a href="#_ba9z6c">article</a><br/></div><div style="margin-left:1em"><strong>logical-operators</strong><br/></div><div style="margin-left:2em"><strong>alert-null-undefined</strong><br/></div><div style="margin-left:3em"><a href="#_eM5Tjr">solution</a><br/></div><div style="margin-left:3em"><a href="#_dZ4myb">task</a><br/></div><div style="margin-left:2em"><strong>alert-or</strong><br/></div><div style="margin-left:3em"><a href="#_2SDKNa">solution</a><br/></div><div style="margin-left:3em"><a href="#_aqrsjb">task</a><br/></div><div style="margin-left:2em"><strong>alert-null-2</strong><br/></div><div style="margin-left:3em"><a href="#_g1TXtW">solution</a><br/></div><div style="margin-left:3em"><a href="#_oJZ9Ct">task</a><br/></div><div style="margin-left:2em"><strong>alert-and</strong><br/></div><div style="margin-left:3em"><a href="#_pgfKQD">solution</a><br/></div><div style="margin-left:3em"><a href="#_lZU49S">task</a><br/></div><div style="margin-left:2em"><strong>alert-and-or</strong><br/></div><div style="margin-left:3em"><a href="#_LGaTzV">solution</a><br/></div><div style="margin-left:3em"><a href="#_cliDD5">task</a><br/></div><div style="margin-left:2em"><strong>check-if-in-range</strong><br/></div><div style="margin-left:3em"><a href="#_z2VvFn">solution</a><br/></div><div style="margin-left:3em"><a href="#_BsQnr9">task</a><br/></div><div style="margin-left:2em"><strong>check-if-out-range</strong><br/></div><div style="margin-left:3em"><a href="#_52j2QO">solution</a><br/></div><div style="margin-left:3em"><a href="#_Rez5AT">task</a><br/></div><div style="margin-left:2em"><strong>if-question</strong><br/></div><div style="margin-left:3em"><a href="#_XzJU18">solution</a><br/></div><div style="margin-left:3em"><a href="#_0KRRm3">task</a><br/></div><div style="margin-left:2em"><strong>check-login</strong><br/></div><div style="margin-left:3em"><a href="#_gDXKqb">solution</a><br/></div><div style="margin-left:3em"><a href="#_lFLSaW">task</a><br/></div><div style="margin-left:2em"><a href="#_Mjg4AR">article</a><br/></div><div style="margin-left:1em"><strong>nullish-coalescing-operator</strong><br/></div><div style="margin-left:2em"><a href="#_kaaOPq">article</a><br/></div><div style="margin-left:1em"><strong>while-for</strong><br/></div><div style="margin-left:2em"><strong>loop-last-value</strong><br/></div><div style="margin-left:3em"><a href="#_iKyDWM">solution</a><br/></div><div style="margin-left:3em"><a href="#_4BqFui">task</a><br/></div><div style="margin-left:2em"><strong>which-value-while</strong><br/></div><div style="margin-left:3em"><a href="#_mOWrfW">solution</a><br/></div><div style="margin-left:3em"><a href="#_5f5iuN">task</a><br/></div><div style="margin-left:2em"><strong>which-value-for</strong><br/></div><div style="margin-left:3em"><a href="#_e6AA6P">solution</a><br/></div><div style="margin-left:3em"><a href="#_gdhxZe">task</a><br/></div><div style="margin-left:2em"><strong>for-even</strong><br/></div><div style="margin-left:3em"><a href="#_FCXq0R">solution</a><br/></div><div style="margin-left:3em"><a href="#_a1bgQU">task</a><br/></div><div style="margin-left:2em"><strong>replace-for-while</strong><br/></div><div style="margin-left:3em"><a href="#_SgP0YW">solution</a><br/></div><div style="margin-left:3em"><a href="#_HB6hNk">task</a><br/></div><div style="margin-left:2em"><strong>repeat-until-correct</strong><br/></div><div style="margin-left:3em"><a href="#_FMQqpd">solution</a><br/></div><div style="margin-left:3em"><a href="#_HM5bdF">task</a><br/></div><div style="margin-left:2em"><strong>list-primes</strong><br/></div><div style="margin-left:3em"><a href="#_ADwnjB">solution</a><br/></div><div style="margin-left:3em"><a href="#_3BXKQC">task</a><br/></div><div style="margin-left:2em"><a href="#_y7trOL">article</a><br/></div><div style="margin-left:1em"><strong>switch</strong><br/></div><div style="margin-left:2em"><strong>rewrite-switch-if-else</strong><br/></div><div style="margin-left:3em"><a href="#_cUrL74">solution</a><br/></div><div style="margin-left:3em"><a href="#_heDWyL">task</a><br/></div><div style="margin-left:2em"><strong>rewrite-if-switch</strong><br/></div><div style="margin-left:3em"><a href="#_FyTGBU">solution</a><br/></div><div style="margin-left:3em"><a href="#_VMfcC8">task</a><br/></div><div style="margin-left:2em"><a href="#_BTjRuu">article</a><br/></div><div style="margin-left:1em"><strong>function-basics</strong><br/></div><div style="margin-left:2em"><strong>if-else-required</strong><br/></div><div style="margin-left:3em"><a href="#_aiBrnX">solution</a><br/></div><div style="margin-left:3em"><a href="#_RZpVp3">task</a><br/></div><div style="margin-left:2em"><strong>rewrite-function-question-or</strong><br/></div><div style="margin-left:3em"><a href="#_4vkMPc">solution</a><br/></div><div style="margin-left:3em"><a href="#_GZORIi">task</a><br/></div><div style="margin-left:2em"><strong>min</strong><br/></div><div style="margin-left:3em"><a href="#_eVH2ib">solution</a><br/></div><div style="margin-left:3em"><a href="#_I9Ebl2">task</a><br/></div><div style="margin-left:2em"><strong>pow</strong><br/></div><div style="margin-left:3em"><a href="#_asHjbj">solution</a><br/></div><div style="margin-left:3em"><a href="#_6cvBrW">task</a><br/></div><div style="margin-left:2em"><a href="#_N1RnY8">article</a><br/></div><div style="margin-left:1em"><strong>function-expressions</strong><br/></div><div style="margin-left:2em"><a href="#_do5TPj">article</a><br/></div><div style="margin-left:1em"><strong>arrow-functions-basics</strong><br/></div><div style="margin-left:2em"><strong>rewrite-arrow</strong><br/></div><div style="margin-left:3em"><a href="#_5RIeqp">solution</a><br/></div><div style="margin-left:3em"><a href="#_qOJ4uH">task</a><br/></div><div style="margin-left:2em"><a href="#_bcef69">article</a><br/></div><div style="margin-left:1em"><strong>javascript-specials</strong><br/></div><div style="margin-left:2em"><a href="#_5xOoHg">article</a><br/></div><div style="margin-left:0em"><strong>code-quality</strong><br/></div><div style="margin-left:1em"><strong>debugging-chrome</strong><br/></div><div style="margin-left:2em"><a href="#_VaoaOM">article</a><br/></div><div style="margin-left:1em"><strong>coding-style</strong><br/></div><div style="margin-left:2em"><strong>style-errors</strong><br/></div><div style="margin-left:3em"><a href="#_Lwhxxn">solution</a><br/></div><div style="margin-left:3em"><a href="#_jufgcU">task</a><br/></div><div style="margin-left:2em"><a href="#_kYODsv">article</a><br/></div><div style="margin-left:1em"><strong>comments</strong><br/></div><div style="margin-left:2em"><a href="#_QLacYV">article</a><br/></div><div style="margin-left:1em"><strong>ninja-code</strong><br/></div><div style="margin-left:2em"><a href="#_fCHZuR">article</a><br/></div><div style="margin-left:1em"><strong>testing-mocha</strong><br/></div><div style="margin-left:2em"><strong>pow-test-wrong</strong><br/></div><div style="margin-left:3em"><a href="#_aYXwDN">solution</a><br/></div><div style="margin-left:3em"><a href="#_RRQ6LK">task</a><br/></div><div style="margin-left:2em"><a href="#_y3YFIN">article</a><br/></div><div style="margin-left:1em"><strong>polyfills</strong><br/></div><div style="margin-left:2em"><a href="#_hzL76F">article</a><br/></div><div style="margin-left:0em"><strong>object-basics</strong><br/></div><div style="margin-left:1em"><strong>object</strong><br/></div><div style="margin-left:2em"><strong>hello-object</strong><br/></div><div style="margin-left:3em"><a href="#_pGEHlw">solution</a><br/></div><div style="margin-left:3em"><a href="#_K4mOjB">task</a><br/></div><div style="margin-left:2em"><strong>is-empty</strong><br/></div><div style="margin-left:3em"><a href="#_KdxLcf">solution</a><br/></div><div style="margin-left:3em"><a href="#_k1GI7N">task</a><br/></div><div style="margin-left:2em"><strong>sum-object</strong><br/></div><div style="margin-left:3em"><a href="#_HJ3Rad">solution</a><br/></div><div style="margin-left:3em"><a href="#_RqXk8y">task</a><br/></div><div style="margin-left:2em"><strong>multiply-numeric</strong><br/></div><div style="margin-left:3em"><a href="#_dY4HOn">solution</a><br/></div><div style="margin-left:3em"><a href="#_EcCHZE">task</a><br/></div><div style="margin-left:2em"><a href="#_r1Gx5D">article</a><br/></div><div style="margin-left:1em"><strong>object-copy</strong><br/></div><div style="margin-left:2em"><a href="#_a1k3KR">article</a><br/></div><div style="margin-left:1em"><strong>garbage-collection</strong><br/></div><div style="margin-left:2em"><a href="#_ajvNsw">article</a><br/></div><div style="margin-left:1em"><strong>object-methods</strong><br/></div><div style="margin-left:2em"><strong>object-property-this</strong><br/></div><div style="margin-left:3em"><a href="#_tSZvgG">solution</a><br/></div><div style="margin-left:3em"><a href="#_UxN7CQ">task</a><br/></div><div style="margin-left:2em"><strong>calculator</strong><br/></div><div style="margin-left:3em"><a href="#_vji5Ac">solution</a><br/></div><div style="margin-left:3em"><a href="#_SMgbSX">task</a><br/></div><div style="margin-left:2em"><strong>chain-calls</strong><br/></div><div style="margin-left:3em"><a href="#_OcuYzc">solution</a><br/></div><div style="margin-left:3em"><a href="#_RaHq67">task</a><br/></div><div style="margin-left:2em"><a href="#_W901dW">article</a><br/></div><div style="margin-left:1em"><strong>constructor-new</strong><br/></div><div style="margin-left:2em"><strong>two-functions-one-object</strong><br/></div><div style="margin-left:3em"><a href="#_p6Ra1E">solution</a><br/></div><div style="margin-left:3em"><a href="#_3foPdB">task</a><br/></div><div style="margin-left:2em"><strong>calculator-constructor</strong><br/></div><div style="margin-left:3em"><a href="#_FvWKXn">solution</a><br/></div><div style="margin-left:3em"><a href="#_KECRzy">task</a><br/></div><div style="margin-left:2em"><strong>accumulator</strong><br/></div><div style="margin-left:3em"><a href="#_s3bB3M">solution</a><br/></div><div style="margin-left:3em"><a href="#_oueHyL">task</a><br/></div><div style="margin-left:2em"><a href="#_a4gEup">article</a><br/></div><div style="margin-left:1em"><strong>optional-chaining</strong><br/></div><div style="margin-left:2em"><a href="#_srtEQq">article</a><br/></div><div style="margin-left:1em"><strong>symbol</strong><br/></div><div style="margin-left:2em"><a href="#_MFkHAv">article</a><br/></div><div style="margin-left:1em"><strong>object-toprimitive</strong><br/></div><div style="margin-left:2em"><a href="#_ERtFfa">article</a><br/></div><div style="margin-left:0em"><strong>data-types</strong><br/></div><div style="margin-left:1em"><strong>primitives-methods</strong><br/></div><div style="margin-left:2em"><strong>string-new-property</strong><br/></div><div style="margin-left:3em"><a href="#_ebQK94">solution</a><br/></div><div style="margin-left:3em"><a href="#_575DK8">task</a><br/></div><div style="margin-left:2em"><a href="#_iWkwLF">article</a><br/></div><div style="margin-left:1em"><strong>number</strong><br/></div><div style="margin-left:2em"><strong>sum-interface</strong><br/></div><div style="margin-left:3em"><a href="#_ch3E1R">solution</a><br/></div><div style="margin-left:3em"><a href="#_Ysu62C">task</a><br/></div><div style="margin-left:2em"><strong>why-rounded-down</strong><br/></div><div style="margin-left:3em"><a href="#_5Nx2zN">solution</a><br/></div><div style="margin-left:3em"><a href="#_ro6Hz0">task</a><br/></div><div style="margin-left:2em"><strong>repeat-until-number</strong><br/></div><div style="margin-left:3em"><a href="#_056BKQ">solution</a><br/></div><div style="margin-left:3em"><a href="#_myebNQ">task</a><br/></div><div style="margin-left:2em"><strong>endless-loop-error</strong><br/></div><div style="margin-left:3em"><a href="#_zr8K0f">solution</a><br/></div><div style="margin-left:3em"><a href="#_SaZOD3">task</a><br/></div><div style="margin-left:2em"><strong>random-min-max</strong><br/></div><div style="margin-left:3em"><a href="#_4EdSOZ">solution</a><br/></div><div style="margin-left:3em"><a href="#_55ckhI">task</a><br/></div><div style="margin-left:2em"><strong>random-int-min-max</strong><br/></div><div style="margin-left:3em"><a href="#_21Mli3">solution</a><br/></div><div style="margin-left:3em"><a href="#_bd9sJ8">task</a><br/></div><div style="margin-left:2em"><a href="#_ZAbqko">article</a><br/></div><div style="margin-left:1em"><strong>string</strong><br/></div><div style="margin-left:2em"><strong>ucfirst</strong><br/></div><div style="margin-left:3em"><a href="#_oqKgPL">solution</a><br/></div><div style="margin-left:3em"><a href="#_BoT3Iw">task</a><br/></div><div style="margin-left:2em"><strong>check-spam</strong><br/></div><div style="margin-left:3em"><a href="#_1e10QI">solution</a><br/></div><div style="margin-left:3em"><a href="#_yPpf6u">task</a><br/></div><div style="margin-left:2em"><strong>truncate</strong><br/></div><div style="margin-left:3em"><a href="#_3eiQKg">solution</a><br/></div><div style="margin-left:3em"><a href="#_38f5zn">task</a><br/></div><div style="margin-left:2em"><strong>extract-currency</strong><br/></div><div style="margin-left:3em"><a href="#_aZxWrz">solution</a><br/></div><div style="margin-left:3em"><a href="#_PNk38j">task</a><br/></div><div style="margin-left:2em"><a href="#_TvaBRN">article</a><br/></div><div style="margin-left:1em"><strong>array</strong><br/></div><div style="margin-left:2em"><strong>item-value</strong><br/></div><div style="margin-left:3em"><a href="#_HqSH6k">solution</a><br/></div><div style="margin-left:3em"><a href="#_ScunOp">task</a><br/></div><div style="margin-left:2em"><strong>maximal-subarray</strong><br/></div><div style="margin-left:3em"><a href="#_EHyJQk">solution</a><br/></div><div style="margin-left:3em"><a href="#_ka0jLN">task</a><br/></div><div style="margin-left:2em"><strong>create-array</strong><br/></div><div style="margin-left:3em"><a href="#_2rXJxT">solution</a><br/></div><div style="margin-left:3em"><a href="#_g37DdH">task</a><br/></div><div style="margin-left:2em"><strong>call-array-this</strong><br/></div><div style="margin-left:3em"><a href="#_sU3YsI">solution</a><br/></div><div style="margin-left:3em"><a href="#_ewrx2I">task</a><br/></div><div style="margin-left:2em"><strong>array-input-sum</strong><br/></div><div style="margin-left:3em"><a href="#_EVjoWf">solution</a><br/></div><div style="margin-left:3em"><a href="#_lJO3al">task</a><br/></div><div style="margin-left:2em"><a href="#_95HHqF">article</a><br/></div><div style="margin-left:1em"><strong>array-methods</strong><br/></div><div style="margin-left:2em"><strong>camelcase</strong><br/></div><div style="margin-left:3em"><a href="#_pu2Jlt">solution</a><br/></div><div style="margin-left:3em"><a href="#_qSgukq">task</a><br/></div><div style="margin-left:2em"><strong>average-age</strong><br/></div><div style="margin-left:3em"><a href="#_WeLsAh">solution</a><br/></div><div style="margin-left:3em"><a href="#_Jpodvl">task</a><br/></div><div style="margin-left:2em"><strong>array-unique</strong><br/></div><div style="margin-left:3em"><a href="#_v4YvPl">solution</a><br/></div><div style="margin-left:3em"><a href="#_peghiL">task</a><br/></div><div style="margin-left:2em"><strong>reduce-object</strong><br/></div><div style="margin-left:3em"><a href="#_PVdz7Q">solution</a><br/></div><div style="margin-left:3em"><a href="#_UFheiM">task</a><br/></div><div style="margin-left:2em"><strong>filter-range</strong><br/></div><div style="margin-left:3em"><a href="#_9w47Up">solution</a><br/></div><div style="margin-left:3em"><a href="#_NoiGzU">task</a><br/></div><div style="margin-left:2em"><strong>filter-range-in-place</strong><br/></div><div style="margin-left:3em"><a href="#_nLVmR4">solution</a><br/></div><div style="margin-left:3em"><a href="#_qQ9EaY">task</a><br/></div><div style="margin-left:2em"><strong>sort-back</strong><br/></div><div style="margin-left:3em"><a href="#_EBwdoV">solution</a><br/></div><div style="margin-left:3em"><a href="#_0dA63x">task</a><br/></div><div style="margin-left:2em"><strong>copy-sort-array</strong><br/></div><div style="margin-left:3em"><a href="#_hI3C1q">solution</a><br/></div><div style="margin-left:3em"><a href="#_7PhXBe">task</a><br/></div><div style="margin-left:2em"><strong>array-get-names</strong><br/></div><div style="margin-left:3em"><a href="#_OYgmyP">solution</a><br/></div><div style="margin-left:3em"><a href="#_VTwNMS">task</a><br/></div><div style="margin-left:2em"><strong>calculator-extendable</strong><br/></div><div style="margin-left:3em"><a href="#_LTeAPh">solution</a><br/></div><div style="margin-left:3em"><a href="#_QCJcfL">task</a><br/></div><div style="margin-left:2em"><strong>map-objects</strong><br/></div><div style="margin-left:3em"><a href="#_4b0Fgh">solution</a><br/></div><div style="margin-left:3em"><a href="#_XiKmhc">task</a><br/></div><div style="margin-left:2em"><strong>sort-objects</strong><br/></div><div style="margin-left:3em"><a href="#_xRkvJs">solution</a><br/></div><div style="margin-left:3em"><a href="#_nOsOvN">task</a><br/></div><div style="margin-left:2em"><strong>shuffle</strong><br/></div><div style="margin-left:3em"><a href="#_Zg2Z5F">solution</a><br/></div><div style="margin-left:3em"><a href="#_pVYTWz">task</a><br/></div><div style="margin-left:2em"><a href="#_WWn86V">article</a><br/></div><div style="margin-left:1em"><strong>iterable</strong><br/></div><div style="margin-left:2em"><a href="#_lShotT">article</a><br/></div><div style="margin-left:1em"><strong>map-set</strong><br/></div><div style="margin-left:2em"><strong>array-unique-map</strong><br/></div><div style="margin-left:3em"><a href="#_rSdQHA">solution</a><br/></div><div style="margin-left:3em"><a href="#_7sVnqv">task</a><br/></div><div style="margin-left:2em"><strong>filter-anagrams</strong><br/></div><div style="margin-left:3em"><a href="#_wIg0O0">solution</a><br/></div><div style="margin-left:3em"><a href="#_9AzfDt">task</a><br/></div><div style="margin-left:2em"><strong>iterable-keys</strong><br/></div><div style="margin-left:3em"><a href="#_aM2aKA">solution</a><br/></div><div style="margin-left:3em"><a href="#_qPaJBb">task</a><br/></div><div style="margin-left:2em"><a href="#_sVAIhu">article</a><br/></div><div style="margin-left:1em"><strong>weakmap-weakset</strong><br/></div><div style="margin-left:2em"><strong>recipients-read</strong><br/></div><div style="margin-left:3em"><a href="#_RSTeFy">solution</a><br/></div><div style="margin-left:3em"><a href="#_osamvA">task</a><br/></div><div style="margin-left:2em"><strong>recipients-when-read</strong><br/></div><div style="margin-left:3em"><a href="#_qLao1a">solution</a><br/></div><div style="margin-left:3em"><a href="#_QBgti6">task</a><br/></div><div style="margin-left:2em"><a href="#_TfakZG">article</a><br/></div><div style="margin-left:1em"><strong>keys-values-entries</strong><br/></div><div style="margin-left:2em"><strong>sum-salaries</strong><br/></div><div style="margin-left:3em"><a href="#_N4tnjK">solution</a><br/></div><div style="margin-left:3em"><a href="#_DdV2GF">task</a><br/></div><div style="margin-left:2em"><strong>count-properties</strong><br/></div><div style="margin-left:3em"><a href="#_ecuGXI">solution</a><br/></div><div style="margin-left:3em"><a href="#_npvTbI">task</a><br/></div><div style="margin-left:2em"><a href="#_6yhlfW">article</a><br/></div><div style="margin-left:1em"><strong>destructuring-assignment</strong><br/></div><div style="margin-left:2em"><strong>destruct-user</strong><br/></div><div style="margin-left:3em"><a href="#_0VISCH">solution</a><br/></div><div style="margin-left:3em"><a href="#_Vf45Rq">task</a><br/></div><div style="margin-left:2em"><strong>max-salary</strong><br/></div><div style="margin-left:3em"><a href="#_4paCxP">solution</a><br/></div><div style="margin-left:3em"><a href="#_vxlF9g">task</a><br/></div><div style="margin-left:2em"><a href="#_OzdPvT">article</a><br/></div><div style="margin-left:1em"><strong>date</strong><br/></div><div style="margin-left:2em"><strong>new-date</strong><br/></div><div style="margin-left:3em"><a href="#_fpxAL7">solution</a><br/></div><div style="margin-left:3em"><a href="#_xoMleN">task</a><br/></div><div style="margin-left:2em"><strong>get-week-day</strong><br/></div><div style="margin-left:3em"><a href="#_6Vvi4K">solution</a><br/></div><div style="margin-left:3em"><a href="#_QJYUhN">task</a><br/></div><div style="margin-left:2em"><strong>weekday</strong><br/></div><div style="margin-left:3em"><a href="#_bymX7j">solution</a><br/></div><div style="margin-left:3em"><a href="#_ZsbdG4">task</a><br/></div><div style="margin-left:2em"><strong>get-date-ago</strong><br/></div><div style="margin-left:3em"><a href="#_3444am">solution</a><br/></div><div style="margin-left:3em"><a href="#_4sv6UC">task</a><br/></div><div style="margin-left:2em"><strong>last-day-of-month</strong><br/></div><div style="margin-left:3em"><a href="#_s84qXp">solution</a><br/></div><div style="margin-left:3em"><a href="#_mFzmM8">task</a><br/></div><div style="margin-left:2em"><strong>get-seconds-today</strong><br/></div><div style="margin-left:3em"><a href="#_84NVWm">solution</a><br/></div><div style="margin-left:3em"><a href="#_TKAjIo">task</a><br/></div><div style="margin-left:2em"><strong>get-seconds-to-tomorrow</strong><br/></div><div style="margin-left:3em"><a href="#_UgXS28">solution</a><br/></div><div style="margin-left:3em"><a href="#_IEEDoP">task</a><br/></div><div style="margin-left:2em"><strong>format-date-relative</strong><br/></div><div style="margin-left:3em"><a href="#_JiAZcC">solution</a><br/></div><div style="margin-left:3em"><a href="#_KPIzAq">task</a><br/></div><div style="margin-left:2em"><a href="#_Gz90Gh">article</a><br/></div><div style="margin-left:1em"><strong>json</strong><br/></div><div style="margin-left:2em"><strong>serialize-object</strong><br/></div><div style="margin-left:3em"><a href="#_VQOJoS">solution</a><br/></div><div style="margin-left:3em"><a href="#_YnNAAY">task</a><br/></div><div style="margin-left:2em"><strong>serialize-event-circular</strong><br/></div><div style="margin-left:3em"><a href="#_TgTM5G">solution</a><br/></div><div style="margin-left:3em"><a href="#_ue0Jg1">task</a><br/></div><div style="margin-left:2em"><a href="#_bTlFGE">article</a><br/></div><div style="margin-left:0em"><strong>advanced-functions</strong><br/></div><div style="margin-left:1em"><strong>recursion</strong><br/></div><div style="margin-left:2em"><strong>sum-to</strong><br/></div><div style="margin-left:3em"><a href="#_3NoglX">solution</a><br/></div><div style="margin-left:3em"><a href="#_vwZq1I">task</a><br/></div><div style="margin-left:2em"><strong>factorial</strong><br/></div><div style="margin-left:3em"><a href="#_WF29gw">solution</a><br/></div><div style="margin-left:3em"><a href="#_nDoDRS">task</a><br/></div><div style="margin-left:2em"><strong>fibonacci-numbers</strong><br/></div><div style="margin-left:3em"><a href="#_vCJdpS">solution</a><br/></div><div style="margin-left:3em"><a href="#_zodrVT">task</a><br/></div><div style="margin-left:2em"><strong>output-single-linked-list</strong><br/></div><div style="margin-left:3em"><a href="#_wkYv09">solution</a><br/></div><div style="margin-left:3em"><a href="#_dIFEJk">task</a><br/></div><div style="margin-left:2em"><strong>output-single-linked-list-reverse</strong><br/></div><div style="margin-left:3em"><a href="#_JfkvS7">solution</a><br/></div><div style="margin-left:3em"><a href="#_svp1S7">task</a><br/></div><div style="margin-left:2em"><a href="#_2P39dy">article</a><br/></div><div style="margin-left:1em"><strong>rest-parameters-spread</strong><br/></div><div style="margin-left:2em"><a href="#_ta1Ddm">article</a><br/></div><div style="margin-left:1em"><strong>closure</strong><br/></div><div style="margin-left:2em"><strong>closure-latest-changes</strong><br/></div><div style="margin-left:3em"><a href="#_Hw0qMo">solution</a><br/></div><div style="margin-left:3em"><a href="#_MMawPg">task</a><br/></div><div style="margin-left:2em"><strong>make-army</strong><br/></div><div style="margin-left:3em"><a href="#_KTfQQQ">solution</a><br/></div><div style="margin-left:3em"><a href="#_nWuTRC">task</a><br/></div><div style="margin-left:2em"><strong>closure-variable-access</strong><br/></div><div style="margin-left:3em"><a href="#_vKsn35">solution</a><br/></div><div style="margin-left:3em"><a href="#_agPl6k">task</a><br/></div><div style="margin-left:2em"><strong>counter-independent</strong><br/></div><div style="margin-left:3em"><a href="#_m6W5vr">solution</a><br/></div><div style="margin-left:3em"><a href="#_DS2Z6j">task</a><br/></div><div style="margin-left:2em"><strong>counter-object-independent</strong><br/></div><div style="margin-left:3em"><a href="#_egmyQZ">solution</a><br/></div><div style="margin-left:3em"><a href="#_MDpjbW">task</a><br/></div><div style="margin-left:2em"><strong>function-in-if</strong><br/></div><div style="margin-left:3em"><a href="#_bAHNsS">solution</a><br/></div><div style="margin-left:3em"><a href="#_ZBJNN0">task</a><br/></div><div style="margin-left:2em"><strong>closure-sum</strong><br/></div><div style="margin-left:3em"><a href="#_9Pw602">solution</a><br/></div><div style="margin-left:3em"><a href="#_gKFutt">task</a><br/></div><div style="margin-left:2em"><strong>let-scope</strong><br/></div><div style="margin-left:3em"><a href="#_hrP4rI">solution</a><br/></div><div style="margin-left:3em"><a href="#_PMuh7l">task</a><br/></div><div style="margin-left:2em"><strong>filter-through-function</strong><br/></div><div style="margin-left:3em"><a href="#_yfTN2f">solution</a><br/></div><div style="margin-left:3em"><a href="#_fohcp1">task</a><br/></div><div style="margin-left:2em"><strong>sort-by-field</strong><br/></div><div style="margin-left:3em"><a href="#_9RZeg8">solution</a><br/></div><div style="margin-left:3em"><a href="#_9iVNUX">task</a><br/></div><div style="margin-left:2em"><a href="#_nxyYKB">article</a><br/></div><div style="margin-left:1em"><strong>var</strong><br/></div><div style="margin-left:2em"><a href="#_L7unjB">article</a><br/></div><div style="margin-left:1em"><strong>global-object</strong><br/></div><div style="margin-left:2em"><a href="#_NFsfiw">article</a><br/></div><div style="margin-left:1em"><strong>function-object</strong><br/></div><div style="margin-left:2em"><strong>counter-inc-dec</strong><br/></div><div style="margin-left:3em"><a href="#_qPOET0">solution</a><br/></div><div style="margin-left:2em"><strong>sum-many-brackets</strong><br/></div><div style="margin-left:3em"><a href="#_khWGTc">solution</a><br/></div><div style="margin-left:3em"><a href="#_TabftG">task</a><br/></div><div style="margin-left:2em"><a href="#_9ACjmX">article</a><br/></div><div style="margin-left:1em"><strong>new-function</strong><br/></div><div style="margin-left:2em"><a href="#_dP5jms">article</a><br/></div><div style="margin-left:1em"><strong>settimeout-setinterval</strong><br/></div><div style="margin-left:2em"><strong>output-numbers-100ms</strong><br/></div><div style="margin-left:3em"><a href="#_i96cle">solution</a><br/></div><div style="margin-left:3em"><a href="#_uPeaa7">task</a><br/></div><div style="margin-left:2em"><strong>settimeout-result</strong><br/></div><div style="margin-left:3em"><a href="#_ROC9IG">solution</a><br/></div><div style="margin-left:3em"><a href="#_xaJPT3">task</a><br/></div><div style="margin-left:2em"><a href="#_ALiG5M">article</a><br/></div><div style="margin-left:1em"><strong>call-apply-decorators</strong><br/></div><div style="margin-left:2em"><strong>spy-decorator</strong><br/></div><div style="margin-left:3em"><a href="#_6WH7qz">solution</a><br/></div><div style="margin-left:3em"><a href="#_CFrhNY">task</a><br/></div><div style="margin-left:2em"><strong>delay</strong><br/></div><div style="margin-left:3em"><a href="#_keOLd0">solution</a><br/></div><div style="margin-left:3em"><a href="#_whoriu">task</a><br/></div><div style="margin-left:2em"><strong>debounce</strong><br/></div><div style="margin-left:3em"><a href="#_9QwH2g">solution</a><br/></div><div style="margin-left:3em"><a href="#_g9wyOJ">task</a><br/></div><div style="margin-left:2em"><strong>throttle</strong><br/></div><div style="margin-left:3em"><a href="#_zNuN9Z">solution</a><br/></div><div style="margin-left:3em"><a href="#_wTighd">task</a><br/></div><div style="margin-left:2em"><a href="#_IdmuXm">article</a><br/></div><div style="margin-left:1em"><strong>bind</strong><br/></div><div style="margin-left:2em"><strong>write-to-object-after-bind</strong><br/></div><div style="margin-left:3em"><a href="#_grvCHX">solution</a><br/></div><div style="margin-left:3em"><a href="#_SOaeYe">task</a><br/></div><div style="margin-left:2em"><strong>second-bind</strong><br/></div><div style="margin-left:3em"><a href="#_XCcK9J">solution</a><br/></div><div style="margin-left:3em"><a href="#_3yjKq7">task</a><br/></div><div style="margin-left:2em"><strong>function-property-after-bind</strong><br/></div><div style="margin-left:3em"><a href="#_aC1Zzf">solution</a><br/></div><div style="margin-left:3em"><a href="#_KeureU">task</a><br/></div><div style="margin-left:2em"><strong>question-use-bind</strong><br/></div><div style="margin-left:3em"><a href="#_4Pet8f">solution</a><br/></div><div style="margin-left:3em"><a href="#_v5fXRd">task</a><br/></div><div style="margin-left:2em"><strong>ask-partial</strong><br/></div><div style="margin-left:3em"><a href="#_pYEUcU">solution</a><br/></div><div style="margin-left:3em"><a href="#_yEdfXb">task</a><br/></div><div style="margin-left:2em"><a href="#_aEbG06">article</a><br/></div><div style="margin-left:1em"><strong>arrow-functions</strong><br/></div><div style="margin-left:2em"><a href="#_7q2F80">article</a><br/></div><div style="margin-left:0em"><strong>object-properties</strong><br/></div><div style="margin-left:1em"><strong>property-descriptors</strong><br/></div><div style="margin-left:2em"><a href="#_nzHyDj">article</a><br/></div><div style="margin-left:1em"><strong>property-accessors</strong><br/></div><div style="margin-left:2em"><a href="#_a315kB">article</a><br/></div><div style="margin-left:0em"><strong>prototypes</strong><br/></div><div style="margin-left:1em"><strong>prototype-inheritance</strong><br/></div><div style="margin-left:2em"><strong>property-after-delete</strong><br/></div><div style="margin-left:3em"><a href="#_E8Soxe">solution</a><br/></div><div style="margin-left:3em"><a href="#_amKbkC">task</a><br/></div><div style="margin-left:2em"><strong>search-algorithm</strong><br/></div><div style="margin-left:3em"><a href="#_L1apid">solution</a><br/></div><div style="margin-left:3em"><a href="#_ILvRjH">task</a><br/></div><div style="margin-left:2em"><strong>proto-and-this</strong><br/></div><div style="margin-left:3em"><a href="#_YFvhP5">solution</a><br/></div><div style="margin-left:3em"><a href="#_PbF2nS">task</a><br/></div><div style="margin-left:2em"><strong>hamster-proto</strong><br/></div><div style="margin-left:3em"><a href="#_NVvCw8">solution</a><br/></div><div style="margin-left:3em"><a href="#_SAR43l">task</a><br/></div><div style="margin-left:2em"><a href="#_vzMnCk">article</a><br/></div><div style="margin-left:1em"><strong>function-prototype</strong><br/></div><div style="margin-left:2em"><strong>changing-prototype</strong><br/></div><div style="margin-left:3em"><a href="#_cDgeNI">solution</a><br/></div><div style="margin-left:3em"><a href="#_1qgeWt">task</a><br/></div><div style="margin-left:2em"><strong>new-object-same-constructor</strong><br/></div><div style="margin-left:3em"><a href="#_hmBqqs">solution</a><br/></div><div style="margin-left:3em"><a href="#_1vJxgA">task</a><br/></div><div style="margin-left:2em"><a href="#_KPTL97">article</a><br/></div><div style="margin-left:1em"><strong>native-prototypes</strong><br/></div><div style="margin-left:2em"><strong>defer-to-prototype</strong><br/></div><div style="margin-left:3em"><a href="#_Lrktk5">solution</a><br/></div><div style="margin-left:3em"><a href="#_uXm82o">task</a><br/></div><div style="margin-left:2em"><strong>defer-to-prototype-extended</strong><br/></div><div style="margin-left:3em"><a href="#_eU2NYp">solution</a><br/></div><div style="margin-left:3em"><a href="#_6gBmRK">task</a><br/></div><div style="margin-left:2em"><a href="#_IEqJnQ">article</a><br/></div><div style="margin-left:1em"><strong>prototype-methods</strong><br/></div><div style="margin-left:2em"><strong>dictionary-tostring</strong><br/></div><div style="margin-left:3em"><a href="#_ZuY1uU">solution</a><br/></div><div style="margin-left:3em"><a href="#_BKRgwh">task</a><br/></div><div style="margin-left:2em"><strong>compare-calls</strong><br/></div><div style="margin-left:3em"><a href="#_8sTMoz">solution</a><br/></div><div style="margin-left:3em"><a href="#_K9gaZy">task</a><br/></div><div style="margin-left:2em"><a href="#_RnjbGc">article</a><br/></div><div style="margin-left:0em"><strong>classes</strong><br/></div><div style="margin-left:1em"><strong>class</strong><br/></div><div style="margin-left:2em"><strong>rewrite-to-class</strong><br/></div><div style="margin-left:3em"><a href="#_AG2vth">solution</a><br/></div><div style="margin-left:3em"><a href="#_iBSr6I">task</a><br/></div><div style="margin-left:2em"><a href="#_YA8FON">article</a><br/></div><div style="margin-left:1em"><strong>class-inheritance</strong><br/></div><div style="margin-left:2em"><strong>class-constructor-error</strong><br/></div><div style="margin-left:3em"><a href="#_KQ255E">solution</a><br/></div><div style="margin-left:3em"><a href="#_xHytE5">task</a><br/></div><div style="margin-left:2em"><strong>clock-class-extended</strong><br/></div><div style="margin-left:3em"><a href="#_7iD6Q2">solution</a><br/></div><div style="margin-left:3em"><a href="#_ZUfuNE">task</a><br/></div><div style="margin-left:2em"><a href="#_GR6Q9o">article</a><br/></div><div style="margin-left:1em"><strong>static-properties-methods</strong><br/></div><div style="margin-left:2em"><strong>class-extend-object</strong><br/></div><div style="margin-left:3em"><a href="#_NUzcpO">solution</a><br/></div><div style="margin-left:3em"><a href="#_FME0UA">task</a><br/></div><div style="margin-left:2em"><a href="#_A74fI9">article</a><br/></div><div style="margin-left:1em"><strong>private-protected-properties-methods</strong><br/></div><div style="margin-left:2em"><a href="#_kIojnS">article</a><br/></div><div style="margin-left:1em"><strong>extend-natives</strong><br/></div><div style="margin-left:2em"><a href="#_glf6NV">article</a><br/></div><div style="margin-left:1em"><strong>instanceof</strong><br/></div><div style="margin-left:2em"><strong>strange-instanceof</strong><br/></div><div style="margin-left:3em"><a href="#_o90nC0">solution</a><br/></div><div style="margin-left:3em"><a href="#_RMbyJo">task</a><br/></div><div style="margin-left:2em"><a href="#_HKmy8y">article</a><br/></div><div style="margin-left:1em"><strong>mixins</strong><br/></div><div style="margin-left:2em"><a href="#_U01WN7">article</a><br/></div><div style="margin-left:0em"><strong>error-handling</strong><br/></div><div style="margin-left:1em"><strong>try-catch</strong><br/></div><div style="margin-left:2em"><strong>finally-or-code-after</strong><br/></div><div style="margin-left:3em"><a href="#_0e1Vxe">solution</a><br/></div><div style="margin-left:3em"><a href="#_Ka3vaq">task</a><br/></div><div style="margin-left:2em"><a href="#_ioBFzS">article</a><br/></div><div style="margin-left:1em"><strong>custom-errors</strong><br/></div><div style="margin-left:2em"><strong>format-error</strong><br/></div><div style="margin-left:3em"><a href="#_JeDwek">solution</a><br/></div><div style="margin-left:3em"><a href="#_Z3O7wD">task</a><br/></div><div style="margin-left:2em"><a href="#_0wHw8y">article</a><br/></div><div style="margin-left:0em"><strong>async</strong><br/></div><div style="margin-left:1em"><strong>callbacks</strong><br/></div><div style="margin-left:2em"><strong>animate-circle-callback</strong><br/></div><div style="margin-left:3em"><a href="#_rFZ4N4">solution</a><br/></div><div style="margin-left:3em"><a href="#_153rRp">task</a><br/></div><div style="margin-left:2em"><a href="#_FTUwL8">article</a><br/></div><div style="margin-left:1em"><strong>promise-basics</strong><br/></div><div style="margin-left:2em"><strong>re-resolve</strong><br/></div><div style="margin-left:3em"><a href="#_FsriLl">solution</a><br/></div><div style="margin-left:3em"><a href="#_ZcSdnp">task</a><br/></div><div style="margin-left:2em"><strong>delay-promise</strong><br/></div><div style="margin-left:3em"><a href="#_B6DS3u">solution</a><br/></div><div style="margin-left:3em"><a href="#_Du8bue">task</a><br/></div><div style="margin-left:2em"><strong>animate-circle-promise</strong><br/></div><div style="margin-left:3em"><a href="#_8jZZ29">solution</a><br/></div><div style="margin-left:3em"><a href="#_tub8Lx">task</a><br/></div><div style="margin-left:2em"><a href="#_B1Whbw">article</a><br/></div><div style="margin-left:1em"><strong>promise-chaining</strong><br/></div><div style="margin-left:2em"><strong>then-vs-catch</strong><br/></div><div style="margin-left:3em"><a href="#_a6ZSHx">solution</a><br/></div><div style="margin-left:3em"><a href="#_IamoU8">task</a><br/></div><div style="margin-left:2em"><a href="#_5hdPxa">article</a><br/></div><div style="margin-left:1em"><strong>promise-error-handling</strong><br/></div><div style="margin-left:2em"><strong>error-async</strong><br/></div><div style="margin-left:3em"><a href="#_4EiQXP">solution</a><br/></div><div style="margin-left:3em"><a href="#_y0P1Fv">task</a><br/></div><div style="margin-left:2em"><a href="#_GO90M2">article</a><br/></div><div style="margin-left:1em"><strong>promise-api</strong><br/></div><div style="margin-left:2em"><a href="#_der34G">article</a><br/></div><div style="margin-left:1em"><strong>promisify</strong><br/></div><div style="margin-left:2em"><a href="#_2D0JFc">article</a><br/></div><div style="margin-left:1em"><strong>microtask-queue</strong><br/></div><div style="margin-left:2em"><a href="#_rlRdvX">article</a><br/></div><div style="margin-left:1em"><strong>async-await</strong><br/></div><div style="margin-left:2em"><strong>rewrite-async</strong><br/></div><div style="margin-left:3em"><a href="#_J94pyF">solution</a><br/></div><div style="margin-left:3em"><a href="#_ass6IP">task</a><br/></div><div style="margin-left:2em"><strong>rewrite-async-2</strong><br/></div><div style="margin-left:3em"><a href="#_fAfVJr">solution</a><br/></div><div style="margin-left:3em"><a href="#_edMza1">task</a><br/></div><div style="margin-left:2em"><strong>async-from-regular</strong><br/></div><div style="margin-left:3em"><a href="#_dkb0Z4">solution</a><br/></div><div style="margin-left:3em"><a href="#_YFR40B">task</a><br/></div><div style="margin-left:2em"><a href="#_Jd6g7l">article</a><br/></div><div style="margin-left:0em"><strong>generators-iterators</strong><br/></div><div style="margin-left:1em"><strong>generators</strong><br/></div><div style="margin-left:2em"><strong>pseudo-random-generator</strong><br/></div><div style="margin-left:3em"><a href="#_bPGEfc">solution</a><br/></div><div style="margin-left:3em"><a href="#_IXxJsz">task</a><br/></div><div style="margin-left:2em"><a href="#_kxcHGr">article</a><br/></div><div style="margin-left:1em"><strong>async-iterators-generators</strong><br/></div><div style="margin-left:2em"><a href="#_QBuHBA">article</a><br/></div><div style="margin-left:0em"><strong>modules</strong><br/></div><div style="margin-left:1em"><strong>modules-intro</strong><br/></div><div style="margin-left:2em"><a href="#_m9xV5R">article</a><br/></div><div style="margin-left:1em"><strong>import-export</strong><br/></div><div style="margin-left:2em"><a href="#_4Y84gv">article</a><br/></div><div style="margin-left:1em"><strong>modules-dynamic-imports</strong><br/></div><div style="margin-left:2em"><a href="#_lvhtP5">article</a><br/></div><div style="margin-left:0em"><strong>js-misc</strong><br/></div><div style="margin-left:1em"><strong>proxy</strong><br/></div><div style="margin-left:2em"><strong>error-nonexisting</strong><br/></div><div style="margin-left:3em"><a href="#_8wk2G5">solution</a><br/></div><div style="margin-left:3em"><a href="#_gbSXtd">task</a><br/></div><div style="margin-left:2em"><strong>array-negative</strong><br/></div><div style="margin-left:3em"><a href="#_L7MXCw">solution</a><br/></div><div style="margin-left:3em"><a href="#_Y4nQiH">task</a><br/></div><div style="margin-left:2em"><strong>observable</strong><br/></div><div style="margin-left:3em"><a href="#_Vw0GhL">solution</a><br/></div><div style="margin-left:3em"><a href="#_6eIY1s">task</a><br/></div><div style="margin-left:2em"><a href="#_sMOOAi">article</a><br/></div><div style="margin-left:1em"><strong>eval</strong><br/></div><div style="margin-left:2em"><strong>eval-calculator</strong><br/></div><div style="margin-left:3em"><a href="#_hYvUlp">solution</a><br/></div><div style="margin-left:3em"><a href="#_hqWBoK">task</a><br/></div><div style="margin-left:2em"><a href="#_J8fmyV">article</a><br/></div><div style="margin-left:1em"><strong>currying-partials</strong><br/></div><div style="margin-left:2em"><a href="#_0lX4Fc">article</a><br/></div><div style="margin-left:1em"><strong>reference-type</strong><br/></div><div style="margin-left:2em"><strong>check-syntax</strong><br/></div><div style="margin-left:3em"><a href="#_ITYSX7">solution</a><br/></div><div style="margin-left:3em"><a href="#_bFq39v">task</a><br/></div><div style="margin-left:2em"><strong>why-this</strong><br/></div><div style="margin-left:3em"><a href="#_hESzcV">solution</a><br/></div><div style="margin-left:3em"><a href="#_5vjb84">task</a><br/></div><div style="margin-left:2em"><a href="#_9P6uyl">article</a><br/></div><div style="margin-left:1em"><strong>bigint</strong><br/></div><div style="margin-left:2em"><a href="#_003RpC">article</a><br/></div></div>
</body></html>