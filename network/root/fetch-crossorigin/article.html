<h1 id="fetch：跨源请求">Fetch：跨源请求</h1>
<p>如果我们向另一个网站发送 <code>fetch</code> 请求，则该请求可能会失败。</p>
<p>例如，让我们尝试向 <code>http://example.com</code> 发送 <code>fetch</code> 请求：</p>
<pre><code class="language-js"><span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;http://example.com&#x27;</span>);
} <span class="hljs-keyword">catch</span>(err) {
  alert(err); <span class="hljs-comment">// fetch 失败</span>
}</code></pre>
<p>正如所料，获取失败。</p>
<p>这里的核心概念是 <strong>源（origin）</strong>—— 域（domain）/端口（port）/协议（protocol）的组合。</p>
<p>跨源请求 —— 那些发送到其他域（即使是子域）、协议或端口的请求 —— 需要来自远程端的特殊 header。</p>
<p>这个策略被称为 &quot;CORS&quot;：跨源资源共享（Cross-Origin Resource Sharing）。</p>
<h2 id="为什么需要-cors？跨源请求简史">为什么需要 CORS？跨源请求简史</h2>
<p>CORS 的存在是为了保护互联网免受黑客攻击。</p>
<p>说真的，在这说点儿题外话，讲讲它的历史。</p>
<p><strong>多年来，来自一个网站的脚本无法访问另一个网站的内容。</strong></p>
<p>这个简单有力的规则是互联网安全的基础。例如，来自 <code>hacker.com</code> 的脚本无法访问 <code>gmail.com</code> 上的用户邮箱。基于这样的规则，人们感到很安全。</p>
<p>在那时候，JavaScript 并没有任何特殊的执行网络请求的方法。它只是一种用来装饰网页的玩具语言而已。</p>
<p>但是 Web 开发人员需要更多功能。人们发明了各种各样的技巧去突破该限制，并向其他网站发出请求。</p>
<h3 id="使用表单">使用表单</h3>
<p>其中一种和其他服务器通信的方法是在那里提交一个 <code>&lt;form&gt;</code>。人们将它提交到 <code>&lt;iframe&gt;</code>，只是为了停留在当前页面，像这样：</p>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 表单目标 --&gt;</span>
*!*
<span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;iframe&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span>
*/!*

<span class="hljs-comment">&lt;!-- 表单可以由 JavaScript 动态生成并提交 --&gt;</span>
*!*
<span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;iframe&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://another.com/…&quot;</span>&gt;</span>
*/!*
  ...
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre>
<p>因此，即使没有网络方法，也可以向其他网站发出 GET/POST 请求，因为表单可以将数据发送到任何地方。但是由于禁止从其他网站访问 <code>&lt;iframe&gt;</code> 中的内容，因此就无法读取响应。</p>
<p>确切地说，实际上有一些技巧能够解决这个问题，这在 iframe 和页面中都需要添加特殊脚本。因此，与 iframe 的通信在技术上是可能的。现在我们没必要讲其细节内容，我们还是让这些古董代码不要再出现了吧。</p>
<h3 id="使用-script">使用 script</h3>
<p>另一个技巧是使用 <code>script</code> 标签。<code>script</code> 可以具有任何域的 <code>src</code>，例如 <code>&lt;script src=&quot;http://another.com/…&quot;&gt;</code>。也可以执行来自任何网站的 <code>script</code>。</p>
<p>如果一个网站，例如 <code>another.com</code> 试图公开这种访问方式的数据，则会使用所谓的 &quot;JSONP (JSON with padding)&quot; 协议。</p>
<p>这是它的工作方式。</p>
<p>假设在我们的网站，需要以这种方式从 <code>http://another.com</code> 网站获取数据，例如天气：</p>
<ol>
<li><p>首先，我们先声明一个全局函数来接收数据，例如 <code>gotWeather</code>。</p>
<pre><code class="language-js"><span class="hljs-comment">// 1. 声明处理天气数据的函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">gotWeather</span>(<span class="hljs-params">{ temperature, humidity }</span>) </span>{
  alert(<span class="hljs-string">`temperature: <span class="hljs-subst">${temperature}</span>, humidity: <span class="hljs-subst">${humidity}</span>`</span>);
}</code></pre>
</li>
<li><p>然后我们创建一个特性（attribute）为 <code>src=&quot;http://another.com/weather.json?callback=gotWeather&quot;</code> 的 <code>&lt;script&gt;</code> 标签，使用我们的函数名作为它的 <code>callback</code> URL-参数。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);
script.src = <span class="hljs-string">`http://another.com/weather.json?callback=gotWeather`</span>;
<span class="hljs-built_in">document</span>.body.append(script);</code></pre>
</li>
<li><p>远程服务器 <code>another.com</code> 动态生成一个脚本，该脚本调用 <code>gotWeather(...)</code>，发送它想让我们接收的数据。</p>
<pre><code class="language-js"><span class="hljs-comment">// 我们期望来自服务器的回答看起来像这样：</span>
gotWeather({
  <span class="hljs-attr">temperature</span>: <span class="hljs-number">25</span>,
  <span class="hljs-attr">humidity</span>: <span class="hljs-number">78</span>
});</code></pre>
</li>
<li><p>当远程脚本加载并执行时，<code>gotWeather</code> 函数将运行，并且因为它是我们的函数，我们就有了需要的数据。</p>
</li>
</ol>
<p>这是可行的，并且不违反安全规定，因为双方都同意以这种方式传递数据。而且，既然双方都同意这种行为，那这肯定不是黑客攻击了。现在仍然有提供这种访问的服务，因为即使是非常旧的浏览器它依然适用。</p>
<p>不久之后，网络方法出现在了浏览器 JavaScript 中。</p>
<p>起初，跨源请求是被禁止的。但是，经过长时间的讨论，跨源请求被允许了，但是任何新功能都需要服务器明确允许，以特殊的 header 表述。</p>
<h2 id="简单的请求">简单的请求</h2>
<p>有两种类型的跨源请求：</p>
<ol>
<li>简单的请求。</li>
<li>所有其他请求。</li>
</ol>
<p>顾名思义，简单的请求很简单，所以我们先从它开始。</p>
<p>一个 <a href="http://www.w3.org/TR/cors/#terminology">简单的请求</a> 是指满足以下两个条件的请求：</p>
<ol>
<li><a href="http://www.w3.org/TR/cors/#simple-method">简单的方法</a>：GET，POST 或 HEAD</li>
<li><a href="http://www.w3.org/TR/cors/#simple-header">简单的 header</a> —— 仅允许自定义下列 header：<ul>
<li><code>Accept</code>，</li>
<li><code>Accept-Language</code>，</li>
<li><code>Content-Language</code>，</li>
<li><code>Content-Type</code> 的值为 <code>application/x-www-form-urlencoded</code>，<code>multipart/form-data</code> 或 <code>text/plain</code>。</li>
</ul>
</li>
</ol>
<p>任何其他请求都被认为是“非简单请求”。例如，具有 <code>PUT</code> 方法或 <code>API-Key</code> HTTP-header 的请求就不是简单请求。</p>
<p><strong>本质区别在于，可以使用 <code>&lt;form&gt;</code> 或 <code>&lt;script&gt;</code> 进行“简单请求”，而无需任何其他特殊方法。</strong></p>
<p>因此，即使是非常旧的服务器也能很好地接收简单请求。</p>
<p>与此相反，带有非标准 header 或者例如 <code>DELETE</code> 方法的请求，无法通过这种方式创建。在很长一段时间里，JavaScript 都不能进行这样的请求。所以，旧的服务器可能会认为此类请求来自具有特权的来源（privileged source），“因为网页无法发送它们”。</p>
<p>当我们尝试发送一个非简单请求时，浏览器会发送一个特殊的“预检（preflight）”请求到服务器 —— 询问服务器，你接受此类跨源请求吗？</p>
<p>并且，除非服务器明确通过 header 进行确认，否则非简单请求不会被发送。</p>
<p>现在，我们来详细介绍它们。</p>
<h2 id="用于简单请求的-cors">用于简单请求的 CORS</h2>
<p>如果一个请求是跨源的，浏览器始终会向其添加 <code>Origin</code> header。</p>
<p>例如，如果我们从 <code>https://javascript.info/page</code> 请求 <code>https://anywhere.com/request</code>，请求的 header 将会如下：</p>
<pre><code class="language-http">GET /request
Host: anywhere.com
*!*
Origin: https://javascript.info
*/!*
...</code></pre>
<p>正如你所见，<code>Origin</code> 包含了确切的源（domain/protocol/port），没有路径。</p>
<p>服务器可以检查 <code>Origin</code>，如果同意接受这样的请求，就会在响应中添加一个特殊的 header <code>Access-Control-Allow-Origin</code>。该 header 包含了允许的源（在我们的示例中是 <code>https://javascript.info</code>），或者一个星号 <code>*</code>。然后响应成功，否则报错。</p>
<p>浏览器在这里扮演受被信任的中间人的角色：</p>
<ol>
<li>它确保发送的跨源请求带有正确的 <code>Origin</code>。</li>
<li>它检查响应中的许可 <code>Access-Control-Allow-Origin</code>，如果存在，则允许 JavaScript 访问响应，否则将失败并报错。</li>
</ol>
<p><img src="xhr-another-domain.svg" alt=""></p>
<p>这是一个带有服务器许可的响应示例：</p>
<pre><code class="language-http">200 OK
Content-Type:text/html; charset=UTF-8
*!*
Access-Control-Allow-Origin: https://javascript.info
*/!*</code></pre>
<h2 id="response-header">Response header</h2>
<p>对于跨源请求，默认情况下，JavaScript 只能访问“简单” response header：</p>
<ul>
<li><code>Cache-Control</code></li>
<li><code>Content-Language</code></li>
<li><code>Content-Type</code></li>
<li><code>Expires</code></li>
<li><code>Last-Modified</code></li>
<li><code>Pragma</code></li>
</ul>
<p>访问任何其他 response header 都将导致 error。</p>
<pre><code class="language-smart">请注意：列表中没有 `Content-Length` header！

该 header 包含完整的响应长度。因此，如果我们正在下载某些内容，并希望跟踪进度百分比，则需要额外的权限才能访问该 header（请见下文）。</code></pre>
<p>要授予 JavaScript 对任何其他 response header 的访问权限，服务器必须发送 <code>Access-Control-Expose-Headers</code> header。它包含一个以逗号分隔的应该被设置为可访问的非简单 header 名称列表。</p>
<p>例如：</p>
<pre><code class="language-http">200 OK
Content-Type:text/html; charset=UTF-8
Content-Length: 12345
API-Key: 2c9de507f2c54aa1
Access-Control-Allow-Origin: https://javascript.info
*!*
Access-Control-Expose-Headers: Content-Length,API-Key
*/!*</code></pre>
<p>有了这种 <code>Access-Control-Expose-Headers</code> header，此脚本就被允许读取响应的 <code>Content-Length</code> 和 <code>API-Key</code> header。</p>
<h2 id="非简单请求">“非简单”请求</h2>
<p>我们可以使用任何 HTTP 方法：不仅仅是 <code>GET/POST</code>，也可以是 <code>PATCH</code>，<code>DELETE</code> 及其他。</p>
<p>之前，没有人能够设想网页能发出这样的请求。因此，可能仍然存在有些 Web 服务将非标准方法视为一个信号：“这不是浏览器”。它们可以在检查访问权限时将其考虑在内。</p>
<p>因此，为了避免误解，任何“非标准”请求 —— 浏览器不会立即发出在过去无法完成的这类请求。即在它发送这类请求前，会先发送“预检（preflight）”请求来请求许可。</p>
<p>预检请求使用 <code>OPTIONS</code> 方法，它没有 body，但是有两个 header：</p>
<ul>
<li><code>Access-Control-Request-Method</code> header 带有非简单请求的方法。</li>
<li><code>Access-Control-Request-Headers</code> header 提供一个以逗号分隔的非简单 HTTP-header 列表。</li>
</ul>
<p>如果服务器同意处理请求，那么它会进行响应，此响应的状态码应该为 200，没有 body，具有 header：</p>
<ul>
<li><code>Access-Control-Allow-Methods</code> 必须具有允许的方法。</li>
<li><code>Access-Control-Allow-Headers</code> 必须具有一个允许的 header 列表。</li>
<li>另外，header <code>Access-Control-Max-Age</code> 可以指定缓存此权限的秒数。因此，浏览器不是必须为满足给定权限的后续请求发送预检。</li>
</ul>
<p><img src="xhr-preflight.svg" alt=""></p>
<p>让我们用一个例子来一步步看一下它是怎么工作的，对于一个跨源的 <code>PATCH</code> 请求（此方法经常被用于更新数据）：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;https://site.com/service.json&#x27;</span>, {
  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;PATCH&#x27;</span>,
  <span class="hljs-attr">headers</span>: {
    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,
    <span class="hljs-string">&#x27;API-Key&#x27;</span>: <span class="hljs-string">&#x27;secret&#x27;</span>
  }
});</code></pre>
<p>这里有三个理由解释为什么它不是一个简单请求（其实一个就够了）：</p>
<ul>
<li>方法 <code>PATCH</code></li>
<li><code>Content-Type</code> 不是这三个中之一：<code>application/x-www-form-urlencoded</code>，<code>multipart/form-data</code>，<code>text/plain</code>。</li>
<li>“非简单” <code>API-Key</code> header。</li>
</ul>
<h3 id="step-1-预检请求（preflight-request）">Step 1 预检请求（preflight request）</h3>
<p>在发送我们的请求前，浏览器会自己发送如下所示的预检请求：</p>
<pre><code class="language-http">OPTIONS /service.json
Host: site.com
Origin: https://javascript.info
Access-Control-Request-Method: PATCH
Access-Control-Request-Headers: Content-Type,API-Key</code></pre>
<ul>
<li>方法：<code>OPTIONS</code>。</li>
<li>路径 —— 与主请求完全相同：<code>/service.json</code>。</li>
<li>特殊跨源头：<ul>
<li><code>Origin</code> —— 来源。</li>
<li><code>Access-Control-Request-Method</code> —— 请求方法。</li>
<li><code>Access-Control-Request-Headers</code> —— 以逗号分隔的“非简单” header 列表。</li>
</ul>
</li>
</ul>
<h3 id="step-2-预检响应（preflight-response）">Step 2 预检响应（preflight response）</h3>
<p>服务应响应状态 200 和 header：</p>
<ul>
<li><code>Access-Control-Allow-Methods: PATCH</code></li>
<li><code>Access-Control-Allow-Headers: Content-Type,API-Key</code>。</li>
</ul>
<p>这将允许后续通信，否则会触发错误。</p>
<p>如果服务器将来期望其他方法和 header，则可以通过添加到列表中来预先允许它们：</p>
<pre><code class="language-http">200 OK
Access-Control-Allow-Methods: PUT,PATCH,DELETE
Access-Control-Allow-Headers: API-Key,Content-Type,If-Modified-Since,Cache-Control
Access-Control-Max-Age: 86400</code></pre>
<p>现在，浏览器可以看到 <code>PATCH</code> 在 <code>Access-Control-Allow-Methods</code> 中，<code>Content-Type,API-Key</code> 在列表 <code>Access-Control-Allow-Headers</code> 中，因此它将发送主请求。</p>
<p>此外，预检响应会缓存一段时间，该时间由 <code>Access-Control-Max-Age</code> header 指定（86400 秒，一天），因此，后续请求将不会导致预检。假设它们符合缓存的配额，则将直接发送它们。</p>
<h3 id="step-3-实际请求（actual-request）">Step 3 实际请求（actual request）</h3>
<p>预检成功后，浏览器现在发出主请求。这里的算法与简单请求的算法相同。</p>
<p>主请求具有 <code>Origin</code> header（因为它是跨源的）：</p>
<pre><code class="language-http">PATCH /service.json
Host: site.com
Content-Type: application/json
API-Key: secret
Origin: https://javascript.info</code></pre>
<h3 id="step-4-实际响应（actual-response）">Step 4 实际响应（actual response）</h3>
<p>服务器不应该忘记在主响应中添加 <code>Access-Control-Allow-Origin</code>。成功的预检并不能免除此要求：</p>
<pre><code class="language-http"><span class="hljs-attribute">Access-Control-Allow-Origin</span>: https://javascript.info</code></pre>
<p>然后，JavaScript 可以读取主服务器响应了。</p>
<pre><code class="language-smart">预检请求发生在“幕后”，它对 JavaScript 不可见。

JavaScript 仅获取对主请求的响应，如果没有服务器许可，则获得一个 error。</code></pre>
<h2 id="凭据（credentials）">凭据（Credentials）</h2>
<p>默认情况下，由 JavaScript 代码发起的跨源请求不会带来任何凭据（cookies 或者 HTTP 认证（HTTP authentication））。</p>
<p>这对于 HTTP 请求来说并不常见。通常，对 <code>http://site.com</code> 的请求附带有该域的所有 cookie。但是由 JavaScript 方法发出的跨源请求是个例外。</p>
<p>例如，<code>fetch(&#39;http://another.com&#39;)</code> 不会发送任何 cookie，即使那些 (!) 属于 <code>another.com</code> 域的 cookie。</p>
<p>为什么？</p>
<p>这是因为具有凭据的请求比没有凭据的请求要强大得多。如果被允许，它会使用它们的凭据授予 JavaScript 代表用户行为和访问敏感信息的全部权力。</p>
<p>服务器真的这么信任这种脚本吗？是的，它必须显式地带有允许请求的凭据和附加 header。</p>
<p>要在 <code>fetch</code> 中发送凭据，我们需要添加 <code>credentials: &quot;include&quot;</code> 选项，像这样：</p>
<pre><code class="language-js">fetch(<span class="hljs-string">&#x27;http://another.com&#x27;</span>, {
  <span class="hljs-attr">credentials</span>: <span class="hljs-string">&quot;include&quot;</span>
});</code></pre>
<p>现在，<code>fetch</code> 将把源自 <code>another.com</code> 的 cookie 和我们的请求发送到该网站。</p>
<p>如果服务器同意接受 <strong>带有凭据</strong> 的请求，则除了 <code>Access-Control-Allow-Origin</code> 外，服务器还应该在响应中添加 header <code>Access-Control-Allow-Credentials: true</code>。</p>
<p>例如：</p>
<pre><code class="language-http">200 OK
Access-Control-Allow-Origin: https://javascript.info
Access-Control-Allow-Credentials: true</code></pre>
<p>请注意：对于具有凭据的请求，禁止 <code>Access-Control-Allow-Origin</code> 使用星号 <code>*</code>。如上所示，它必须有一个确切的源。这是另一项安全措施，以确保服务器真的知道它信任的发出此请求的是谁。</p>
<h2 id="总结">总结</h2>
<p>从浏览器角度来看，有两种跨源请求：“简单”请求和其他请求。</p>
<p><a href="http://www.w3.org/TR/cors/#terminology">简单请求</a> 必须满足下列条件：</p>
<ul>
<li>方法：GET，POST 或 HEAD。</li>
<li>header —— 我们仅能设置：<ul>
<li><code>Accept</code></li>
<li><code>Accept-Language</code></li>
<li><code>Content-Language</code></li>
<li><code>Content-Type</code> 的值为 <code>application/x-www-form-urlencoded</code>，<code>multipart/form-data</code> 或 <code>text/plain</code>。</li>
</ul>
</li>
</ul>
<p>简单请求和其他请求的本质区别在于，自古以来使用 <code>&lt;form&gt;</code> 或 <code>&lt;script&gt;</code> 标签进行简单请求就是可行的，而长期以来浏览器都不能进行非简单请求。</p>
<p>所以，实际区别在于，简单请求会使用 <code>Origin</code> header 并立即发送，而对于其他请求，浏览器会发出初步的“预检”请求，以请求许可。</p>
<p><strong>对于简单请求：</strong></p>
<ul>
<li>→ 浏览器发送带有源的 <code>Origin</code> header。</li>
<li>← 对于没有凭据的请求（默认不发送），服务器应该设置：<ul>
<li><code>Access-Control-Allow-Origin</code> 为 <code>*</code> 或与 <code>Origin</code> 的值相同</li>
</ul>
</li>
<li>← 对于具有凭据的请求，服务器应该设置：<ul>
<li><code>Access-Control-Allow-Origin</code> 值与 <code>Origin</code> 的相同</li>
<li><code>Access-Control-Allow-Credentials</code> 为 <code>true</code></li>
</ul>
</li>
</ul>
<p>此外，要授予 JavaScript 访问除 <code>Cache-Control</code>，<code>Content-Language</code>，<code>Content-Type</code>，<code>Expires</code>，<code>Last-Modified</code> 或 <code>Pragma</code> 外的任何 response header 的权限，服务器应该在 header <code>Access-Control-Expose-Headers</code> 中列出允许的那些 header。</p>
<p><strong>对于非简单请求，会在请求之前发出初步“预检”请求：</strong></p>
<ul>
<li>→ 浏览器将具有以下 header 的 <code>OPTIONS</code> 请求发送到相同的 URL：<ul>
<li><code>Access-Control-Request-Method</code> 有请求方法。</li>
<li><code>Access-Control-Request-Headers</code> 以逗号分隔的“非简单” header 列表。</li>
</ul>
</li>
<li>← 服务器应该响应状态码为 200 和 header：<ul>
<li><code>Access-Control-Allow-Methods</code> 带有允许的方法的列表，</li>
<li><code>Access-Control-Allow-Headers</code> 带有允许的 header 的列表，</li>
<li><code>Access-Control-Max-Age</code> 带有指定缓存权限的秒数。</li>
</ul>
</li>
<li>然后，发出实际请求，应用先前的“简单”方案。</li>
</ul>
