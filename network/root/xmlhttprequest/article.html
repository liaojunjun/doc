<h1 id="xmlhttprequest">XMLHttpRequest</h1>
<p><code>XMLHttpRequest</code> 是一个内建的浏览器对象，它允许使用 JavaScript 发送 HTTP 请求。</p>
<p>虽然它的名字里面有 &quot;XML&quot; 一词，但它可以操作任何数据，而不仅仅是 XML 格式。我们可以用它来上传/下载文件，跟踪进度等。</p>
<p>现如今，我们有一个更为现代的方法叫做 <code>fetch</code>，它的出现使得 <code>XMLHttpRequest</code> 在某种程度上被弃用。</p>
<p>在现代 Web 开发中，出于以下三种原因，我们还在使用 <code>XMLHttpRequest</code>：</p>
<ol>
<li>历史原因：我们需要支持现有的使用了 <code>XMLHttpRequest</code> 的脚本。</li>
<li>我们需要兼容旧浏览器，并且不想用 polyfill（例如为了使脚本更小）。</li>
<li>我们需要做一些 <code>fetch</code> 目前无法做到的事情，例如跟踪上传进度。</li>
</ol>
<p>这些话听起来熟悉吗？如果是，那么请继续阅读下面的 <code>XMLHttpRequest</code> 相关内容吧。如果还不是很熟悉的话，那么请先阅读 <a href="info:fetch">info:fetch</a> 一章的内容。</p>
<h2 id="xmlhttprequest-基础">XMLHttpRequest 基础</h2>
<p>XMLHttpRequest 有两种执行模式：同步（synchronous）和异步（asynchronous）。</p>
<p>我们首先来看看最常用的异步模式：</p>
<p>要发送请求，需要 3 个步骤：</p>
<ol>
<li><p>创建 <code>XMLHttpRequest</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();</code></pre>
<p> 此构造器没有参数。</p>
</li>
<li><p>初始化它，通常就在 <code>new XMLHttpRequest</code> 之后：</p>
<pre><code class="language-js">xhr.open(method, URL, [<span class="hljs-keyword">async</span>, user, password])</code></pre>
<p> 此方法指定请求的主要参数：</p>
<ul>
<li><p><code>method</code> —— HTTP 方法。通常是 <code>&quot;GET&quot;</code> 或 <code>&quot;POST&quot;</code>。</p>
</li>
<li><p><code>URL</code> —— 要请求的 URL，通常是一个字符串，也可以是 <a href="info:url">URL</a> 对象。</p>
</li>
<li><p><code>async</code> —— 如果显式地设置为 <code>false</code>，那么请求将会以同步的方式处理，我们稍后会讲到它。</p>
</li>
<li><p><code>user</code>，<code>password</code> —— HTTP 基本身份验证（如果需要的话）的登录名和密码。</p>
<p>请注意，<code>open</code> 调用与其名称相反，不会建立连接。它仅配置请求，而网络活动仅以 <code>send</code> 调用开启。</p>
</li>
</ul>
</li>
<li><p>发送请求。</p>
<pre><code class="language-js">xhr.send([body])</code></pre>
<p> 这个方法会建立连接，并将请求发送到服务器。可选参数 <code>body</code> 包含了 request body。</p>
<p> 一些请求方法，像 <code>GET</code> 没有 request body。还有一些请求方法，像 <code>POST</code> 使用 <code>body</code> 将数据发送到服务器。我们稍后会看到相应示例。</p>
</li>
<li><p>监听 <code>xhr</code> 事件以获取响应。</p>
<p> 这三个事件是最常用的：</p>
<ul>
<li><p><code>load</code> —— 当请求完成（即使 HTTP 状态为 400 或 500 等），并且响应已完全下载。</p>
</li>
<li><p><code>error</code> —— 当无法发出请求，例如网络中断或者无效的 URL。</p>
</li>
<li><p><code>progress</code> —— 在下载响应期间定期触发，报告已经下载了多少。</p>
<pre><code class="language-js">xhr.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
alert(<span class="hljs-string">`Loaded: <span class="hljs-subst">${xhr.status}</span> <span class="hljs-subst">${xhr.response}</span>`</span>);
};

xhr.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// 仅在根本无法发出请求时触发</span>
alert(<span class="hljs-string">`Network Error`</span>);
};

xhr.onprogress = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{ <span class="hljs-comment">// 定期触发</span>
<span class="hljs-comment">// event.loaded —— 已经下载了多少字节</span>
<span class="hljs-comment">// event.lengthComputable = true，当服务器发送了 Content-Length header 时</span>
<span class="hljs-comment">// event.total —— 总字节数（如果 lengthComputable 为 true）</span>
alert(<span class="hljs-string">`Received <span class="hljs-subst">${event.loaded}</span> of <span class="hljs-subst">${event.total}</span>`</span>);
};</code></pre>
</li>
</ul>
</li>
</ol>
<p>下面是一个完整的示例。它从服务器加载 <code>/article/xmlhttprequest/example/load</code>，并打印加载进度：</p>
<pre><code class="language-js"><span class="hljs-comment">// 1. 创建一个 new XMLHttpRequest 对象</span>
<span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();

<span class="hljs-comment">// 2. 配置它：从 URL /article/.../load GET-request</span>
xhr.open(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;/article/xmlhttprequest/example/load&#x27;</span>);

<span class="hljs-comment">// 3. 通过网络发送请求</span>
xhr.send();

<span class="hljs-comment">// 4. 当接收到响应后，将调用此函数</span>
xhr.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (xhr.status != <span class="hljs-number">200</span>) { <span class="hljs-comment">// 分析响应的 HTTP 状态</span>
    alert(<span class="hljs-string">`Error <span class="hljs-subst">${xhr.status}</span>: <span class="hljs-subst">${xhr.statusText}</span>`</span>); <span class="hljs-comment">// 例如 404: Not Found</span>
  } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 显示结果</span>
    alert(<span class="hljs-string">`Done, got <span class="hljs-subst">${xhr.response.length}</span> bytes`</span>); <span class="hljs-comment">// response 是服务器响应</span>
  }
};

xhr.onprogress = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
  <span class="hljs-keyword">if</span> (event.lengthComputable) {
    alert(<span class="hljs-string">`Received <span class="hljs-subst">${event.loaded}</span> of <span class="hljs-subst">${event.total}</span> bytes`</span>);
  } <span class="hljs-keyword">else</span> {
    alert(<span class="hljs-string">`Received <span class="hljs-subst">${event.loaded}</span> bytes`</span>); <span class="hljs-comment">// 没有 Content-Length</span>
  }

};

xhr.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-string">&quot;Request failed&quot;</span>);
};</code></pre>
<p>一旦服务器有了响应，我们可以在以下 <code>xhr</code> 属性中接收结果：</p>
<p><code>status</code>
: HTTP 状态码（一个数字）：<code>200</code>，<code>404</code>，<code>403</code> 等，如果出现非 HTTP 错误，则为 <code>0</code>。</p>
<p><code>statusText</code>
: HTTP 状态消息（一个字符串）：状态码为 <code>200</code> 对应于 <code>OK</code>，<code>404</code> 对应于 <code>Not Found</code>，<code>403</code> 对应于 <code>Forbidden</code>。</p>
<p><code>response</code>（旧脚本可能用的是 <code>responseText</code>）
: 服务器 response body。</p>
<p>我们还可以使用相应的属性指定超时（timeout）：</p>
<pre><code class="language-js">xhr.timeout = <span class="hljs-number">10000</span>; <span class="hljs-comment">// timeout 单位是 ms，此处即 10 秒</span></code></pre>
<p>如果在给定时间内请求没有成功执行，请求就会被取消，并且触发 <code>timeout</code> 事件。</p>
<pre><code class="language-smart">为了向 URL 添加像 `?name=value` 这样的参数，并确保正确的编码，我们可以使用 [URL](info:url) 对象：

```js
let url = new URL(&#x27;https://google.com/search&#x27;);
url.searchParams.set(&#x27;q&#x27;, &#x27;test me!&#x27;);

// 参数 &#x27;q&#x27; 被编码
xhr.open(&#x27;GET&#x27;, url); // https://google.com/search?q=test+me%21
```
</code></pre>
<h2 id="响应类型">响应类型</h2>
<p>我们可以使用 <code>xhr.responseType</code> 属性来设置响应格式：</p>
<ul>
<li><code>&quot;&quot;</code>（默认）—— 响应格式为字符串，</li>
<li><code>&quot;text&quot;</code> —— 响应格式为字符串，</li>
<li><code>&quot;arraybuffer&quot;</code> —— 响应格式为 <code>ArrayBuffer</code>（对于二进制数据，请参见 <a href="info:arraybuffer-binary-arrays">info:arraybuffer-binary-arrays</a>），</li>
<li><code>&quot;blob&quot;</code> —— 响应格式为 <code>Blob</code>（对于二进制数据，请参见 <a href="info:blob">info:blob</a>），</li>
<li><code>&quot;document&quot;</code> —— 响应格式为 XML document（可以使用 XPath 和其他 XML 方法），</li>
<li><code>&quot;json&quot;</code> —— 响应格式为 JSON（自动解析）。</li>
</ul>
<p>例如，我们以 JSON 格式获取响应：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();

xhr.open(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;/article/xmlhttprequest/example/json&#x27;</span>);

*!*
xhr.responseType = <span class="hljs-string">&#x27;json&#x27;</span>;
*/!*

xhr.send();

<span class="hljs-comment">// 响应为 {&quot;message&quot;: &quot;Hello, world!&quot;}</span>
xhr.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> responseObj = xhr.response;
  alert(responseObj.message); <span class="hljs-comment">// Hello, world!</span>
};</code></pre>
<pre><code class="language-smart">在旧的脚本中，你可能会看到 `xhr.responseText`，甚至会看到 `xhr.responseXML` 属性。

它们是由于历史原因而存在的，以获取字符串或 XML 文档。如今，我们应该在 `xhr.responseType` 中设置格式，然后就能获取如上所示的 `xhr.response` 了。</code></pre>
<h2 id="readystate">readyState</h2>
<p><code>XMLHttpRequest</code> 的状态（state）会随着它的处理进度变化而变化。可以通过 <code>xhr.readyState</code> 来了解当前状态。</p>
<p><a href="https://xhr.spec.whatwg.org/#states">规范</a> 中提到的所有状态如下：</p>
<pre><code class="language-js">UNSENT = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始状态</span>
OPENED = <span class="hljs-number">1</span>; <span class="hljs-comment">// open 被调用</span>
HEADERS_RECEIVED = <span class="hljs-number">2</span>; <span class="hljs-comment">// 接收到 response header</span>
LOADING = <span class="hljs-number">3</span>; <span class="hljs-comment">// 响应正在被加载（接收到一个数据包）</span>
DONE = <span class="hljs-number">4</span>; <span class="hljs-comment">// 请求完成</span></code></pre>
<p><code>XMLHttpRequest</code> 对象以 <code>0</code> -&gt; <code>1</code> -&gt; <code>2</code> -&gt; <code>3</code> -&gt; ... -&gt; <code>3</code> -&gt; <code>4</code> 的顺序在它们之间转变。每当通过网络接收到一个数据包，就会重复一次状态 <code>3</code>。</p>
<p>我们可以使用 <code>readystatechange</code> 事件来跟踪它们：</p>
<pre><code class="language-js">xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (xhr.readyState == <span class="hljs-number">3</span>) {
    <span class="hljs-comment">// 加载中</span>
  }
  <span class="hljs-keyword">if</span> (xhr.readyState == <span class="hljs-number">4</span>) {
    <span class="hljs-comment">// 请求完成</span>
  }
};</code></pre>
<p>你可能在非常老的代码中找到 <code>readystatechange</code> 这样的事件监听器，它的存在是有历史原因的，因为曾经有很长一段时间都没有 <code>load</code> 以及其他事件。如今，它已被 <code>load/error/progress</code> 事件处理程序所替代。</p>
<h2 id="中止请求（aborting）">中止请求（Aborting）</h2>
<p>我们可以随时终止请求。调用 <code>xhr.abort()</code> 即可：</p>
<pre><code class="language-js">xhr.abort(); <span class="hljs-comment">// 终止请求</span></code></pre>
<p>它会触发 <code>abort</code> 事件，且 <code>xhr.status</code> 变为 <code>0</code>。</p>
<h2 id="同步请求">同步请求</h2>
<p>如果在 <code>open</code> 方法中将第三个参数 <code>async</code> 设置为 <code>false</code>，那么请求就会以同步的方式进行。</p>
<p>换句话说，JavaScript 执行在 <code>send()</code> 处暂停，并在收到响应后恢复执行。这有点儿像 <code>alert</code> 或 <code>prompt</code> 命令。</p>
<p>下面是重写的示例，<code>open</code> 的第三个参数为 <code>false</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();

xhr.open(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;/article/xmlhttprequest/hello.txt&#x27;</span>, *!*<span class="hljs-literal">false</span>*/!*);

<span class="hljs-keyword">try</span> {
  xhr.send();
  <span class="hljs-keyword">if</span> (xhr.status != <span class="hljs-number">200</span>) {
    alert(<span class="hljs-string">`Error <span class="hljs-subst">${xhr.status}</span>: <span class="hljs-subst">${xhr.statusText}</span>`</span>);
  } <span class="hljs-keyword">else</span> {
    alert(xhr.response);
  }
} <span class="hljs-keyword">catch</span>(err) { <span class="hljs-comment">// 代替 onerror</span>
  alert(<span class="hljs-string">&quot;Request failed&quot;</span>);
}</code></pre>
<p>这看起来好像不错，但是很少使用同步调用，因为它们会阻塞页面内的 JavaScript，直到加载完成。在某些浏览器中，滚动可能无法正常进行。如果一个同步调用执行时间过长，浏览器可能会建议关闭“挂起（hanging）”的网页。</p>
<p><code>XMLHttpRequest</code> 的很多高级功能在同步请求中都不可用，例如向其他域发起请求或者设置超时。并且，正如你所看到的，没有进度指示。</p>
<p>基于这些原因，同步请求使用的非常少，几乎从不使用。在这我们就不再讨论它了。</p>
<h2 id="http-header">HTTP-header</h2>
<p><code>XMLHttpRequest</code> 允许发送自定义 header，并且可以从响应中读取 header。</p>
<p>HTTP-header 有三种方法：</p>
<p><code>setRequestHeader(name, value)</code>
: 使用给定的 <code>name</code> 和 <code>value</code> 设置 request header。</p>
<pre><code>例如：

```js
xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;);
```

```warn header=&quot;Header 的限制&quot;
一些 header 是由浏览器专门管理的，例如 `Referer` 和 `Host`。
完整列表请见 [规范](http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader-method)。

为了用户安全和请求的正确性，`XMLHttpRequest` 不允许更改它们。
```

````warn header=&quot;不能移除 header&quot;
`XMLHttpRequest` 的另一个特点是不能撤销 `setRequestHeader`。

一旦设置了 header，就无法撤销了。其他调用会向 header 中添加信息，但不会覆盖它。

例如：

```js
xhr.setRequestHeader(&#x27;X-Auth&#x27;, &#x27;123&#x27;);
xhr.setRequestHeader(&#x27;X-Auth&#x27;, &#x27;456&#x27;);

// header 将是：
// X-Auth: 123, 456
```
````</code></pre>
<p><code>getResponseHeader(name)</code>
: 获取具有给定 <code>name</code> 的 header（<code>Set-Cookie</code> 和 <code>Set-Cookie2</code> 除外）。</p>
<pre><code>例如：

```js
xhr.getResponseHeader(&#x27;Content-Type&#x27;)
```</code></pre>
<p><code>getAllResponseHeaders()</code>
: 返回除 <code>Set-Cookie</code> 和 <code>Set-Cookie2</code> 外的所有 response header。</p>
<pre><code>header 以单行形式返回，例如：

```http
Cache-Control: max-age=31536000
Content-Length: 4260
Content-Type: image/png
Date: Sat, 08 Sep 2012 16:53:16 GMT
```

header 之间的换行符始终为 `&quot;\r\n&quot;`（不依赖于操作系统），所以我们可以很容易地将其拆分为单独的 header。name 和 value 之间总是以冒号后跟一个空格 `&quot;: &quot;` 分隔。这是标准格式。

因此，如果我们想要获取具有 name/value 对的对象，则需要用一点 JavaScript 代码来处理它们。

像这样（假设如果两个 header 具有相同的名称，那么后者就会覆盖前者）：

```js
let headers = xhr
  .getAllResponseHeaders()
  .split(&#x27;\r\n&#x27;)
  .reduce((result, current) =&gt; {
    let [name, value] = current.split(&#x27;: &#x27;);
    result[name] = value;
    return result;
  }, {});

// headers[&#x27;Content-Type&#x27;] = &#x27;image/png&#x27;
```</code></pre>
<h2 id="post，formdata">POST，FormData</h2>
<p>要建立一个 POST 请求，我们可以使用内建的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData">FormData</a> 对象。</p>
<p>语法为：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> formData = <span class="hljs-keyword">new</span> FormData([form]); <span class="hljs-comment">// 创建一个对象，可以选择从 &lt;form&gt; 中获取数据</span>
formData.append(name, value); <span class="hljs-comment">// 附加一个字段</span></code></pre>
<p>我们创建它，可以选择从一个表单中获取数据，如果需要，还可以 <code>append</code> 更多字段，然后：</p>
<ol>
<li><code>xhr.open(&#39;POST&#39;, ...)</code> —— 使用 <code>POST</code> 方法。</li>
<li><code>xhr.send(formData)</code> 将表单发送到服务器。</li>
</ol>
<p>例如：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;person&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;John&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;surname&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Smith&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-comment">// 从表单预填充 FormData</span>
  <span class="hljs-keyword">let</span> formData = <span class="hljs-keyword">new</span> FormData(<span class="hljs-built_in">document</span>.forms.person);

  <span class="hljs-comment">// 附加一个字段</span>
  formData.append(<span class="hljs-string">&quot;middle&quot;</span>, <span class="hljs-string">&quot;Lee&quot;</span>);

  <span class="hljs-comment">// 将其发送出去</span>
  <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();
  xhr.open(<span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&quot;/article/xmlhttprequest/post/user&quot;</span>);
  xhr.send(formData);

  xhr.onload = <span class="hljs-function">() =&gt;</span> alert(xhr.response);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>以 <code>multipart/form-data</code> 编码发送表单。</p>
<p>或者，如果我们更喜欢 JSON，那么可以使用 <code>JSON.stringify</code> 并以字符串形式发送。</p>
<p>只是，不要忘记设置 header <code>Content-Type: application/json</code>，只要有了它，很多服务端框架都能自动解码 JSON：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();

<span class="hljs-keyword">let</span> json = <span class="hljs-built_in">JSON</span>.stringify({
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">surname</span>: <span class="hljs-string">&quot;Smith&quot;</span>
});

xhr.open(<span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&#x27;/submit&#x27;</span>)
xhr.setRequestHeader(<span class="hljs-string">&#x27;Content-type&#x27;</span>, <span class="hljs-string">&#x27;application/json; charset=utf-8&#x27;</span>);

xhr.send(json);</code></pre>
<p><code>.send(body)</code> 方法就像一个非常杂食性的动物。它几乎可以发送任何 <code>body</code>，包括 <code>Blob</code> 和 <code>BufferSource</code> 对象。</p>
<h2 id="上传进度">上传进度</h2>
<p><code>progress</code> 事件仅在下载阶段触发。</p>
<p>也就是说：如果我们 <code>POST</code> 一些内容，<code>XMLHttpRequest</code> 首先上传我们的数据（request body），然后下载响应。</p>
<p>如果我们要上传的东西很大，那么我们肯定会对跟踪上传进度感兴趣。但是 <code>xhr.onprogress</code> 在这里并不起作用。</p>
<p>这里有另一个对象，它没有方法，它专门用于跟踪上传事件：<code>xhr.upload</code>。</p>
<p>它会生成事件，类似于 <code>xhr</code>，但是 <code>xhr.upload</code> 仅在上传时触发它们：</p>
<ul>
<li><code>loadstart</code> —— 上传开始。</li>
<li><code>progress</code> —— 上传期间定期触发。</li>
<li><code>abort</code> —— 上传中止。</li>
<li><code>error</code> —— 非 HTTP 错误。</li>
<li><code>load</code> —— 上传成功完成。</li>
<li><code>timeout</code> —— 上传超时（如果设置了 <code>timeout</code> 属性）。</li>
<li><code>loadend</code> —— 上传完成，无论成功还是 error。</li>
</ul>
<p>handler 示例：</p>
<pre><code class="language-js">xhr.upload.onprogress = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
  alert(<span class="hljs-string">`Uploaded <span class="hljs-subst">${event.loaded}</span> of <span class="hljs-subst">${event.total}</span> bytes`</span>);
};

xhr.upload.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-string">`Upload finished successfully.`</span>);
};

xhr.upload.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-string">`Error during the upload: <span class="hljs-subst">${xhr.status}</span>`</span>);
};</code></pre>
<p>这是一个真实示例：带有进度指示的文件上传：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">onchange</span>=<span class="hljs-string">&quot;upload(this.files[0])&quot;</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">upload</span>(<span class="hljs-params">file</span>) </span>{
  <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();

  <span class="hljs-comment">// 跟踪上传进度</span>
*!*
  xhr.upload.onprogress = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Uploaded <span class="hljs-subst">${event.loaded}</span> of <span class="hljs-subst">${event.total}</span>`</span>);
  };
*/!*

  <span class="hljs-comment">// 跟踪完成：无论成功与否</span>
  xhr.onloadend = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (xhr.status == <span class="hljs-number">200</span>) {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;success&quot;</span>);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;error &quot;</span> + <span class="hljs-built_in">this</span>.status);
    }
  };

  xhr.open(<span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&quot;/article/xmlhttprequest/post/upload&quot;</span>);
  xhr.send(file);
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h2 id="跨源请求">跨源请求</h2>
<p><code>XMLHttpRequest</code> 可以使用和 <a href="info:fetch-crossorigin">fetch</a> 相同的 CORS 策略进行跨源请求。</p>
<p>就像 <code>fetch</code> 一样，默认情况下不会将 cookie 和 HTTP 授权发送到其他域。要启用它们，可以将 <code>xhr.withCredentials</code> 设置为 <code>true</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();
*!*
xhr.withCredentials = <span class="hljs-literal">true</span>;
*/!*

xhr.open(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;http://anywhere.com/request&#x27;</span>);
...</code></pre>
<p>有关跨源 header 的详细信息，请见 <a href="info:fetch-crossorigin">info:fetch-crossorigin</a> 一章。</p>
<h2 id="总结">总结</h2>
<p>使用 <code>XMLHttpRequest</code> 的 GET 请求的典型代码：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();

xhr.open(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;/my/url&#x27;</span>);

xhr.send();

xhr.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (xhr.status != <span class="hljs-number">200</span>) { <span class="hljs-comment">// HTTP error?</span>
    <span class="hljs-comment">// 处理 error</span>
    alert( <span class="hljs-string">&#x27;Error: &#x27;</span> + xhr.status);
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-comment">// 获取来自 xhr.response 的响应</span>
};

xhr.onprogress = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
  <span class="hljs-comment">// 报告进度</span>
  alert(<span class="hljs-string">`Loaded <span class="hljs-subst">${event.loaded}</span> of <span class="hljs-subst">${event.total}</span>`</span>);
};

xhr.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// 处理非 HTTP error（例如网络中断）</span>
};</code></pre>
<p>实际上还有很多事件，在 <a href="http://www.w3.org/TR/XMLHttpRequest/#events">现代规范</a> 中有详细列表（按生命周期排序）：</p>
<ul>
<li><code>loadstart</code> —— 请求开始。</li>
<li><code>progress</code> —— 一个响应数据包到达，此时整个 response body 都在 <code>response</code> 中。</li>
<li><code>abort</code> —— 调用 <code>xhr.abort()</code> 取消了请求。</li>
<li><code>error</code> —— 发生连接错误，例如，域错误。不会发生诸如 404 这类的 HTTP 错误。</li>
<li><code>load</code> —— 请求成功完成。</li>
<li><code>timeout</code> —— 由于请求超时而取消了该请求（仅发生在设置了 timeout 的情况下）。</li>
<li><code>loadend</code> —— 在 <code>load</code>，<code>error</code>，<code>timeout</code> 或 <code>abort</code> 之后触发。</li>
</ul>
<p><code>error</code>，<code>abort</code>，<code>timeout</code> 和 <code>load</code> 事件是互斥的。其中只有一种可能发生。</p>
<p>最常用的事件是加载完成（<code>load</code>），加载失败（<code>error</code>），或者我们可以使用单个 <code>loadend</code> 处理程序并检查请求对象 <code>xhr</code> 的属性，以查看发生了什么。</p>
<p>我们还了解了另一个事件：<code>readystatechange</code>。由于历史原因，它早在规范制定之前就出现了。如今我们已经无需使用它了，我们可以用新的事件代替它，但通常可以在旧的代码中找到它。</p>
<p>如果我们需要专门跟踪上传，那么我们应该在 <code>xhr.upload</code> 对象上监听相同的事件。</p>
