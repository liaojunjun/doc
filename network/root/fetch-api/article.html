<h1 id="fetch-api">Fetch API</h1>
<p>到目前为止，我们已经对 <code>fetch</code> 相当了解了。</p>
<p>现在让我们来看看 <code>fetch</code> 的剩余 API，来了解它的全部本领吧。</p>
<pre><code class="language-smart">请注意：这些选项 (option) 大多都很少使用。即使跳过本章，你也可以很好地使用 `fetch`。

但是，知道 `fetch` 可以做什么还是很好的，所以如果需要，你可以来看看这些细节内容。</code></pre>
<p>这是所有可能的 <code>fetch</code> 选项及其默认值（注释中标注了可选值）的完整列表：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> promise = fetch(url, {
  <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-comment">// POST，PUT，DELETE，等。</span>
  <span class="hljs-attr">headers</span>: {
    <span class="hljs-comment">// 内容类型 header 值通常是自动设置的</span>
    <span class="hljs-comment">// 取决于 request body</span>
    <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;text/plain;charset=UTF-8&quot;</span>
  },
  <span class="hljs-attr">body</span>: <span class="hljs-literal">undefined</span> <span class="hljs-comment">// string，FormData，Blob，BufferSource，或 URLSearchParams</span>
  <span class="hljs-attr">referrer</span>: <span class="hljs-string">&quot;about:client&quot;</span>, <span class="hljs-comment">// 或 &quot;&quot; 以不发送 Referer header，</span>
  <span class="hljs-comment">// 或者是当前源的 url</span>
  <span class="hljs-attr">referrerPolicy</span>: <span class="hljs-string">&quot;no-referrer-when-downgrade&quot;</span>, <span class="hljs-comment">// no-referrer，origin，same-origin...</span>
  <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;cors&quot;</span>, <span class="hljs-comment">// same-origin，no-cors</span>
  <span class="hljs-attr">credentials</span>: <span class="hljs-string">&quot;same-origin&quot;</span>, <span class="hljs-comment">// omit，include</span>
  <span class="hljs-attr">cache</span>: <span class="hljs-string">&quot;default&quot;</span>, <span class="hljs-comment">// no-store，reload，no-cache，force-cache，或 only-if-cached</span>
  <span class="hljs-attr">redirect</span>: <span class="hljs-string">&quot;follow&quot;</span>, <span class="hljs-comment">// manual，error</span>
  <span class="hljs-attr">integrity</span>: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// 一个 hash，像 &quot;sha256-abcdef1234567890&quot;</span>
  <span class="hljs-attr">keepalive</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// true</span>
  <span class="hljs-attr">signal</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-comment">// AbortController 来中止请求</span>
  <span class="hljs-attr">window</span>: <span class="hljs-built_in">window</span> <span class="hljs-comment">// null</span>
});</code></pre>
<p>一个令人印象深刻的列表，对吧?</p>
<p>我们已经在 <a href="info:fetch">info:fetch</a> 一章中详细介绍了 <code>method</code>，<code>headers</code> 和 <code>body</code>。</p>
<p>在 <a href="info:fetch-abort">info:fetch-abort</a> 一章中介绍了 <code>signal</code> 选项。</p>
<p>现在让我们学习其余的本领。</p>
<h2 id="referrer，referrerpolicy">referrer，referrerPolicy</h2>
<p>这些选项决定了 <code>fetch</code> 如何设置 HTTP 的 <code>Referer</code> header。</p>
<p>通常来说，这个 header 是被自动设置的，并包含了发出请求的页面的 url。在大多数情况下，它一点也不重要，但有时出于安全考虑，删除或缩短它是有意义的。</p>
<p><strong><code>referer</code> 选项允许设置在当前域的任何 <code>Referer</code>，或者移除它。</strong></p>
<p>要不发送 referer，可以将 <code>referer</code> 设置为空字符串：</p>
<pre><code class="language-js">fetch(<span class="hljs-string">&#x27;/page&#x27;</span>, {

  referrer: <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment">// 没有 Referer header</span>

});</code></pre>
<p>设置在当前域内的另一个 url：</p>
<pre><code class="language-js">fetch(<span class="hljs-string">&#x27;/page&#x27;</span>, {
  <span class="hljs-comment">// 假设我们在 https://javascript.info</span>
  <span class="hljs-comment">// 我们可以设置任何 Referer header，但必须是在当前域内的</span>

  referrer: <span class="hljs-string">&quot;https://javascript.info/anotherpage&quot;</span>

});</code></pre>
<p><strong><code>referrerPolicy</code> 选项为 <code>Referer</code> 设置一般的规则。</strong></p>
<p>请求分为 3 种类型：</p>
<ol>
<li>同源请求。</li>
<li>跨源请求。</li>
<li>从 HTTPS 到 HTTP 的请求 (从安全协议到不安全协议)。</li>
</ol>
<p>与 <code>referrer</code> 选项允许设置确切的 <code>Referer</code> 值不同，<code>referrerPolicy</code> 告诉浏览器针对各个请求类型的一般的规则。</p>
<p>可能的值在 <a href="https://w3c.github.io/webappsec-referrer-policy/">Referrer Policy 规范</a>中有详细描述：</p>
<ul>
<li><strong><code>&quot;no-referrer-when-downgrade&quot;</code></strong> —— 默认值：除非我们从 HTTPS 发送请求到 HTTP（到安全性较低的协议），否则始终会发送完整的 <code>Referer</code>。</li>
<li><strong><code>&quot;no-referrer&quot;</code></strong> —— 从不发送 <code>Referer</code>。</li>
<li><strong><code>&quot;origin&quot;</code></strong> —— 只发送在 <code>Referer</code> 中的域，而不是完整的页面 URL，例如，只发送 <code>http://site.com</code> 而不是 <code>http://site.com/path</code>。</li>
<li><strong><code>&quot;origin-when-cross-origin&quot;</code></strong> —— 发送完整的 <code>Referer</code> 到相同的源，但对于跨源请求，只发送域部分（同上）。</li>
<li><strong><code>&quot;same-origin&quot;</code></strong> —— 发送完整的 <code>Referer</code> 到相同的源，但对于跨源请求，不发送 <code>Referer</code>。</li>
<li><strong><code>&quot;strict-origin&quot;</code></strong> —— 只发送域，对于 HTTPS→HTTP 请求，则不发送中则不发送 <code>Referer</code>。</li>
<li><strong><code>&quot;strict-origin-when-cross-origin&quot;</code></strong> —— 对于同源情况下则发送完整的 <code>Referer</code>，对于跨源情况下，则只发送域，如果是 HTTPS→HTTP 请求，则什么都不发送。</li>
<li><strong><code>&quot;unsafe-url&quot;</code></strong> —— 在 <code>Referer</code> 中始终发送完整的 url，即使是 HTTPS→HTTP 请求。</li>
</ul>
<p>这是一个包含所有组合的表格：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>同源</th>
<th>跨源</th>
<th>HTTPS→HTTP</th>
</tr>
</thead>
<tbody><tr>
<td><code>&quot;no-referrer&quot;</code></td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td><code>&quot;no-referrer-when-downgrade&quot;</code> 或 <code>&quot;&quot;</code>（默认）</td>
<td>完整的 url</td>
<td>完整的 url</td>
<td>-</td>
</tr>
<tr>
<td><code>&quot;origin&quot;</code></td>
<td>仅域</td>
<td>仅域</td>
<td>仅域</td>
</tr>
<tr>
<td><code>&quot;origin-when-cross-origin&quot;</code></td>
<td>完整的 url</td>
<td>仅域</td>
<td>仅域</td>
</tr>
<tr>
<td><code>&quot;same-origin&quot;</code></td>
<td>完整的 url</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td><code>&quot;strict-origin&quot;</code></td>
<td>仅域</td>
<td>仅域</td>
<td>-</td>
</tr>
<tr>
<td><code>&quot;strict-origin-when-cross-origin&quot;</code></td>
<td>完整的 url</td>
<td>仅域</td>
<td>-</td>
</tr>
<tr>
<td><code>&quot;unsafe-url&quot;</code></td>
<td>完整的 url</td>
<td>完整的 url</td>
<td>完整的 url</td>
</tr>
</tbody></table>
<p>假如我们有一个带有 URL 结构的管理区域（admin zone），它不应该被从网站外看到。</p>
<p>如果我们发送了一个 <code>fetch</code>，则默认情况下，它总是发送带有页面完整 url 的 <code>Referer</code> header（我们从 HTTPS 向 HTTP 发送请求的情况除外，这种情况下没有 <code>Referer</code>）。</p>
<p>例如 <code>Referer: https://javascript.info/admin/secret/paths</code>。</p>
<p>如果我们想让其他网站只知道域的部分，而不是 URL 路径，我们可以这样设置选项：</p>
<pre><code class="language-js">fetch(<span class="hljs-string">&#x27;https://another.com/page&#x27;</span>, {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">referrerPolicy</span>: <span class="hljs-string">&quot;origin-when-cross-origin&quot;</span> <span class="hljs-comment">// Referer: https://javascript.info</span>
});</code></pre>
<p>我们可以将其置于所有 <code>fetch</code> 调用中，也可以将其集成到我们项目的执行所有请求并在内部使用 <code>fetch</code> 的 JavaScript 库中。</p>
<p>与默认行为相比，它的唯一区别在于，对于跨源请求，<code>fetch</code> 只发送 URL 域的部分（例如 <code>https://javascript.info</code>，没有路径）。对于同源请求，我们仍然可以获得完整的 <code>Referer</code>（可能对于调试目的是有用的）。</p>
<p>```smart header=&quot;Referrer policy 不仅适用于 <code>fetch</code>&quot;
在 <a href="https://w3c.github.io/webappsec-referrer-policy/">规范</a> 中描述的 referrer policy，不仅适用于 <code>fetch</code>，它还具有全局性。</p>
<p>特别是，可以使用 <code>Referrer-Policy</code> HTTP header，或者为每个链接设置 <code>&lt;a rel=&quot;noreferrer&quot;&gt;</code>，来为整个页面设置默认策略（policy）。</p>
<pre><code>
## mode

`mode` 选项是一种安全措施，可以防止偶发的跨源请求：

- **`&quot;cors&quot;`** —— 默认值，允许跨源请求，如 &lt;info:fetch-crossorigin&gt; 一章所述，
- **`&quot;same-origin&quot;`** —— 禁止跨源请求，
- **`&quot;no-cors&quot;`** —— 只允许简单的跨源请求。

当 `fetch` 的 URL 来自于第三方，并且我们想要一个“断电开关”来限制跨源能力时，此选项可能很有用。

## credentials

`credentials` 选项指定 `fetch` 是否应该随请求发送 cookie 和 HTTP-Authorization header。

- **`&quot;same-origin&quot;`** —— 默认值，对于跨源请求不发送，
- **`&quot;include&quot;`** —— 总是发送，需要来自跨源服务器的 `Accept-Control-Allow-Credentials`，才能使 JavaScript 能够访问响应，详细内容在 &lt;info:fetch-crossorigin&gt; 一章有详细介绍，
- **`&quot;omit&quot;`** —— 不发送，即使对于同源请求。

## cache

默认情况下，`fetch` 请求使用标准的 HTTP 缓存。就是说，它遵从 `Expires`，`Cache-Control` header，发送 `If-Modified-Since`，等。就像常规的 HTTP 请求那样。

使用 `cache` 选项可以忽略 HTTP 缓存或者对其用法进行微调：

- **`&quot;default&quot;`** —— `fetch` 使用标准的 HTTP 缓存规则和 header，
- **`&quot;no-store&quot;`** —— 完全忽略 HTTP 缓存，如果我们设置 header `If-Modified-Since`，`If-None-Match`，`If-Unmodified-Since`，`If-Match`，或 `If-Range`，则此模式会成为默认模式，
- **`&quot;reload&quot;`** —— 不从 HTTP 缓存中获取结果（如果有），而是使用响应填充缓存（如果 response header 允许），
- **`&quot;no-cache&quot;`** —— 如果有一个已缓存的响应，则创建一个有条件的请求，否则创建一个普通的请求。使用响应填充 HTTP 缓存，
- **`&quot;force-cache&quot;`** —— 使用来自 HTTP 缓存的响应，即使该响应已过时（stale）。如果 HTTP 缓存中没有响应，则创建一个常规的 HTTP 请求，行为像正常那样，
- **`&quot;only-if-cached&quot;`** —— 使用来自 HTTP 缓存的响应，即使该响应已过时（stale）。如果 HTTP 缓存中没有响应，则报错。只有当 `mode` 为 `same-origin` 时生效。

## redirect

通常来说，`fetch` 透明地遵循 HTTP 重定向，例如 301，302 等。

`redirect` 选项允许对此进行更改：

- **`&quot;follow&quot;`** —— 默认值，遵循 HTTP 重定向，
- **`&quot;error&quot;`** —— HTTP 重定向时报错，
- **`&quot;manual&quot;`** —— 不遵循 HTTP 重定向，但 `response.url` 将是一个新的 URL，并且 `response redirectd` 将为 `true`，以便我们能够手动执行重定向到新的 URL（如果需要的话）。

## integrity

`integrity` 选项允许检查响应是否与已知的预先校验和相匹配。

正如 [规范](https://w3c.github.io/webappsec-subresource-integrity/) 所描述的，支持的哈希函数有 SHA-256，SHA-384，和 SHA-512，可能还有其他的，这取决于浏览器。

例如，我们下载一个文件，并且我们知道它的 SHA-256 校验和为 &quot;abcdef&quot;（当然，实际校验和会更长）。

我们可以将其放在 `integrity` 选项中，就像这样:

```js
fetch(&#x27;http://site.com/file&#x27;, {
  integrity: &#x27;sha256-abcdef&#x27;
});</code></pre>
<p>然后 <code>fetch</code> 将自行计算 SHA-256 并将其与我们的字符串进行比较。如果不匹配，则会触发错误。</p>
<h2 id="keepalive">keepalive</h2>
<p><code>keepalive</code> 选项表示该请求可能会使发起它的网页“失活（outlive）”。</p>
<p>例如，我们收集有关当前访问者是如何使用我们的页面（鼠标点击，他查看的页面片段）的统计信息，以分析和改善用户体验。</p>
<p>当访问者离开我们的网页时 —— 我们希望能够将数据保存到我们的服务器上。</p>
<p>我们可以使用 <code>window.onunload</code> 事件来实现：</p>
<pre><code class="language-js"><span class="hljs-built_in">window</span>.onunload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  fetch(<span class="hljs-string">&#x27;/analytics&#x27;</span>, {
    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,
    <span class="hljs-attr">body</span>: <span class="hljs-string">&quot;statistics&quot;</span>,

    keepalive: <span class="hljs-literal">true</span>

  });
};</code></pre>
<p>通常，当一个文档被卸载时（unloaded），所有相关的网络请求都会被中止。但是，<code>keepalive</code> 选项告诉浏览器，即使在离开页面后，也要在后台执行请求。所以，此选项对于我们的请求成功至关重要。</p>
<p>它有一些限制：</p>
<ul>
<li>我们无法发送兆字节的数据：<code>keepalive</code> 请求的 body 限制为 64kb。<ul>
<li>如果我们收集了更多数据，我们可以定期将其以数据包的形式发送出去，这样就不会留下太多数据给最后的 <code>onunload</code> 请求了。</li>
<li>该限制是对当前正在进行的所有请求的。因此，我们无法通过创建 100 个请求，每个 64kb 这样来作弊。</li>
</ul>
</li>
<li>如果请求是在 <code>onunload</code> 中发起的，我们将无法处理服务器响应，因为文档在那个时候已经卸载了（unloaded），函数将无法工作。<ul>
<li>通常来说，服务器会向此类请求发送空响应，所以这不是问题。</li>
</ul>
</li>
</ul>
