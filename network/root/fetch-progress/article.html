<h1 id="fetch：下载进度">Fetch：下载进度</h1>
<p><code>fetch</code> 方法允许去跟踪 <strong>下载</strong> 进度。</p>
<p>请注意：到目前为止，<code>fetch</code> 方法无法跟踪 <strong>上传</strong> 进度。对于这个目的，请使用 <a href="info:xmlhttprequest">XMLHttpRequest</a>，我们在后面章节会讲到。</p>
<p>要跟踪下载进度，我们可以使用 <code>response.body</code> 属性。它是 <code>ReadableStream</code> —— 一个特殊的对象，它可以逐块（chunk）提供 body。在 <a href="https://streams.spec.whatwg.org/#rs-class">Streams API</a> 规范中有对 <code>ReadableStream</code> 的详细描述。</p>
<p>与 <code>response.text()</code>，<code>response.json()</code> 和其他方法不同，<code>response.body</code> 给予了对进度读取的完全控制，我们可以随时计算下载了多少。</p>
<p>这是从 <code>response.body</code> 读取 response 的示例代码：</p>
<pre><code class="language-js"><span class="hljs-comment">// 代替 response.json() 以及其他方法</span>
<span class="hljs-keyword">const</span> reader = response.body.getReader();

<span class="hljs-comment">// 在 body 下载时，一直为无限循环</span>
<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) {
  <span class="hljs-comment">// 当最后一块下载完成时，done 值为 true</span>
  <span class="hljs-comment">// value 是块字节的 Uint8Array</span>
  <span class="hljs-keyword">const</span> {done, value} = <span class="hljs-keyword">await</span> reader.read();

  <span class="hljs-keyword">if</span> (done) {
    <span class="hljs-keyword">break</span>;
  }

  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Received <span class="hljs-subst">${value.length}</span> bytes`</span>)
}</code></pre>
<p><code>await reader.read()</code> 调用的结果是一个具有两个属性的对象：</p>
<ul>
<li><strong><code>done</code></strong> —— 当读取完成时为 <code>true</code>，否则为 <code>false</code>。</li>
<li><strong><code>value</code></strong> —— 字节的类型化数组：<code>Uint8Array</code>。</li>
</ul>
<pre><code class="language-smart">Streams API 还描述了如果使用 `for await..of` 循环异步迭代 `ReadableStream`，但是目前为止，它还未得到很好的支持（参见 [浏览器问题](https://github.com/whatwg/streams/issues/778#issuecomment-461341033)），所以我们使用了 `while` 循环。</code></pre>
<p>我们在循环中接收响应块（response chunk），直到加载完成，也就是：直到 <code>done</code> 为 <code>true</code>。</p>
<p>要将进度打印出来，我们只需要将每个接收到的片段 <code>value</code> 的长度（length）加到 counter 即可。</p>
<p>这是获取响应，并在控制台中记录进度的完整工作示例，下面有更多说明：</p>
<pre><code class="language-js"><span class="hljs-comment">// Step 1：启动 fetch，并获得一个 reader</span>
<span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits?per_page=100&#x27;</span>);

<span class="hljs-keyword">const</span> reader = response.body.getReader();

<span class="hljs-comment">// Step 2：获得总长度（length）</span>
<span class="hljs-keyword">const</span> contentLength = +response.headers.get(<span class="hljs-string">&#x27;Content-Length&#x27;</span>);

<span class="hljs-comment">// Step 3：读取数据</span>
<span class="hljs-keyword">let</span> receivedLength = <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前接收到了这么多字节</span>
<span class="hljs-keyword">let</span> chunks = []; <span class="hljs-comment">// 接收到的二进制块的数组（包括 body）</span>
<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">const</span> {done, value} = <span class="hljs-keyword">await</span> reader.read();

  <span class="hljs-keyword">if</span> (done) {
    <span class="hljs-keyword">break</span>;
  }

  chunks.push(value);
  receivedLength += value.length;

  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Received <span class="hljs-subst">${receivedLength}</span> of <span class="hljs-subst">${contentLength}</span>`</span>)
}

<span class="hljs-comment">// Step 4：将块连接到单个 Uint8Array</span>
<span class="hljs-keyword">let</span> chunksAll = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(receivedLength); <span class="hljs-comment">// (4.1)</span>
<span class="hljs-keyword">let</span> position = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> chunk <span class="hljs-keyword">of</span> chunks) {
    chunksAll.set(chunk, position); <span class="hljs-comment">// (4.2)</span>
    position += chunk.length;
}

<span class="hljs-comment">// Step 5：解码成字符串</span>
<span class="hljs-keyword">let</span> result = <span class="hljs-keyword">new</span> TextDecoder(<span class="hljs-string">&quot;utf-8&quot;</span>).decode(chunksAll);

<span class="hljs-comment">// 我们完成啦！</span>
<span class="hljs-keyword">let</span> commits = <span class="hljs-built_in">JSON</span>.parse(result);
alert(commits[<span class="hljs-number">0</span>].author.login);</code></pre>
<p>让我们一步步解释下这个过程：</p>
<ol>
<li><p>我们像往常一样执行 <code>fetch</code>，但不是调用 <code>response.json()</code>，而是获得了一个流读取器（stream reader）<code>response.body.getReader()</code>。</p>
<p> 请注意，我们不能同时使用这两种方法来读取相同的响应。要么使用流读取器，要么使用 reponse 方法来获取结果。</p>
</li>
<li><p>在读取数据之前，我们可以从 <code>Content-Length</code> header 中得到完整的响应长度。</p>
<p> 跨源请求中可能不存在这个 header（请参见 <a href="info:fetch-crossorigin">info:fetch-crossorigin</a>），并且从技术上讲，服务器可以不设置它。但是通常情况下它都会在那里。</p>
</li>
<li><p>调用 <code>await reader.read()</code>，直到它完成。</p>
<p> 我们将响应块收集到数组 <code>chunks</code> 中。这很重要，因为在使用完（consumed）响应后，我们将无法使用 <code>response.json()</code> 或者其他方式（你可以试试，将会出现 error）去“重新读取”它。</p>
</li>
<li><p>最后，我们有了一个 <code>chunks</code> —— 一个 <code>Uint8Array</code> 字节块数组。我们需要将这些块合并成一个结果。但不幸的是，没有单个方法可以将它们串联起来，所以这里需要一些代码来实现：</p>
<ol>
<li>我们创建 <code>chunksAll = new Uint8Array(receivedLength)</code> —— 一个具有所有数据块合并后的长度的同类型数组。</li>
<li>然后使用 <code>.set(chunk, position)</code> 方法，从数组中一个个地复制这些 <code>chunk</code>。</li>
</ol>
</li>
<li><p>我们的结果现在储存在 <code>chunksAll</code> 中。但它是一个字节数组，不是字符串。</p>
<p> 要创建一个字符串，我们需要解析这些字节。可以使用内建的 <a href="info:text-decoder">TextDecoder</a> 对象完成。然后，我们可以 <code>JSON.parse</code> 它，如果有必要的话。</p>
<p> 如果我们需要的是二进制内容而不是字符串呢？这更简单。用下面这行代码替换掉第 4 和第 5 步，这行代码从所有块创建一个 <code>Blob</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> blob = <span class="hljs-keyword">new</span> Blob(chunks);</code></pre>
</li>
</ol>
<p>最后，我们得到了结果（以字符串或 blob 的形式表示，什么方便就用什么），并在过程中对进度进行了跟踪。</p>
<p>再强调一遍，这不能用于 <strong>上传</strong> 过程（现在无法通过 <code>fetch</code> 获取），仅用于 <strong>下载</strong> 过程。</p>
