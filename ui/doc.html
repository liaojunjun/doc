<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>create for ggdoc , @author sunyi</title>
    <style>
        .octicon{display:inline-block;fill:currentColor;vertical-align:text-bottom}
        .anchor{float:left;line-height:1;margin-left:-20px;padding-right:4px}
        .anchor:focus{outline:0}
        h1 .octicon-link,h2 .octicon-link,h3 .octicon-link,h4 .octicon-link,h5 .octicon-link,h6 .octicon-link{color:#1b1f23;vertical-align:middle;visibility:hidden}
        h1:hover .anchor,h2:hover .anchor,h3:hover .anchor,h4:hover .anchor,h5:hover .anchor,h6:hover .anchor{text-decoration:none}
        h1:hover .anchor .octicon-link,h2:hover .anchor .octicon-link,h3:hover .anchor .octicon-link,h4:hover .anchor .octicon-link,h5:hover .anchor .octicon-link,h6:hover .anchor .octicon-link{visibility:visible}
        h1:hover .anchor .octicon-link:before,h2:hover .anchor .octicon-link:before,h3:hover .anchor .octicon-link:before,h4:hover .anchor .octicon-link:before,h5:hover .anchor .octicon-link:before,h6:hover .anchor .octicon-link:before{width:16px;height:16px;content:" ";display:inline-block;background-image:url("data:image/svg+xml,%3Csvgxmlns='http://www.w3.org/2000/svg'viewBox='001616'version='1.1'width='16'height='16'aria-hidden='true'%3E%3Cpathfill-rule='evenodd'd='M49h1v1H4c-1.50-3-1.69-3-3.5S2.55343h4c1.45031.6933.501.41-.912.72-23.25V8.59c.58-.451-1.271-2.09C105.228.98484H4c-.980-21.22-22.5S3949zm9-3h-1v1h1c1021.2222.5S13.98121312H9c-.980-2-1.22-2-2.50-.83.42-1.641-2.09V6.25c-1.09.53-21.84-23.25C611.317.5513913h4c1.4503-1.693-3.5S14.56136z'%3E%3C/path%3E%3C/svg%3E")}
        body{-webkit-text-size-adjust:100%;line-height:1.5;color:#24292e;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji;font-size:16px;line-height:1.5;word-wrap:break-word;background-color:#e3e3ef;height:100%;width:100%;margin:0;padding:20px}
        details{display:block}
        summary{display:list-item}
        a{background-color:initial}
        a:active,a:hover{outline-width:0}
        strong{font-weight:inherit;font-weight:bolder}
        h1{font-size:2em;margin:.67em 0}
        img{border-style:none}
        code,kbd,pre{font-family:monospace,monospace;font-size:1em}
        hr{box-sizing:initial;height:0;overflow:visible}
        input{font:inherit;margin:0}
        input{overflow:visible}
        [type="checkbox"]{box-sizing:border-box;padding:0}
        *{box-sizing:border-box}
        input{font-family:inherit;font-size:inherit;line-height:inherit}
        a{color:#0366d6;text-decoration:none}
        a:hover{text-decoration:underline}
        strong{font-weight:600}
        hr{height:0;margin:15px 0;overflow:hidden;background:transparent;border:0;border-bottom:1px solid #dfe2e5}
        hr:after,hr:before{display:table;content:""}
        hr:after{clear:both}
        table{border-spacing:0;border-collapse:collapse}
        td,th{padding:0}
        details summary{cursor:pointer}
        kbd{display:inline-block;padding:3px 5px;font:11px SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;line-height:10px;color:#444d56;vertical-align:middle;background-color:#fafbfc;border:1px solid #d1d5da;border-radius:3px;box-shadow:inset 0 -1px 0 #d1d5da}
        h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:0}
        h1{font-size:32px}
        h1,h2{font-weight:600}
        h2{font-size:24px}
        h3{font-size:20px}
        h3,h4{font-weight:600}
        h4{font-size:16px}
        h5{font-size:14px}
        h5,h6{font-weight:600}
        h6{font-size:12px}
        p{margin-top:0;margin-bottom:10px}
        blockquote{margin:0}
        ol,ul{padding-left:0;margin-top:0;margin-bottom:0}
        ol ol,ul ol{list-style-type:lower-roman}
        ol ol ol,ol ul ol,ul ol ol,ul ul ol{list-style-type:lower-alpha}
        dd{margin-left:0}
        code,pre{font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:12px}
        pre{margin-top:0;margin-bottom:0}
        input::-webkit-inner-spin-button,input::-webkit-outer-spin-button{margin:0;-webkit-appearance:none;appearance:none}
        :checked+.radio-label{position:relative;z-index:1;border-color:#0366d6}
        .border{border:1px solid #e1e4e8!important}
        .border-0{border:0!important}
        .border-bottom{border-bottom:1px solid #e1e4e8!important}
        .rounded-1{border-radius:3px!important}
        .bg-white{background-color:#fff!important}
        .bg-gray-light{background-color:#fafbfc!important}
        .text-gray-light{color:#6a737d!important}
        .mb-0{margin-bottom:0!important}
        .my-2{margin-top:8px!important;margin-bottom:8px!important}
        .pl-0{padding-left:0!important}
        .py-0{padding-top:0!important;padding-bottom:0!important}
        .pl-1{padding-left:4px!important}
        .pl-2{padding-left:8px!important}
        .py-2{padding-top:8px!important;padding-bottom:8px!important}
        .pl-3,.px-3{padding-left:16px!important}
        .px-3{padding-right:16px!important}
        .pl-4{padding-left:24px!important}
        .pl-5{padding-left:32px!important}
        .pl-6{padding-left:40px!important}
        .f6{font-size:12px!important}
        .lh-condensed{line-height:1.25!important}
        .text-bold{font-weight:600!important}
        .pl-c{color:#6a737d}
        .pl-c1,.pl-s .pl-v{color:#005cc5}
        .pl-e,.pl-en{color:#6f42c1}
        .pl-s .pl-s1,.pl-smi{color:#24292e}
        .pl-ent{color:#22863a}
        .pl-k{color:#d73a49}
        .pl-pds,.pl-s,.pl-s .pl-pse .pl-s1,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre{color:#032f62}
        .pl-smw,.pl-v{color:#e36209}
        .pl-bu{color:#b31d28}
        .pl-ii{color:#fafbfc;background-color:#b31d28}
        .pl-c2{color:#fafbfc;background-color:#d73a49}
        .pl-c2:before{content:"^M"}
        .pl-sr .pl-cce{font-weight:700;color:#22863a}
        .pl-ml{color:#735c0f}
        .pl-mh,.pl-mh .pl-en,.pl-ms{font-weight:700;color:#005cc5}
        .pl-mi{font-style:italic;color:#24292e}
        .pl-mb{font-weight:700;color:#24292e}
        .pl-md{color:#b31d28;background-color:#ffeef0}
        .pl-mi1{color:#22863a;background-color:#f0fff4}
        .pl-mc{color:#e36209;background-color:#ffebda}
        .pl-mi2{color:#f6f8fa;background-color:#005cc5}
        .pl-mdr{font-weight:700;color:#6f42c1}
        .pl-ba{color:#586069}
        .pl-sg{color:#959da5}
        .pl-corl{text-decoration:underline;color:#032f62}
        .mb-0{margin-bottom:0!important}
        .my-2{margin-bottom:8px!important}
        .my-2{margin-top:8px!important}
        .pl-0{padding-left:0!important}
        .py-0{padding-top:0!important;padding-bottom:0!important}
        .pl-1{padding-left:4px!important}
        .pl-2{padding-left:8px!important}
        .py-2{padding-top:8px!important;padding-bottom:8px!important}
        .pl-3{padding-left:16px!important}
        .pl-4{padding-left:24px!important}
        .pl-5{padding-left:32px!important}
        .pl-6{padding-left:40px!important}
        .pl-7{padding-left:48px!important}
        .pl-8{padding-left:64px!important}
        .pl-9{padding-left:80px!important}
        .pl-10{padding-left:96px!important}
        .pl-11{padding-left:112px!important}
        .pl-12{padding-left:128px!important}
        hr{border-bottom-color:#eee}
        kbd{display:inline-block;padding:3px 5px;font:11px SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;line-height:10px;color:#444d56;vertical-align:middle;background-color:#fafbfc;border:1px solid #d1d5da;border-radius:3px;box-shadow:inset 0 -1px 0 #d1d5da}
        .markdown-body:after,.markdown-body:before{display:table;content:""}
        .markdown-body:after{clear:both}
        .markdown-body>:first-child{margin-top:0!important}
        .markdown-body>:last-child{margin-bottom:0!important}
        a:not([href]){color:inherit;text-decoration:none}
        blockquote,details,dl,ol,p,pre,table,ul{margin-top:0;margin-bottom:16px}
        hr{height:.25em;padding:0;margin:24px 0;background-color:#e1e4e8;border:0}
        blockquote{padding:0 1em;color:#6a737d;border-left:.25em solid #dfe2e5}
        blockquote>:first-child{margin-top:0}
        blockquote>:last-child{margin-bottom:0}
        h1,h2,h3,h4,h5,h6{margin-top:24px;margin-bottom:16px;font-weight:600;line-height:1.25}
        h1{font-size:2em}
        h1,h2{padding-bottom:.3em;border-bottom:1px solid #eaecef}
        h2{font-size:1.5em}
        h3{font-size:1.25em}
        h4{font-size:1em}
        h5{font-size:.875em}
        h6{font-size:.85em;color:#6a737d}
        ol,ul{padding-left:2em}
        ol ol,ol ul,ul ol,ul ul{margin-top:0;margin-bottom:0}
        li{word-wrap:break-all}
        li>p{margin-top:16px}
        li+li{margin-top:.25em}
        dl{padding:0}
        dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:600}
        dl dd{padding:0 16px;margin-bottom:16px}
        table{display:block;width:100%;overflow:auto}
        table th{font-weight:600}
        table td,table th{padding:6px 13px;border:1px solid #dfe2e5}
        table tr{background-color:#fff;border-top:1px solid #c6cbd1}
        table tr:nth-child(2n){background-color:#f6f8fa}
        img{max-width:100%;box-sizing:initial;background-color:#fff}
        img[align="right"]{padding-left:20px}
        img[align="left"]{padding-right:20px}
        code{padding:.2em .4em;margin:0;font-size:85%;background-color:rgba(27,31,35,0.05);border-radius:3px}
        pre{word-wrap:normal}
        pre>code{padding:0;margin:0;font-size:100%;word-break:normal;white-space:pre;background:transparent;border:0}
        .highlight{margin-bottom:16px}
        .highlight pre{margin-bottom:0;word-break:normal}
        .highlight pre,pre{padding:16px;overflow:auto;font-size:85%;line-height:1.45;background-color:#f6f8fa;border-radius:3px}
        pre code{display:inline;max-width:auto;padding:0;margin:0;overflow:visible;line-height:inherit;word-wrap:normal;background-color:initial;border:0}
        .commit-tease-sha{display:inline-block;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:90%;color:#444d56}
        .full-commit .btn-outline:not(:disabled):hover{color:#005cc5;border-color:#005cc5}
        .blob-wrapper{overflow-x:auto;overflow-y:hidden}
        .blob-wrapper-embedded{max-height:240px;overflow-y:auto}
        .blob-num{width:1%;min-width:50px;padding-right:10px;padding-left:10px;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:12px;line-height:20px;color:rgba(27,31,35,0.3);text-align:right;white-space:nowrap;vertical-align:top;cursor:pointer;user-select:none}
        .blob-num:hover{color:rgba(27,31,35,0.6)}
        .blob-num:before{content:attr(data-line-number)}
        .blob-code{position:relative;padding-right:10px;padding-left:10px;line-height:20px;vertical-align:top}
        .blob-code-inner{overflow:visible;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:12px;color:#24292e;word-wrap:normal;white-space:pre}
        .pl-token.active,.pl-token:hover{cursor:pointer;background:#ffea7f}
        .tab-size[data-tab-size="1"]{-moz-tab-size:1;tab-size:1}
        .tab-size[data-tab-size="2"]{-moz-tab-size:2;tab-size:2}
        .tab-size[data-tab-size="3"]{-moz-tab-size:3;tab-size:3}
        .tab-size[data-tab-size="4"]{-moz-tab-size:4;tab-size:4}
        .tab-size[data-tab-size="5"]{-moz-tab-size:5;tab-size:5}
        .tab-size[data-tab-size="6"]{-moz-tab-size:6;tab-size:6}
        .tab-size[data-tab-size="7"]{-moz-tab-size:7;tab-size:7}
        .tab-size[data-tab-size="8"]{-moz-tab-size:8;tab-size:8}
        .tab-size[data-tab-size="9"]{-moz-tab-size:9;tab-size:9}
        .tab-size[data-tab-size="10"]{-moz-tab-size:10;tab-size:10}
        .tab-size[data-tab-size="11"]{-moz-tab-size:11;tab-size:11}
        .tab-size[data-tab-size="12"]{-moz-tab-size:12;tab-size:12}
        .task-list-item{list-style-type:none}
        .task-list-item+.task-list-item{margin-top:3px}
        .task-list-item input{margin:0 .2em .25em -1.6em;vertical-align:middle}
        #page{width:calc(100% - 500px);margin-left:500px;overflow: hidden;}
        fieldset{display:none;background-color:#fff;border:0;overflow:hidden;box-shadow:2px 2px 10px rgba(128,128,128,0.2);margin-bottom:20px;padding:20px}
        fieldset legend{font-weight:bold;color:green;height:3.5em;margin-left:-20px;padding:0}
        #nav{background:rgb(255 255 255 / .7);padding:20px 10px 100px 20px;position:fixed;top:0;left:0;bottom:0;width:500px;overflow-y:auto;overflow-x: hidden;white-space:nowrap}
        ::-webkit-scrollbar{width:5px}
        ::-webkit-scrollbar-thumb{background-color:#79a5e8}
        @media print,(max-width:900px){
          #nav{display:none!important}
          #page{width:100%!important;margin-left:0!important}
          fieldset{padding-top: 0 !important;padding-bottom: 0 !important;display:block!important;box-shadow:none!important}
          .toggle-hash-btn {display: none !important;}
        }
        .hljs{display:block;overflow-x:auto;padding:.5em;color:#333;background:#f8f8f8}
        .hljs-comment,.hljs-quote{color:#998;font-style:italic}
        .hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:bold}
        .hljs-number,.hljs-literal,.hljs-variable,.hljs-template-variable,.hljs-tag .hljs-attr{color:#008080}
        .hljs-string,.hljs-doctag{color:#d14}
        .hljs-title,.hljs-section,.hljs-selector-id{color:#900;font-weight:bold}
        .hljs-subst{font-weight:normal}
        .hljs-type,.hljs-class .hljs-title{color:#458;font-weight:bold}
        .hljs-tag,.hljs-name,.hljs-attribute{color:#000080;font-weight:normal}
        .hljs-regexp,.hljs-link{color:#009926}
        .hljs-symbol,.hljs-bullet{color:#990073}
        .hljs-built_in,.hljs-builtin-name{color:#0086b3}
        .hljs-meta{color:#999;font-weight:bold}
        .hljs-deletion{background:#fdd}
        .hljs-addition{background:#dfd}
        .hljs-emphasis{font-style:italic}
        .hljs-strong{font-weight:bold}
        .toggle-hash-btn {position: fixed;bottom: 10px;left:10px;z-index: 1000; display: flex; justify-content: space-between;  width: 270px;}
        iframe {border: 5px solid #999;margin:10px;width: 90%;min-height: 50px;}
    </style>
    <script>
          const $ = selector => document.querySelector(selector);
          const $$ = selector => document.querySelectorAll(selector);
          const decode = s => decodeURIComponent(s);
          const domInfo = dom => ({
            offsetParent: dom.offsetParent.className,
            offsetLeft: dom.offsetLeft,
            offsetTop: dom.offsetTop,
            clientWidth: dom.clientWidth,
            offsetWidth: dom.offsetWidth,
            BoundingClientRect: dom.getBoundingClientRect(),
          });
          let openHash = false;
          function viewFieldset() {
            const hash = decode(location.hash);
            if(openHash && hash &&$(`fieldset${hash}`)) {
              Array.from($$('fieldset')).forEach(dom  =>dom.style.display = 'none');
              $(`fieldset${hash}`).style.display = 'block';
            }else {
              Array.from($$('fieldset')).forEach(dom  =>dom.style.display = 'block');
            }
          }
          window.onhashchange = viewFieldset;
          window.onload  = ()=>{
            viewFieldset();
            setATarget();
          };
          
          function toggleHash() {
            openHash = !openHash;
            viewFieldset();
            $('.toggle-hash-btn button').innerText = openHash ? '关闭专注模式' : '开启专注模式';
          }
          function setATarget() {
            $$('#page a').forEach(a=>a.target = '_blank');
          }
    </script>
</head>

<body>
  <div class="toggle-hash-btn">
    <button  onclick="toggleHash()">开启专注模式</button>
  </div><div id="page">
      <fieldset id='_QSncxJ'>
      <legend>article</legend>
      <h1 id="浏览器环境，规格">浏览器环境，规格</h1>
<p>JavaScript 语言最初是为 Web 浏览器创建的。此后，它已经发展成为一种具有多种用途和平台的语言。</p>
<p>平台可以是一个浏览器，一个 Web 服务器，或其他 <strong>主机（host）</strong>，甚至可以是一个“智能”咖啡机，如果它能运行 JavaScript 的话。它们每个都提供了特定于平台的功能。JavaScript 规范将其称为 <strong>主机环境</strong>。</p>
<p>主机环境提供了自己的对象和语言核心以外的函数。Web 浏览器提供了一种控制网页的方法。Node.JS 提供了服务器端功能，等等。</p>
<p>下面是 JavaScript 在浏览器中运行时的鸟瞰示意图：</p>
<p><img src="windowObjects.svg" alt=""></p>
<p>有一个叫做 <code>window</code> 的“根”对象。它有两个角色：</p>
<ol>
<li>首先，它是 JavaScript 代码的全局对象，如 <a href="info:global-object">info:global-object</a> 一章所述。</li>
<li>其次，它代表“浏览器窗口”，并提供了控制它的方法。</li>
</ol>
<p>例如，在这里我们将它用作全局对象：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-string">&quot;Hello&quot;</span>);
}

<span class="hljs-comment">// 全局函数是全局对象的方法：</span>
<span class="hljs-built_in">window</span>.sayHi();</code></pre>
<p>在这里，我们将它用作浏览器窗口，以查看窗口高度：</p>
<pre><code class="language-js">alert(<span class="hljs-built_in">window</span>.innerHeight); <span class="hljs-comment">// 内部窗口高度</span></code></pre>
<p>还有更多窗口特定的方法和属性，我们稍后会介绍它们。</p>
<h2 id="文档对象模型（dom）">文档对象模型（DOM）</h2>
<p>文档对象模型（Document Object Model），简称 DOM，将所有页面内容表示为可以修改的对象。</p>
<p><code>document</code> 对象是页面的主要“入口点”。我们可以使用它来更改或创建页面上的任何内容。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-comment">// 将背景颜色修改为红色</span>
<span class="hljs-built_in">document</span>.body.style.background = <span class="hljs-string">&quot;red&quot;</span>;

<span class="hljs-comment">// 在 1 秒后将其修改回来</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">document</span>.body.style.background = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">1000</span>);</code></pre>
<p>在这里，我们使用了 <code>document.body.style</code>，但还有很多很多其他的东西。规范中有属性和方法的详细描述：<a href="https://dom.spec.whatwg.org">DOM Living Standard</a>。</p>
<pre><code class="language-smart">DOM 规范解释了文档的结构，并提供了操作文档的对象。有的非浏览器设备也使用 DOM。

例如，下载 HTML 文件并对其进行处理的服务器端脚本也可以使用 DOM。但它们可能仅支持部分规范中的内容。</code></pre>
<pre><code class="language-smart">另外也有一份针对 CSS 规则和样式表的、单独的规范 [CSS Object Model (CSSOM)](https://www.w3.org/TR/cssom-1/)，这份规范解释了如何将 CSS 表示为对象，以及如何读写这些对象。

当我们修改文档的样式规则时，CSSOM 与 DOM 是一起使用的。但实际上，很少需要 CSSOM，因为我们很少需要从 JavaScript 中修改 CSS 规则（我们通常只是添加/移除一些 CSS 类，而不是直接修改其中的 CSS 规则），但这也是可行的。</code></pre>
<h2 id="浏览器对象模型（bom）">浏览器对象模型（BOM）</h2>
<p>浏览器对象模型（Browser Object Model），简称 BOM，表示由浏览器（主机环境）提供的用于处理文档（document）之外的所有内容的其他对象。</p>
<p>例如：</p>
<ul>
<li><a href="mdn:api/Window/navigator">navigator</a> 对象提供了有关浏览器和操作系统的背景信息。navigator 有许多属性，但是最广为人知的两个属性是：<code>navigator.userAgent</code> — 关于当前浏览器，<code>navigator.platform</code> — 关于平台（可以帮助区分 Windows/Linux/Mac 等）。</li>
<li><a href="mdn:api/Window/navigator">location</a> 对象允许我们读取当前 URL，并且可以将浏览器重定向到新的 URL。</li>
</ul>
<p>这是我们可以如何使用 <code>location</code> 对象的方法：</p>
<pre><code class="language-js">alert(location.href); <span class="hljs-comment">// 显示当前 URL</span>
<span class="hljs-keyword">if</span> (confirm(<span class="hljs-string">&quot;Go to Wikipedia?&quot;</span>)) {
  location.href = <span class="hljs-string">&quot;https://wikipedia.org&quot;</span>; <span class="hljs-comment">// 将浏览器重定向到另一个 URL</span>
}</code></pre>
<p>函数 <code>alert/confirm/prompt</code> 也是 BOM 的一部分：它们与文档（document）没有直接关系，但它代表了与用户通信的纯浏览器方法。</p>
<pre><code class="language-smart">BOM 是通用 [HTML 规范](https://html.spec.whatwg.org) 的一部分。

是的，你没听错。在 &lt;https://html.spec.whatwg.org&gt; 中的 HTML 规范不仅是关于“HTML 语言”（标签，特性）的，还涵盖了一堆对象、方法和浏览器特定的 DOM 扩展。这就是“广义的 HTML”。此外，某些部分也有其他的规范，它们被列在 &lt;https://spec.whatwg.org&gt; 中。</code></pre>
<h2 id="总结">总结</h2>
<p>说到标准，我们有：</p>
<p>DOM 规范
: 描述文档的结构、操作和事件，详见 <a href="https://dom.spec.whatwg.org">https://dom.spec.whatwg.org</a>。</p>
<p>CSSOM 规范
: 描述样式表和样式规则，对它们进行的操作，以及它们与文档的绑定，详见 <a href="https://www.w3.org/TR/cssom-1/">https://www.w3.org/TR/cssom-1/</a>。</p>
<p>HTML 规范
: 描述 HTML 语言（例如标签）以及 BOM（浏览器对象模型）— 各种浏览器函数：<code>setTimeout</code>，<code>alert</code>，<code>location</code> 等，详见 <a href="https://html.spec.whatwg.org">https://html.spec.whatwg.org</a>。它采用了 DOM 规范，并使用了许多其他属性和方法对其进行了扩展。</p>
<p>此外，某些类被分别描述在 <a href="https://spec.whatwg.org/">https://spec.whatwg.org/</a>。</p>
<p>请注意这些链接，因为要学的东西太多了，所以不可能涵盖并记住所有内容。</p>
<p>当你想要了解某个属性或方法时，Mozilla 手册 <a href="https://developer.mozilla.org/en-US/search">https://developer.mozilla.org/en-US/search</a> 是一个很好的资源，但对应的规范可能会更好：它更复杂，且阅读起来需要更长的时间，但是会使你的基本知识更加全面，更加完整。</p>
<p>要查找某些内容时，你通常可以使用互联网搜索 &quot;WHATWG [term]&quot; 或 &quot;MDN [term]&quot;，例如 <a href="https://google.com?q=whatwg+localstorage">https://google.com?q=whatwg+localstorage</a>，<a href="https://google.com?q=mdn+localstorage">https://google.com?q=mdn+localstorage</a>。</p>
<p>现在，我们开始学习 DOM，因为文档在 UI 中扮演着核心角色。</p>

      </fieldset>
      
      <fieldset id='_awpr8v'>
      <legend>article</legend>
      <p>libs:</p>
<ul>
<li>d3</li>
<li>domtree</li>
</ul>
<hr>
<h1 id="dom-树">DOM 树</h1>
<p>HTML 文档的主干是标签（tag）。</p>
<p>根据文档对象模型（DOM），每个 HTML 标签都是一个对象。嵌套的标签是闭合标签的“子标签（children）”。标签内的文本也是一个对象。</p>
<p>所有这些对象都可以通过 JavaScript 来访问，我们可以使用它们来修改页面。</p>
<p>例如，<code>document.body</code> 是表示 <code>&lt;body&gt;</code> 标签的对象。</p>
<p>运行这段代码会使 <code>&lt;body&gt;</code> 保持 3 秒红色状态:</p>
<pre><code class="language-js"><span class="hljs-built_in">document</span>.body.style.background = <span class="hljs-string">&#x27;red&#x27;</span>; <span class="hljs-comment">// 将背景设置为红色</span>

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">document</span>.body.style.background = <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-number">3000</span>); <span class="hljs-comment">// 恢复回去</span></code></pre>
<p>在这，我们使用了 <code>style.background</code> 来修改 <code>document.body</code> 的背景颜色，但是还有很多其他的属性，例如：</p>
<ul>
<li><code>innerHTML</code> — 节点的 HTML 内容。</li>
<li><code>offsetWidth</code> — 节点宽度（以像素度量）</li>
<li>……等。</li>
</ul>
<p>很快，我们将学习更多操作 DOM 的方法，但首先我们需要了解 DOM 的结构。</p>
<h2 id="dom-的例子">DOM 的例子</h2>
<p>让我们从下面这个简单的文档（document）开始：</p>
<pre><code class="language-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">HTML</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>About elk<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  The truth about elk.
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p>DOM 将 HTML 表示为标签的树形结构。它看起来如下所示：</p>
<div class="domtree"></div>

<script>
let node1 = {"name":"HTML","nodeType":1,"children":[{"name":"HEAD","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"\n    "},{"name":"TITLE","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"About elk"}]},{"name":"#text","nodeType":3,"content":"\n  "}]},{"name":"#text","nodeType":3,"content":"\n  "},{"name":"BODY","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"\n  The truth about elk."}]}]}

drawHtmlTree(node1, 'div.domtree', 690, 320);
</script>

<pre><code class="language-online">在上面的图片中，你可以点击元素（element）节点，它们的子节点会打开/折叠。</code></pre>
<p>每个树的节点都是一个对象。</p>
<p>标签被称为 <strong>元素节点</strong>（或者仅仅是元素），并形成了树状结构：<code>&lt;html&gt;</code> 在根节点，<code>&lt;head&gt;</code> 和 <code>&lt;body&gt;</code> 是其子项，等。</p>
<p>元素内的文本形成 <strong>文本节点</strong>，被标记为 <code>＃text</code>。一个文本节点只包含一个字符串。它没有子项，并且总是树的叶子。</p>
<p>例如，<code>&lt;title&gt;</code> 标签里面有文本 <code>&quot;About elk&quot;</code>。</p>
<p>请注意文本节点中的特殊字符：</p>
<ul>
<li>换行符：<code>↵</code>（在 JavaScript 中为 <code>\n</code>）</li>
<li>空格：<code>␣</code></li>
</ul>
<p>空格和换行符都是完全有效的字符，就像字母和数字。它们形成文本节点并成为 DOM 的一部分。所以，例如，在上面的示例中，<code>&lt;head&gt;</code> 标签中的 <code>&lt;title&gt;</code> 标签前面包含了一些空格，并且该文本变成了一个 <code>#text</code> 节点（它只包含一个换行符和一些空格）。</p>
<p>只有两个顶级排除项：</p>
<ol>
<li>由于历史原因，<code>&lt;head&gt;</code> 之前的空格和换行符均被忽略。</li>
<li>如果我们在 <code>&lt;/body&gt;</code> 之后放置一些东西，那么它会被自动移动到 <code>body</code> 内，并处于 <code>body</code> 中的最下方，因为 HTML 规范要求所有内容必须位于 <code>&lt;body&gt;</code> 内。所以 <code>&lt;/body&gt;</code> 之后不能有空格。</li>
</ol>
<p>在其他情况下，一切都很简单 — 如果文档中有空格（就像任何字符一样），那么它们将成为 DOM 中的文本节点，而如果我们删除它们，则不会有任何空格。</p>
<p>这是没有空格的文本节点：</p>
<pre><code class="language-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">HTML</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>About elk<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>The truth about elk.<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<div class="domtree"></div>

<script>
let node2 = {"name":"HTML","nodeType":1,"children":[{"name":"HEAD","nodeType":1,"children":[{"name":"TITLE","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"About elk"}]}]},{"name":"BODY","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"The truth about elk."}]}]}

drawHtmlTree(node2, 'div.domtree', 690, 210);
</script>

<pre><code class="language-smart">与 DOM 一起使用的浏览器工具（即将介绍）通常不会在文本的开始/结尾显示空格，并且在标签之间也不会显示空文本节点（换行符）。

开发者工具通过这种方式节省屏幕空间。

在本教程中，如果这些空格和空文本节点无关紧要时，我们在后面出现的关于 DOM 的示意图中会忽略它们。这样的空格通常不会影响文档的显示方式。</code></pre>
<h2 id="自动修正">自动修正</h2>
<p>如果浏览器遇到格式不正确的 HTML，它会在形成 DOM 时自动更正它。</p>
<p>例如，顶级标签总是 <code>&lt;html&gt;</code>。即使它不存在于文档中 — 它也会出现在 DOM 中，因为浏览器会创建它。对于 <code>&lt;body&gt;</code> 也是一样。</p>
<p>例如，如果一个 HTML 文件中只有一个单词 &quot;Hello&quot;，浏览器则会把它包装到 <code>&lt;html&gt;</code> 和 <code>&lt;body&gt;</code> 中，并且会添加所需的 <code>&lt;head&gt;</code>，DOM 将会变成下面这样：</p>
<div class="domtree"></div>

<script>
let node3 = {"name":"HTML","nodeType":1,"children":[{"name":"HEAD","nodeType":1,"children":[]},{"name":"BODY","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"Hello"}]}]}

drawHtmlTree(node3, 'div.domtree', 690, 150);
</script>

<p>在生成 DOM 时，浏览器会自动处理文档中的错误，关闭标签等。</p>
<p>一个没有关闭标签的文档：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello
<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Mom
<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>and
<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Dad</code></pre>
<p>……将成为一个正常的 DOM，因为浏览器在读取标签时会填补缺失的部分：</p>
<div class="domtree"></div>

<script>
let node4 = {"name":"HTML","nodeType":1,"children":[{"name":"HEAD","nodeType":1,"children":[]},{"name":"BODY","nodeType":1,"children":[{"name":"P","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"Hello"}]},{"name":"LI","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"Mom"}]},{"name":"LI","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"and"}]},{"name":"LI","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"Dad"}]}]}]}

drawHtmlTree(node4, 'div.domtree', 690, 360);
</script>

<p>````warn header=&quot;表格永远有 <code>&lt;tbody&gt;</code>&quot;
表格是一个有趣的“特殊的例子”。按照 DOM 规范，它们必须具有 <code>&lt;tbody&gt;</code>，但 HTML 文本却（官方的）忽略了它。然后浏览器在创建 DOM 时，自动地创建了 <code>&lt;tbody&gt;</code>。</p>
<p>对于 HTML：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;table&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre>
<p>DOM 结构会变成：</p>
<div class="domtree"></div>

<script>
let node5 = {"name":"TABLE","nodeType":1,"children":[{"name":"TBODY","nodeType":1,"children":[{"name":"TR","nodeType":1,"children":[{"name":"TD","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"1"}]}]}]}]};

drawHtmlTree(node5,  'div.domtree', 600, 200);
</script>

<p>看到了吗？<code>&lt;tbody&gt;</code> 出现了。你应该记住这一点，以免在使用表格时，对这种情况感到惊讶。</p>
<pre><code>
## 其他节点类型

除了元素和文本节点外，还有一些其他的节点类型。

例如，注释：

```html
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;body&gt;
  The truth about elk.
  &lt;ol&gt;
    &lt;li&gt;An elk is a smart&lt;/li&gt;
*!*
    &lt;!-- comment --&gt;
*/!*
    &lt;li&gt;...and cunning animal!&lt;/li&gt;
  &lt;/ol&gt;
&lt;/body&gt;
&lt;/html&gt;
```

&lt;div class=&quot;domtree&quot;&gt;&lt;/div&gt;

&lt;script&gt;
let node6 = {&quot;name&quot;:&quot;HTML&quot;,&quot;nodeType&quot;:1,&quot;children&quot;:[{&quot;name&quot;:&quot;HEAD&quot;,&quot;nodeType&quot;:1,&quot;children&quot;:[]},{&quot;name&quot;:&quot;BODY&quot;,&quot;nodeType&quot;:1,&quot;children&quot;:[{&quot;name&quot;:&quot;#text&quot;,&quot;nodeType&quot;:3,&quot;content&quot;:&quot;\n  The truth about elk.\n    &quot;},{&quot;name&quot;:&quot;OL&quot;,&quot;nodeType&quot;:1,&quot;children&quot;:[{&quot;name&quot;:&quot;#text&quot;,&quot;nodeType&quot;:3,&quot;content&quot;:&quot;\n      &quot;},{&quot;name&quot;:&quot;LI&quot;,&quot;nodeType&quot;:1,&quot;children&quot;:[{&quot;name&quot;:&quot;#text&quot;,&quot;nodeType&quot;:3,&quot;content&quot;:&quot;An elk is a smart&quot;}]},{&quot;name&quot;:&quot;#text&quot;,&quot;nodeType&quot;:3,&quot;content&quot;:&quot;\n      &quot;},{&quot;name&quot;:&quot;#comment&quot;,&quot;nodeType&quot;:8,&quot;content&quot;:&quot;comment&quot;},{&quot;name&quot;:&quot;#text&quot;,&quot;nodeType&quot;:3,&quot;content&quot;:&quot;\n      &quot;},{&quot;name&quot;:&quot;LI&quot;,&quot;nodeType&quot;:1,&quot;children&quot;:[{&quot;name&quot;:&quot;#text&quot;,&quot;nodeType&quot;:3,&quot;content&quot;:&quot;...and cunning animal!&quot;}]},{&quot;name&quot;:&quot;#text&quot;,&quot;nodeType&quot;:3,&quot;content&quot;:&quot;\n    &quot;}]},{&quot;name&quot;:&quot;#text&quot;,&quot;nodeType&quot;:3,&quot;content&quot;:&quot;\n  \n&quot;}]}]};

drawHtmlTree(node6, &#x27;div.domtree&#x27;, 690, 500);
&lt;/script&gt;

在这里我们可以看到一个新的树节点类型 — *comment node*，被标记为 `#comment`，它在两个文本节点之间。

我们可能会想 — 为什么要将注释添加到 DOM 中？它不会对视觉展现产生任何影响吗。但是有一条规则 — 如果一些内容存在于 HTML 中，那么它也必须在 DOM 树中。

**HTML 中的所有内容，甚至注释，都会成为 DOM 的一部分。**

甚至 HTML 开头的 `&lt;!DOCTYPE...&gt;` 指令也是一个 DOM 节点。它在 DOM 树中位于 `&lt;html&gt;` 之前。我们不会触及那个节点，出于这个原因，我们甚至不会在图表中绘制它，但它确实就在那里。

表示整个文档的 `document` 对象，在形式上也是一个 DOM 节点。

一共有 [12 种节点类型](https://dom.spec.whatwg.org/#node)。实际上，我们通常用到的是其中的 4 种：

1. `document` — DOM 的“入口点”。
2. 元素节点 — HTML 标签，树构建块。
3. 文本节点 — 包含文本。
4. 注释 — 有时我们可以将一些信息放入其中，它不会显示，但 JS 可以从 DOM 中读取它。

## 自己看看

要在实际中查看 DOM 结构，请尝试 [Live DOM Viewer](http://software.hixie.ch/utilities/js/live-dom-viewer/)。只需输入文档，它将立即显示为 DOM。

探索 DOM 的另一种方式是使用浏览器开发工具。实际上，这就是我们在开发中所使用的。

你可以打开这个网页 [elks.html](elks.html)，然后打开浏览器开发工具，并切换到元素（Elements）选项卡。

它看起来像这样：

![](elks.svg)

你可以看到 DOM，点击元素，查看它们的细节等。

请注意，开发者工具中的 DOM 结构是经过简化的。文本节点仅以文本形式显示。并且根本没有“空白”（只有空格）的文本节点。这其实挺好，因为大多数情况下，我们只关心元素节点。

点击左上角的 &lt;span class=&quot;devtools&quot; style=&quot;background-position:-328px -124px&quot;&gt;&lt;/span&gt; 按钮可以让我们使用鼠标（或其他指针设备）从网页中选择一个节点并“检查（inspect）”它（在元素选项卡中滚动到该节点）。当我们有一个巨大的 HTML 页面（和相应的巨大 DOM），并希望查看其中的一个特定元素的位置时，这很有用。

另一种方法是在网页上右键单击，然后在上下文菜单中选择“检查（Inspect）”。

![](inspect.svg)

在工具的右侧部分有以下子选项卡：
- **Styles** — 我们可以看到按规则应用于当前元素的 CSS 规则，包括内置规则（灰色）。几乎所有内容都可以就地编辑，包括下面的方框的 dimension/margin/padding。
- **Computed** — 按属性查看应用于元素的 CSS：对于每个属性，我们可以都可以看到赋予它的规则（包括 CSS 继承等）。
- **Event Listeners** — 查看附加到 DOM 元素的事件侦听器（我们将在本教程的下一部分介绍它们）。
- ……等。

学习它们的最佳方式就是多点一点看一下。大多数值都是可以就地编辑的。

## 与控制台交互

在我们处理 DOM 时，我们可能还希望对其应用 JavaScript。例如：获取一个节点并运行一些代码来修改它，以查看结果。以下是在元素（Elements）选项卡和控制台（Console）之间切换的一些技巧。

首先：

- 在元素（Elements）选项卡中选择第一个 `&lt;li&gt;`。
- 按下 `key:Esc` — 它将在元素（Elements）选项卡下方打开控制台（Console）。

现在最后选中的元素可以通过 `$0` 来进行操作，先前选择的是 `$1`，等。

我们可以对它们执行一些命令。例如，`$0.style.background = &#x27;red&#x27;` 使选定的列表项（list item）变成红色，像这样：

![](domconsole0.svg)

这就是在控制台（Console）中获取元素（Elements）选项卡中的节点的方法。

还有一种方式。如果存在引用 DOM 节点的变量，那么我们可以在控制台（Console）中使用命令 `inspect(node)`，来在元素（Elements）选项卡中查看它。

或者我们可以直接在控制台（Console）中输出 DOM 节点，并“就地”探索它，例如下面的 `document.body`：

![](domconsole1.svg)

当然，这是出于调试目的。从下一章开始，我们将使用 JavaScript 访问和修改 DOM。

浏览器开发者工具对于开发有很大的帮助：我们可以探索 DOM，尝试一些东西，并找出问题所在。

## 总结

HTML/XML 文档在浏览器内均被表示为 DOM 树。

- 标签（tag）成为元素节点，并形成文档结构。
- 文本（text）成为文本节点。
- ……等，HTML 中的所有东西在 DOM 中都有它的位置，甚至对注释也是如此。

我们可以使用开发者工具来检查（inspect）DOM 并手动修改它。

在这里，我们介绍了基础知识，入门最常用和最重要的行为。在 &lt;https://developers.google.cn/web/tools/chrome-devtools&gt; 上有关于 Chrome 开发者工具的详细文档说明。学习这些工具的最佳方式就是到处点一点看一看，阅读菜单：大多数选项都很明显。而后，当你大致了解它们后，请阅读文档并学习其余内容。

DOM 节点具有允许我们在它们之间移动，修改它们，在页面中移动等的属性和方法。在下一章中，我们将介绍它们。</code></pre>

      </fieldset>
      
      <fieldset id='_u51xbI'>
      <legend>solution</legend>
      <p>这里有很多种方法，例如：</p>
<p>获取 <code>&lt;div&gt;</code> DOM 节点：</p>
<pre><code class="language-js"><span class="hljs-built_in">document</span>.body.firstElementChild
<span class="hljs-comment">// 或</span>
<span class="hljs-built_in">document</span>.body.children[<span class="hljs-number">0</span>]
<span class="hljs-comment">// 或（第一个节点是空格，所以我们应该获取的是第二个）</span>
<span class="hljs-built_in">document</span>.body.childNodes[<span class="hljs-number">1</span>]</code></pre>
<p>获取 <code>&lt;ul&gt;</code> DOM 节点：</p>
<pre><code class="language-js"><span class="hljs-built_in">document</span>.body.lastElementChild
<span class="hljs-comment">// 或</span>
<span class="hljs-built_in">document</span>.body.children[<span class="hljs-number">1</span>]</code></pre>
<p>获取第二个 <code>&lt;li&gt;</code>（即包含 Pete 的节点）：</p>
<pre><code class="language-js"><span class="hljs-comment">// 获取 &lt;ul&gt;，然后获取它的最后一个子元素</span>
<span class="hljs-built_in">document</span>.body.lastElementChild.lastElementChild</code></pre>

      </fieldset>
      
      <fieldset id='_vkHaL2'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="dom-子节点">DOM 子节点</h1>
<p>对于这个页面：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Users:<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>John<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Pete<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<p>对于以下各项，请给出至少一种访问方式：</p>
<ul>
<li><code>&lt;div&gt;</code> DOM 节点？</li>
<li><code>&lt;ul&gt;</code> DOM 节点？</li>
<li> 第二个 <code>&lt;li&gt;</code> 节点（即包含 Pete 的节点）？</li>
</ul>

      </fieldset>
      
      <fieldset id='_ZuBekJ'>
      <legend>solution</legend>
      <ol>
<li>是的，这是真的。<code>elem.lastChild</code> 就是最后一个元素，它没有 <code>nextSibling</code>。</li>
<li>不，这是错的，因为  <code>elem.children[0]</code> 是元素中的第一个子元素。但是在它前面可能存在非元素的节点。所以 <code>previousSibling</code> 可能是一个文本节点。</li>
</ol>
<p>请注意，对于这两种情况，如果没有子节点，那么就会报错。</p>
<p>如果这里没有子节点，那么 <code>elem.lastChild</code> 是 <code>null</code>，所以我们就访问不到 <code>elem.lastChild.nextSibling</code>。并且 <code>elem.children</code> 是空的（像一个空数组一样 <code>[]</code>）。</p>

      </fieldset>
      
      <fieldset id='_eOXcbp'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="兄弟节点问题">兄弟节点问题</h1>
<p>如果 <code>elem</code> 是任意一个 DOM 元素节点……</p>
<ul>
<li><code>elem.lastChild.nextSibling</code> 值一直都是 <code>null</code>，这个判定是不是真的？</li>
<li><code>elem.children[0].previousSibling</code> 值一直都是 <code>null</code>，这个判定是不是真的？</li>
</ul>

      </fieldset>
      
      <fieldset id='_OCTNew'>
      <legend>solution</legend>
      <p>我们将使用 <code>rows</code> 和 <code>cells</code> 属性来获取表格中的对角单元格。</p>

      </fieldset>
      
      <fieldset id='_avvXrR'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="选择所有对角单元格">选择所有对角单元格</h1>
<p>编写代码来把表格中的对角单元格都绘制成红色。</p>
<p>你需要用代码从 <code>&lt;table&gt;</code> 中获取所有的对角单元格 <code>&lt;td&gt;</code>，然后绘制它们：</p>
<pre><code class="language-js"><span class="hljs-comment">// td 表示的是对单元格的引用</span>
td.style.backgroundColor = <span class="hljs-string">&#x27;red&#x27;</span>;</code></pre>
<p>结果应该如下所示：</p>
<p>[iframe src=&quot;solution&quot; height=180]</p>

      </fieldset>
      
      <fieldset id='_cHtPyU'>
      <legend>article</legend>
      <p>libs:</p>
<ul>
<li>d3</li>
<li>domtree</li>
</ul>
<hr>
<h1 id="遍历-dom">遍历 DOM</h1>
<p>DOM 让我们可以对元素和它们中的内容做任何事，但是首先我们需要获取到对应的 DOM 对象。</p>
<p>对 DOM 的所有操作都是以 <code>document</code> 对象开始。它是 DOM 的主“入口点”。从它我们可以访问任何节点。</p>
<p>这里是一张描述对象间链接的图片，通过这些链接我们可以在 DOM 节点之间移动。</p>
<p><img src="dom-links.svg" alt=""></p>
<p>让我们更详细地讨论它们吧。</p>
<h2 id="在最顶层：documentelement-和-body">在最顶层：documentElement 和 body</h2>
<p>最顶层的树节点可以直接作为 <code>document</code> 的属性来使用：</p>
<p><code>&lt;html&gt;</code> = <code>document.documentElement</code>
: 最顶层的 document 节点是 <code>document.documentElement</code>。这是对应 <code>&lt;html&gt;</code> 标签的 DOM 节点。</p>
<p><code>&lt;body&gt;</code> = <code>document.body</code>
: 另一个被广泛使用的 DOM 节点是 <code>&lt;body&gt;</code> 元素 — <code>document.body</code>。</p>
<p><code>&lt;head&gt;</code> = <code>document.head</code>
: <code>&lt;head&gt;</code> 标签可以通过 <code>document.head</code> 访问。</p>
<p>````warn header=&quot;这里有个问题：<code>document.body</code> 的值可能是 <code>null</code>&quot;
脚本无法访问在运行时不存在的元素。</p>
<p>尤其是，如果一个脚本是在 <code>&lt;head&gt;</code> 中，那么脚本是访问不到 <code>document.body</code> 元素的，因为浏览器还没有读到它。</p>
<p>所以，下面例子中的第一个 <code>alert</code> 显示 <code>null</code>：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
*!*
    alert( <span class="hljs-string">&quot;From HEAD: &quot;</span> + <span class="hljs-built_in">document</span>.body ); <span class="hljs-comment">// null，这里目前还没有 &lt;body&gt;</span>
*/!*
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    alert( <span class="hljs-string">&quot;From BODY: &quot;</span> + <span class="hljs-built_in">document</span>.body ); <span class="hljs-comment">// HTMLBodyElement，现在存在了</span>
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<pre><code>
```smart header=&quot;在 DOM 的世界中，`null` 就意味着“不存在”&quot;
在 DOM 中，`null` 值就意味着“不存在”或者“没有这个节点”。 
```

## 子节点：childNodes，firstChild，lastChild

从现在开始，我们将使用下面这两个术语：

- **子节点（或者叫作子）** — 对应的是直系的子元素。换句话说，它们被完全嵌套在给定的元素中。例如，`&lt;head&gt;` 和 `&lt;body&gt;` 就是 `&lt;html&gt;` 元素的子元素。
- **子孙元素** — 嵌套在给定元素中的所有元素，包括子元素，以及子元素的子元素等。

例如，这里 `&lt;body&gt;` 有子元素 `&lt;div&gt;` 和 `&lt;ul&gt;`（以及一些空白的文本节点）：

```html run
&lt;html&gt;
&lt;body&gt;
  &lt;div&gt;Begin&lt;/div&gt;

  &lt;ul&gt;
    &lt;li&gt;
      &lt;b&gt;Information&lt;/b&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
```

……`&lt;body&gt;` 元素的子孙元素不仅包含直接的子元素 `&lt;div&gt;` 和 `&lt;ul&gt;`，还包含像 `&lt;li&gt;`（`&lt;ul&gt;` 的子元素）和 `&lt;b&gt;`（`&lt;li&gt;` 的子元素）这样的元素 — 整个子树。

**`childNodes` 集合列出了所有子节点，包括文本节点。**

下面这个例子显示了 `document.body` 的子元素：

```html run
&lt;html&gt;
&lt;body&gt;
  &lt;div&gt;Begin&lt;/div&gt;

  &lt;ul&gt;
    &lt;li&gt;Information&lt;/li&gt;
  &lt;/ul&gt;

  &lt;div&gt;End&lt;/div&gt;

  &lt;script&gt;
*!*
    for (let i = 0; i &lt; document.body.childNodes.length; i++) {
      alert( document.body.childNodes[i] ); // Text, DIV, Text, UL, ..., SCRIPT
    }
*/!*
  &lt;/script&gt;
  ...more stuff...
&lt;/body&gt;
&lt;/html&gt;
```

请注意这里的一个有趣的细节。如果我们运行上面这个例子，所显示的最后一个元素是 `&lt;script&gt;`。实际上，文档下面还有很多东西，但是在这个脚本运行的时候，浏览器还没有读到下面的内容，所以这个脚本也就看不到它们。

**`firstChild` 和 `lastChild` 属性是访问第一个和最后一个子元素的快捷方式。**

它们只是简写。如果元素存在子节点，那么下面的脚本运行结果将是 true：
```js
elem.childNodes[0] === elem.firstChild
elem.childNodes[elem.childNodes.length - 1] === elem.lastChild
```

这里还有一个特别的函数 `elem.hasChildNodes()` 用于检查节点是否有子节点。

### DOM 集合

正如我们看到的那样，`childNodes` 看起来就像一个数组。但实际上它并不是一个数组，而是一个 **集合** — 一个类数组的可迭代对象。

这个性质会导致两个重要的结果：

1. 我们可以使用 `for..of` 来迭代它：
  ```js
  for (let node of document.body.childNodes) {
    alert(node); // 显示集合中的所有节点
  }
  ```
  这是因为集合是可迭代的（提供了所需要的 `Symbol.iterator` 属性）。

2. 无法使用数组的方法，因为它不是一个数组：
  ```js run
  alert(document.body.childNodes.filter); // undefined（这里没有 filter 方法！）
  ```

集合的性质所得到的第一个结果很不错。第二个结果也还可以忍受，因为如果我们想要使用数组的方法的话，我们可以使用 `Array.from` 方法来从集合创建一个“真”数组：

  ```js run
  alert( Array.from(document.body.childNodes).filter ); // function
  ```

```warn header=&quot;DOM 集合是只读的&quot;
DOM 集合，甚至可以说本章中列出的 **所有** 导航（navigation）属性都是只读的。

我们不能通过类似 `childNodes[i] = ...` 的操作来替换一个子节点。

修改子节点需要使用其它方法。我们将会在下一章中看到它们。
```

```warn header=&quot;DOM 集合是实时的&quot;
除小部分例外，几乎所有的 DOM 集合都是 **实时** 的。换句话说，它们反映了 DOM 的当前状态。

如果我们保留一个对 `elem.childNodes` 的引用，然后向 DOM 中添加/移除节点，那么这些节点的更新会自动出现在集合中。
```

````warn header=&quot;不要使用 `for..in` 来遍历集合&quot;
可以使用 `for..of` 对集合进行迭代。但有时候人们会尝试使用 `for..in` 来迭代集合。

请不要这么做。`for..in` 循环遍历的是所有可枚举的（enumerable）属性。集合还有一些“额外的”很少被用到的属性，通常这些属性也是我们不期望得到的：

```html run
&lt;body&gt;
&lt;script&gt;
  // 显示 0，1，length，item，values 及其他。
  for (let prop in document.body.childNodes) alert(prop);
&lt;/script&gt;
&lt;/body&gt;</code></pre>
<h2 id="兄弟节点和父节点">兄弟节点和父节点</h2>
<p><strong>兄弟节点（Sibling）</strong> 是指有同一个父节点的节点。</p>
<p>例如，<code>&lt;head&gt;</code> 和 <code>&lt;body&gt;</code> 就是兄弟节点：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<ul>
<li><code>&lt;body&gt;</code> 可以说是 <code>&lt;head&gt;</code> 的“下一个”或者“右边”兄弟节点。</li>
<li><code>&lt;head&gt;</code> 可以说是 <code>&lt;body&gt;</code> 的“前一个”或者“左边”兄弟节点。</li>
</ul>
<p>下一个兄弟节点在 <code>nextSibling</code> 属性中，上一个是在 <code>previousSibling</code> 属性中。</p>
<p>可以通过 <code>parentNode</code> 来访问父节点。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-comment">// &lt;body&gt; 的父节点是 &lt;html&gt;</span>
alert( <span class="hljs-built_in">document</span>.body.parentNode === <span class="hljs-built_in">document</span>.documentElement ); <span class="hljs-comment">// true</span>

<span class="hljs-comment">// &lt;head&gt; 的后一个是 &lt;body&gt;</span>
alert( <span class="hljs-built_in">document</span>.head.nextSibling ); <span class="hljs-comment">// HTMLBodyElement</span>

<span class="hljs-comment">// &lt;body&gt; 的前一个是 &lt;head&gt;</span>
alert( <span class="hljs-built_in">document</span>.body.previousSibling ); <span class="hljs-comment">// HTMLHeadElement</span></code></pre>
<h2 id="纯元素导航">纯元素导航</h2>
<p>上面列出的导航（navigation）属性引用 <strong>所有</strong> 节点。例如，在 <code>childNodes</code> 中我们可以看到文本节点，元素节点，甚至如果注释节点存在的话，也能访问到。 </p>
<p>但是对于很多任务来说，我们并不想要文本节点或注释节点。我们希望操纵的是代表标签的和形成页面结构的元素节点。</p>
<p>所以，让我们看看更多只考虑 <strong>元素节点</strong> 的导航链接（navigation link）：</p>
<p><img src="dom-links-elements.svg" alt=""></p>
<p>这些链接和我们在上面提到过的类似，只是在词中间加了 <code>Element</code>：</p>
<ul>
<li><code>children</code> — 仅那些作为元素节点的子代的节点。</li>
<li><code>firstElementChild</code>，<code>lastElementChild</code> — 第一个和最后一个子元素。</li>
<li><code>previousElementSibling</code>，<code>nextElementSibling</code> — 兄弟元素。</li>
<li><code>parentElement</code> — 父元素。</li>
</ul>
<p>````smart header=&quot;为什么是 <code>parentElement</code>? 父节点可以不是一个元素吗？&quot;
<code>parentElement</code> 属性返回的是“元素类型”的父节点，而 <code>parentNode</code> 返回的是“任何类型”的父节点。这些属性通常来说是一样的：它们都是用于获取父节点。</p>
<p>唯一的例外就是 <code>document.documentElement</code>：</p>
<pre><code class="language-js">alert( <span class="hljs-built_in">document</span>.documentElement.parentNode ); <span class="hljs-comment">// document</span>
alert( <span class="hljs-built_in">document</span>.documentElement.parentElement ); <span class="hljs-comment">// null</span></code></pre>
<p>因为根节点 <code>document.documentElement</code>（<code>&lt;html&gt;</code>）的父节点是 <code>document</code>。但 <code>document</code> 不是一个元素节点，所以 <code>parentNode</code> 返回了 <code>document</code>，但 <code>parentElement</code> 返回的是 <code>null</code>。</p>
<p>当我们想从任意节点 <code>elem</code> 到 <code>&lt;html&gt;</code> 而不是到 <code>document</code> 时，这个细节可能很有用：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-params">elem = elem.parentElement</span>)</span> { <span class="hljs-comment">// 向上，直到 &lt;html&gt;</span>
  alert( elem );
}</code></pre>
<pre><code>
让我们修改上面的一个示例：用 `children` 来替换 `childNodes`。现在它只显示元素：

```html run
&lt;html&gt;
&lt;body&gt;
  &lt;div&gt;Begin&lt;/div&gt;

  &lt;ul&gt;
    &lt;li&gt;Information&lt;/li&gt;
  &lt;/ul&gt;

  &lt;div&gt;End&lt;/div&gt;

  &lt;script&gt;
*!*
    for (let elem of document.body.children) {
      alert(elem); // DIV, UL, DIV, SCRIPT
    }
*/!*
  &lt;/script&gt;
  ...
&lt;/body&gt;
&lt;/html&gt;
```

## 更多链接：表格 [#dom-navigation-tables]

到现在，我们已经描述了基本的导航（navigation）属性。

方便起见，某些类型的 DOM 元素可能会提供特定于其类型的其他属性。

表格（Table）是一个很好的例子，它代表了一个特别重要的情况：

**`&lt;table&gt;`** 元素支持 (除了上面给出的，之外) 以下这些属性:
- `table.rows` — `&lt;tr&gt;` 元素的集合。
- `table.caption/tHead/tFoot` — 引用元素 `&lt;caption&gt;`，`&lt;thead&gt;`，`&lt;tfoot&gt;`。
- `table.tBodies` — `&lt;tbody&gt;` 元素的集合（根据标准还有很多元素，但是这里至少会有一个 — 即使没有被写在 HTML 源文件中，浏览器也会将其放入 DOM 中）。

**`&lt;thead&gt;`，`&lt;tfoot&gt;`，`&lt;tbody&gt;`** 元素提供了 `rows` 属性：
- `tbody.rows` — 表格内部 `&lt;tr&gt;` 元素的集合。

**`&lt;tr&gt;`：**
- `tr.cells` — 在给定 `&lt;tr&gt;` 中的 `&lt;td&gt;` 和 `&lt;th&gt;` 单元格的集合。
- `tr.sectionRowIndex` — 给定的 `&lt;tr&gt;` 在封闭的 `&lt;thead&gt;/&lt;tbody&gt;/&lt;tfoot&gt;` 中的位置（索引）。
- `tr.rowIndex` — 在整个表格中 `&lt;tr&gt;` 的编号（包括表格的所有行）。

**`&lt;td&gt;` 和 `&lt;th&gt;`：**
- `td.cellIndex` — 在封闭的 `&lt;tr&gt;` 中单元格的编号。

用法示例：

```html run height=100
&lt;table id=&quot;table&quot;&gt;
  &lt;tr&gt;
    &lt;td&gt;one&lt;/td&gt;&lt;td&gt;two&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;three&lt;/td&gt;&lt;td&gt;four&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;script&gt;
  // 获取带有 &quot;two&quot; 的 td（第一行，第二列）
  let td = table.*!*rows[0].cells[1]*/!*;
  td.style.backgroundColor = &quot;red&quot;; // highlight it
&lt;/script&gt;
```

规范：[tabular data](https://html.spec.whatwg.org/multipage/tables.html)。

HTML 表单（form）还有其它导航（navigation）属性。稍后当我们开始使用表单（form）时，我们将对其进行研究。

## 总结

给定一个 DOM 节点，我们可以使用导航（navigation）属性访问其直接的邻居。

这些属性主要分为两组：

- 对于所有节点：`parentNode`，`childNodes`，`firstChild`，`lastChild`，`previousSibling`，`nextSibling`。
- 仅对于元素节点：`parentElement`，`children`，`firstElementChild`，`lastElementChild`，`previousElementSibling`，`nextElementSibling`。

某些类型的 DOM 元素，例如 table，提供了用于访问其内容的其他属性和集合。</code></pre>

      </fieldset>
      
      <fieldset id='_65GfB1'>
      <legend>solution</legend>
      <p>实现的方式有很多种。</p>
<p>以下列举的是其中一些方法：</p>
<pre><code class="language-js"><span class="hljs-comment">// 1. 带有 id=&quot;age-table&quot; 的表格。</span>
<span class="hljs-keyword">let</span> table = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;age-table&#x27;</span>)

<span class="hljs-comment">// 2. 表格内的所有 label 元素</span>
table.getElementsByTagName(<span class="hljs-string">&#x27;label&#x27;</span>)
<span class="hljs-comment">// 或</span>
<span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;#age-table label&#x27;</span>)

<span class="hljs-comment">// 3. 表格中的第一个 td（带有 &quot;Age&quot; 字段）</span>
table.rows[<span class="hljs-number">0</span>].cells[<span class="hljs-number">0</span>]
<span class="hljs-comment">// 或</span>
table.getElementsByTagName(<span class="hljs-string">&#x27;td&#x27;</span>)[<span class="hljs-number">0</span>]
<span class="hljs-comment">// 或</span>
table.querySelector(<span class="hljs-string">&#x27;td&#x27;</span>)

<span class="hljs-comment">// 4. 带有 name=&quot;search&quot; 的 form。</span>
<span class="hljs-comment">// 假设文档中只有一个 name=&quot;search&quot; 的元素</span>
<span class="hljs-keyword">let</span> form = <span class="hljs-built_in">document</span>.getElementsByName(<span class="hljs-string">&#x27;search&#x27;</span>)[<span class="hljs-number">0</span>]
<span class="hljs-comment">// 或者，专门对于 form</span>
<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;form[name=&quot;search&quot;]&#x27;</span>)

<span class="hljs-comment">// 5. 表单中的第一个 input</span>
form.getElementsByTagName(<span class="hljs-string">&#x27;input&#x27;</span>)[<span class="hljs-number">0</span>]
<span class="hljs-comment">// 或</span>
form.querySelector(<span class="hljs-string">&#x27;input&#x27;</span>)

<span class="hljs-comment">// 6. 表单中的最后一个 input</span>
<span class="hljs-keyword">let</span> inputs = form.querySelectorAll(<span class="hljs-string">&#x27;input&#x27;</span>) <span class="hljs-comment">// 查找所有 input</span>
inputs[inputs.length-<span class="hljs-number">1</span>] <span class="hljs-comment">// 取出最后一个</span></code></pre>

      </fieldset>
      
      <fieldset id='_OhZFXy'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="搜索元素">搜索元素</h1>
<p>这是带有表格（table）和表单（form）的文档。</p>
<p>如何查找？……</p>
<ol>
<li>带有 <code>id=&quot;age-table&quot;</code> 的表格。</li>
<li>表格内的所有 <code>label</code> 元素（应该有三个）。</li>
<li>表格中的第一个 <code>td</code>（带有 &quot;Age&quot; 字段）。</li>
<li>带有 <code>name=&quot;search&quot;</code> 的 <code>form</code>。</li>
<li>表单中的第一个 <code>input</code>。</li>
<li>表单中的最后一个 <code>input</code>。</li>
</ol>
<p>在一个单独的窗口中打开 <a href="table.html">table.html</a> 页面，并对此页面使用浏览器开发者工具。</p>

      </fieldset>
      
      <fieldset id='_uOrMem'>
      <legend>article</legend>
      <h1 id="搜索：getelement，queryselector">搜索：getElement<em>，querySelector</em></h1>
<p>当元素彼此靠得近时，DOM 导航属性（navigation property）非常有用。如果不是，那该怎么办？如何去获取页面上的任意元素？</p>
<p>还有其他搜索方法。</p>
<h2 id="documentgetelementbyid-或者只使用-id">document.getElementById 或者只使用 id</h2>
<p>如果一个元素有 <code>id</code> 特性（attribute），那我们就可以使用 <code>document.getElementById(id)</code> 方法获取该元素，无论它在哪里。</p>
<p>例如：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;elem&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;elem-content&quot;</span>&gt;</span>Element<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-comment">// 获取该元素</span>
*!*
  <span class="hljs-keyword">let</span> elem = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;elem&#x27;</span>);
*/!*

  <span class="hljs-comment">// 将该元素背景改为红色</span>
  elem.style.background = <span class="hljs-string">&#x27;red&#x27;</span>;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>此外，还有一个通过 <code>id</code> 命名的全局变量，它引用了元素：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;*!*elem*/!*&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;*!*elem-content*/!*&quot;</span>&gt;</span>Element<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-comment">// elem 是对带有 id=&quot;elem&quot; 的 DOM 元素的引用 </span>
  elem.style.background = <span class="hljs-string">&#x27;red&#x27;</span>;

  <span class="hljs-comment">// id=&quot;elem-content&quot; 内有连字符，所以它不能成为一个变量</span>
  <span class="hljs-comment">// ...但是我们可以通过使用方括号 window[&#x27;elem-content&#x27;] 来访问它</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>……除非我们声明一个具有相同名称的 JavaScript 变量，否则它具有优先权：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;elem&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">let</span> elem = <span class="hljs-number">5</span>; <span class="hljs-comment">// 现在 elem 是 5，而不是对 &lt;div id=&quot;elem&quot;&gt; 的引用</span>

  alert(elem); <span class="hljs-comment">// 5</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<pre><code class="language-warn">[在规范中](http://www.whatwg.org/specs/web-apps/current-work/#dom-window-nameditem) 对此行为进行了描述，所以它是一种标准。但这是注意考虑到兼容性才支持的。

浏览器尝试通过混合 JavaScript 和 DOM 的命名空间来帮助我们。对于内联到 HTML 中的简单脚本来说，这还行，但是通常来说，这不是一件好事。因为这可能会造成命名冲突。另外，当人们阅读 JavaScript 代码且看不到对应的 HTML 时，变量的来源就会不明显。

在本教程中，我们只会在元素来源非常明显时，为了简洁起见，才会使用 `id` 直接引用对应的元素。

在实际开发中，`document.getElementById` 是首选方法。</code></pre>
<p>```smart header=&quot;<code>id</code> 必须是唯一的&quot;
<code>id</code> 必须是唯一的。在文档中，只能有一个元素带有给定的 <code>id</code>。</p>
<p>如果有多个元素都带有同一个 <code>id</code>，那么使用它的方法的行为是不可预测的，例如 <code>document.getElementById</code> 可能会随机返回其中一个元素。因此，请遵守规则，保持 <code>id</code> 的唯一性。</p>
<pre><code>
```warn header=&quot;只有 `document.getElementById`，没有 `anyElem.getElementById`&quot;
`getElementById` 方法只能被在 `document` 对象上调用。它会在整个文档中查找给定的 `id`。</code></pre>
<h2 id="queryselectorall-queryselectorall">querySelectorAll [#querySelectorAll]</h2>
<p>到目前为止，最通用的方法是 <code>elem.querySelectorAll(css)</code>，它返回 <code>elem</code> 中与给定 CSS 选择器匹配的所有元素。</p>
<p>在这里，我们查找所有为最后一个子元素的 <code>&lt;li&gt;</code> 元素：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>The<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>has<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>passed<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
*!*
  <span class="hljs-keyword">let</span> elements = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;ul &gt; li:last-child&#x27;</span>);
*/!*

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> elem <span class="hljs-keyword">of</span> elements) {
    alert(elem.innerHTML); <span class="hljs-comment">// &quot;test&quot;, &quot;passed&quot;</span>
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>这个方法确实功能强大，因为可以使用任何 CSS 选择器。</p>
<pre><code class="language-smart">CSS 选择器的伪类，例如 `:hover` 和 `:active` 也都是被支持的。例如，`document.querySelectorAll(&#x27;:hover&#x27;)` 将会返回鼠标指针现在已经结束的元素的集合（按嵌套顺序：从最外层 `&lt;html&gt;` 到嵌套最多的元素）。</code></pre>
<h2 id="queryselector-queryselector">querySelector [#querySelector]</h2>
<p><code>elem.querySelector(css)</code> 调用会返回给定 CSS 选择器的第一个元素。</p>
<p>换句话说，结果与 <code>elem.querySelectorAll(css)[0]</code> 相同，但是后者会查找 <strong>所有</strong> 元素，并从中选取一个，而 <code>elem.querySelector</code> 只会查找一个。因此它在速度上更快，并且写起来更短。</p>
<h2 id="matches">matches</h2>
<p>之前的方法是搜索 DOM。</p>
<p><a href="http://dom.spec.whatwg.org/#dom-element-matches">elem.matches(css)</a> 不会查找任何内容，它只会检查 <code>elem</code> 是否与给定的 CSS 选择器匹配。它返回 <code>true</code> 或 <code>false</code>。</p>
<p>当我们遍历元素（例如数组或其他内容）并试图过滤那些我们感兴趣的元素时，这个方法会很有用。</p>
<p>例如：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://example.com/file.zip&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://ya.ru&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-comment">// 不一定是 document.body.children，还可以是任何集合</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> elem <span class="hljs-keyword">of</span> <span class="hljs-built_in">document</span>.body.children) {
*!*
    <span class="hljs-keyword">if</span> (elem.matches(<span class="hljs-string">&#x27;a[href$=&quot;zip&quot;]&#x27;</span>)) {
*/!*
      alert(<span class="hljs-string">&quot;The archive reference: &quot;</span> + elem.href );
    }
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h2 id="closest">closest</h2>
<p>元素的祖先（ancestor）是：父级，父级的父级，它的父级等。祖先们一起组成了从元素到顶端的父级链。</p>
<p><code>elem.closest(css)</code> 方法会查找与 CSS 选择器匹配的最近的祖先。<code>elem</code> 自己也会被搜索。</p>
<p>换句话说，方法 <code>closest</code> 在元素中得到了提升，并检查每个父级。如果它与选择器匹配，则停止搜索并返回该祖先。</p>
<p>例如：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Contents<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;contents&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;book&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;chapter&quot;</span>&gt;</span>Chapter 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;chapter&quot;</span>&gt;</span>Chapter 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">let</span> chapter = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.chapter&#x27;</span>); <span class="hljs-comment">// LI</span>

  alert(chapter.closest(<span class="hljs-string">&#x27;.book&#x27;</span>)); <span class="hljs-comment">// UL</span>
  alert(chapter.closest(<span class="hljs-string">&#x27;.contents&#x27;</span>)); <span class="hljs-comment">// DIV</span>

  alert(chapter.closest(<span class="hljs-string">&#x27;h1&#x27;</span>)); <span class="hljs-comment">// null（因为 h1 不是祖先）</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h2 id="getelementsby">getElementsBy*</h2>
<p>还有其他通过标签，类等查找节点的方法。</p>
<p>如今，它们大多已经成为了历史，因为 <code>querySelector</code> 功能更强大，写起来更短。</p>
<p>因此，这里我们介绍它们只是为了完整起见，而你仍然可以在就脚本中找到这些方法。</p>
<ul>
<li><code>elem.getElementsByTagName(tag)</code> 查找具有给定标签的元素，并返回它们的集合。<code>tag</code> 参数也可以是对于“任何标签”的星号 <code>&quot;*&quot;</code>。</li>
<li><code>elem.getElementsByClassName(className)</code> 返回具有给定CSS类的元素。</li>
<li><code>document.getElementsByName(name)</code> 返回在文档范围内具有给定 <code>name</code> 特性的元素。很少使用。</li>
</ul>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-comment">// 获取文档中的所有 div</span>
<span class="hljs-keyword">let</span> divs = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;div&#x27;</span>);</code></pre>
<p>让我们查找 table 中的所有 <code>input</code> 标签：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;table&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Your age:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;young&quot;</span> <span class="hljs-attr">checked</span>&gt;</span> less than 18
      <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mature&quot;</span>&gt;</span> from 18 to 50
      <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;senior&quot;</span>&gt;</span> more than 60
      <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
*!*
  <span class="hljs-keyword">let</span> inputs = table.getElementsByTagName(<span class="hljs-string">&#x27;input&#x27;</span>);
*/!*

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> input <span class="hljs-keyword">of</span> inputs) {
    alert( input.value + <span class="hljs-string">&#x27;: &#x27;</span> + input.checked );
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>```warn header=&quot;不要忘记字母 <code>\&quot;s\&quot;</code>！&quot;
新手开发者有时会忘记字符 <code>&quot;s&quot;</code>。也就是说，他们会调用 <code>getElementByTagName</code> 而不是 <code>getElement<b>s</b>ByTagName</code>。</p>
<p><code>getElementById</code> 中没有字母 <code>&quot;s&quot;</code>，是因为它只返回单个元素。但是 <code>getElementsByTagName</code> 返回的是元素的集合，所以里面有 <code>&quot;s&quot;</code>。</p>
<pre><code>
````warn header=&quot;它返回的是一个集合，不是一个元素！&quot;
新手的另一个普遍的错误是写：

```js
// 行不通
document.getElementsByTagName(&#x27;input&#x27;).value = 5;</code></pre>
<p>这是行不通的，因为它需要的是一个 input 的 <strong>集合</strong>，并将值赋（assign）给它，而不是赋值给其中的一个元素。</p>
<p>我们应该遍历集合或通过对应的索引来获取元素，然后赋值，如下所示：</p>
<pre><code class="language-js"><span class="hljs-comment">// 应该可以运行（如果有 input）</span>
<span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;input&#x27;</span>)[<span class="hljs-number">0</span>].value = <span class="hljs-number">5</span>;</code></pre>
<pre><code>
查找 `.article` 元素：

```html run height=50
&lt;form name=&quot;my-form&quot;&gt;
  &lt;div class=&quot;article&quot;&gt;Article&lt;/div&gt;
  &lt;div class=&quot;long article&quot;&gt;Long article&lt;/div&gt;
&lt;/form&gt;

&lt;script&gt;
  // 按 name 特性查找
  let form = document.getElementsByName(&#x27;my-form&#x27;)[0];

  // 在 form 中按 class 查找
  let articles = form.getElementsByClassName(&#x27;article&#x27;);
  alert(articles.length); // 2, found two elements with class &quot;article&quot;
&lt;/script&gt;
```

## 实时的集合

所有的 `&quot;getElementsBy*&quot;` 方法都会返回一个 **实时的（live）** 集合。这样的集合始终反映的是文档的当前状态，并且在文档发生更改时会“自动更新”。

在下面的例子中，有两个脚本。

1. 第一个创建了对 `&lt;div&gt;` 的集合的引用。截至目前，它的长度是 `1`。
2. 第二个脚本在浏览器再遇到一个 `&lt;div&gt;` 时运行，所以它的长度是 `2`。

```html run
&lt;div&gt;First div&lt;/div&gt;

&lt;script&gt;
  let divs = document.getElementsByTagName(&#x27;div&#x27;);
  alert(divs.length); // 1
&lt;/script&gt;

&lt;div&gt;Second div&lt;/div&gt;

&lt;script&gt;
*!*
  alert(divs.length); // 2
*/!*
&lt;/script&gt;
```

相反，`querySelectorAll` 返回的是一个 **静态的** 集合。就像元素的固定数组。

如果我们使用它，那么两个脚本都会输出 `1`：


```html run
&lt;div&gt;First div&lt;/div&gt;

&lt;script&gt;
  let divs = document.querySelectorAll(&#x27;div&#x27;);
  alert(divs.length); // 1
&lt;/script&gt;

&lt;div&gt;Second div&lt;/div&gt;

&lt;script&gt;
*!*
  alert(divs.length); // 1
*/!*
&lt;/script&gt;
```

现在我们可以很容易地看到不同之处。在文档中出现新的 `div` 后，静态集合并没有增加。

## 总结

有 6 种主要的方法，可以在 DOM 中搜素节点：

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;td&gt;Method&lt;/td&gt;
&lt;td&gt;Searches by...&lt;/td&gt;
&lt;td&gt;Can call on an element?&lt;/td&gt;
&lt;td&gt;Live?&lt;/td&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;querySelector&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;CSS-selector&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;querySelectorAll&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;CSS-selector&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;getElementById&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;id&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;getElementsByName&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;name&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;getElementsByTagName&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;tag or &lt;code&gt;&#x27;*&#x27;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;getElementsByClassName&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;class&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

目前为止，最常用的是 `querySelector` 和 `querySelectorAll`，但是 `getElementBy*` 可能会偶尔有用，或者可以在旧脚本中找到。

此外：

- `elem.matches(css)` 用于检查 `elem` 与给定的 CSS 选择器是否匹配。
- `elem.closest(css)` 用于查找与给定 CSS 选择器相匹配的最近的祖先。`elem` 本身也会被检查。

让我们在这里提一下另一种用来检查子级与父级之间关系的方法，因为它有时很有用：
- 如果 `elemB` 在 `elemA` 内（`elemA` 的后代）或者 `elemA==elemB`，`elemA.contains(elemB)` 将返回 true。</code></pre>

      </fieldset>
      
      <fieldset id='_X5lhbj'>
      <legend>solution</legend>
      <p>这里有一个陷阱。</p>
<p>在 <code>&lt;script&gt;</code> 执行时，最后一个 DOM 节点就是 <code>&lt;script&gt;</code>，因为浏览器还没有处理页面的其余部分。</p>
<p>所以结果是 <code>1</code>（元素节点）。</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    alert(<span class="hljs-built_in">document</span>.body.lastChild.nodeType);
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>

      </fieldset>
      
      <fieldset id='_mjDba5'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="nodetype-中是什么？">nodeType 中是什么？</h1>
<p>下面这个脚本会显示什么？</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    alert(<span class="hljs-built_in">document</span>.body.lastChild.nodeType);
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>

      </fieldset>
      
      <fieldset id='_eGpPua'>
      <legend>solution</legend>
      <p>我们使用循环遍历 <code>&lt;li&gt;</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> li <span class="hljs-keyword">of</span> <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;li&#x27;</span>)) {
  ...
}</code></pre>
<p>循环时，我们需要获取每个 <code>li</code> 中的文本。</p>
<p>我们可以从 <code>li</code> 的第一个子节点读取文本，即文本节点：</p>
<pre><code class="language-js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> li <span class="hljs-keyword">of</span> <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;li&#x27;</span>)) {
  <span class="hljs-keyword">let</span> title = li.firstChild.data;

  <span class="hljs-comment">// title 是在 &lt;li&gt; 中的任何其他节点之前的文本</span>
}</code></pre>
<p>然后我们就可以使用 <code>li.getElementsByTagName(&#39;li&#39;)</code> 来获取后代的数目了。</p>

      </fieldset>
      
      <fieldset id='_h2Sg7z'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="计数后代">计数后代</h1>
<p>这里有一个树结构嵌套的 <code>ul/li</code>。</p>
<p>编写代码，为每个 <code>&lt;li&gt;</code> 显示：</p>
<ol>
<li>里面的文本内容是什么（没有子树）</li>
<li>嵌套的 <code>&lt;li&gt;</code> 的数量 — 所有后代，包括深层嵌套的后代。</li>
</ol>
<p>[demo src=&quot;solution&quot;]</p>

      </fieldset>
      
      <fieldset id='_nVrRy0'>
      <legend>solution</legend>
      <p>答案：**<code>BODY</code>**。</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="handlebars"><span class="xml">
  let body = document.body;

  body.innerHTML = &quot;<span class="hljs-comment">&lt;!--&quot; + body.tagName + &quot;--&gt;</span>&quot;;

  alert( body.firstChild.data ); // BODY
</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>让我们一步一步来看看发生了什么：</p>
<ol>
<li><code>&lt;body&gt;</code> 中的内容被注释所取代。注释为 <code>&lt;!--BODY--&gt;</code>，因为 <code>body.tagName == &quot;BODY&quot;</code>。正如我们所记得的，在 HTML 模式下，<code>tagName</code> 总是大写的。</li>
<li>现在这个注释是唯一的子节点，所以我们在 <code>body.firstChild</code> 中获取了它。</li>
<li>注释的 <code>data</code> 属性是它的内容（在 <code>&lt;!--...--&gt;</code> 内的)：<code>&quot;BODY&quot;</code>。</li>
</ol>

      </fieldset>
      
      <fieldset id='_ZbiuoF'>
      <legend>task</legend>
      <p>importance: 3</p>
<hr>
<h1 id="注释中的标签">注释中的标签</h1>
<p>这段代码会显示什么？</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="handlebars"><span class="xml">
  let body = document.body;

  body.innerHTML = &quot;<span class="hljs-comment">&lt;!--&quot; + body.tagName + &quot;--&gt;</span>&quot;;

  alert( body.firstChild.data ); // 这里会显示什么？
</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>

      </fieldset>
      
      <fieldset id='_V8VKQR'>
      <legend>solution</legend>
      <p>我们可以通过输出它，来看看它是属于哪个类的，像这样：</p>
<pre><code class="language-js">alert(<span class="hljs-built_in">document</span>); <span class="hljs-comment">// [object HTMLDocument]</span></code></pre>
<p>或者：</p>
<pre><code class="language-js">alert(<span class="hljs-built_in">document</span>.constructor.name); <span class="hljs-comment">// HTMLDocument</span></code></pre>
<p>因此，<code>document</code> 是 <code>HTMLDocument</code> 类的一个实例。</p>
<p>它位于 DOM 层次结构（hierarchy）中的什么位置？</p>
<p>是的，我们可以浏览规范，但是手动找出它会更快。</p>
<p>我们通过 <code>__proto__</code> 来遍历原型链。</p>
<p>正如我们所知道的，类的方法在 constructor 的 <code>prototype</code> 中。例如，<code>HTMLDocument.prototype</code> 有用于文档（document）的方法。</p>
<p>此外，在 <code>prototype</code> 中还有一个对构造函数的引用：</p>
<pre><code class="language-js">alert(HTMLDocument.prototype.constructor === HTMLDocument); <span class="hljs-comment">// true</span></code></pre>
<p>为了以字符串的形式获取一个类的 name，我们可以使用 <code>constructor.name</code>。让我们对整个 <code>document</code> 的原型链执行该操作，直到 class <code>Node</code>：</p>
<pre><code class="language-js">alert(HTMLDocument.prototype.constructor.name); <span class="hljs-comment">// HTMLDocument</span>
alert(HTMLDocument.prototype.__proto__.constructor.name); <span class="hljs-comment">// Document</span>
alert(HTMLDocument.prototype.__proto__.__proto__.constructor.name); <span class="hljs-comment">// Node</span></code></pre>
<p>这就是层次结构。</p>
<p>我们还可以使用 <code>console.dir(document)</code> 来检查对象，并通过打开 <code>__proto__</code> 来查看这些名称。控制台将它们从 <code>constructor</code> 内部取出来。</p>

      </fieldset>
      
      <fieldset id='_XZfGb3'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="层次结构中的-document-在哪里？">层次结构中的 &quot;document&quot; 在哪里？</h1>
<p><code>document</code> 属于哪一类？</p>
<p>它位于 DOM 层次结构（hierarchy）中的什么位置？</p>
<p>它继承自 <code>Node</code> 还是 <code>Element</code>，或者可能是 <code>HTMLElement</code>？</p>

      </fieldset>
      
      <fieldset id='_4c7F2l'>
      <legend>article</legend>
      <h1 id="节点属性：type，tag-和-content">节点属性：type，tag 和 content</h1>
<p>让我们更深入地了解一下 DOM 节点。</p>
<p>在本章中，我们将更深入地了解它们是什么，并学习它们最常用的属性。</p>
<h2 id="dom-节点类">DOM 节点类</h2>
<p>不同的 DOM 节点可能有不同的属性。例如，标签 <code>&lt;a&gt;</code> 相对应的元素节点具有链接相关的（link-related）属性，标签 <code>&lt;input&gt;</code> 相对应的元素节点具有与输入相关的属性，等。文本节点与元素节点不同。但是所有这些标签对应的 DOM 节点之间也存在共有的属性和方法，因为所有类型的 DOM 节点都形成了一个单一层次的结构（single hierarchy）。</p>
<p>每个 DOM 节点都属于相应的内建类。</p>
<p>层次结构（hierarchy）的根节点是 <a href="https://dom.spec.whatwg.org/#eventtarget">EventTarget</a>，<a href="http://dom.spec.whatwg.org/#interface-node">Node</a> 继承自它，其他 DOM 节点继承自 Node。</p>
<p>下图做了进一步说明：</p>
<p><img src="dom-class-hierarchy.svg" alt=""></p>
<p>类如下所示：</p>
<ul>
<li><a href="https://dom.spec.whatwg.org/#eventtarget">EventTarget</a> — 是根的“抽象（abstract）”类。该类的对象从未被创建。它作为一个基础，以便让所有 DOM 节点都支持所谓的“事件（event）”，我们会在之后学习它。</li>
<li><a href="http://dom.spec.whatwg.org/#interface-node">Node</a> — 也是一个“抽象”类，充当 DOM 节点的基础。它提供了树的核心功能：<code>parentNode</code>，<code>nextSibling</code>，<code>childNodes</code> 等（它们都是 getter）。<code>Node</code> 类的对象从未被创建。但是有一些继承自它的具体的节点类，例如：文本节点的 <code>Text</code>，元素节点的 <code>Element</code>，以及更多异域（exotic）类，例如注释节点的 <code>Comment</code>。</li>
<li><a href="http://dom.spec.whatwg.org/#interface-element">Element</a> — 是 DOM 元素的基本类。它提供了元素级的导航（navigation），例如 <code>nextElementSibling</code>，<code>children</code>，以及像 <code>getElementsByTagName</code> 和 <code>querySelector</code> 这样的搜索方法。浏览器中不仅有 HTML，还会有 XML 和 SVG。<code>Element</code> 类充当更多特定类的基本类：<code>SVGElement</code>，<code>XMLElement</code> 和 <code>HTMLElement</code>。</li>
<li><a href="https://html.spec.whatwg.org/multipage/dom.html#htmlelement">HTMLElement</a> — 最终是所有 HTML 元素的基本类。各种 HTML 元素均继承自它：<ul>
<li><a href="https://html.spec.whatwg.org/multipage/forms.html#htmlinputelement">HTMLInputElement</a> — <code>&lt;input&gt;</code> 元素的类，</li>
<li><a href="https://html.spec.whatwg.org/multipage/semantics.html#htmlbodyelement">HTMLBodyElement</a> — <code>&lt;body&gt;</code> 元素的类，</li>
<li><a href="https://html.spec.whatwg.org/multipage/semantics.html#htmlanchorelement">HTMLAnchorElement</a> — <code>&lt;a&gt;</code> 元素的类，</li>
<li>……等，每个标签都有自己的类，这些类可以提供特定的属性和方法。</li>
</ul>
</li>
</ul>
<p>因此，给定节点的全部属性和方法都是继承的结果。</p>
<p>例如，我们考虑一下 <code>&lt;input&gt;</code> 元素的 DOM 对象。它属于 <a href="https://html.spec.whatwg.org/multipage/forms.html#htmlinputelement">HTMLInputElement</a> 类。</p>
<p>它获取属性和方法，并将其作为下列类（按继承顺序列出）的叠加：</p>
<ul>
<li><code>HTMLInputElement</code> — 该类提供特定于输入的属性，</li>
<li><code>HTMLElement</code> — 它提供了通用（common）的 HTML 元素方法（以及 getter 和 setter）</li>
<li><code>Element</code> — 提供通用（generic）元素方法，</li>
<li><code>Node</code> — 提供通用 DOM 节点属性，</li>
<li><code>EventTarget</code> — 为事件（包括事件本身）提供支持，</li>
<li>……最后，它继承自 <code>Object</code>，因为像 <code>hasOwnProperty</code> 这样的“普通对象”方法也是可用的。</li>
</ul>
<p>我们可以通过回调来查看 DOM 节点类名，因为对象通常都具有 <code>constructor</code> 属性。它引用类的 constructor，<code>constructor.name</code> 就是它的名称：</p>
<pre><code class="language-js">alert( <span class="hljs-built_in">document</span>.body.constructor.name ); <span class="hljs-comment">// HTMLBodyElement</span></code></pre>
<p>……或者我们可以对其使用 <code>toString</code> 方法：</p>
<pre><code class="language-js">alert( <span class="hljs-built_in">document</span>.body ); <span class="hljs-comment">// [object HTMLBodyElement]</span></code></pre>
<p>我们还可以使用 <code>instanceof</code> 来检查继承：</p>
<pre><code class="language-js">alert( <span class="hljs-built_in">document</span>.body <span class="hljs-keyword">instanceof</span> HTMLBodyElement ); <span class="hljs-comment">// true</span>
alert( <span class="hljs-built_in">document</span>.body <span class="hljs-keyword">instanceof</span> HTMLElement ); <span class="hljs-comment">// true</span>
alert( <span class="hljs-built_in">document</span>.body <span class="hljs-keyword">instanceof</span> Element ); <span class="hljs-comment">// true</span>
alert( <span class="hljs-built_in">document</span>.body <span class="hljs-keyword">instanceof</span> Node ); <span class="hljs-comment">// true</span>
alert( <span class="hljs-built_in">document</span>.body <span class="hljs-keyword">instanceof</span> EventTarget ); <span class="hljs-comment">// true</span></code></pre>
<p>正如我们所看到的，DOM 节点是常规的 JavaScript 对象。它们使用基于原型的类进行继承。</p>
<p>在浏览器中，使用 <code>console.dir(elem)</code> 输出元素来查看也是非常容易的。在控制台中，你可以看到 <code>HTMLElement.prototype</code> 和 <code>Element.prototype</code> 等。</p>
<p>```smart header=&quot;<code>console.dir(elem)</code> 与 <code>console.log(elem)</code>&quot;
大多数浏览器在其开发者工具中都支持这两个命令：<code>console.log</code> 和 <code>console.dir</code>。它们将它们的参数输出到控制台中。对于 JavaScript 对象，这些命令通常做的是相同的事。</p>
<p>但对于 DOM 元素，它们是不同的：</p>
<ul>
<li><code>console.log(elem)</code> 显示元素的 DOM 树。</li>
<li><code>console.dir(elem)</code> 将元素显示为 DOM 对象，非常适合探索其属性。</li>
</ul>
<p>你可以在 <code>document.body</code> 上尝试一下。</p>
<pre><code>
````smart header=&quot;规范中的 IDL&quot;
在规范中，DOM 类不是使用 JavaScript 来描述的，而是一种特殊的 [接口描述语言（Interface description language）](https://en.wikipedia.org/wiki/Interface_description_language)，简写为 IDL，它通常很容易理解。

在 IDL 中，所有属性以其类型开头。例如，`DOMString` 和 `boolean` 等。

以下是摘录（excerpt），并附有注释：

```js
// 定义 HTMLInputElement
*!*
// 冒号 &quot;:&quot; 表示 HTMLInputElement 继承自 HTMLElement
*/!*
interface HTMLInputElement: HTMLElement {
  // 接下来是 &lt;input&gt; 元素的属性和方法

*!*
  // &quot;DOMString&quot; 表示属性的值是字符串
*/!*
  attribute DOMString accept;
  attribute DOMString alt;
  attribute DOMString autocomplete;
  attribute DOMString value;

*!*
  // 布尔值属性（true/false）
  attribute boolean autofocus;
*/!*
  ...
*!*
  // 现在方法：&quot;void&quot; 表示方法没有返回值
*/!*
  void select();
  ...
}</code></pre>
<pre><code>
## &quot;nodeType&quot; 属性

`nodeType` 属性提供了另一种“过时的”用来获取 DOM 节点类型的方法。

它有一个数值型值（numeric value）：
- 对于元素节点 `elem.nodeType == 1`，
- 对于文本节点 `elem.nodeType == 3`，
- 对于 document 对象 `elem.nodeType == 9`，
- 在 [规范](https://dom.spec.whatwg.org/#node) 中还有一些其他值。

例如：

```html run
&lt;body&gt;
  &lt;script&gt;  
  let elem = document.body;

  // 让我们检查一下它是什么？
  alert(elem.nodeType); // 1 =&gt; element

  // 第一个子节点是
  alert(elem.firstChild.nodeType); // 3 =&gt; text

  // 对于 document 对象，类型是 9
  alert( document.nodeType ); // 9
  &lt;/script&gt;
&lt;/body&gt;
```

在现代脚本中，我们可以使用 `instanceof` 和其他基于类的检查方法来查看节点类型，但有时 `nodeType` 可能更简单。我们只能读取 `nodeType` 而不能修改它。

## 标签：nodeName 和 tagName

给定一个 DOM 节点，我们可以从 `nodeName` 或者 `tagName` 属性中读取它的标签名：

例如：

```js run
alert( document.body.nodeName ); // BODY
alert( document.body.tagName ); // BODY
```

tagName 和 nodeName 之间有什么不同吗？

当然，差异就体现在它们的名字上，但确实有些微妙。

- `tagName` 属性仅适用于 `Element` 节点。
- `nodeName` 是为任意 `Node` 定义的：
    - 对于元素，它的意义与 `tagName` 相同。
    - 对于其他节点类型（text，comment 等），它拥有一个对应节点类型的字符串。

换句话说，`tagName` 仅受元素节点支持（因为它起源于 `Element` 类），而 `nodeName` 则可以说明其他节点类型。

例如，我们比较一下 `document` 的 `tagName` 和 `nodeName`，以及一个注释节点：


```html run
&lt;body&gt;&lt;!-- comment --&gt;

  &lt;script&gt;
    // for comment
    alert( document.body.firstChild.tagName ); // undefined（不是一个元素）
    alert( document.body.firstChild.nodeName ); // #comment

    // for document
    alert( document.tagName ); // undefined（不是一个元素）
    alert( document.nodeName ); // #document
  &lt;/script&gt;
&lt;/body&gt;
```

如果我们只处理元素，那么 `tagName` 和 `nodeName` 这两种方法，我们都可以使用，没有区别。

```smart header=&quot;标签名称始终是大写的，除非是在 XML 模式下&quot;
浏览器有两种处理文档（document）的模式：HTML 和 XML。通常，HTML 模式用于网页。只有在浏览器接收到带有 header `Content-Type: application/xml+xhtml` 的 XML-document 时，XML 模式才会被启用。

在 HTML 模式下，`tagName/nodeName` 始终是大写的：它是 `BODY`，而不是 `&lt;body&gt;` 或 `&lt;BoDy&gt;`。

在 XML 模式中，大小写保持为“原样”。如今，XML 模式很少被使用。
```


## innerHTML：内容

[innerHTML](https://w3c.github.io/DOM-Parsing/#widl-Element-innerHTML) 属性允许将元素中的 HTML 获取为字符串形式。

我们也可以修改它。因此，它是更改页面最有效的方法之一。

下面这个示例显示了 `document.body` 中的内容，然后将其完全替换：

```html run
&lt;body&gt;
  &lt;p&gt;A paragraph&lt;/p&gt;
  &lt;div&gt;A div&lt;/div&gt;

  &lt;script&gt;
    alert( document.body.innerHTML ); // 读取当前内容
    document.body.innerHTML = &#x27;The new BODY!&#x27;; // 替换它
  &lt;/script&gt;

&lt;/body&gt;
```

我们可以尝试插入无效的 HTML，浏览器会修复我们的错误：

```html run
&lt;body&gt;

  &lt;script&gt;
    document.body.innerHTML = &#x27;&lt;b&gt;test&#x27;; // 忘记闭合标签
    alert( document.body.innerHTML ); // &lt;b&gt;test&lt;/b&gt;（被修复了）
  &lt;/script&gt;

&lt;/body&gt;
```

```smart header=&quot;脚本不会执行&quot;
如果 `innerHTML` 将一个 `&lt;script&gt;` 标签插入到 document 中 — 它会成为 HTML 的一部分，但是不会执行。
```

### 小心：&quot;innerHTML+=&quot; 会进行完全重写

我们可以使用 `elem.innerHTML+=&quot;more html&quot;` 将 HTML 附加到元素上。

就像这样：

```js
chatDiv.innerHTML += &quot;&lt;div&gt;Hello&lt;img src=&#x27;smile.gif&#x27;/&gt; !&lt;/div&gt;&quot;;
chatDiv.innerHTML += &quot;How goes?&quot;;
```

但我们必须非常谨慎地使用它，因为我们所做的 **不是** 附加内容，而且完全地重写。

从技术上来说，下面这两行代码的作用相同：

```js
elem.innerHTML += &quot;...&quot;;
// 进行写入的一种更简短的方式：
*!*
elem.innerHTML = elem.innerHTML + &quot;...&quot;
*/!*
```

换句话说，`innerHTML+=` 做了以下工作：

1. 移除旧的内容。
2. 然后写入新的 `innerHTML`（新旧结合）。

**因为内容已“归零”并从头开始重写，因此所有的图片和其他资源都将重写加载。**

在上面的 `chatDiv` 示例中，`chatDiv.innerHTML+=&quot;How goes?&quot;` 重建了 HTML 内容并重新加载了 `smile.gif`（希望它是缓存的）。如果 `chatDiv` 有许多其他文本和图片，那么就很容易看到重新加载（译注：是指在有很多内容时，重新加载会耗费更多的时间，所以你就很容易看见页面重载的过程）。

并且还会有其他副作用。例如，如果现有的文本被用鼠标选中了，那么大多数浏览器都会在重写 `innerHTML` 时删除选定状态。如果这里有一个带有用户输入的文本的 `&lt;input&gt;`，那么这个被输入的文本将会被移除。诸如此类。

幸运的是，除了 `innerHTML`，还有其他可以添加 HTML 的方法，我们很快就会学到。

## outerHTML：元素的完整 HTML

`outerHTML` 属性包含了元素的完整 HTML。就像 `innerHTML` 加上元素本身一样。

下面是一个示例：

```html run
&lt;div id=&quot;elem&quot;&gt;Hello &lt;b&gt;World&lt;/b&gt;&lt;/div&gt;

&lt;script&gt;
  alert(elem.outerHTML); // &lt;div id=&quot;elem&quot;&gt;Hello &lt;b&gt;World&lt;/b&gt;&lt;/div&gt;
&lt;/script&gt;
```

**注意：与 `innerHTML` 不同，写入 `outerHTML` 不会改变元素。而是在 DOM 中替换它。**

是的，听起来很奇怪，它确实很奇怪，这就是为什么我们在这里对此做了一个单独的注释。看一下。

考虑下面这个示例：

```html run
&lt;div&gt;Hello, world!&lt;/div&gt;

&lt;script&gt;
  let div = document.querySelector(&#x27;div&#x27;);

*!*
  // 使用 &lt;p&gt;...&lt;/p&gt; 替换 div.outerHTML
*/!*
  div.outerHTML = &#x27;&lt;p&gt;A new element&lt;/p&gt;&#x27;; // (*)

*!*
  // 蛤！&#x27;div&#x27; 还是原来那样！
*/!*
  alert(div.outerHTML); // &lt;div&gt;Hello, world!&lt;/div&gt; (**)
&lt;/script&gt;
```

看起来真的很奇怪，对吧？

在 `(*)` 行，我们使用 `&lt;p&gt;A new element&lt;/p&gt;` 替换 `div`。在外部文档（DOM）中我们可以看到的是新内容而不是 `&lt;div&gt;`。但是正如我们在 `(**)` 行所看到的，旧的 `div` 变量并没有被改变。

`outerHTML` 赋值不会修改 DOM 元素（在这个例子中是被 &#x27;div&#x27; 引用的对象），而是将其从 DOM 中删除并在其位置插入新的 HTML。

所以，在 `div.outerHTML=...` 中发生的事情是：
- `div` 被从文档（document）中移除。
- 另一个 HTML 片段 `&lt;p&gt;A new element&lt;/p&gt;` 被插入到其位置上。
- `div` 仍拥有其旧的值。新的 HTML 没有被赋值给任何变量。

在这儿很容易出错：修改 `div.outerHTML` 然后继续使用 `div`，就好像它包含的是新内容一样。但事实并非如此。这样的东西对于 `innerHTML` 是正确的，但是对于 `outerHTML` 却不正确。

我们可以向 `elem.outerHTML` 写入内容，但是要记住，它不会改变我们所写的元素（&#x27;elem&#x27;）。而是将新的 HTML 放在其位置上。我们可以通过查询 DOM 来获取对新元素的引用。

## nodeValue/data：文本节点内容

`innerHTML` 属性仅对元素节点有效。

其他节点类型，例如文本节点，具有它们的对应项：`nodeValue` 和 `data` 属性。这两者在实际使用中几乎相同，只有细微规范上的差异。因此，我们将使用 `data`，因为它更短。

读取文本节点和注释节点的内容的示例：

```html run height=&quot;50&quot;
&lt;body&gt;
  Hello
  &lt;!-- Comment --&gt;
  &lt;script&gt;
    let text = document.body.firstChild;
*!*
    alert(text.data); // Hello
*/!*

    let comment = text.nextSibling;
*!*
    alert(comment.data); // Comment
*/!*
  &lt;/script&gt;
&lt;/body&gt;
```

对于文本节点，我们可以想象读取或修改它们的原因，但是注释呢？

有时，开发者会将信息或模板说明嵌入到 HTML 中的注释中，如下所示：

```html
&lt;!-- if isAdmin --&gt;
  &lt;div&gt;Welcome, Admin!&lt;/div&gt;
&lt;!-- /if --&gt;
```

……然后，JavaScript 可以从 `data` 属性中读取它，并处理嵌入的指令。

## textContent：纯文本

`textContent` 提供了对元素内的 **文本** 的访问权限：仅文本，去掉所有 `&lt;tags&gt;`。

例如：

```html run
&lt;div id=&quot;news&quot;&gt;
  &lt;h1&gt;Headline!&lt;/h1&gt;
  &lt;p&gt;Martians attack people!&lt;/p&gt;
&lt;/div&gt;

&lt;script&gt;
  // Headline! Martians attack people!
  alert(news.textContent);
&lt;/script&gt;
```

正如我们所看到，只返回文本，就像所有 `&lt;tags&gt;` 都被剪掉了一样，但实际上其中的文本仍然存在。

在实际开发中，用到这样的文本读取的场景非常少。

**写入 `textContent` 要有用得多，因为它允许以“安全方式”写入文本。**

假设我们有一个用户输入的任意字符串，我们希望将其显示出来。

- 使用 `innerHTML`，我们将其“作为 HTML”插入，带有所有 HTML 标签。
- 使用 `textContent`，我们将其“作为文本”插入，所有符号（symbol）均按字面意义处理。

比较两者：

```html run
&lt;div id=&quot;elem1&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;elem2&quot;&gt;&lt;/div&gt;

&lt;script&gt;
  let name = prompt(&quot;What&#x27;s your name?&quot;, &quot;&lt;b&gt;Winnie-the-pooh!&lt;/b&gt;&quot;);

  elem1.innerHTML = name;
  elem2.textContent = name;
&lt;/script&gt;
```

1. 第一个 `&lt;div&gt;` 获取 name “作为 HTML”：所有标签都变成标签，所以我们可以看到粗体的 name。
2. 第二个 `&lt;div&gt;` 获取 name “作为文本”，因此我们可以从字面上看到 `&lt;b&gt;Winnie-the-pooh!&lt;/b&gt;`。

在大多数情况下，我们期望来自用户的文本，并希望将其视为文本对待。我们不希望在我们的网站中出现意料不到的 HTML。对 `textContent` 的赋值正好可以做到这一点。

## &quot;hidden&quot; 属性

&quot;hidden&quot; 特性（attribute）和 DOM 属性（property）指定元素是否可见。

我们可以在 HTML 中使用它，或者使用 JavaScript 进行赋值，如下所示：

```html run height=&quot;80&quot;
&lt;div&gt;Both divs below are hidden&lt;/div&gt;

&lt;div hidden&gt;With the attribute &quot;hidden&quot;&lt;/div&gt;

&lt;div id=&quot;elem&quot;&gt;JavaScript assigned the property &quot;hidden&quot;&lt;/div&gt;

&lt;script&gt;
  elem.hidden = true;
&lt;/script&gt;
```

从技术上来说，`hidden` 与 `style=&quot;display:none&quot;` 做的是相同的事。但 `hidden` 写法更简洁。

这里有一个 blinking 元素：


```html run height=50
&lt;div id=&quot;elem&quot;&gt;A blinking element&lt;/div&gt;

&lt;script&gt;
  setInterval(() =&gt; elem.hidden = !elem.hidden, 1000);
&lt;/script&gt;
```

## 更多属性

DOM 元素还有其他属性，特别是那些依赖于 class 的属性：

- `value` — `&lt;input&gt;`，`&lt;select&gt;` 和 `&lt;textarea&gt;`（`HTMLInputElement`，`HTMLSelectElement`……）的 value。
- `href` — `&lt;a href=&quot;...&quot;&gt;`（`HTMLAnchorElement`）的 href。
- `id` — 所有元素（`HTMLElement`）的 &quot;id&quot; 特性（attribute）的值。
- ……以及更多其他内容……

例如：

```html run height=&quot;80&quot;
&lt;input type=&quot;text&quot; id=&quot;elem&quot; value=&quot;value&quot;&gt;

&lt;script&gt;
  alert(elem.type); // &quot;text&quot;
  alert(elem.id); // &quot;elem&quot;
  alert(elem.value); // value
&lt;/script&gt;
```

大多数标准 HTML 特性（attribute）都具有相应的 DOM 属性，我们可以像这样访问它。

如果我们想知道给定类的受支持属性的完整列表，我们可以在规范中找到它们。例如，在 &lt;https://html.spec.whatwg.org/#htmlinputelement&gt; 中记录了 `HTMLInputElement`。

或者，如果我们想要快速获取它们，或者对具体的浏览器规范感兴趣 — 我们总是可以使用 `console.dir(elem)` 输出元素并读取其属性。或者在浏览器的开发者工具的元素（Elements）标签页中探索“DOM 属性”。

## 总结

每个 DOM 节点都属于一个特定的类。这些类形成层次结构（hierarchy）。完整的属性和方法集是继承的结果。

主要的 DOM 节点属性有：

`nodeType`
: 我们可以使用它来查看节点是文本节点还是元素节点。它具有一个数值型值（numeric value）：`1` 表示元素，`3` 表示文本节点，其他一些则代表其他节点类型。只读。

`nodeName/tagName`
: 用于元素名，标签名（除了 XML 模式，都要大写）。对于非元素节点，`nodeName` 描述了它是什么。只读。

`innerHTML`
: 元素的 HTML 内容。可以被修改。

`outerHTML`
: 元素的完整 HTML。对 `elem.outerHTML` 的写入操作不会触及 `elem` 本身。而是在外部上下文中将其替换为新的 HTML。

`nodeValue/data`
: 非元素节点（文本、注释）的内容。两者几乎一样，我们通常使用 `data`。可以被修改。

`textContent`
: 元素内的文本：HTML 减去所有 `&lt;tags&gt;`。写入文本会将文本放入元素内，所有特殊字符和标签均被视为文本。可以安全地插入用户生成的文本，并防止不必要的 HTML 插入。

`hidden`
: 当被设置为 `true` 时，执行与 CSS `display:none` 相同的事。

DOM 节点还具有其他属性，具体有哪些属性则取决于它们的类。例如，`&lt;input&gt;` 元素（`HTMLInputElement`）支持 `value`，`type`，而 `&lt;a&gt;` 元素（`HTMLAnchorElement`）则支持 `href` 等。大多数标准 HTML 特性（attribute）都具有相应的 DOM 属性。

然而，但是 HTML 特性（attribute）和 DOM 属性（property）并不总是相同的，我们将在下一章中看到。</code></pre>

      </fieldset>
      
      <fieldset id='_jq8MTj'>
      <legend>solution</legend>
      <pre><code class="language-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-widget-name</span>=<span class="hljs-string">&quot;menu&quot;</span>&gt;</span>Choose the genre<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-comment">// 获取它</span>
    <span class="hljs-keyword">let</span> elem = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;[data-widget-name]&#x27;</span>);

    <span class="hljs-comment">// 读取值</span>
    alert(elem.dataset.widgetName);
    <span class="hljs-comment">// 或</span>
    alert(elem.getAttribute(<span class="hljs-string">&#x27;data-widget-name&#x27;</span>));
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>

      </fieldset>
      
      <fieldset id='_crdt5O'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="获取特性">获取特性</h1>
<p>编写代码，从文档（document）中获取带有 <code>data-widget-name</code> 特性（attribute）的元素，并读取它的值。</p>
<pre><code class="language-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-widget-name</span>=<span class="hljs-string">&quot;menu&quot;</span>&gt;</span>Choose the genre<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-comment">/* your code */</span>
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>

      </fieldset>
      
      <fieldset id='_iAsEmS'>
      <legend>solution</legend>
      <p>首先，我们需要找到所有外部链接。</p>
<p>这里有两种方式。</p>
<p>第一种是使用 <code>document.querySelectorAll(&#39;a&#39;)</code> 找到所有链接，然后过滤出我们需要的部分：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> links = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;a&#x27;</span>);

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> link <span class="hljs-keyword">of</span> links) {
*!*
  <span class="hljs-keyword">let</span> href = link.getAttribute(<span class="hljs-string">&#x27;href&#x27;</span>);
*/!*
  <span class="hljs-keyword">if</span> (!href) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 没有特性</span>

  <span class="hljs-keyword">if</span> (!href.includes(<span class="hljs-string">&#x27;://&#x27;</span>)) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 没有协议</span>

  <span class="hljs-keyword">if</span> (href.startsWith(<span class="hljs-string">&#x27;http://internal.com&#x27;</span>)) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 内部的</span>

  link.style.color = <span class="hljs-string">&#x27;orange&#x27;</span>;
}</code></pre>
<p>请注意：我们用的是 <code>link.getAttribute(&#39;href&#39;)</code>。而不是 <code>link.href</code>，因为我们需要的是来自 HTML 的值。</p>
<p>……另一种更简单的方法，是使用 CSS 选择器进行检查：</p>
<pre><code class="language-js"><span class="hljs-comment">// 查找所有 href 中包含 :// 的链接</span>
<span class="hljs-comment">// 但 href 不是以 http://internal.com 开头</span>
<span class="hljs-keyword">let</span> selector = <span class="hljs-string">&#x27;a[href*=&quot;://&quot;]:not([href^=&quot;http://internal.com&quot;])&#x27;</span>;
<span class="hljs-keyword">let</span> links = <span class="hljs-built_in">document</span>.querySelectorAll(selector);

links.forEach(<span class="hljs-function"><span class="hljs-params">link</span> =&gt;</span> link.style.color = <span class="hljs-string">&#x27;orange&#x27;</span>);</code></pre>

      </fieldset>
      
      <fieldset id='_NJXha8'>
      <legend>task</legend>
      <p>importance: 3</p>
<hr>
<h1 id="将外部链接设为橙色">将外部链接设为橙色</h1>
<p>通过修改 <code>style</code> 属性，将所有外部链接变为橙色。</p>
<p>如果一个链接是外部的：</p>
<ul>
<li>其 <code>href</code> 中包含 <code>://</code></li>
<li>但不是以 <code>http://internal.com</code> 开头。</li>
</ul>
<p>例如：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span>the list<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://google.com&quot;</span>&gt;</span>http://google.com<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/tutorial&quot;</span>&gt;</span>/tutorial.html<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;local/path&quot;</span>&gt;</span>local/path<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;ftp://ftp.com/my.zip&quot;</span>&gt;</span>ftp://ftp.com/my.zip<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://nodejs.org&quot;</span>&gt;</span>http://nodejs.org<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://internal.com/test&quot;</span>&gt;</span>http://internal.com/test<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-comment">// 为单个链接设置样式</span>
  <span class="hljs-keyword">let</span> link = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;a&#x27;</span>);
  link.style.color = <span class="hljs-string">&#x27;orange&#x27;</span>;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>结果应该是：</p>
<p>[iframe border=1 height=180 src=&quot;solution&quot;]</p>

      </fieldset>
      
      <fieldset id='_05OdF4'>
      <legend>article</legend>
      <h1 id="特性和属性（attributes-and-properties）">特性和属性（Attributes and properties）</h1>
<p>当浏览器加载页面时，它会“读取”（或者称之为：“解析”）HTML 并从中生成 DOM 对象。对于元素节点，大多数标准的 HTML 特性（attributes）会自动变成 DOM 对象的属性（properties）。（译注：attribute 和 property 两词意思相近，为作区分，全文将 attribute 译为“特性”，property 译为“属性”，请读者注意区分。）</p>
<p>例如，如果标签是 <code>&lt;body id=&quot;page&quot;&gt;</code>，那么 DOM 对象就会有 <code>body.id=&quot;page&quot;</code>。</p>
<p>但特性—属性映射并不是一一对应的！在本章，我们将带领你一起分清楚这两个概念，了解如何使用它们，了解它们何时相同何时不同。</p>
<h2 id="dom-属性">DOM 属性</h2>
<p>我们已经见过了内建 DOM 属性。它们数量庞大。但是从技术上讲，没有人会限制我们，如果我们觉得这些 DOM 还不够，我们可以添加我们自己的。</p>
<p>DOM 节点是常规的 JavaScript 对象。我们可以 alert 它们。</p>
<p>例如，让我们在 <code>document.body</code> 中创建一个新的属性：</p>
<pre><code class="language-js"><span class="hljs-built_in">document</span>.body.myData = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Caesar&#x27;</span>,
  <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Imperator&#x27;</span>
};

alert(<span class="hljs-built_in">document</span>.body.myData.title); <span class="hljs-comment">// Imperator</span></code></pre>
<p>我们也可以像下面这样添加一个方法：</p>
<pre><code class="language-js"><span class="hljs-built_in">document</span>.body.sayTagName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-built_in">this</span>.tagName);
};

<span class="hljs-built_in">document</span>.body.sayTagName(); <span class="hljs-comment">// BODY（这个方法中的 &quot;this&quot; 的值是 document.body）</span></code></pre>
<p>我们还可以修改内建属性的原型，例如修改 <code>Element.prototype</code> 为所有元素添加一个新方法：</p>
<pre><code class="language-js">Element.prototype.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-string">`Hello, I&#x27;m <span class="hljs-subst">${<span class="hljs-built_in">this</span>.tagName}</span>`</span>);
};

<span class="hljs-built_in">document</span>.documentElement.sayHi(); <span class="hljs-comment">// Hello, I&#x27;m HTML</span>
<span class="hljs-built_in">document</span>.body.sayHi(); <span class="hljs-comment">// Hello, I&#x27;m BODY</span></code></pre>
<p>所以，DOM 属性和方法的行为就像常规的 Javascript 对象一样：</p>
<ul>
<li>它们可以有很多值。</li>
<li>它们是大小写敏感的（要写成 <code>elem.nodeType</code>，而不是 <code>elem.NoDeTyPe</code>）。</li>
</ul>
<h2 id="html-特性">HTML 特性</h2>
<p>在 HTML 中，标签可能拥有特性（attributes）。当浏览器解析 HTML 文本，并根据标签创建 DOM 对象时，浏览器会辨别 <strong>标准的</strong> 特性并以此创建 DOM 属性。</p>
<p>所以，当一个元素有 <code>id</code> 或其他 <strong>标准的</strong> 特性，那么就会生成对应的 DOM 属性。但是非 <strong>标准的</strong> 特性则不会。</p>
<p>例如：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span> <span class="hljs-attr">something</span>=<span class="hljs-string">&quot;non-standard&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    alert(<span class="hljs-built_in">document</span>.body.id); <span class="hljs-comment">// test</span>
*!*
    <span class="hljs-comment">// 非标准的特性没有获得对应的属性</span>
    alert(<span class="hljs-built_in">document</span>.body.something); <span class="hljs-comment">// undefined</span>
*/!*
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>请注意，一个元素的标准的特性对于另一个元素可能是未知的。例如 <code>&quot;type&quot;</code> 是 <code>&lt;input&gt;</code> 的一个标准的特性（<a href="https://html.spec.whatwg.org/#htmlinputelement">HTMLInputElement</a>），但对于 <code>&lt;body&gt;</code>（<a href="https://html.spec.whatwg.org/#htmlbodyelement">HTMLBodyElement</a>）来说则不是。规范中对相应元素类的标准的属性进行了详细的描述。</p>
<p>这里我们可以看到：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;body&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;input&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    alert(input.type); <span class="hljs-comment">// text</span>
*!*
    alert(body.type); <span class="hljs-comment">// undefined：DOM 属性没有被创建，因为它不是一个标准的特性</span>
*/!*
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>所以，如果一个特性不是标准的，那么就没有相对应的 DOM 属性。那我们有什么方法来访问这些特性吗？</p>
<p>当然。所有特性都可以通过使用以下方法进行访问：</p>
<ul>
<li><code>elem.hasAttribute(name)</code> — 检查特性是否存在。</li>
<li><code>elem.getAttribute(name)</code> — 获取这个特性值。</li>
<li><code>elem.setAttribute(name, value)</code> — 设置这个特性值。</li>
<li><code>elem.removeAttribute(name)</code> — 移除这个特性。</li>
</ul>
<p>这些方法操作的实际上是 HTML 中的内容。</p>
<p>我们也可以使用 <code>elem.attributes</code> 读取所有特性：属于内建 <a href="https://dom.spec.whatwg.org/#attr">Attr</a> 类的对象的集合，具有 <code>name</code> 和 <code>value</code> 属性。</p>
<p>下面是一个读取非标准的特性的示例：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">something</span>=<span class="hljs-string">&quot;non-standard&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
*!*
    alert(<span class="hljs-built_in">document</span>.body.getAttribute(<span class="hljs-string">&#x27;something&#x27;</span>)); <span class="hljs-comment">// 非标准的</span>
*/!*
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>HTML 特性有以下几个特征：</p>
<ul>
<li>它们的名字是大小写不敏感的（<code>id</code> 与 <code>ID</code> 相同）。</li>
<li>它们的值总是字符串类型的。</li>
</ul>
<p>下面是一个使用特性的扩展示例：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;elem&quot;</span> <span class="hljs-attr">about</span>=<span class="hljs-string">&quot;Elephant&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    alert( elem.getAttribute(<span class="hljs-string">&#x27;About&#x27;</span>) ); <span class="hljs-comment">// (1) &#x27;Elephant&#x27;，读取</span>

    elem.setAttribute(<span class="hljs-string">&#x27;Test&#x27;</span>, <span class="hljs-number">123</span>); <span class="hljs-comment">// (2) 写入</span>

    alert( elem.outerHTML ); <span class="hljs-comment">// (3) 查看特性是否在 HTML 中（在）</span>

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> attr <span class="hljs-keyword">of</span> elem.attributes) { <span class="hljs-comment">// (4) 列出所有</span>
      alert( <span class="hljs-string">`<span class="hljs-subst">${attr.name}</span> = <span class="hljs-subst">${attr.value}</span>`</span> );
    }
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>请注意：</p>
<ol>
<li><code>getAttribute(&#39;About&#39;)</code> — 这里的第一个字母是大写的，但是在 HTML 中，它们都是小写的。但这没有影响：特性的名称是大小写不敏感的。</li>
<li>我们可以将任何东西赋值给特性，但是这些东西会变成字符串类型的。所以这里我们的值为 <code>&quot;123&quot;</code>。</li>
<li>所有特性，包括我们设置的那个特性，在 <code>outerHTML</code> 中都是可见的。</li>
<li><code>attributes</code> 集合是可迭代对象，该对象将所有元素的特性（标准和非标准的）作为 <code>name</code> 和 <code>value</code> 属性存储在对象中。</li>
</ol>
<h2 id="属性特性同步">属性—特性同步</h2>
<p>当一个标准的特性被改变，对应的属性也会自动更新，（除了几个特例）反之亦然。</p>
<p>在下面这个示例中，<code>id</code> 被修改为特性，我们可以看到对应的属性也发生了变化。然后反过来也是同样的效果：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">let</span> input = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;input&#x27;</span>);

  <span class="hljs-comment">// 特性 =&gt; 属性</span>
  input.setAttribute(<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;id&#x27;</span>);
  alert(input.id); <span class="hljs-comment">// id（被更新了）</span>

  <span class="hljs-comment">// 属性 =&gt; 特性</span>
  input.id = <span class="hljs-string">&#x27;newId&#x27;</span>;
  alert(input.getAttribute(<span class="hljs-string">&#x27;id&#x27;</span>)); <span class="hljs-comment">// newId（被更新了）</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>但这里也有些例外，例如 <code>input.value</code> 只能从特性同步到属性，反过来则不行：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">let</span> input = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;input&#x27;</span>);

  <span class="hljs-comment">// 特性 =&gt; 属性</span>
  input.setAttribute(<span class="hljs-string">&#x27;value&#x27;</span>, <span class="hljs-string">&#x27;text&#x27;</span>);
  alert(input.value); <span class="hljs-comment">// text</span>

*!*
  <span class="hljs-comment">// 这个操作无效，属性 =&gt; 特性</span>
  input.value = <span class="hljs-string">&#x27;newValue&#x27;</span>;
  alert(input.getAttribute(<span class="hljs-string">&#x27;value&#x27;</span>)); <span class="hljs-comment">// text（没有被更新！）</span>
*/!*
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>在上面这个例子中：</p>
<ul>
<li>改变特性值 <code>value</code> 会更新属性。</li>
<li>但是属性的更改不会影响特性。</li>
</ul>
<p>这个“功能”在实际中会派上用场，因为用户行为可能会导致 <code>value</code> 的更改，然后在这些操作之后，如果我们想从 HTML 中恢复“原始”值，那么该值就在特性中。</p>
<h2 id="dom-属性是多类型的">DOM 属性是多类型的</h2>
<p>DOM 属性不总是字符串类型的。例如，<code>input.checked</code> 属性（对于 checkbox 的）是布尔型的。</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;input&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">checked</span>&gt;</span> checkbox

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  alert(input.getAttribute(<span class="hljs-string">&#x27;checked&#x27;</span>)); <span class="hljs-comment">// 特性值是：空字符串</span>
  alert(input.checked); <span class="hljs-comment">// 属性值是：true</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>还有其他的例子。<code>style</code> 特性是字符串类型的，但 <code>style</code> 属性是一个对象：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red;font-size:120%&quot;</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-comment">// 字符串</span>
  alert(div.getAttribute(<span class="hljs-string">&#x27;style&#x27;</span>)); <span class="hljs-comment">// color:red;font-size:120%</span>

  <span class="hljs-comment">// 对象</span>
  alert(div.style); <span class="hljs-comment">// [object CSSStyleDeclaration]</span>
  alert(div.style.color); <span class="hljs-comment">// red</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>尽管大多数 DOM 属性都是字符串类型的。</p>
<p>有一种非常少见的情况，即使一个 DOM 属性是字符串类型的，但它可能和 HTML 特性也是不同的。例如，<code>href</code> DOM 属性一直是一个 <strong>完整的</strong> URL，即使该特性包含一个相对路径或者包含一个 <code>#hash</code>。</p>
<p>这里有一个例子：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;a&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#hello&quot;</span>&gt;</span>link<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-comment">// 特性</span>
  alert(a.getAttribute(<span class="hljs-string">&#x27;href&#x27;</span>)); <span class="hljs-comment">// #hello</span>

  <span class="hljs-comment">// 属性</span>
  alert(a.href ); <span class="hljs-comment">// http://site.com/page#hello 形式的完整 URL </span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>如果我们需要 <code>href</code> 特性的值，或者其他与 HTML 中所写的完全相同的特性，则可以使用 <code>getAttribute</code>。</p>
<h2 id="非标准的特性，dataset">非标准的特性，dataset</h2>
<p>当编写 HTML 时，我们会用到很多标准的特性。但是非标准的，自定义的呢？首先，让我们看看它们是否有用？用来做什么？</p>
<p>有时，非标准的特性常常用于将自定义的数据从 HTML 传递到 JavaScript，或者用于为 JavaScript “标记” HTML 元素。</p>
<p>像这样：</p>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 标记这个 div 以在这显示 &quot;name&quot; --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> *!*<span class="hljs-attr">show-info</span>=<span class="hljs-string">&quot;name&quot;</span>*/!*&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 标记这个 div 以在这显示 &quot;age&quot; --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> *!*<span class="hljs-attr">show-info</span>=<span class="hljs-string">&quot;age&quot;</span>*/!*&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-comment">// 这段代码找到带有标记的元素，并显示需要的内容</span>
  <span class="hljs-keyword">let</span> user = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Pete&quot;</span>,
    <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>
  };

  <span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> div <span class="hljs-keyword">of</span> <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;[show-info]&#x27;</span>)</span>)</span> {
    <span class="hljs-comment">// 在字段中插入相应的信息</span>
    <span class="hljs-keyword">let</span> field = div.getAttribute(<span class="hljs-string">&#x27;show-info&#x27;</span>);
    div.innerHTML = user[field]; <span class="hljs-comment">// 首先 &quot;name&quot; 变为 Pete，然后 &quot;age&quot; 变为 25</span>
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>它们还可以用来设置元素的样式。</p>
<p>例如，这里使用 <code>order-state</code> 特性来设置订单状态：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
  <span class="hljs-comment">/* 样式依赖于自定义特性 &quot;order-state&quot; */</span>
  <span class="hljs-selector-class">.order</span><span class="hljs-selector-attr">[order-state=<span class="hljs-string">&quot;new&quot;</span>]</span> {
    <span class="hljs-attribute">color</span>: green;
  }

  <span class="hljs-selector-class">.order</span><span class="hljs-selector-attr">[order-state=<span class="hljs-string">&quot;pending&quot;</span>]</span> {
    <span class="hljs-attribute">color</span>: blue;
  }

  <span class="hljs-selector-class">.order</span><span class="hljs-selector-attr">[order-state=<span class="hljs-string">&quot;canceled&quot;</span>]</span> {
    <span class="hljs-attribute">color</span>: red;
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;order&quot;</span> <span class="hljs-attr">order-state</span>=<span class="hljs-string">&quot;new&quot;</span>&gt;</span>
  A new order.
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;order&quot;</span> <span class="hljs-attr">order-state</span>=<span class="hljs-string">&quot;pending&quot;</span>&gt;</span>
  A pending order.
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;order&quot;</span> <span class="hljs-attr">order-state</span>=<span class="hljs-string">&quot;canceled&quot;</span>&gt;</span>
  A canceled order.
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>为什么使用特性比使用 <code>.order-state-new</code>，<code>.order-state-pending</code>，<code>order-state-canceled</code> 这些样式类要好？</p>
<p>因为特性值更容易管理。我们可以轻松地更改状态：</p>
<pre><code class="language-js"><span class="hljs-comment">// 比删除旧的或者添加一个新的类要简单一些</span>
div.setAttribute(<span class="hljs-string">&#x27;order-state&#x27;</span>, <span class="hljs-string">&#x27;canceled&#x27;</span>);</code></pre>
<p>但是自定义的特性也存在问题。如果我们出于我们的目的使用了非标准的特性，之后它被引入到了标准中并有了其自己的用途，该怎么办？HTML 语言是在不断发展的，并且更多的特性出现在了标准中，以满足开发者的需求。在这种情况下，自定义的属性可能会产生意料不到的影响。</p>
<p>为了避免冲突，存在 <a href="https://html.spec.whatwg.org/#embedding-custom-non-visible-data-with-the-data-*-attributes">data-*</a> 特性。</p>
<p><strong>所有以 &quot;data-&quot; 开头的特性均被保留供程序员使用。它们可在 <code>dataset</code> 属性中使用。</strong></p>
<p>例如，如果一个 <code>elem</code> 有一个名为 <code>&quot;data-about&quot;</code> 的特性，那么可以通过 <code>elem.dataset.about</code> 取到它。</p>
<p>像这样：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">data-about</span>=<span class="hljs-string">&quot;Elephants&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  alert(<span class="hljs-built_in">document</span>.body.dataset.about); <span class="hljs-comment">// Elephants</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>像 <code>data-order-state</code> 这样的多词特性可以以驼峰式进行调用：<code>dataset.orderState</code>。</p>
<p>这里是 &quot;order state&quot; 那个示例的重构版：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
  <span class="hljs-selector-class">.order</span><span class="hljs-selector-attr">[data-order-state=<span class="hljs-string">&quot;new&quot;</span>]</span> {
    <span class="hljs-attribute">color</span>: green;
  }

  <span class="hljs-selector-class">.order</span><span class="hljs-selector-attr">[data-order-state=<span class="hljs-string">&quot;pending&quot;</span>]</span> {
    <span class="hljs-attribute">color</span>: blue;
  }

  <span class="hljs-selector-class">.order</span><span class="hljs-selector-attr">[data-order-state=<span class="hljs-string">&quot;canceled&quot;</span>]</span> {
    <span class="hljs-attribute">color</span>: red;
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;order&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;order&quot;</span> <span class="hljs-attr">data-order-state</span>=<span class="hljs-string">&quot;new&quot;</span>&gt;</span>
  A new order.
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-comment">// 读取</span>
  alert(order.dataset.orderState); <span class="hljs-comment">// new</span>

  <span class="hljs-comment">// 修改</span>
  order.dataset.orderState = <span class="hljs-string">&quot;pending&quot;</span>; <span class="hljs-comment">// (*)</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>使用 <code>data-*</code> 特性是一种合法且安全的传递自定义数据的方式。</p>
<p>请注意，我们不仅可以读取数据，还可以修改数据属性（data-attributes）。然后 CSS 会更新相应的视图：在上面这个例子中的最后一行 <code>(*)</code> 将颜色更改为了蓝色。</p>
<h2 id="总结">总结</h2>
<ul>
<li>特性（attribute）— 写在 HTML 中的内容。</li>
<li>属性（property）— DOM 对象中的内容。</li>
</ul>
<p>简略的对比：</p>
<table>
<thead>
<tr>
<th></th>
<th>属性</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>任何值，标准的属性具有规范中描述的类型</td>
<td>字符串</td>
</tr>
<tr>
<td>名字</td>
<td>名字（name）是大小写敏感的</td>
<td>名字（name）是大小写不敏感的</td>
</tr>
</tbody></table>
<p>操作特性的方法：</p>
<ul>
<li><code>elem.hasAttribute(name)</code> — 检查是否存在这个特性。</li>
<li><code>elem.getAttribute(name)</code> — 获取这个特性值。</li>
<li><code>elem.setAttribute(name, value)</code> — 设置这个特性值。</li>
<li><code>elem.removeAttribute(name)</code> — 移除这个特性。</li>
<li><code>elem.attributes</code> — 所有特性的集合。</li>
</ul>
<p>在大多数情况下，最好使用 DOM 属性。仅当 DOM 属性无法满足开发需求，并且我们真的需要特性时，才使用特性，例如：</p>
<ul>
<li>我们需要一个非标准的特性。但是如果它以 <code>data-</code> 开头，那么我们应该使用 <code>dataset</code>。</li>
<li>我们想要读取 HTML 中“所写的”值。对应的 DOM 属性可能不同，例如 <code>href</code> 属性一直是一个 <strong>完整的</strong> URL，但是我们想要的是“原始的”值。</li>
</ul>

      </fieldset>
      
      <fieldset id='_3sR0Mm'>
      <legend>solution</legend>
      <p>回答：<strong>1 和 3</strong>。</p>
<p>这两个命令都会将 <code>text</code> “作为文本”添加到 <code>elem</code> 中。</p>
<p>这是一个例子：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;elem1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;elem2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;elem3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">let</span> text = <span class="hljs-string">&#x27;&lt;b&gt;text&lt;/b&gt;&#x27;</span>;

  elem1.append(<span class="hljs-built_in">document</span>.createTextNode(text));
  elem2.innerHTML = text;
  elem3.textContent = text;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>

      </fieldset>
      
      <fieldset id='_jreTQb'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="createtextnode-vs-innerhtml-vs-textcontent">createTextNode vs innerHTML vs textContent</h1>
<p>我们有一个空的 DOM 元素 <code>elem</code> 和一个字符串 <code>text</code>。</p>
<p>下面这 3 个命令中的哪个命令做的是完全相同的事儿？</p>
<ol>
<li><code>elem.append(document.createTextNode(text))</code></li>
<li><code>elem.innerHTML = text</code></li>
<li><code>elem.textContent = text</code></li>
</ol>

      </fieldset>
      
      <fieldset id='_UQg7X9'>
      <legend>solution</legend>
      <p>首先，让我们编写 HTML/CSS。</p>
<p>时间的每个组件都有其自己的 <code>&lt;span&gt;</code>，那将会看起来很棒：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;clock&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;hour&quot;</span>&gt;</span>hh<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;min&quot;</span>&gt;</span>mm<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sec&quot;</span>&gt;</span>ss<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>另外，我们需要使用 CSS 为它们着色。</p>
<p>函数 <code>update</code> 会刷新时钟，由 <code>setInterval</code> 每秒调用一次：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> clock = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;clock&#x27;</span>);
*!*
  <span class="hljs-keyword">let</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(); <span class="hljs-comment">// (*)</span>
*/!*
  <span class="hljs-keyword">let</span> hours = date.getHours();
  <span class="hljs-keyword">if</span> (hours &lt; <span class="hljs-number">10</span>) hours = <span class="hljs-string">&#x27;0&#x27;</span> + hours;
  clock.children[<span class="hljs-number">0</span>].innerHTML = hours;

  <span class="hljs-keyword">let</span> minutes = date.getMinutes();
  <span class="hljs-keyword">if</span> (minutes &lt; <span class="hljs-number">10</span>) minutes = <span class="hljs-string">&#x27;0&#x27;</span> + minutes;
  clock.children[<span class="hljs-number">1</span>].innerHTML = minutes;

  <span class="hljs-keyword">let</span> seconds = date.getSeconds();
  <span class="hljs-keyword">if</span> (seconds &lt; <span class="hljs-number">10</span>) seconds = <span class="hljs-string">&#x27;0&#x27;</span> + seconds;
  clock.children[<span class="hljs-number">2</span>].innerHTML = seconds;
}</code></pre>
<p>在 <code>(*)</code> 行中，我们每次都检查当前时间。<code>setInterval</code> 调用并不可靠：它们可能会发生延迟现象。</p>
<p>时钟管理函数：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> timerId;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clockStart</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// 运行时钟</span>
  timerId = <span class="hljs-built_in">setInterval</span>(update, <span class="hljs-number">1000</span>);
  update(); <span class="hljs-comment">// (*)</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clockStop</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">clearInterval</span>(timerId);
  timerId = <span class="hljs-literal">null</span>;
}</code></pre>
<p>请注意，<code>update()</code> 不仅在 <code>clockStart()</code> 中被调度，而且还立即在 <code>(*)</code> 行运行。否则，访问者将不得不等到 <code>setInterval</code> 第一次执行。在那之前，时钟将是空的。</p>

      </fieldset>
      
      <fieldset id='_tXl4qQ'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="使用-setinterval-的彩色时钟">使用 setInterval 的彩色时钟</h1>
<p>创建一个像这样的彩色时钟：</p>
<p>[iframe src=&quot;solution&quot; height=60]</p>
<p>使用 HTML/CSS 进行样式设计，JavaScript 仅用来更新元素中的时间。</p>

      </fieldset>
      
      <fieldset id='_32is4V'>
      <legend>solution</legend>
      <p>当我们需要在某处插入 HTML 时，<code>insertAdjacentHTML</code> 是最适合的方案。</p>
<p>解决方法：</p>
<pre><code class="language-js">one.insertAdjacentHTML(<span class="hljs-string">&#x27;afterend&#x27;</span>, <span class="hljs-string">&#x27;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&#x27;</span>);</code></pre>

      </fieldset>
      
      <fieldset id='_vETkXX'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="将-html-插入到列表中">将 HTML 插入到列表中</h1>
<p>编写代码，将 <code>&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;</code>，插入到两个 <code>&lt;li&gt;</code> 之间：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ul&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;one&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;two&quot;</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre>

      </fieldset>
      
      <fieldset id='_pjooXP'>
      <legend>solution</legend>
      <p>这个解决方案虽然很短，但可能看起来有点难理解，因此，在这里我提供了一些扩展性的注释：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> sortedRows = <span class="hljs-built_in">Array</span>.from(table.tBodies[<span class="hljs-number">0</span>].rows) <span class="hljs-comment">// 1</span>
  .sort(<span class="hljs-function">(<span class="hljs-params">rowA, rowB</span>) =&gt;</span> rowA.cells[<span class="hljs-number">0</span>].innerHTML.localeCompare(rowB.cells[<span class="hljs-number">0</span>].innerHTML));

table.tBodies[<span class="hljs-number">0</span>].append(...sortedRows); <span class="hljs-comment">// (3)</span></code></pre>
<p>对此算法一步一步进行讲解：</p>
<ol>
<li>从 <code>&lt;tbody&gt;</code> 获取所有 <code>&lt;tr&gt;</code>。</li>
<li>然后将它们按第一个 <code>&lt;td&gt;</code>（<code>name</code> 字段）中的内容进行比较。</li>
<li>然后使用 <code>.append(...sortedRows)</code> 按正确的顺序插入节点。</li>
</ol>
<p>我们不必删除行元素，只需要“重新插入”，它们就会自动离开原来的位置。</p>
<p>P.S. 在我们的例子中，表格中有一个明确的 <code>&lt;tbody&gt;</code>，但即使 HTML 中的表格没有 <code>&lt;tbody&gt;</code>，DOM 结构也总是具有它。</p>

      </fieldset>
      
      <fieldset id='_O2Tif2'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="对表格进行排序">对表格进行排序</h1>
<p>下面是一个表格：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Name<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Surname<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Age<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>John<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Smith<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Pete<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Brown<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>15<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Ann<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Lee<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre>
<p>可能会有更多行。</p>
<p>编写代码，按 <code>&quot;name&quot;</code> 列对其进行排序。</p>

      </fieldset>
      
      <fieldset id='_ABsK0P'>
      <legend>solution</legend>
      <p>首先，让我们看看 <strong>错误</strong> 的做法：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clear</span>(<span class="hljs-params">elem</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i &lt; elem.childNodes.length; i++) {
      elem.childNodes[i].remove();
  }
}</code></pre>
<p>这是行不通的，因为调用 <code>remove()</code> 会从首端开始移除 <code>elem.childNodes</code> 集合中的元素，因此，元素每次都从索引 <code>0</code> 开始。但是 <code>i</code> 在增加，所以元素就被跳过了。</p>
<p>用 <code>for..of</code> 循环的结果也跟上面一样。</p>
<p>正确的做法是：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clear</span>(<span class="hljs-params">elem</span>) </span>{
  <span class="hljs-keyword">while</span> (elem.firstChild) {
    elem.firstChild.remove();
  }
}</code></pre>
<p>还有一种更简单的方法，也可以达到我们所要的效果：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clear</span>(<span class="hljs-params">elem</span>) </span>{
  elem.innerHTML = <span class="hljs-string">&#x27;&#x27;</span>;
}</code></pre>

      </fieldset>
      
      <fieldset id='_KzIYHY'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="清除元素">清除元素</h1>
<p>创建一个函数 <code>clear(elem)</code> 用来移除元素里的内容。</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;elem&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>World<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clear</span>(<span class="hljs-params">elem</span>) </span>{ <span class="hljs-comment">/* 你的代码 */</span> }

  clear(elem); <span class="hljs-comment">// 清除列表</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>

      </fieldset>
      
      <fieldset id='_nFj86J'>
      <legend>solution</legend>
      <p>这个题目中的 HTML 是错的。这就是造成怪异现象的原因。</p>
<p>浏览器必须自动修复它。但 <code>&lt;table&gt;</code> 内可能会没有文本：根据规范，只允许特定于表格的标签。所以浏览器把 <code>&quot;aaa&quot;</code> 添加到了 <code>&lt;table&gt;</code> <strong>前面</strong>。</p>
<p>当我们删除表格后，文本 <code>&quot;aaa&quot;</code> 仍然存在的原因就很明显了吧。</p>
<p>通过使用浏览器开发者工具查看 DOM，就可以轻松地回答这个问题。从浏览器开发者工具中我们可以看到，<code>&quot;aaa&quot;</code> 在 <code>&lt;table&gt;</code> 前面。</p>
<p>HTML 标准规范详细描述了如何处理错误的 HTML，并且浏览器的这种行为是正确的。</p>

      </fieldset>
      
      <fieldset id='_be9gjI'>
      <legend>task</legend>
      <p>importance: 1</p>
<hr>
<h1 id="为什么留下-aaa？">为什么留下 &quot;aaa&quot;？</h1>
<p>在下面这个示例中，我们调用 <code>table.remove()</code> 从文档中删除表格。</p>
<p>但如果运行它，你就会看到文本 <code>&quot;aaa&quot;</code> 并没有被删除。</p>
<p>这是为什么？</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;table&quot;</span>&gt;</span>
  aaa
  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Test<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  alert(table); <span class="hljs-comment">// 表格，就是它应有的样子</span>

  table.remove();
  <span class="hljs-comment">// 为什么 aaa 还存在于文档中？</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>

      </fieldset>
      
      <fieldset id='_WPayqS'>
      <legend>solution</legend>
      <p>请注意使用 <code>textContent</code> 对 <code>&lt;li&gt;</code> 的内容进行赋值的用法。</p>

      </fieldset>
      
      <fieldset id='_TmeuCo'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="创建一个列表">创建一个列表</h1>
<p>编写一个接口，根据用户输入创建一个列表（list）。</p>
<p>对于每个列表项：</p>
<ol>
<li>使用 <code>prompt</code> 向用户询问列表项的内容。</li>
<li>使用用户输入的内容创建 <code>&lt;li&gt;</code>，并添加到 <code>&lt;ul&gt;</code>。</li>
<li>重复以上步骤，直到用户取消输入（按下 <code>key:Esc</code> 键，或点击 <code>prompt</code> 弹窗的 CANCEL 按钮）。</li>
</ol>
<p>所有元素应该都是动态创建的。</p>
<p>如果用户输入了 HTML 标签，那么这些内容应该被视为文本进行后续处理。</p>
<p>[demo src=&quot;solution&quot;]</p>

      </fieldset>
      
      <fieldset id='_mzxcMi'>
      <legend>solution</legend>
      <p>遍历对象的最简单的方法是使用递归。</p>
<ol>
<li><a href="sandbox:innerhtml">使用 innerHTML 的解决方案</a>。</li>
<li><a href="sandbox:build-tree-dom">使用 DOM 的解决方案</a>。</li>
</ol>

      </fieldset>
      
      <fieldset id='_AmjoeY'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="从对象创建树">从对象创建树</h1>
<p>编写一个函数 <code>createTree</code>，从嵌套对象创建一个嵌套的 <code>ul/li</code> 列表（list）。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> data = {
  <span class="hljs-string">&quot;Fish&quot;</span>: {
    <span class="hljs-string">&quot;trout&quot;</span>: {},
    <span class="hljs-string">&quot;salmon&quot;</span>: {}
  },

  <span class="hljs-string">&quot;Tree&quot;</span>: {
    <span class="hljs-string">&quot;Huge&quot;</span>: {
      <span class="hljs-string">&quot;sequoia&quot;</span>: {},
      <span class="hljs-string">&quot;oak&quot;</span>: {}
    },
    <span class="hljs-string">&quot;Flowering&quot;</span>: {
      <span class="hljs-string">&quot;apple tree&quot;</span>: {},
      <span class="hljs-string">&quot;magnolia&quot;</span>: {}
    }
  }
};</code></pre>
<p>语法：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> container = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;container&#x27;</span>);
*!*
createTree(container, data); <span class="hljs-comment">// 将树创建在 container 中</span>
*/!*</code></pre>
<p>结果（树）看起来像这样：</p>
<p>[iframe border=1 src=&quot;build-tree-dom&quot;]</p>
<p>选择下面两种方式中的一种，来完成这个任务：</p>
<ol>
<li>为树创建 HTML，然后将它们赋值给 <code>container.innerHTML</code>。</li>
<li>创建节点树，并使用 DOM 方法将它们附加（append）上去。</li>
</ol>
<p>如果这两种方式你都做，那就太好了。</p>
<p>P.S. 树上不应该有“多余”的元素，例如空的 <code>&lt;ul&gt;&lt;/ul&gt;</code> 叶子节点。</p>

      </fieldset>
      
      <fieldset id='_OdU9hg'>
      <legend>solution</legend>
      <p>为了将文本附加到每个 <code>&lt;li&gt;</code> 中，我们可以改变文本节点的 <code>data</code>。</p>

      </fieldset>
      
      <fieldset id='_el6HcV'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="在树中显示后代">在树中显示后代</h1>
<p>这里有一棵由嵌套的 <code>ul/li</code> 组成的树。</p>
<p>编写代码，为每个 <code>&lt;li&gt;</code> 添加其后代数量。跳过叶子节点（没有子代的节点）。</p>
<p>结果：</p>
<p>[iframe border=1 src=&quot;solution&quot;]</p>

      </fieldset>
      
      <fieldset id='_fVVWo3'>
      <legend>solution</legend>
      <p>我们将表格创建为字符串：<code>&quot;&lt;table&gt;...&lt;/table&gt;&quot;</code>，然后将其赋值给 <code>innerHTML</code>。</p>
<p>算法如下：</p>
<ol>
<li>使用 <code>&lt;th&gt;</code> 创建带有星期名的表头。</li>
<li>创建日期对象 <code>d = new Date(year, month-1)</code>。它是 <code>month</code> 的第一天（考虑到 JavaScript 中的月份从 <code>0</code> 开始，而不是从 <code>1</code> 开始）。</li>
<li>直到月份的第一天 <code>d.getDay()</code>，前面的几个单元格是空的。让我们用 <code>&lt;td&gt;&lt;/td&gt;</code> 填充它们。</li>
<li>天数增长 <code>d</code>：<code>d.setDate(d.getDate()+1)</code>。如果 <code>d.getMonth()</code> 还没到下一个月，那么就将新的单元格 <code>&lt;td&gt;</code> 添加到日历中。如果那天是星期日，就添加一个新行 <code>"&lt;/tr&gt;&lt;tr&gt;"</code>。</li>
<li>如果该月结束，但表格的行尚未填满，就用空的 <code>&lt;td&gt;</code> 补齐。</li>
</ol>

      </fieldset>
      
      <fieldset id='_ttLZxn'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="创建一个日历">创建一个日历</h1>
<p>编写一个函数 <code>createCalendar(elem, year, month)</code>。</p>
<p>对该函数的调用，应该使用给定的 year/month 创建一个日历，并将创建的日历放入 <code>elem</code> 中。</p>
<p>创建的日历应该是一个表格（table），其中每一周用 <code>&lt;tr&gt;</code> 表示，每一天用 <code>&lt;td&gt;</code> 表示。表格顶部应该是带有星期名的 <code>&lt;th&gt;</code>：第一天应该是 Monday，依此类推，直到 Sunday。</p>
<p>例如，<code>createCalendar(cal, 2012, 9)</code> 应该在元素 <code>cal</code> 中生成如下所示的日历：</p>
<p>[iframe height=210 src=&quot;solution&quot;]</p>
<p>P.S. 在这个任务中，生成一个日历就可以了，不需要有点击交互的功能。</p>

      </fieldset>
      
      <fieldset id='_Ew4yHY'>
      <legend>article</legend>
      <h1 id="修改文档（document）">修改文档（document）</h1>
<p>DOM 修改是创建“实时”页面的关键。</p>
<p>在这里，我们将会看到如何“即时”创建新元素并修改现有页面内容。</p>
<h2 id="例子：展示一条消息">例子：展示一条消息</h2>
<p>让我们使用一个示例进行演示。我们将在页面上添加一条比 <code>alert</code> 更好看的消息。</p>
<p>它的外观如下：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
<span class="hljs-selector-class">.alert</span> {
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">15px</span>;
  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#d6e9c6</span>;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#3c763d</span>;
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#dff0d8</span>;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

*!*
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;alert&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>Hi there!<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span> You&#x27;ve read an important message.
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
*/!*</code></pre>
<p>这是一个 HTML 示例。现在，让我们使用 JavaScript 创建一个相同的 <code>div</code>（假设样式已经在 HTML/CSS 文件中）。</p>
<h2 id="创建一个元素">创建一个元素</h2>
<p>要创建 DOM 节点，这里有两种方法：</p>
<p><code>document.createElement(tag)</code>
: 用给定的标签创建一个新 <strong>元素节点（element node）</strong>：</p>
<pre><code>```js
let div = document.createElement(&#x27;div&#x27;);
```</code></pre>
<p><code>document.createTextNode(text)</code>
: 用给定的文本创建一个 <strong>文本节点</strong>：</p>
<pre><code>```js
let textNode = document.createTextNode(&#x27;Here I am&#x27;);
```</code></pre>
<p>大多数情况下，我们需要为此消息创建像 <code>div</code> 这样的元素节点。</p>
<h3 id="创建一条消息">创建一条消息</h3>
<p>创建一个消息 <code>div</code> 分为 3 个步骤：</p>
<pre><code class="language-js"><span class="hljs-comment">// 1. 创建 &lt;div&gt; 元素</span>
<span class="hljs-keyword">let</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);

<span class="hljs-comment">// 2. 将元素的类设置为 &quot;alert&quot;</span>
div.className = <span class="hljs-string">&quot;alert&quot;</span>;

<span class="hljs-comment">// 3. 填充消息内容</span>
div.innerHTML = <span class="hljs-string">&quot;&lt;strong&gt;Hi there!&lt;/strong&gt; You&#x27;ve read an important message.&quot;</span>;</code></pre>
<p>我们已经创建了该元素。但到目前为止，它还只是在一个名为 <code>div</code> 的变量中，尚未在页面中。所以我们无法在页面上看到它。</p>
<h2 id="插入方法">插入方法</h2>
<p>为了让 <code>div</code> 显示出来，我们需要将其插入到 <code>document</code> 中的某处。例如，into <code>&lt;body&gt;</code> element, referenced by <code>document.body</code>.</p>
<p>对此有一个特殊的方法 <code>append</code>：<code>document.body.append(div)</code>。</p>
<p>这是完整代码：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
<span class="hljs-selector-class">.alert</span> {
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">15px</span>;
  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#d6e9c6</span>;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#3c763d</span>;
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#dff0d8</span>;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">let</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);
  div.className = <span class="hljs-string">&quot;alert&quot;</span>;
  div.innerHTML = <span class="hljs-string">&quot;&lt;strong&gt;Hi there!&lt;/strong&gt; You&#x27;ve read an important message.&quot;</span>;

*!*
  <span class="hljs-built_in">document</span>.body.append(div);
*/!*
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>在这个例子中，我们对 <code>document.body</code> 调用了 <code>append</code> 方法。不过我们可以在其他任何元素上调用 <code>append</code> 方法，以将另外一个元素放入到里面。例如，通过调用 <code>div.append(anotherElement)</code>，我们便可以在 <code>&lt;div&gt;</code> 末尾添加一些内容。</p>
<p>这里是更多的元素插入方法，指明了不同的插入位置：</p>
<ul>
<li><code>node.append(...nodes or strings)</code> —— 在 <code>node</code> <strong>末尾</strong> 插入节点或字符串，</li>
<li><code>node.prepend(...nodes or strings)</code> —— 在 <code>node</code> <strong>开头</strong> 插入节点或字符串，</li>
<li><code>node.before(...nodes or strings)</code> —— 在 <code>node</code> <strong>前面</strong> 插入节点或字符串，</li>
<li><code>node.after(...nodes or strings)</code> —— 在 <code>node</code> <strong>后面</strong> 插入节点或字符串，</li>
<li><code>node.replaceWith(...nodes or strings)</code> —— 将 <code>node</code> 替换为给定的节点或字符串。</li>
</ul>
<p>这些方法的参数可以是一个要插入的任意的 DOM 节点列表，或者文本字符串（会被自动转换成文本节点）。</p>
<p>让我们在实际应用中看一看。</p>
<p>下面是使用这些方法将列表项添加到列表中，以及将文本添加到列表前面和后面的示例：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ol&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  ol.before(<span class="hljs-string">&#x27;before&#x27;</span>); <span class="hljs-comment">// 将字符串 &quot;before&quot; 插入到 &lt;ol&gt; 前面</span>
  ol.after(<span class="hljs-string">&#x27;after&#x27;</span>); <span class="hljs-comment">// 将字符串 &quot;after&quot; 插入到 &lt;ol&gt; 后面</span>

  <span class="hljs-keyword">let</span> liFirst = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;li&#x27;</span>);
  liFirst.innerHTML = <span class="hljs-string">&#x27;prepend&#x27;</span>;
  ol.prepend(liFirst); <span class="hljs-comment">// 将 liFirst 插入到 &lt;ol&gt; 的最开始</span>

  <span class="hljs-keyword">let</span> liLast = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;li&#x27;</span>);
  liLast.innerHTML = <span class="hljs-string">&#x27;append&#x27;</span>;
  ol.append(liLast); <span class="hljs-comment">// 将 liLast 插入到 &lt;ol&gt; 的最末尾</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>这张图片直观地显示了这些方法所做的工作：</p>
<p><img src="before-prepend-append-after.svg" alt=""></p>
<p>因此，最终列表将为：</p>
<pre><code class="language-html">before
<span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ol&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>prepend<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>append<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span>
after</code></pre>
<p>如上所述，这些方法可以在单个调用中插入多个节点列表和文本片段。</p>
<p>例如，在这里插入了一个字符串和一个元素：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  div.before(<span class="hljs-string">&#x27;&lt;p&gt;Hello&lt;/p&gt;&#x27;</span>, <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;hr&#x27;</span>));
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>请注意：这里的文字都被“作为文本”插入，而不是“作为 HTML 代码”。因此像 <code>&lt;</code>、<code>&gt;</code> 这样的符号都会被作转义处理来保证正确显示。</p>
<p>所以，最终的 HTML 为：</p>
<pre><code class="language-html">*!*
<span class="hljs-symbol">&amp;lt;</span>p<span class="hljs-symbol">&amp;gt;</span>Hello<span class="hljs-symbol">&amp;lt;</span>/p<span class="hljs-symbol">&amp;gt;</span>
*/!*
<span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>换句话说，字符串被以一种安全的方式插入到页面中，就像 <code>elem.textContent</code> 所做的一样。</p>
<p>所以，这些方法只能用来插入 DOM 节点或文本片段。</p>
<p>但如果我们想要将内容“作为 HTML 代码插入”，让内容中的所有标签和其他东西都像使用 <code>elem.innerHTML</code> 所表现的效果一样，那应该怎么办呢？</p>
<h2 id="insertadjacenthtmltextelement">insertAdjacentHTML/Text/Element</h2>
<p>为此，我们可以使用另一个非常通用的方法：<code>elem.insertAdjacentHTML(where, html)</code>。</p>
<p>该方法的第一个参数是代码字（code word），指定相对于 <code>elem</code> 的插入位置。必须为以下之一：</p>
<ul>
<li><code>&quot;beforebegin&quot;</code> — 将 <code>html</code> 插入到 <code>elem</code> 前插入，</li>
<li><code>&quot;afterbegin&quot;</code> — 将 <code>html</code> 插入到 <code>elem</code> 开头，</li>
<li><code>&quot;beforeend&quot;</code> — 将 <code>html</code> 插入到 <code>elem</code> 末尾，</li>
<li><code>&quot;afterend&quot;</code> — 将 <code>html</code> 插入到 <code>elem</code> 后。</li>
</ul>
<p>第二个参数是 HTML 字符串，该字符串会被“作为 HTML” 插入。</p>
<p>例如：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  div.insertAdjacentHTML(<span class="hljs-string">&#x27;beforebegin&#x27;</span>, <span class="hljs-string">&#x27;&lt;p&gt;Hello&lt;/p&gt;&#x27;</span>);
  div.insertAdjacentHTML(<span class="hljs-string">&#x27;afterend&#x27;</span>, <span class="hljs-string">&#x27;&lt;p&gt;Bye&lt;/p&gt;&#x27;</span>);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>……将导致：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Bye<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre>
<p>这就是我们可以在页面上附加任意 HTML 的方式。</p>
<p>这是插入变体的示意图：</p>
<p><img src="insert-adjacent.svg" alt=""></p>
<p>我们很容易就会注意到这张图片和上一张图片的相似之处。插入点实际上是相同的，但此方法插入的是 HTML。</p>
<p>这个方法有两个兄弟：</p>
<ul>
<li><code>elem.insertAdjacentText(where, text)</code> — 语法一样，但是将 <code>text</code> 字符串“作为文本”插入而不是作为 HTML，</li>
<li><code>elem.insertAdjacentElement(where, elem)</code> — 语法一样，但是插入的是一个元素。</li>
</ul>
<p>它们的存在主要是为了使语法“统一”。实际上，大多数时候只使用 <code>insertAdjacentHTML</code>。因为对于元素和文本，我们有 <code>append/prepend/before/after</code> 方法 — 它们也可以用于插入节点/文本片段，但写起来更短。</p>
<p>所以，下面是显示一条消息的另一种变体：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
<span class="hljs-selector-class">.alert</span> {
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">15px</span>;
  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#d6e9c6</span>;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#3c763d</span>;
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#dff0d8</span>;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="handlebars"><span class="xml">
  document.body.insertAdjacentHTML(&quot;afterbegin&quot;, `<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;alert&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>Hi there!<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span> You&#x27;ve read an important message.
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>`);
</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h2 id="节点移除">节点移除</h2>
<p>想要移除一个节点，可以使用 <code>node.remove()</code>。</p>
<p>让我们的消息在一秒后消失：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
<span class="hljs-selector-class">.alert</span> {
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">15px</span>;
  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#d6e9c6</span>;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#3c763d</span>;
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#dff0d8</span>;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">let</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);
  div.className = <span class="hljs-string">&quot;alert&quot;</span>;
  div.innerHTML = <span class="hljs-string">&quot;&lt;strong&gt;Hi there!&lt;/strong&gt; You&#x27;ve read an important message.&quot;</span>;

  <span class="hljs-built_in">document</span>.body.append(div);
*!*
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> div.remove(), <span class="hljs-number">1000</span>);
*/!*
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>请注意：如果我们要将一个元素 <strong>移动</strong> 到另一个地方，则无需将其从原来的位置中删除。</p>
<p><strong>所有插入方法都会自动从旧位置删除该节点。</strong></p>
<p>例如，让我们进行元素交换：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;first&quot;</span>&gt;</span>First<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;second&quot;</span>&gt;</span>Second<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-comment">// 无需调用 remove</span>
  second.after(first); <span class="hljs-comment">// 获取 #second，并在其后面插入 #first</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h2 id="克隆节点：clonenode">克隆节点：cloneNode</h2>
<p>如何再插入一条类似的消息？</p>
<p>我们可以创建一个函数，并将代码放在其中。但是另一种方法是 <strong>克隆</strong> 现有的 <code>div</code>，并修改其中的文本（如果需要）。</p>
<p>当我们有一个很大的元素时，克隆的方式可能更快更简单。</p>
<p>调用 <code>elem.cloneNode(true)</code> 来创建元素的一个“深”克隆 — 具有所有特性（attribute）和子元素。如果我们调用 <code>elem.cloneNode(false)</code>，那克隆就不包括子元素。</p>
<p>一个拷贝消息的示例：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
<span class="hljs-selector-class">.alert</span> {
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">15px</span>;
  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#d6e9c6</span>;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#3c763d</span>;
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#dff0d8</span>;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;alert&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>Hi there!<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span> You&#x27;ve read an important message.
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
*!*
  <span class="hljs-keyword">let</span> div2 = div.cloneNode(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 克隆消息</span>
  div2.querySelector(<span class="hljs-string">&#x27;strong&#x27;</span>).innerHTML = <span class="hljs-string">&#x27;Bye there!&#x27;</span>; <span class="hljs-comment">// 修改克隆</span>

  div.after(div2); <span class="hljs-comment">// 在已有的 div 后显示克隆</span>
*/!*
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h2 id="documentfragment-document-fragment">DocumentFragment [#document-fragment]</h2>
<p><code>DocumentFragment</code> 是一个特殊的 DOM 节点，用作来传递节点列表的包装器（wrapper）。</p>
<p>我们可以向其附加其他节点，但是当我们将其插入某个位置时，则会插入其内容。</p>
<p>例如，下面这段代码中的 <code>getListContent</code> 会生成带有 <code>&lt;li&gt;</code> 列表项的片段，然后将其插入到 <code>&lt;ul&gt;</code> 中：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ul&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getListContent</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> fragment = <span class="hljs-keyword">new</span> DocumentFragment();

  <span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">3</span>; i++</span>)</span> {
    <span class="hljs-keyword">let</span> li = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;li&#x27;</span>);
    li.append(i);
    fragment.append(li);
  }

  <span class="hljs-keyword">return</span> fragment;
}

*!*
ul.append(getListContent()); <span class="hljs-comment">// (*)</span>
*/!*
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>请注意，在最后一行 <code>(*)</code> 我们附加了 <code>DocumentFragment</code>，但是它和 <code>ul</code> “融为一体（blends in）”了，所以最终的文档结构应该是：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre>
<p><code>DocumentFragment</code> 很少被显式使用。如果可以改为返回一个节点数组，那为什么还要附加到特殊类型的节点上呢？重写示例：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ul&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getListContent</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> result = [];

  <span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">3</span>; i++</span>)</span> {
    <span class="hljs-keyword">let</span> li = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;li&#x27;</span>);
    li.append(i);
    result.push(li);
  }

  <span class="hljs-keyword">return</span> result;
}

*!*
ul.append(...getListContent()); <span class="hljs-comment">// append + &quot;...&quot; operator = friends!</span>
*/!*
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>我们之所以提到 <code>DocumentFragment</code>，主要是因为它上面有一些概念，例如 <a href="info:template-element">template</a> 元素，我们将在以后讨论。</p>
<h2 id="老式的-insertremove-方法">老式的 insert/remove 方法</h2>
<p>[old]</p>
<p>由于历史原因，还存在“老式”的 DOM 操作方法。</p>
<p>这些方法来自真正的远古时代。如今，没有理由再使用它们了，因为诸如 <code>append</code>，<code>prepend</code>，<code>before</code>，<code>after</code>，<code>remove</code>，<code>replaceWith</code> 这些现代方法更加灵活。</p>
<p>我们在这儿列出这些方法的唯一原因是，你可能会在许多脚本中遇到它们。</p>
<p><code>parentElem.appendChild(node)</code>
: 将 <code>node</code> 附加为 <code>parentElem</code> 的最后一个子元素。</p>
<pre><code>下面这个示例在 `&lt;ol&gt;` 的末尾添加了一个新的 `&lt;li&gt;`：

```html run height=100
&lt;ol id=&quot;list&quot;&gt;
  &lt;li&gt;0&lt;/li&gt;
  &lt;li&gt;1&lt;/li&gt;
  &lt;li&gt;2&lt;/li&gt;
&lt;/ol&gt;

&lt;script&gt;
  let newLi = document.createElement(&#x27;li&#x27;);
  newLi.innerHTML = &#x27;Hello, world!&#x27;;

  list.appendChild(newLi);
&lt;/script&gt;
```</code></pre>
<p><code>parentElem.insertBefore(node, nextSibling)</code>
: 在 <code>parentElem</code> 的 <code>nextSibling</code> 前插入 <code>node</code>。</p>
<pre><code>下面这段代码在第二个 `&lt;li&gt;` 前插入了一个新的列表项：

```html run height=100
&lt;ol id=&quot;list&quot;&gt;
  &lt;li&gt;0&lt;/li&gt;
  &lt;li&gt;1&lt;/li&gt;
  &lt;li&gt;2&lt;/li&gt;
&lt;/ol&gt;
&lt;script&gt;
  let newLi = document.createElement(&#x27;li&#x27;);
  newLi.innerHTML = &#x27;Hello, world!&#x27;;

*!*
  list.insertBefore(newLi, list.children[1]);
*/!*
&lt;/script&gt;
```
如果要将 `newLi` 插入为第一个元素，我们可以这样做：

```js
list.insertBefore(newLi, list.firstChild);
```</code></pre>
<p><code>parentElem.replaceChild(node, oldChild)</code>
: 将 <code>parentElem</code> 的后代中的 <code>oldChild</code> 替换为 <code>node</code>。</p>
<p><code>parentElem.removeChild(node)</code>
: 从 <code>parentElem</code> 中删除 <code>node</code>（假设 <code>node</code> 为 <code>parentElem</code> 的后代）。</p>
<pre><code>下面这个示例从 `&lt;ol&gt;` 中删除了 `&lt;li&gt;`：

```html run height=100
&lt;ol id=&quot;list&quot;&gt;
  &lt;li&gt;0&lt;/li&gt;
  &lt;li&gt;1&lt;/li&gt;
  &lt;li&gt;2&lt;/li&gt;
&lt;/ol&gt;

&lt;script&gt;
  let li = list.firstElementChild;
  list.removeChild(li);
&lt;/script&gt;
```</code></pre>
<p>所有这些方法都会返回插入/删除的节点。换句话说，<code>parentElem.appendChild(node)</code> 返回 <code>node</code>。但是通常我们不会使用返沪值，我们只是使用对应的方法。</p>
<h2 id="聊一聊-documentwrite">聊一聊 &quot;document.write&quot;</h2>
<p>还有一个非常古老的向网页添加内容的方法：<code>document.write</code>。</p>
<p>语法如下：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Somewhere in the page...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
*!*
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&#x27;&lt;b&gt;Hello from JS&lt;/b&gt;&#x27;</span>);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
*/!*
<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>The end<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre>
<p>调用 <code>document.write(html)</code> 意味着将 <code>html</code> “就地马上”写入页面。<code>html</code> 字符串可以是动态生成的，所以它很灵活。我们可以使用 JavaScript 创建一个完整的页面并对其进行写入。</p>
<p>这个方法来自于没有 DOM，没有标准的上古时期……。但这个方法依被保留了下来，因为还有脚本在使用它。</p>
<p>由于以下重要的限制，在现代脚本中我们很少看到它：</p>
<p><strong><code>document.write</code> 调用只在页面加载时工作。</strong></p>
<p>如果我们稍后调用它，则现有文档内容将被擦除。</p>
<p>例如：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>After one second the contents of this page will be replaced...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
*!*
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-comment">// 1 秒后调用 document.write</span>
  <span class="hljs-comment">// 这时页面已经加载完成，所以它会擦除现有内容</span>
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&#x27;&lt;b&gt;...By this.&lt;/b&gt;&#x27;</span>), <span class="hljs-number">1000</span>);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
*/!*</code></pre>
<p>因此，在某种程度上讲，它在“加载完成”阶段是不可用的，这与我们上面介绍的其他 DOM 方法不同。</p>
<p>这是它的缺陷。</p>
<p>还有一个好处。从技术上讲，当在浏览器正在读取（“解析”）传入的 HTML 时调用 <code>document.write</code> 方法来写入一些东西，浏览器会像它本来就在 HTML 文本中那样使用它。</p>
<p>所以它运行起来出奇的快，因为它 <strong>不涉及 DOM 修改</strong>。它直接写入到页面文本中，而此时 DOM 尚未构建。</p>
<p>因此，如果我们需要向 HTML 动态地添加大量文本，并且我们正处于页面加载阶段，并且速度很重要，那么它可能会有帮助。但实际上，这些要求很少同时出现。我们可以在脚本中看到此方法，通常是因为这些脚本很旧。</p>
<h2 id="总结">总结</h2>
<ul>
<li><p>创建新节点的方法：</p>
<ul>
<li><code>document.createElement(tag)</code> — 用给定的标签创建一个元素节点，</li>
<li><code>document.createTextNode(value)</code> — 创建一个文本节点（很少使用），</li>
<li><code>elem.cloneNode(deep)</code> — 克隆元素，如果 <code>deep==true</code> 则与其后代一起克隆。</li>
</ul>
</li>
<li><p>插入和移除节点的方法：</p>
<ul>
<li><p><code>node.append(...nodes or strings)</code> — 在 <code>node</code> 末尾插入，</p>
</li>
<li><p><code>node.prepend(...nodes or strings)</code> — 在 <code>node</code> 开头插入，</p>
</li>
<li><p><code>node.before(...nodes or strings)</code> — 在 <code>node</code> 之前插入，</p>
</li>
<li><p><code>node.after(...nodes or strings)</code> — 在 <code>node</code> 之后插入，</p>
</li>
<li><p><code>node.replaceWith(...nodes or strings)</code> — 替换 <code>node</code>。</p>
</li>
<li><p><code>node.remove()</code> — 移除 <code>node</code>。</p>
<p>文本字符串被“作为文本”插入。</p>
</li>
</ul>
</li>
<li><p>这里还有“旧式”的方法：</p>
<ul>
<li><p><code>parent.appendChild(node)</code></p>
</li>
<li><p><code>parent.insertBefore(node, nextSibling)</code></p>
</li>
<li><p><code>parent.removeChild(node)</code></p>
</li>
<li><p><code>parent.replaceChild(newElem, node)</code></p>
<p>这些方法都返回 <code>node</code>。</p>
</li>
</ul>
</li>
<li><p>在 <code>html</code> 中给定一些 HTML，<code>elem.insertAdjacentHTML(where, html)</code> 会根据 <code>where</code> 的值来插入它：</p>
<ul>
<li><code>&quot;beforebegin&quot;</code> — 将 <code>html</code> 插入到 <code>elem</code> 前面，</li>
<li><code>&quot;afterbegin&quot;</code> — 将 <code>html</code> 插入到 <code>elem</code> 的开头，</li>
<li><code>&quot;beforeend&quot;</code> — 将 <code>html</code> 插入到 <code>elem</code> 的末尾，</li>
<li><code>&quot;afterend&quot;</code> — 将 <code>html</code> 插入到 <code>elem</code> 后面。</li>
</ul>
</li>
</ul>
<p>另外，还有类似的方法，<code>elem.insertAdjacentText</code> 和 <code>elem.insertAdjacentElement</code>，它们会插入文本字符串和元素，但很少使用。</p>
<ul>
<li><p>要在页面加载完成之前将 HTML 附加到页面：</p>
<ul>
<li><p><code>document.write(html)</code></p>
<p>页面加载完成后，这样的调用将会擦除文档。多见于旧脚本。</p>
</li>
</ul>
</li>
</ul>

      </fieldset>
      
      <fieldset id='_j2e7rD'>
      <legend>solution</legend>
      
      </fieldset>
      
      <fieldset id='_qZdZaL'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="创建一个通知">创建一个通知</h1>
<p>编写一个函数 <code>showNotification(options)</code>：该函数创建一个带有给定内容的通知 <code>&lt;div class=&quot;notification&quot;&gt;</code>。该通知应该在 1.5 秒后自动消失。</p>
<p>参数：</p>
<pre><code class="language-js"><span class="hljs-comment">// 在窗口的右上角附近显示一个带有文本 &quot;Hello&quot; 的元素</span>
showNotification({
  <span class="hljs-attr">top</span>: <span class="hljs-number">10</span>, <span class="hljs-comment">// 距窗口顶部 10px（默认为 0px）</span>
  <span class="hljs-attr">right</span>: <span class="hljs-number">10</span>, <span class="hljs-comment">// 距窗口右边缘 10px（默认为 0px）</span>
  <span class="hljs-attr">html</span>: <span class="hljs-string">&quot;Hello!&quot;</span>, <span class="hljs-comment">// 通知中的 HTML</span>
  <span class="hljs-attr">className</span>: <span class="hljs-string">&quot;welcome&quot;</span> <span class="hljs-comment">// div 的附加类（可选）</span>
});</code></pre>
<p>[demo src=&quot;solution&quot;]</p>
<p>使用 CSS 定位在给定的 top/right 坐标处显示元素。源文档已经提供了必要的样式。</p>

      </fieldset>
      
      <fieldset id='_dkx8hn'>
      <legend>article</legend>
      <h1 id="样式和类">样式和类</h1>
<p>在我们讨论 JavaScript 处理样式和类的方法之前 — 有一个重要的规则。希望它足够明显，但是我们仍然必须提到它。</p>
<p>通常有两种设置元素样式的方式：</p>
<ol>
<li>在 CSS 中创建一个类，并添加它：<code>&lt;div class=&quot;...&quot;&gt;</code></li>
<li>将属性直接写入 <code>style</code>：<code>&lt;div style=&quot;...&quot;&gt;</code>。</li>
</ol>
<p>JavaScript 既可以修改类，也可以修改 <code>style</code> 属性。</p>
<p>相较于将样式写入 <code>style</code> 属性，我们应该首选通过 CSS 类的方式来添加样式。仅当类“无法处理”时，才应选择使用 <code>style</code> 属性的方式。</p>
<p>例如，如果我们动态地计算元素的坐标，并希望通过 JavaScript 来设置它们，那么使用 <code>style</code> 是可以接受的，如下所示：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> top = <span class="hljs-comment">/* 复杂的计算 */</span>;
<span class="hljs-keyword">let</span> left = <span class="hljs-comment">/* 复杂的计算 */</span>;

elem.style.left = left; <span class="hljs-comment">// 例如 &#x27;123px&#x27;，在运行时计算出的</span>
elem.style.top = top; <span class="hljs-comment">// 例如 &#x27;456px&#x27;</span></code></pre>
<p>对于其他情况，例如将文本设为红色，添加一个背景图标 — 可以在 CSS 中对这些样式进行描述，然后添加类（JavaScript 可以做到）。这样更灵活，更易于支持。</p>
<h2 id="classname-和-classlist">className 和 classList</h2>
<p>更改类是脚本中最常见的操作之一。</p>
<p>在很旧以前，JavaScript 中有一个限制：像 <code>&quot;class&quot;</code> 这样的保留字不能用作对象的属性。这一限制现在已经不存在了，但当时就不能存在像 <code>elem.class</code> 这样的 <code>&quot;class&quot;</code> 属性。</p>
<p>因此，对于类，引入了看起来类似的属性 <code>&quot;className&quot;</code>：<code>elem.className</code> 对应于 <code>&quot;class&quot;</code> 特性（attribute）。</p>
<p>例如：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main page&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    alert(<span class="hljs-built_in">document</span>.body.className); <span class="hljs-comment">// main page</span>
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>如果我们对 <code>elem.className</code> 进行赋值，它将替换类中的整个字符串。有时，这正是我们所需要的，但通常我们希望添加/删除单个类。</p>
<p>这里还有另一个属性：<code>elem.classList</code>。</p>
<p><code>elem.classList</code> 是一个特殊的对象，它具有 <code>add/remove/toggle</code> 单个类的方法。</p>
<p>例如：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main page&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
*!*
    <span class="hljs-comment">// 添加一个 class</span>
    <span class="hljs-built_in">document</span>.body.classList.add(<span class="hljs-string">&#x27;article&#x27;</span>);
*/!*

    alert(<span class="hljs-built_in">document</span>.body.className); <span class="hljs-comment">// main page article</span>
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>因此，我们既可以使用 <code>className</code> 对完整的类字符串进行操作，也可以使用使用 <code>classList</code> 对单个类进行操作。我们选择什么取决于我们的需求。</p>
<p><code>classList</code> 的方法：</p>
<ul>
<li><code>elem.classList.add/remove(class)</code> — 添加/移除类。</li>
<li><code>elem.classList.toggle(class)</code> — 如果类不存在就添加类，存在就移除它。</li>
<li><code>elem.classList.contains(class)</code> — 检查给定类，返回 <code>true/false</code>。</li>
</ul>
<p>此外，<code>classList</code> 是可迭代的，因此，我们可以像下面这样列出所有类：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main page&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> name <span class="hljs-keyword">of</span> <span class="hljs-built_in">document</span>.body.classList) {
      alert(name); <span class="hljs-comment">// main，然后是 page</span>
    }
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<h2 id="元素样式">元素样式</h2>
<p><code>elem.style</code> 属性是一个对象，它对应于 <code>&quot;style&quot;</code> 特性（attribute）中所写的内容。<code>elem.style.width=&quot;100px&quot;</code> 的效果等价于我们在 <code>style</code> 特性中有一个 <code>width:100px</code> 字符串。</p>
<p>对于多词（multi-word）属性，使用驼峰式 camelCase：</p>
<pre><code class="language-js">background-<span class="hljs-function"><span class="hljs-params">color</span>  =&gt;</span> elem.style.backgroundColor
z-<span class="hljs-function"><span class="hljs-params">index</span>           =&gt;</span> elem.style.zIndex
border-left-<span class="hljs-function"><span class="hljs-params">width</span> =&gt;</span> elem.style.borderLeftWidth</code></pre>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-built_in">document</span>.body.style.backgroundColor = prompt(<span class="hljs-string">&#x27;background color?&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>);</code></pre>
<pre><code class="language-smart">像 `-moz-border-radius` 和 `-webkit-border-radius` 这样的浏览器前缀属性，也遵循同样的规则：连字符 `-` 表示大写。

例如：

```js
button.style.MozBorderRadius = &#x27;5px&#x27;;
button.style.WebkitBorderRadius = &#x27;5px&#x27;;
```</code></pre>
<h2 id="重置样式属性">重置样式属性</h2>
<p>有时我们想要分配一个样式属性，稍后移除它。</p>
<p>例如，为了隐藏一个元素，我们可以设置 <code>elem.style.display = &quot;none&quot;</code>。</p>
<p>然后，稍后我们可能想要移除 <code>style.display</code>，就像它没有被设置一样。这里不应该使用 <code>delete elem.style.display</code>，而应该使用 <code>elem.style.display = &quot;&quot;</code> 将其赋值为空。</p>
<pre><code class="language-js"><span class="hljs-comment">// 如果我们运行这段代码，&lt;body&gt; 将会闪烁</span>
<span class="hljs-built_in">document</span>.body.style.display = <span class="hljs-string">&quot;none&quot;</span>; <span class="hljs-comment">// 隐藏</span>

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">document</span>.body.style.display = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">1000</span>); <span class="hljs-comment">// 恢复正常</span></code></pre>
<p>如果我们将 <code>display</code> 设置为空字符串，那么浏览器通常会应用 CSS 类以及内置样式，就好像根本没有这样的 <code>style</code> 属性一样。</p>
<p>````smart header=&quot;用 <code>style.cssText</code> 进行完全的重写&quot;
通常，我们使用 <code>style.*</code> 来对各个样式属性进行赋值。我们不能像这样的 <code>div.style=&quot;color: red; width: 100px&quot;</code> 设置完整的属性，因为 <code>div.style</code> 是一个对象，并且它是只读的。</p>
<p>想要以字符串的形式设置完整的样式，可以使用特殊属性 <code>style.cssText</code>：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div&quot;</span>&gt;</span>Button<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-comment">// 我们可以在这里设置特殊的样式标记，例如 &quot;important&quot;</span>
  div.style.cssText=<span class="hljs-string">`color: red !important;
    background-color: yellow;
    width: 100px;
    text-align: center;
  `</span>;

  alert(div.style.cssText);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>我们很少使用这个属性，因为这样的赋值会删除所有现有样式：它不是进行添加，而是替换它们。有时可能会删除所需的内容。但是，当我们知道我们不会删除现有样式时，可以安全地将其用于新元素。</p>
<p>可以通过设置一个特性（attribute）来实现同样的效果：<code>div.setAttribute(&#39;style&#39;, &#39;color: red...&#39;)</code>。</p>
<pre><code>
## 注意单位

不要忘记将 CSS 单位添加到值上。

例如，我们不应该将 `elem.style.top` 设置为 `10`，而应将其设置为 `10px`。否则设置会无效：

```html run height=100
&lt;body&gt;
  &lt;script&gt;
  *!*
    // 无效！
    document.body.style.margin = 20;
    alert(document.body.style.margin); // &#x27;&#x27;（空字符串，赋值被忽略了）
  */!*

    // 现在添加了 CSS 单位（px）— 生效了
    document.body.style.margin = &#x27;20px&#x27;;
    alert(document.body.style.margin); // 20px

    alert(document.body.style.marginTop); // 20px
    alert(document.body.style.marginLeft); // 20px
  &lt;/script&gt;
&lt;/body&gt;
```

请注意：浏览器在最后几行代码中对属性 `style.margin` 进行了“解包”，并从中推断出 `style.marginLeft` 和 `style.marginTop`。

## 计算样式：getComputedStyle

修改样式很简单。但是如何 **读取** 样式呢？

例如，我们想知道元素的 size，margins 和 color。应该怎么获取？

**`style` 属性仅对 `&quot;style&quot;` 特性（attribute）值起作用，而没有任何 CSS 级联（cascade）。**

因此我们无法使用 `elem.style` 读取来自 CSS 类的任何内容。

例如，这里的 `style` 看不到 margin：

```html run height=60 no-beautify
&lt;head&gt;
  &lt;style&gt; body { color: red; margin: 5px } &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

  The red text
  &lt;script&gt;
*!*
    alert(document.body.style.color); // 空的
    alert(document.body.style.marginTop); // 空的
*/!*
  &lt;/script&gt;
&lt;/body&gt;
```

……但如果我们需要，例如，将 margin 增加 20px 呢？那么我们需要 margin 的当前值。

对于这个需求，这里有另一种方法：`getComputedStyle`。

语法如下：

```js
getComputedStyle(element, [pseudo])
```

element
: 需要被读取样式值的元素。

pseudo
: 伪元素（如果需要），例如 `::before`。空字符串或无参数则意味着元素本身。

结果是一个具有样式属性的对象，像 `elem.style`，但现在对于所有的 CSS 类来说都是如此。

例如：

```html run height=100
&lt;head&gt;
  &lt;style&gt; body { color: red; margin: 5px } &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

  &lt;script&gt;
    let computedStyle = getComputedStyle(document.body);

    // 现在我们可以读取它的 margin 和 color 了

    alert( computedStyle.marginTop ); // 5px
    alert( computedStyle.color ); // rgb(255, 0, 0)
  &lt;/script&gt;

&lt;/body&gt;
```

```smart header=&quot;计算值和解析值&quot;
在 [CSS](https://drafts.csswg.org/cssom/#resolved-values) 中有两个概念：

1. **计算 (computed)** 样式值是所有 CSS 规则和 CSS 继承都应用后的值，这是 CSS 级联（cascade）的结果。它看起来像 `height:1em` 或 `font-size:125%`。
2. **解析 (resolved)** 样式值是最终应用于元素的样式值值。诸如 `1em` 或 `125%` 这样的值是相对的。浏览器将使用计算（computed）值，并使所有单位均为固定的，且为绝对单位，例如：`height:20px` 或 `font-size:16px`。对于几何属性，解析（resolved）值可能具有浮点，例如：`width:50.5px`。

很久以前，创建了 `getComputedStyle` 来获取计算（computed）值，但事实证明，解析（resolved）值要方便得多，标准也因此发生了变化。

所以，现在 `getComputedStyle` 实际上返回的是属性的解析值（resolved）。
```

````warn header=&quot;`getComputedStyle` 需要完整的属性名&quot;
我们应该总是使用我们想要的确切的属性，例如 `paddingLeft`、`marginTop` 或 `borderTopWidth`。否则，就不能保证正确的结果。

例如，如果有 `paddingLeft/paddingTop` 属性，那么对于 `getComputedStyle(elem).padding`，我们会得到什么？什么都没有，或者是从已知的 padding 中“生成”的值？这里没有标准的规则。

还有其他不一致的地方。例如，在下面这个例子中，某些浏览器（Chrome）会显示 `10px`，而某些浏览器（Firefox）则没有：

```html run
&lt;style&gt;
  body {
    margin: 10px;
  }
&lt;/style&gt;
&lt;script&gt;
  let style = getComputedStyle(document.body);
  alert(style.margin); // 在 Firefox 中是空字符串
&lt;/script&gt;
```</code></pre>
<p>```smart header=&quot;应用于 <code>:visited</code> 链接的样式被隐藏了！&quot;
可以使用 CSS 伪类 <code>:visited</code> 对被访问过的链接进行着色。</p>
<p>但 <code>getComputedStyle</code> 没有给出访问该颜色的方式，因为否则，任意页面都可以通过在页面上创建它，并通过检查样式来确定用户是否访问了某链接。</p>
<p>JavaScript 看不到 <code>:visited</code> 所应用的样式。此外，CSS 中也有一个限制，即禁止在 <code>:visited</code> 中应用更改几何形状的样式。这是为了确保一个不好的页面无法测试链接是否被访问，进而窥探隐私。</p>
<pre><code>
## 总结

要管理 class，有两个 DOM 属性：

- `className` — 字符串值，可以很好地管理整个类的集合。
- `classList` — 具有 `add/remove/toggle/contains` 方法的对象，可以很好地支持单个类。

要改变样式：

- `style` 属性是具有驼峰（camelCased）样式的对象。对其进行读取和修改与修改 `&quot;style&quot;` 特性（attribute）中的各个属性具有相同的效果。要了解如何应用 `important` 和其他特殊内容 — 在 [MDN](mdn:api/CSSStyleDeclaration) 中有一个方法列表。

- `style.cssText` 属性对应于整个 `&quot;style&quot;` 特性（attribute），即完整的样式字符串。

要读取已解析的（resolved）样式（对于所有类，在应用所有 CSS 并计算最终值之后）：

- `getComputedStyle(elem, [pseudo])` 返回与 `style` 对象类似的，且包含了所有类的对象。只读。</code></pre>

      </fieldset>
      
      <fieldset id='_82818F'>
      <legend>solution</legend>
      <p>解决方案：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> scrollBottom = elem.scrollHeight - elem.scrollTop - elem.clientHeight;</code></pre>
<p>换句话说：（完全高度）减去（已滚出顶部的高度）减去（可见部分的高度）— 得到的结果就是滚动出来的底部的部分。</p>

      </fieldset>
      
      <fieldset id='_BvaTeh'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="相对于底部滚动了多少？">相对于底部滚动了多少？</h1>
<p><code>elem.scrollTop</code> 属性是从顶部滚动出来的部分的大小。如何获得底部滚动的大小（我们称其为 <code>scrollBottom</code>）？</p>
<p>编写适用于任意 <code>elem</code> 的代码。</p>
<p>P.S. 请检查你的代码：如果没有滚动，或元素底部已经完全滚动完成，那么它应该返回 <code>0</code>。</p>

      </fieldset>
      
      <fieldset id='_lGeBCT'>
      <legend>solution</legend>
      <p>为了获得滚动条的宽度，我们可以创建一个带有滚动条的元素，但是没有边框（border）和内边距（padding）。</p>
<p>然后，它的全宽度 <code>offsetWidth</code> 和内部内容宽度 <code>clientWidth</code> 之间的差值就是滚动条的宽度：</p>
<pre><code class="language-js"><span class="hljs-comment">// 创建一个包含滚动条的 div</span>
<span class="hljs-keyword">let</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);

div.style.overflowY = <span class="hljs-string">&#x27;scroll&#x27;</span>;
div.style.width = <span class="hljs-string">&#x27;50px&#x27;</span>;
div.style.height = <span class="hljs-string">&#x27;50px&#x27;</span>;

<span class="hljs-comment">// 必须将其放入文档（document）中，否则其大小将为 0</span>
<span class="hljs-built_in">document</span>.body.append(div);
<span class="hljs-keyword">let</span> scrollWidth = div.offsetWidth - div.clientWidth;

div.remove();

alert(scrollWidth);</code></pre>

      </fieldset>
      
      <fieldset id='_y4J9Jk'>
      <legend>task</legend>
      <p>importance: 3</p>
<hr>
<h1 id="滚动条的宽度是多少？">滚动条的宽度是多少？</h1>
<p>编写代码，返回标准滚动条宽度。</p>
<p>对于 Windows，它通常在 <code>12px</code> 和 <code>20px</code> 之间变化。如果浏览器没有为其保留任何空间（滚动条以半透明的形式处于文本上面，也是可能发生的），那么它可能是 <code>0px</code>。</p>
<p>P.S. 该代码应适用于任何 HTML 文档，而不依赖于其内容。</p>

      </fieldset>
      
      <fieldset id='_SP9ynq'>
      <legend>solution</legend>
      <p>球具有 <code>position:absolute</code>。这意味着它的 <code>left/top</code> 坐标是从最近的具有定位属性的元素开始测量的，这个元素即 <code>#field</code>（因为它有 <code>position:relative</code>）。</p>
<p>坐标从场（field）的左上角内侧开始：</p>
<p><img src="field.svg" alt=""></p>
<p>内部的场（field）的 width/height 是 <code>clientWidth/clientHeight</code>。所以场（field）的中心坐标为 <code>(clientWidth/2, clientHeight/2)</code>。</p>
<p>……但是，如果我们将 <code>ball.style.left/top</code> 设置为这种值，那么在中心的会是球的左上边缘，而不是整个球：</p>
<pre><code class="language-js">ball.style.left = <span class="hljs-built_in">Math</span>.round(field.clientWidth / <span class="hljs-number">2</span>) + <span class="hljs-string">&#x27;px&#x27;</span>;
ball.style.top = <span class="hljs-built_in">Math</span>.round(field.clientHeight / <span class="hljs-number">2</span>) + <span class="hljs-string">&#x27;px&#x27;</span>;</code></pre>
<p>这是它将显示出来的效果：</p>
<p>[iframe height=180 src=&quot;ball-half&quot;]</p>
<p>为了使球的中心与场（field）的中心重合，我们应该把球向左移动球宽度的一半，并向上移动球高度的一半：</p>
<pre><code class="language-js">ball.style.left = <span class="hljs-built_in">Math</span>.round(field.clientWidth / <span class="hljs-number">2</span> - ball.offsetWidth / <span class="hljs-number">2</span>) + <span class="hljs-string">&#x27;px&#x27;</span>;
ball.style.top = <span class="hljs-built_in">Math</span>.round(field.clientHeight / <span class="hljs-number">2</span> - ball.offsetHeight / <span class="hljs-number">2</span>) + <span class="hljs-string">&#x27;px&#x27;</span>;</code></pre>
<p>现在，球终于居中了。</p>
<pre><code class="language-warn">
当 `&lt;img&gt;` 没有 width/height 时，代码将无法可靠地工作：

```html
&lt;img src=&quot;ball.png&quot; id=&quot;ball&quot;&gt;
```</code></pre>
<p>当浏览器不知道图片的 width/height（通过标签 attribute 或 CSS）时，它会假定它们等于 <code>0</code>，直到图片加载完成。</p>
<p>因此，在图片加载完成之前，<code>ball.offsetWidth</code> 的值为 <code>0</code>。这会导致上面的代码中会有错误的坐标。</p>
<p>在第一次加载完成后，浏览器通常会缓存该图片，并在下一次加载时，浏览器会立即拥有该图片的大小。但是在第一次加载时，<code>ball.offsetWidth</code> 的值为 <code>0</code>。</p>
<p>我们应该通过在 <code>&lt;img&gt;</code> 中添加 <code>width/height</code> 来解决这个问题：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;ball.png&quot;</span> *!*<span class="hljs-attr">width</span>=<span class="hljs-string">&quot;40&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;40&quot;</span>*/!* <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ball&quot;</span>&gt;</span></code></pre>
<p>……或者在 CSS 中提供大小：</p>
<pre><code class="language-css"><span class="hljs-selector-id">#ball</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">40px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">40px</span>;
}</code></pre>

      </fieldset>
      
      <fieldset id='_zQZwUV'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="将小球置于区域（field）中心">将小球置于区域（field）中心</h1>
<p>源文件的效果如下：</p>
<p>[iframe src=&quot;source&quot; edit link height=180]</p>
<p>区域（field）的中心坐标是多少？</p>
<p>计算它们，并将小球置于绿色的区域（field）中心：</p>
<p>[iframe src=&quot;solution&quot; height=180]</p>
<ul>
<li>该元素应该通过 JavaScript 移动，而不是 CSS。</li>
<li>该代码应该适用于任何大小的球（<code>10</code>、<code>20</code>、<code>30</code> 像素）以及任意大小的区域（field），而不应该绑定到给定值。</li>
</ul>
<p>P.S. 当然了，置于中心的操作通过 CSS 也可以完成，但是这里我们需要通过 JavaScript 完成。此外，当必须使用 JavaScript 时，我们可能会遇到其他话题以及更加复杂的情况，这里我们只是做一个“热身”。</p>

      </fieldset>
      
      <fieldset id='_OG2cli'>
      <legend>solution</legend>
      <p>不同点：</p>
<ol>
<li><code>clientWidth</code> 值是数值，而 <code>getComputedStyle(elem).width</code> 返回一个以 <code>px</code> 作为后缀的字符串。</li>
<li><code>getComputedStyle</code> 可能会返回非数值的 width，例如内联（inline）元素的 <code>&quot;auto&quot;</code>。</li>
<li><code>clientWidth</code> 是元素的内部内容区域加上 padding，而 CSS width（具有标准的 <code>box-sizing</code>）是内部内容区域，<strong>不包括 padding</strong>。</li>
<li>如果有滚动条，并且浏览器为其保留了空间，那么某些浏览器会从 CSS width 中减去该空间（因为它不再可用于内容），而有些则不会这样做。<code>clientWidth</code> 属性总是相同的：如果为滚动条保留了空间，那么将减去滚动条的大小。</li>
</ol>

      </fieldset>
      
      <fieldset id='_DhPn8l'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="css-width-与-clientwidth-的不同点">CSS width 与 clientWidth 的不同点</h1>
<p><code>getComputedStyle(elem).width</code> 与 <code>elem.clientWidth</code> 之间有什么不同点？</p>
<p>指出至少三种不同点。当然越多越好。</p>

      </fieldset>
      
      <fieldset id='_KOi1Mw'>
      <legend>article</legend>
      <h1 id="元素大小和滚动">元素大小和滚动</h1>
<p>JavaScript 中有许多属性可让我们读取有关元素宽度、高度和其他几何特征的信息。</p>
<p>我们在 JavaScript 中移动或定位元素时，我们会经常需要它们。</p>
<h2 id="示例元素">示例元素</h2>
<p>作为演示属性的示例元素，我们将使用下面给出的元素：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span>
  ...Text...
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
  <span class="hljs-selector-id">#example</span> {
    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;
    <span class="hljs-attribute">border</span>: <span class="hljs-number">25px</span> solid <span class="hljs-number">#E8C48F</span>;
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;              
    <span class="hljs-attribute">overflow</span>: auto;             
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre>
<p>它有边框（border），内边距（padding）和滚动（scrolling）等全套功能。但没有外边距（margin），因为它们不是元素本身的一部分，并且它们没什么特殊的属性。</p>
<p>这个元素看起来就像这样：</p>
<p><img src="metric-css.svg" alt=""></p>
<p>你可以 <a href="sandbox:metric">在 sandbox 中打开这个文档</a>。</p>
<pre><code class="language-smart">上图演示了元素具有滚动条这种最复杂的情况。一些浏览器（并非全部）通过从内容（上面标记为 &quot;content width&quot;）中获取空间来为滚动条保留空间。

因此，如果没有滚动条，内容宽度将是 `300 px`，但是如果滚动条宽度是 `16px`（不同的设备和浏览器，滚动条的宽度可能有所不同），那么还剩下 `300 - 16 ＝ 284px`，我们应该考虑到这一点。这就是为什么本章的例子总是假设有滚动条。如果没有滚动条，一些计算会更简单。</code></pre>
<p>```smart header=&quot;文本可能会溢出到 <code>padding-bottom</code> 中&quot;
在我们的插图中的 padding 中通常显示为空，但是如果元素中有很多文本，并且溢出了，那么浏览器会在 <code>padding-bottom</code> 处显示“溢出”文本，这是正常现象。</p>
<pre><code>
## 几何

这是带有几何属性的整体图片：

![](metric-all.svg)

这些属性的值在技术上讲是数字，但这些数字其实是“像素（pixel）”，因此它们是像素测量值。

让我们从元素外部开始探索属性。

## offsetParent，offsetLeft/Top

这些属性很少使用，但它们仍然是“最外面”的几何属性，所以我们将从它们开始。

`offsetParent` 是最接近的祖先（ancestor），在浏览器渲染期间，它被用于计算坐标。

最近的祖先为下列之一：

1. CSS 定位的（`position` 为 `absolute`，`relative` 或 `fixed`），
2. 或 `&lt;td&gt;`，`&lt;th&gt;`，`&lt;table&gt;`，
3. 或 `&lt;body&gt;`。

属性 `offsetLeft/offsetTop` 提供相对于 `offsetParent` 左上角的 x/y 坐标。

在下面这个例子中，内部的 `&lt;div&gt;` 有 `&lt;main&gt;` 作为 `offsetParent`，并且 `offsetLeft/offsetTop` 让它从左上角位移（`180`）：

```html run height=10
&lt;main style=&quot;position: relative&quot; id=&quot;main&quot;&gt;
  &lt;article&gt;
    &lt;div id=&quot;example&quot; style=&quot;position: absolute; left: 180px; top: 180px&quot;&gt;...&lt;/div&gt;
  &lt;/article&gt;
&lt;/main&gt;
&lt;script&gt;
  alert(example.offsetParent.id); // main
  alert(example.offsetLeft); // 180（注意：这是一个数字，不是字符串 &quot;180px&quot;）
  alert(example.offsetTop); // 180
&lt;/script&gt;</code></pre>
<p><img src="metric-offset-parent.svg" alt=""></p>
<p>有以下几种情况下，<code>offsetParent</code> 的值为 <code>null</code>：</p>
<ol>
<li>对于未显示的元素（<code>display:none</code> 或者不在文档中）。</li>
<li>对于 <code>&lt;body&gt;</code> 与 <code>&lt;html&gt;</code>。</li>
<li>对于带有 <code>position:fixed</code> 的元素。</li>
</ol>
<h2 id="offsetwidthheight">offsetWidth/Height</h2>
<p>现在，让我们继续关注元素本身。</p>
<p>这两个属性是最简单的。它们提供了元素的“外部” width/height。或者，换句话说，它的完整大小（包括边框）。</p>
<p><img src="metric-offset-width-height.svg" alt=""></p>
<p>对于我们的示例元素：</p>
<ul>
<li><code>offsetWidth = 390</code> — 外部宽度（width），可以计算为内部 CSS-width（<code>300px</code>）加上 padding（<code>2 * 20px</code>）和 border（<code>2 * 25px</code>）。</li>
<li><code>offsetHeight = 290</code> — 外部高度（height）。</li>
</ul>
<pre><code class="language-smart">仅针对显示的元素计算几何属性。

如果一个元素（或其任何祖先）具有 `display:none` 或不在文档中，则所有几何属性均为零（或 `offsetParent` 为 `null`）。

例如，当我们创建了一个元素，但尚未将其插入文档中，或者它（或它的祖先）具有 `display:none` 时，`offsetParent` 为 `null`，并且 `offsetWidth` 和 `offsetHeight` 为 `0`。

我们可以用它来检查一个元素是否被隐藏，像这样：

```js
function isHidden(elem) {
  return !elem.offsetWidth &amp;&amp; !elem.offsetHeight;
}
```

请注意，对于屏幕上显示，但大小为零的元素（例如空的 `&lt;div&gt;`），它们的 `isHidden` 返回 `true`。</code></pre>
<h2 id="clienttopleft">clientTop/Left</h2>
<p>在元素内部，我们有边框（border）。</p>
<p>为了测量它们，可以使用 <code>clientTop</code> 和 <code>clientLeft</code>。</p>
<p>在我们的例子中：</p>
<ul>
<li><code>clientLeft = 25</code> — 左边框宽度</li>
<li><code>clientTop = 25</code> — 上边框宽度</li>
</ul>
<p><img src="metric-client-left-top.svg" alt=""></p>
<p>……但准确地说 — 这些属性不是边框的 width/height，而是内侧与外侧的相对坐标。</p>
<p>有什么区别？</p>
<p>当文档从右到左显示（操作系统为阿拉伯语或希伯来语）时，影响就显现出来了。此时滚动条不在右边，而是在左边，此时 <code>clientLeft</code> 则包含了滚动条的宽度。</p>
<p>在这种情况下，<code>clientLeft</code> 的值将不是 <code>25</code>，而是加上滚动条的宽度 <code>25 + 16 = 41</code>。</p>
<p>这是希伯来语的例子：</p>
<p><img src="metric-client-left-top-rtl.svg" alt=""></p>
<h2 id="clientwidthheight">clientWidth/Height</h2>
<p>这些属性提供了元素边框内区域的大小。</p>
<p>它们包括了 &quot;content width&quot; 和 &quot;padding&quot;，但不包括滚动条宽度（scrollbar）：</p>
<p><img src="metric-client-width-height.svg" alt=""></p>
<p>在上图中，我们首先考虑 <code>clientHeight</code>。</p>
<p>这里没有水平滚动条，所以它恰好是 border 内的总和：CSS-width <code>200px</code> 加上顶部和底部的 padding（<code>2 * 20px</code>），总计 <code>240px</code>。</p>
<p>现在 <code>clientWidth</code> — 这里的 &quot;content width&quot; 不是 <code>300px</code>，而是 <code>284px</code>，因为被滚动条占用了 <code>16px</code>。所以加起来就是 <code>284px</code> 加上左侧和右侧的 padding，总计 <code>324px</code>。</p>
<p><strong>如果这里没有 padding，那么 <code>clientWidth/Height</code> 代表的就是内容区域，即 border 和 scrollbar（如果有）内的区域。</strong></p>
<p><img src="metric-client-width-nopadding.svg" alt=""></p>
<p>因此，当没有 padding 时，我们可以使用 <code>clientWidth/clientHeight</code> 来获取内容区域的大小。</p>
<h2 id="scrollwidthheight">scrollWidth/Height</h2>
<p>这些属性就像 <code>clientWidth/clientHeight</code>，但它们还包括滚动出（隐藏）的部分：</p>
<p><img src="metric-scroll-width-height.svg" alt=""></p>
<p>在上图中：</p>
<ul>
<li><code>scrollHeight = 723</code> — 是内容区域的完整内部高度，包括滚动出的部分。</li>
<li><code>scrollWidth = 324</code> — 是完整的内部宽度，这里我们没有水平滚动，因此它等于 <code>clientWidth</code>。</li>
</ul>
<p>我们可以使用这些属性将元素展开（expand）到整个 width/height。</p>
<p>像这样：</p>
<pre><code class="language-js"><span class="hljs-comment">// 将元素展开（expand）到完整的内容高度</span>
element.style.height = <span class="hljs-string">`<span class="hljs-subst">${element.scrollHeight}</span>px`</span>;</code></pre>
<pre><code class="language-online">点击按钮展开元素：

&lt;div id=&quot;element&quot; style=&quot;width:300px;height:200px; padding: 0;overflow: auto; border:1px solid black;&quot;&gt;text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text&lt;/div&gt;

&lt;button style=&quot;padding:0&quot; onclick=&quot;element.style.height = `${element.scrollHeight}px`&quot;&gt;element.style.height = `${element.scrollHeight}px`&lt;/button&gt;</code></pre>
<h2 id="scrollleftscrolltop">scrollLeft/scrollTop</h2>
<p>属性 <code>scrollLeft/scrollTop</code> 是元素的隐藏、滚动部分的 width/height。</p>
<p>在下图中，我们可以看到带有垂直滚动块的 <code>scrollHeight</code> 和 <code>scrollTop</code>。</p>
<p><img src="metric-scroll-top.svg" alt=""></p>
<p>换句话说，<code>scrollTop</code> 就是“已经滚动了多少”。</p>
<p>````smart header=&quot;<code>scrollLeft/scrollTop</code> 是可修改的&quot;
大多数几何属性是只读的，但是 <code>scrollLeft/scrollTop</code> 是可修改的，并且浏览器会滚动该元素。</p>
<pre><code class="language-online">如果你点击下面的元素，则会执行代码 `elem.scrollTop += 10`。这使得元素内容向下滚动 `10px`。

&lt;div onclick=&quot;this.scrollTop+=10&quot; style=&quot;cursor:pointer;border:1px solid black;width:100px;height:80px;overflow:auto&quot;&gt;Click&lt;br&gt;Me&lt;br&gt;1&lt;br&gt;2&lt;br&gt;3&lt;br&gt;4&lt;br&gt;5&lt;br&gt;6&lt;br&gt;7&lt;br&gt;8&lt;br&gt;9&lt;/div&gt;</code></pre>
<p>将 <code>scrollTop</code> 设置为 <code>0</code> 或一个大的值，例如 <code>1e9</code>，将会使元素滚动到顶部/底部。</p>
<pre><code>
## 不要从 CSS 中获取 width/height

我们刚刚介绍了 DOM 元素的几何属性，它们可用于获得宽度、高度和计算距离。

但是，正如我们在 &lt;info:styles-and-classes&gt; 一章所知道的那样，我们可以使用 `getComputedStyle` 来读取 CSS-width 和 height。

那为什么不像这样用 `getComputedStyle` 读取元素的 width 呢？

```js run
let elem = document.body;

alert( getComputedStyle(elem).width ); // 显示 elem 的 CSS width
```

为什么我们应该使用几何属性呢？这里有两个原因：

1. 首先，CSS `width/height` 取决于另一个属性：`box-sizing`，它定义了“什么是” CSS 宽度和高度。出于 CSS 的目的而对 `box-sizing` 进行的更改可能会破坏此类 JavaScript 操作。
2. 其次，CSS 的 `width/height` 可能是 `auto`，例如内联（inline）元素：

    ```html run
    &lt;span id=&quot;elem&quot;&gt;Hello!&lt;/span&gt;

    &lt;script&gt;
    *!*
      alert( getComputedStyle(elem).width ); // auto
    */!*
    &lt;/script&gt;
    ```

    从 CSS 的观点来看，`width:auto` 是完全正常的，但在 JavaScript 中，我们需要一个确切的 `px` 大小，以便我们在计算中使用它。因此，这里的 CSS 宽度没什么用。

还有另一个原因：滚动条。有时，在没有滚动条的情况下代码工作正常，当出现滚动条时，代码就出现了 bug，因为在某些浏览器中，滚动条会占用内容的空间。因此，可用于内容的实际宽度小于 CSS 宽度。而 `clientWidth/clientHeight` 则会考虑到这一点。

……但是，使用 `getComputedStyle(elem).width` 时，情况就不同了。某些浏览器（例如 Chrome）返回的是实际内部宽度减去滚动条宽度，而某些浏览器（例如 Firefox）返回的是 CSS 宽度（忽略了滚动条）。这种跨浏览器的差异是不使用 `getComputedStyle` 而依靠几何属性的原因。

```online
如果你的浏览器保留了滚动条的空间（大多数 Windows 中的浏览器），那么你可以在下面测试它。

[iframe src=&quot;cssWidthScroll&quot; link border=1]

带有文本的元素具有 `width:300px`。

在桌面 Windows 操作系统上，Firefox、Chrome、Edgy 都为滚动条保留了空间。但 Firefox 显示的是 `300px`，而 Chrome 和 Edgy 显示较少。这是因为 Firefox 返回 CSS 宽度，其他浏览器返回“真实”宽度。
```

请注意，所描述的差异只是关于从 JavaScript 读取的 `getComputedStyle(...).width`，而视觉上看，一切都是正确的。

## 总结

元素具有以下几何属性：

- `offsetParent` — 是最接近的 CSS 定位的祖先，或者是 `td`，`th`，`table`，`body`。
- `offsetLeft/offsetTop` — 是相对于 `offsetParent` 的左上角边缘的坐标。
- `offsetWidth/offsetHeight` — 元素的“外部” width/height，边框（border）尺寸计算在内。
- `clientLeft/clientTop` — 从元素左上角外角到左上角内角的距离。对于从左到右显示内容的操作系统来说，它们始终是左侧/顶部 border 的宽度。而对于从右到左显示内容的操作系统来说，垂直滚动条在左边，所以 `clientLeft` 也包括滚动条的宽度。
- `clientWidth/clientHeight` — 内容的 width/height，包括 padding，但不包括滚动条（scrollbar）。
- `scrollWidth/scrollHeight` — 内容的 width/height，就像 `clientWidth/clientHeight` 一样，但还包括元素的滚动出的不可见的部分。
- `scrollLeft/scrollTop` — 从元素的左上角开始，滚动出元素的上半部分的 width/height。

除了 `scrollLeft/scrollTop` 外，所有属性都是只读的。如果我们修改 `scrollLeft/scrollTop`，浏览器会滚动对应的元素。</code></pre>

      </fieldset>
      
      <fieldset id='_x5KyD5'>
      <legend>article</legend>
      <h1 id="window-大小和滚动">Window 大小和滚动</h1>
<p>我们如何找到浏览器窗口（window）的宽度和高度呢？我们如何获得文档（document）的包括滚动部分在内的完整宽度和高度呢？我们如何使用 JavaScript 滚动页面？</p>
<p>对于大多数此类请求，我们可以使用与 <code>&lt;html&gt;</code> 标签相对应的根文档元素 <code>document.documentElement</code>。但是还有很多其他方法，这些方法和特性非常重要，值得我们考虑。</p>
<h2 id="窗口的-widthheight">窗口的 width/height</h2>
<p>为了获取窗口（window）的宽度和高度，我们可以使用 <code>document.documentElement</code> 的 <code>clientWidth/clientHeight</code>：</p>
<p><img src="document-client-width-height.svg" alt=""></p>
<pre><code class="language-online">例如，这个按钮会显示窗口的高度：

&lt;button onclick=&quot;alert(document.documentElement.clientHeight)&quot;&gt;alert(document.documentElement.clientHeight)&lt;/button&gt;</code></pre>
<p>````warn header=&quot;不是 <code>window.innerWidth/Height</code>&quot;
浏览器也支持 <code>window.innerWidth/innerHeight</code> 属性。它们看起来像我们想要的。那为什么不使用它们呢？</p>
<p>如果这里存在一个滚动条，并且滚动条占用了一些空间，那么 <code>clientWidth/clientHeight</code> 会提供没有滚动条（减去它）的 width/height。换句话说，它们返回的是可用于内容的文档的可见部分的 width/height。</p>
<p>……而 <code>window.innerWidth/innerHeight</code> 包括了滚动条。</p>
<p>如果这里有一个滚动条，它占用了一些空间，那么这两行代码会显示不同的值：</p>
<pre><code class="language-js">alert( <span class="hljs-built_in">window</span>.innerWidth ); <span class="hljs-comment">// 整个窗口的宽度</span>
alert( <span class="hljs-built_in">document</span>.documentElement.clientWidth ); <span class="hljs-comment">// 减去滚动条宽度后的窗口宽度</span></code></pre>
<p>在大多数情况下，我们需要 <strong>可用</strong> 的窗口宽度：以绘制或放置某些东西。也就是说：在滚动条内（如果有）。所以我们应该使用 <code>documentElement.clientHeight/Width</code>。</p>
<pre><code>
```warn header=&quot;`DOCTYPE` 很重要&quot;
请注意：当 HTML 中没有 `&lt;!DOCTYPE HTML&gt;` 时，顶层级（top-level）几何属性的工作方式可能就会有所不同。可能会出现一些稀奇古怪的情况。

在现代 HTML 中，我们始终都应该写 `DOCTYPE`。
```

## 文档的 width/height

从理论上讲，由于根文档元素是 `document.documentElement`，并且它包围了所有内容，因此我们可以通过使用 `documentElement.scrollWidth/scrollHeight` 来测量文档的完整大小。

但是在该元素上，对于整个文档，这些属性均无法正常工作。在 Chrome/Safari/Opera 中，如果没有滚动条，`documentElement.scrollHeight` 甚至可能小于 `documentElement.clientHeight`！听起来像胡话，很奇怪，对吧？

为了可靠地获得完整的文档高度，我们应该采用以下这些属性的最大值：

```js run
let scrollHeight = Math.max(
  document.body.scrollHeight, document.documentElement.scrollHeight,
  document.body.offsetHeight, document.documentElement.offsetHeight,
  document.body.clientHeight, document.documentElement.clientHeight
);

alert(&#x27;Full document height, with scrolled out part: &#x27; + scrollHeight);
```

为什么这样？最好不要问。这些不一致来源于远古时代，而不是“聪明”的逻辑。

## 获得当前滚动 [#page-scroll]

DOM 元素的当前滚动状态在 `elem.scrollLeft/scrollTop` 中。

对于文档滚动，在大多数浏览器中，我们可以使用 `document.documentElement.scrollLeft/Top`，但在较旧的基于 WebKit 的浏览器中则不行，例如在 Safari（bug [5991](https://bugs.webkit.org/show_bug.cgi?id=5991)）中，我们应该使用 `document.body` 而不是 `document.documentElement`。

幸运的是，我们根本不必记住这些特性，因为滚动在 `window.pageXOffset/pageYOffset` 中可用：

```js run
alert(&#x27;Current scroll from the top: &#x27; + window.pageYOffset);
alert(&#x27;Current scroll from the left: &#x27; + window.pageXOffset);
```

这些属性是只读的。

## 滚动：scrollTo，scrollBy，scrollIntoView [#window-scroll]

```warn
必须在 DOM 完全构建好之后才能通过 JavaScript 滚动页面

例如，如果我们尝试从 `&lt;head&gt;` 中的脚本滚动页面，它将无法正常工作。
```

可以通过更改 `scrollTop/scrollLeft` 来滚动常规元素。

我们可以使用 `document.documentElement.scrollTop/Left` 对页面进行相同的操作（Safari 除外，而应该使用 `document.body.scrollTop/Left` 代替）。

或者，有一个更简单的通用解决方案：使用特殊方法 [window.scrollBy(x,y)](mdn:api/Window/scrollBy) 和 [window.scrollTo(pageX,pageY)](mdn:api/Window/scrollTo)。

- 方法 `scrollBy(x,y)` 将页面滚动至 **相对于当前位置的 `(x, y)` 位置**。例如，`scrollBy(0,10)` 会将页面向下滚动 `10px`。

    ```online
    下面这个按钮演示了这个方法：

    &lt;button onclick=&quot;window.scrollBy(0,10)&quot;&gt;window.scrollBy(0,10)&lt;/button&gt;
    ```
- 方法 `scrollTo(pageX,pageY)` 将页面滚动至 **绝对坐标**，使得可见部分的左上角具有相对于文档左上角的坐标 `(pageX, pageY)`。就像设置了 `scrollLeft/scrollTop` 一样。

    要滚动到最开始，我们可以使用 `scrollTo(0,0)`。

    ```online
    &lt;button onclick=&quot;window.scrollTo(0,0)&quot;&gt;window.scrollTo(0,0)&lt;/button&gt;
    ```

这些方法适用于所有浏览器。

## scrollIntoView

为了完整起见，让我们再介绍一种方法：[elem.scrollIntoView(top)](mdn:api/Element/scrollIntoView)。

对 `elem.scrollIntoView(top)` 的调用将滚动页面以使 `elem` 可见。它有一个参数：

- 如果 `top=true`（默认值），页面滚动，使 `elem` 出现在窗口顶部。元素的上边缘与窗口顶部对齐。
- 如果 `top=false`，页面滚动，使 `elem` 出现在窗口底部。元素的底部边缘与窗口底部对齐。

```online
下面这个按钮会滚动页面，以使它自身显示在窗口顶部：

&lt;button onclick=&quot;this.scrollIntoView()&quot;&gt;this.scrollIntoView()&lt;/button&gt;

下面这个按钮会滚动页面，以使它自身显示在窗口底部：

&lt;button onclick=&quot;this.scrollIntoView(false)&quot;&gt;this.scrollIntoView(false)&lt;/button&gt;
```

## 禁止滚动

有时候我们需要使文档“不可滚动”。例如，当我们需要用一条需要立即引起注意的大消息来覆盖文档时，我们希望访问者与该消息而不是与文档进行交互。

要使文档不可滚动，只需要设置 `document.body.style.overflow = &quot;hidden&quot;`。该页面将冻结在其当前滚动上。

```online
试一试：

&lt;button onclick=&quot;document.body.style.overflow = &#x27;hidden&#x27;&quot;&gt;document.body.style.overflow = &#x27;hidden&#x27;&lt;/button&gt;

&lt;button onclick=&quot;document.body.style.overflow = &#x27;&#x27;&quot;&gt;document.body.style.overflow = &#x27;&#x27;&lt;/button&gt;

第一个按钮冻结了滚动，第二个按钮则恢复了滚动。
```

我们还可以使用相同的技术来“冻结”其他元素的滚动，而不仅仅是 `document.body`。

这个方法的缺点是会使滚动条消失。如果滚动条占用了一些空间，它原本占用的空间就会空出来，那么内容就会“跳”进去以填充它。

这看起来有点奇怪，但是我们可以对比冻结前后的 `clientWidth`，如果它增加了（滚动条消失后），那么我们可以在 `document.body` 中滚动条原来的位置处通过添加 `padding`，来替代滚动条，这样这个问题就解决了。保持了滚动条冻结前后文档内容宽度相同。

## 总结

几何：

- 文档可见部分的 width/height（内容区域的 width/height）：`document.documentElement.clientWidth/Height`
- 整个文档的 width/height，其中包括滚动出去的部分：

    ```js
    let scrollHeight = Math.max(
      document.body.scrollHeight, document.documentElement.scrollHeight,
      document.body.offsetHeight, document.documentElement.offsetHeight,
      document.body.clientHeight, document.documentElement.clientHeight
    );
    ```

滚动：

- 读取当前的滚动：`window.pageYOffset/pageXOffset`。
- 更改当前的滚动：

    - `window.scrollTo(pageX,pageY)` — 绝对坐标，
    - `window.scrollBy(x,y)` — 相对当前位置进行滚动，
    - `elem.scrollIntoView(top)` — 滚动以使 `elem` 可见（`elem` 与窗口的顶部/底部对齐）。</code></pre>

      </fieldset>
      
      <fieldset id='_vumhk6'>
      <legend>solution</legend>
      <h1 id="外角">外角</h1>
<p>外角就是我们从 <a href="https://developer.mozilla.org/en-US/docs/DOM/element.getBoundingClientRect">elem.getBoundingClientRect()</a> 获取的。</p>
<p><code>answer1</code> 为左上角的坐标，<code>answer2</code> 为右下角的坐标：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> coords = elem.getBoundingClientRect();

<span class="hljs-keyword">let</span> answer1 = [coords.left, coords.top];
<span class="hljs-keyword">let</span> answer2 = [coords.right, coords.bottom];</code></pre>
<h1 id="左上的内角坐标">左上的内角坐标</h1>
<p>内角与外角主要的不同在于边框的宽度。一种获取距离的可靠的方法是 <code>clientLeft/clientTop</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> answer3 = [coords.left + field.clientLeft, coords.top + field.clientTop];</code></pre>
<h1 id="右下的内角坐标">右下的内角坐标</h1>
<p>在我们的例子中，我们需要把外部坐标减去边框（border）大小。</p>
<p>我们可以使用 CSS 的方式：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> answer4 = [
  coords.right - <span class="hljs-built_in">parseInt</span>(getComputedStyle(field).borderRightWidth),
  coords.bottom - <span class="hljs-built_in">parseInt</span>(getComputedStyle(field).borderBottomWidth)
];</code></pre>
<p>另一种方式是把 <code>clientWidth/clientHeight</code> 和左上角的坐标相加。这个方式相较于上一个或许更好：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> answer4 = [
  coords.left + elem.clientLeft + elem.clientWidth,
  coords.top + elem.clientTop + elem.clientHeight
];</code></pre>

      </fieldset>
      
      <fieldset id='_sLVRkf'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="查找区域的窗口坐标">查找区域的窗口坐标</h1>
<p>在下面的 iframe 中，你可以看到一个带有绿色区域（field）的文档。</p>
<p>使用 JavaScript 查找带箭头指向的角的窗口坐标。</p>
<p>为了方便起见，已经在文档中实现了一个小功能。在任何地方点击都会显示那里的坐标。</p>
<p>[iframe border=1 height=360 src=&quot;source&quot; link edit]</p>
<p>你的代码应该使用 DOM 来获取以下窗口坐标：</p>
<ol>
<li>左上的外角（这很简单）。</li>
<li>右下的外角（也挺简单）。</li>
<li>左上的内角（这有点难）。</li>
<li>右下的内角（有几种方式，选择其中一种）。</li>
</ol>
<p>你计算得到的坐标，应该与点击鼠标返回的坐标相同。</p>
<p>P.S. 如果元素具有其他大小（size）和边框（border），且未绑定任何固定的值，你写的代码也应该起作用。</p>

      </fieldset>
      
      <fieldset id='_gNBVp8'>
      <legend>solution</legend>
      <p>在这个任务中，我们只需要准确地计算坐标即可。具体细节，请参见代码。</p>
<p>请注意：元素必须在文档中才能读取 <code>offsetHeight</code> 和其它属性。
隐藏的（<code>display:none</code>）或者不在文档中的元素没有大小。</p>

      </fieldset>
      
      <fieldset id='_sVHSuv'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="在元素旁显示一个-note">在元素旁显示一个 note</h1>
<p>创建一个函数 <code>positionAt(anchor, position, elem)</code> 来定位 <code>elem</code>，具体取决于 <code>anchor</code> 元素附近的 <code>position</code>。</p>
<p><code>position</code> 必须具有下列三个字符串中的一个：</p>
<ul>
<li><code>&quot;top&quot;</code> — 将 <code>elem</code> 定位在 <code>anchor</code> 上方</li>
<li><code>&quot;right&quot;</code> — 将 <code>elem</code> 定位在 <code>anchor</code> 右侧</li>
<li><code>&quot;bottom&quot;</code> — 将 <code>elem</code> 定位在 <code>anchor</code> 下方</li>
</ul>
<p><code>position</code> 被用在函数 <code>showNote(anchor, position, html)</code> 内，该函数使用给定的 <code>html</code> 创建一个 &quot;note&quot; 元素，并将其显示在 <code>anchor</code> 附近的 <code>position</code> 处。</p>
<p>这是一个演示示例：</p>
<p>[iframe src=&quot;solution&quot; height=&quot;350&quot; border=&quot;1&quot; link]</p>

      </fieldset>
      
      <fieldset id='_P7IwG4'>
      <legend>solution</legend>
      <p>解决方案实际上很简单：</p>
<ul>
<li>在 <code>.note</code> 的 CSS 中，使用 <code>position:absolute</code> 代替 <code>position:fixed</code>。</li>
<li>使用在 <a href="info:coordinates">info:coordinates</a> 一章中所讲的函数 <a href="info:coordinates#getCoords">getCoords()</a> 来获取相对于文档的坐标。</li>
</ul>

      </fieldset>
      
      <fieldset id='_Z9wpSc'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="在元素旁（absolute）显示一个-note">在元素旁（absolute）显示一个 note</h1>
<p>修改 <a href="info:task/position-at">上一个任务</a> 的解决方案，让 note 元素使用 <code>position:absolute</code> 来替代 <code>position:fixed</code>。</p>
<p>这可以防止页面滚动时元素的“失控”。</p>
<p>以上一个任务的解决方案为基础。为了测试页面滚动，请添加样式 <code>&lt;body style=&quot;height: 2000px&quot;&gt;</code>。</p>

      </fieldset>
      
      <fieldset id='_VVB1TK'>
      <legend>solution</legend>
      
      </fieldset>
      
      <fieldset id='_wEI1MD'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="把-note-放在元素内部（absolute）">把 note 放在元素内部（absolute）</h1>
<p>扩展上一个任务 <a href="info:task/position-at-absolute">info:task/position-at-absolute</a>：教函数 <code>positionAt(anchor, position, elem)</code> 把 <code>elem</code> 插入到 <code>anchor</code> 内部。</p>
<p><code>position</code> 的新值：</p>
<ul>
<li><code>top-out</code>，<code>right-out</code>，<code>bottom-out</code> — 和之前一样工作，它们把 <code>elem</code> 插入到 <code>anchor</code> 的上方/右侧/下方。</li>
<li><code>top-in</code>，<code>right-in</code>，<code>bottom-in</code> — 把 <code>elem</code> 插入到 <code>anchor</code> 内部：将其粘贴到上/右/下边缘。</li>
</ul>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-comment">// 在 blockquote 上方显示 note</span>
positionAt(blockquote, <span class="hljs-string">&quot;top-out&quot;</span>, note);

<span class="hljs-comment">// 在 blockquote 内部的上边缘显示 note</span>
positionAt(blockquote, <span class="hljs-string">&quot;top-in&quot;</span>, note);</code></pre>
<p>结果：</p>
<p>[iframe src=&quot;solution&quot; height=&quot;310&quot; border=&quot;1&quot; link]</p>
<p>可以以上一个任务 <a href="info:task/position-at-absolute">info:task/position-at-absolute</a> 的解决方案为基础。</p>

      </fieldset>
      
      <fieldset id='_S9GoHl'>
      <legend>article</legend>
      <h1 id="坐标">坐标</h1>
<p>要移动页面的元素，我们应该先熟悉坐标。</p>
<p>大多数 JavaScript 方法处理的是以下两种坐标系中的一个：</p>
<ol>
<li><strong>相对于窗口</strong> — 类似于 <code>position:fixed</code>，从窗口的顶部/左侧边缘计算得出。<ul>
<li>我们将这些坐标表示为 <code>clientX/clientY</code>，当我们研究事件属性时，就会明白为什么使用这种名称来表示坐标。</li>
</ul>
</li>
<li><strong>相对于文档</strong> — 与文档根（document root）中的 <code>position:absolute</code> 类似，从文档的顶部/左侧边缘计算得出。<ul>
<li>我们将它们表示为 <code>pageX/pageY</code>。</li>
</ul>
</li>
</ol>
<p>当页面滚动到最开始时，此时窗口的左上角恰好是文档的左上角，它们的坐标彼此相等。但是，在文档移动之后，元素的窗口相对坐标会发生变化，因为元素在窗口中移动，而元素在文档中的相对坐标保持不变。</p>
<p>在下图中，我们在文档中取一点，并演示了它滚动之前（左）和之后（右）的坐标：</p>
<p><img src="document-and-window-coordinates-scrolled.svg" alt=""></p>
<p>当文档滚动了：</p>
<ul>
<li><code>pageY</code> — 元素在文档中的相对坐标保持不变，从文档顶部（现在已滚动出去）开始计算。</li>
<li><code>clientY</code> — 窗口相对坐标确实发生了变化（箭头变短了），因为同一个点越来越靠近窗口顶部。</li>
</ul>
<h2 id="元素坐标：getboundingclientrect">元素坐标：getBoundingClientRect</h2>
<p>方法 <code>elem.getBoundingClientRect()</code> 返回最小矩形的窗口坐标，该矩形将 <code>elem</code> 作为内建 <a href="https://www.w3.org/TR/geometry-1/#domrect">DOMRect</a> 类的对象。</p>
<p>主要的 <code>DOMRect</code> 属性：</p>
<ul>
<li><code>x/y</code> — 矩形原点相对于窗口的 X/Y 坐标，</li>
<li><code>width/height</code> — 矩形的 width/height（可以为负）。</li>
</ul>
<p>此外，还有派生（derived）属性：</p>
<ul>
<li><code>top/bottom</code> — 顶部/底部矩形边缘的 Y 坐标，</li>
<li><code>left/right</code> — 左/右矩形边缘的 X 坐标。</li>
</ul>
<pre><code class="language-online">例如，点击下面这个按钮以查看其窗口坐标：

&lt;p&gt;&lt;input id=&quot;brTest&quot; type=&quot;button&quot; value=&quot;Get coordinates using button.getBoundingClientRect() for this button&quot; onclick=&#x27;showRect(this)&#x27;/&gt;&lt;/p&gt;

&lt;script&gt;
function showRect(elem) {
  let r = elem.getBoundingClientRect();
  alert(`x:${r.x}
y:${r.y}
width:${r.width}
height:${r.height}
top:${r.top}
bottom:${r.bottom}
left:${r.left}
right:${r.right}
`);
}
&lt;/script&gt;

如果你滚动此页面并重复点击上面那个按钮，你会发现随着窗口相对按钮位置的改变，其窗口坐标（如果你垂直滚动页面，则为 `y/top/bottom`）也随之改变。</code></pre>
<p>下面这张是 <code>elem.getBoundingClientRect()</code> 的输出的示意图：</p>
<p><img src="coordinates.svg" alt=""></p>
<p>正如你所看到的，<code>x/y</code> 和 <code>width/height</code> 对矩形进行了完整的描述。可以很容易地从它们计算出派生（derived）属性：</p>
<ul>
<li><code>left = x</code></li>
<li><code>top = y</code></li>
<li><code>right = x + width</code></li>
<li><code>bottom = y + height</code></li>
</ul>
<p>请注意：</p>
<ul>
<li>坐标可能是小数，例如 <code>10.5</code>。这是正常的，浏览器内部使用小数进行计算。在设置 <code>style.left/top</code> 时，我们不是必须对它们进行舍入。</li>
<li>坐标可能是负数。例如滚动页面，使 <code>elem</code> 现在位于窗口的上方，则 <code>elem.getBoundingClientRect().top</code> 为负数。</li>
</ul>
<p>```smart header=&quot;为什么需要派生（derived）属性？如果有了 <code>x/y</code>，为什么还要还会存在 <code>top/left</code>？&quot;
从数学上讲，一个矩形是使用其起点 <code>(x,y)</code> 和方向向量 <code>(width,height)</code> 唯一定义的。因此，其它派生属性是为了方便起见。</p>
<p>从技术上讲，<code>width/height</code> 可能为负数，从而允许“定向（directed）”矩形，例如代表带有正确标记的开始和结束的鼠标选择。</p>
<p>负的 <code>width/height</code> 值表示矩形从其右下角开始，然后向左上方“增长”。</p>
<p>这是一个矩形，其 <code>width</code> 和 <code>height</code> 均为负数（例如 <code>width=-200</code>，<code>height=-100</code>）：</p>
<p><img src="coordinates-negative.svg" alt=""></p>
<p>正如你所看到的，在这个例子中，<code>left/top</code> 与 <code>x/y</code> 不相等。</p>
<p>但是实际上，<code>elem.getBoundingClientRect()</code> 总是返回正数的 width/height，这里我们提及负的 <code>width/height</code> 只是为了帮助你理解，为什么这些看起来重复的属性，实际上并不是重复的。</p>
<pre><code>
```warn header=&quot;IE 和 Edge 浏览器不支持 `x/y`&quot;
由于历史原因，IE 和 Edge 浏览器不支持 `x/y` 属性。

因此，我们可以写一个 polyfill（在 `DomRect.prototype` 中添加一个 getter），或者仅使用 `top/left`，因为对于正值的 `width/height` 来说，它们和 `x/y` 一直是一样的，尤其是对于 `elem.getBoundingClientRect()` 的结果。</code></pre>
<pre><code class="language-warn">相对于窗口（window）的坐标和 CSS `position:fixed` 之间有明显的相似之处。

但是在 CSS 定位中，`right` 属性表示距右边缘的距离，而 `bottom` 属性表示距下边缘的距离。

如果我们再看一下上面的图片，我们可以看到在 JavaScript 中并非如此。窗口的所有坐标都从左上角开始计数，包括这些坐标。</code></pre>
<h2 id="elementfrompointx-y-elementfrompoint">elementFromPoint(x, y) [#elementFromPoint]</h2>
<p>对 <code>document.elementFromPoint(x, y)</code> 的调用会返回在窗口坐标 <code>(x, y)</code> 处嵌套最多（the most nested）的元素。</p>
<p>语法如下：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> elem = <span class="hljs-built_in">document</span>.elementFromPoint(x, y);</code></pre>
<p>例如，下面的代码会高亮显示并输出现在位于窗口中间的元素的标签：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> centerX = <span class="hljs-built_in">document</span>.documentElement.clientWidth / <span class="hljs-number">2</span>;
<span class="hljs-keyword">let</span> centerY = <span class="hljs-built_in">document</span>.documentElement.clientHeight / <span class="hljs-number">2</span>;

<span class="hljs-keyword">let</span> elem = <span class="hljs-built_in">document</span>.elementFromPoint(centerX, centerY);

elem.style.background = <span class="hljs-string">&quot;red&quot;</span>;
alert(elem.tagName);</code></pre>
<p>因为它使用的是窗口坐标，所以元素可能会因当前滚动位置而有所不同。</p>
<p>````warn header=&quot;对于在窗口之外的坐标，<code>elementFromPoint</code> 返回 <code>null</code>&quot;
方法 <code>document.elementFromPoint(x,y)</code> 只对在可见区域内的坐标 <code>(x,y)</code> 起作用。</p>
<p>如果任何坐标为负或者超过了窗口的 width/height，那么该方法就会返回 <code>null</code>。</p>
<p>在大多数情况下，这种行为并不是一个问题，但是我们应该记住这一点。</p>
<p>如果我们没有对其进行检查，可能就会发生下面这个典型的错误：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> elem = <span class="hljs-built_in">document</span>.elementFromPoint(x, y);
<span class="hljs-comment">// 如果坐标恰好在窗口外，则 elem = null</span>
*!*
elem.style.background = <span class="hljs-string">&#x27;&#x27;</span>; <span class="hljs-comment">// Error!</span>
*/!*</code></pre>
<pre><code>
## 用于 &quot;fixed&quot; 定位

为了显示元素附近的东西，我们可以使用 `getBoundingClientRect` 来获取其坐标，然后使用 CSS `position` 以及 `left/top`（或 `right/bottom`）。

例如，下面的函数 `createMessageUnder(elem, html)` 在 `elem` 下显示了消息：

```js
let elem = document.getElementById(&quot;coords-show-mark&quot;);

function createMessageUnder(elem, html) {
  // 创建 message 元素
  let message = document.createElement(&#x27;div&#x27;);
  // 在这里最好使用 CSS class 来定义样式
  message.style.cssText = &quot;position:fixed; color: red&quot;;

*!*
  // 分配坐标，不要忘记 &quot;px&quot;！
  let coords = elem.getBoundingClientRect();

  message.style.left = coords.left + &quot;px&quot;;
  message.style.top = coords.bottom + &quot;px&quot;;
*/!*

  message.innerHTML = html;

  return message;
}

// 用法：
// 在文档中添加 message 保持 5 秒
let message = createMessageUnder(elem, &#x27;Hello, world!&#x27;);
document.body.append(message);
setTimeout(() =&gt; message.remove(), 5000);
```

```online
点击下面这个按钮来运行它：

&lt;button id=&quot;coords-show-mark&quot;&gt;Button with id=&quot;coords-show-mark&quot;, the message will appear under it&lt;/button&gt;
```

我们可以修改代码以在元素左侧，右侧或下面显示消息，也可以应用 CSS 动画来营造“淡入淡出”效果等。这很简单，因为我们有该元素所有坐标和大小。

但是请注意一个重要的细节：滚动页面时，消息就会从按钮流出。

原因很显然：message 元素依赖于 `position:fixed`，因此当页面滚动时，它仍位于窗口的同一位置。

要改变这一点，我们需要使用基于文档（document）的坐标和 `position:absolute` 样式。

## 文档坐标 [#getCoords]

文档相对坐标从文档的左上角开始计算，而不是窗口。

在 CSS 中，窗口坐标对应于 `position:fixed`，而文档坐标与顶部的 `position:absolute` 类似。

我们可以使用 `position:absolute` 和 `top/left` 来把某些内容放到文档中的某个位置，以便在页面滚动时，元素仍能保留在该位置。但是我们首先需要正确的坐标。

这里没有标准方法来获取元素的文档坐标。但是写起来很容易。

这两个坐标系统通过以下公式相连接：
- `pageY` = `clientY` + 文档的垂直滚动出的部分的高度。
- `pageX` = `clientX` + 文档的水平滚动出的部分的宽度。

函数 `getCoords(elem)` 将从 `elem.getBoundingClientRect()` 获取窗口坐标，并向其中添加当前滚动：

```js
// 获取元素的文档坐标
function getCoords(elem) {
  let box = elem.getBoundingClientRect();

  return {
    top: box.top + window.pageYOffset,
    right: box.right + window.pageXOffset,
    bottom: box.bottom + window.pageYOffset,
    left: box.left + window.pageXOffset
  };
}
```

如果在上面的示例中，我们将其与 `position:absolute` 一起使用，则在页面滚动时，消息仍停留在元素附近。

修改后的 `createMessageUnder` 函数：

```js
function createMessageUnder(elem, html) {
  let message = document.createElement(&#x27;div&#x27;);
  message.style.cssText = &quot;*!*position:absolute*/!*; color: red&quot;;

  let coords = *!*getCoords(elem);*/!*

  message.style.left = coords.left + &quot;px&quot;;
  message.style.top = coords.bottom + &quot;px&quot;;

  message.innerHTML = html;

  return message;
}
```

## 总结

页面上的任何点都有坐标：

1. 相对于窗口的坐标 — `elem.getBoundingClientRect()`。
2. 相对于文档的坐标 — `elem.getBoundingClientRect()` 加上当前页面滚动。

窗口坐标非常适合和 `position:fixed` 一起使用，文档坐标非常适合和 `position:absolute` 一起使用。

这两个坐标系统各有利弊。有时我们需要其中一个或另一个，就像 CSS `position` 的 `absolute` 和 `fixed` 一样。</code></pre>

      </fieldset>
      
      <fieldset id='_ESCPRQ'>
      <legend>solution</legend>
      
      </fieldset>
      
      <fieldset id='_xsUzhL'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="点击隐藏">点击隐藏</h1>
<p>为 <code>button</code> 添加 JavaScript 代码，使得 <code>&lt;div id=&quot;text&quot;&gt;</code> 在我们点击该按钮时消失。</p>
<p>示例：</p>
<p>[iframe border=1 src=&quot;solution&quot; height=80]</p>

      </fieldset>
      
      <fieldset id='_zVbQaZ'>
      <legend>solution</legend>
      <p>可以在处理程序中使用 <code>this</code> 来引用“元素自身”：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;this.hidden=true&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Click to hide&quot;</span>&gt;</span></code></pre>

      </fieldset>
      
      <fieldset id='_lOJeS7'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="隐藏自己">隐藏自己</h1>
<p>创建一个按钮，在被点击时，隐藏自己。</p>
<pre><code class="language-online">就像这样：
&lt;input type=&quot;button&quot; onclick=&quot;this.hidden=true&quot; value=&quot;Click to hide&quot;&gt;</code></pre>

      </fieldset>
      
      <fieldset id='_SCqErq'>
      <legend>solution</legend>
      <p>答案：<code>1</code> 和 <code>2</code>。</p>
<p>第一个处理程序会触发，因为它没有被 <code>removeEventListener</code> 移除。要移除处理程序，我们需要传递正确的所分配的函数。在代码中，传递了一个新的函数，该函数看起来相同，但仍然是另一个函数。</p>
<p>要移除一个函数对象，我们需要存储对它的引用，像这样：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handler</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-number">1</span>);
}

button.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, handler);
button.removeEventListener(<span class="hljs-string">&quot;click&quot;</span>, handler);</code></pre>
<p>无论 <code>addEventListener</code> 怎样，<code>button.onclick</code> 处理程序都会触发。</p>

      </fieldset>
      
      <fieldset id='_Vfb82x'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="哪个处理程序会运行？">哪个处理程序会运行？</h1>
<p>在变量中有一个按钮。它上面没有处理程序。</p>
<p>执行以下代码之后，哪些处理程序会在按钮被点击时运行？会显示哪些 alert？</p>
<pre><code class="language-js">button.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> alert(<span class="hljs-string">&quot;1&quot;</span>));

button.removeEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> alert(<span class="hljs-string">&quot;1&quot;</span>));

button.onclick = <span class="hljs-function">() =&gt;</span> alert(<span class="hljs-number">2</span>);</code></pre>

      </fieldset>
      
      <fieldset id='_QZLvDw'>
      <legend>solution</legend>
      <p>首先，我们需要选择一种定位球的方法。</p>
<p>我们不能使用 <code>position:fixed</code>，因为滚动页面会造成球被移出球场。</p>
<p>所以我们应该使用 <code>position:absolute</code>，并且要使定位真正可靠，应该使 <code>field</code> 自身具有 <code>position:absolute</code>。</p>
<p>然后，球将相对于球场定位：</p>
<pre><code class="language-css"><span class="hljs-selector-id">#field</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;
  <span class="hljs-attribute">position</span>: relative;
}

<span class="hljs-selector-id">#ball</span> {
  <span class="hljs-attribute">position</span>: absolute;
  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>; <span class="hljs-comment">/* 相对于最接近的祖先（field） */</span>
  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">transition</span>: <span class="hljs-number">1s</span> all; <span class="hljs-comment">/* left/top 的 CSS 动画，使球飞起来 */</span>
}</code></pre>
<p>接下来我们需要指定正确的 <code>ball.style.left/top</code>。它们现在包含相对于球场的坐标。</p>
<p>这是示意图：</p>
<p><img src="move-ball-coords.svg" alt=""></p>
<p>我们有 <code>event.clientX/clientY</code> —— 点击位置的窗口相对坐标。</p>
<p>要获取点击位置的球场相对坐标 <code>left</code>，我们可以减去球场左边缘和边框的宽度：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> left = event.clientX - fieldCoords.left - field.clientLeft;</code></pre>
<p>通常情况下，<code>ball.style.left</code> 表示“元素的左边缘”（球）。因此，如果我们将其指定为 <code>left</code>，那么球的边缘而非球的中心将位于鼠标光标下方。</p>
<p>我们需要将球向左移动球宽度的一半，向上移动球高度的一半，以使其居中。</p>
<p>所以，最后的 <code>left</code> 将是：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> left = event.clientX - fieldCoords.left - field.clientLeft - ball.offsetWidth/<span class="hljs-number">2</span>;</code></pre>
<p>使用相同的逻辑来计算垂直坐标。</p>
<p>请注意，球的宽度/高度必须在我们访问 <code>ball.offsetWidth</code> 时就已知。应该在 HTML 或 CSS 中指定。</p>

      </fieldset>
      
      <fieldset id='_5AtFEu'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="让球在球场中移动">让球在球场中移动</h1>
<p>点击球场中任意一点，让球在球场中移动。就像这样：</p>
<p>[iframe src=&quot;solution&quot; height=&quot;260&quot; link]</p>
<p>要求：</p>
<ul>
<li>球的中心应该恰好在点击时鼠标指针位置的下方（如果在球不越过球场边缘的情况下，能实现的话）。</li>
<li>最好添加一些 CSS 动画。</li>
<li>球不能越过场地边界。</li>
<li>页面滚动时，不会有任何中断。</li>
</ul>
<p>注意：</p>
<ul>
<li>代码还应该适用于不同大小的球和球场，而不应该绑定到任何固定值。</li>
<li>使用 <code>event.clientX/event.clientY</code> 属性来获取点击坐标。</li>
</ul>

      </fieldset>
      
      <fieldset id='_f907WK'>
      <legend>solution</legend>
      <h1 id="htmlcss">HTML/CSS</h1>
<p>首先，让我们创建 HTML/CSS。</p>
<p>菜单是页面上的一个独立图形组件，所以最好把它放入一个单独的 DOM 元素中。</p>
<p>菜单项的列表可以被作为列表 <code>ul/li</code> 列出。</p>
<p>下面是示例结构：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;menu&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>Sweeties (click me)!<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Cake<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Donut<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Honey<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>我们对标题使用 <code>&lt;span&gt;</code>，因为 <code>&lt;div&gt;</code> 有一个隐式的 <code>display:block</code>，它会占据 100% 的水平宽度。</p>
<p>就像这样：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border: solid red 1px&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(1)&quot;</span>&gt;</span>Sweeties (click me)!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>因此，如果我们在它上面设置 <code>onclick</code>，那么它也会捕获文本右侧的点击。</p>
<p>……由于 <code>&lt;span&gt;</code> 有一个隐式的 <code>display: inline</code>，它恰好占据了足以容纳所有文本的位置：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border: solid red 1px&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(1)&quot;</span>&gt;</span>Sweeties (click me)!<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre>
<h1 id="切换菜单">切换菜单</h1>
<p>切换菜单应更改箭头并显示/隐藏菜单列表。</p>
<p>所有这些更改都可以通过 CSS 完美处理。在 JavaScript 中，我们应该通过添加/移除 <code>.open</code> 类来标记菜单的当前状态。</p>
<p>没有它，菜单就会被关闭：</p>
<pre><code class="language-css"><span class="hljs-selector-class">.menu</span> <span class="hljs-selector-tag">ul</span> {
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">list-style</span>: none;
  <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">20px</span>;
  <span class="hljs-attribute">display</span>: none;
}

<span class="hljs-selector-class">.menu</span> <span class="hljs-selector-class">.title</span><span class="hljs-selector-pseudo">::before</span> {
  <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;▶ &#x27;</span>;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">80%</span>;
  <span class="hljs-attribute">color</span>: green;
}</code></pre>
<p>……有 <code>.open</code> 后，箭头会改变，列表会出现：</p>
<pre><code class="language-css"><span class="hljs-selector-class">.menu</span><span class="hljs-selector-class">.open</span> <span class="hljs-selector-class">.title</span><span class="hljs-selector-pseudo">::before</span> {
  <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;▼ &#x27;</span>;
}

<span class="hljs-selector-class">.menu</span><span class="hljs-selector-class">.open</span> <span class="hljs-selector-tag">ul</span> {
  <span class="hljs-attribute">display</span>: block;
}</code></pre>

      </fieldset>
      
      <fieldset id='_VRAcbM'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="创建滑动菜单">创建滑动菜单</h1>
<p>创建一个在点击时打开/折叠的菜单：</p>
<p>[iframe border=1 height=100 src=&quot;solution&quot;]</p>
<p>P.S. 源文档的 HTML/CSS 将被修改。</p>

      </fieldset>
      
      <fieldset id='_bIZJQt'>
      <legend>solution</legend>
      <p>我们可以使用 <code>position:absolute</code>（并使窗格 <code>position:relative</code>）或者 <code>float:right</code> 来添加按钮。<code>float:right</code> 的好处是按钮永远都不会与文本重叠，但是 <code>position:absolute</code> 则提供了更大的自由度。选择权在你自己手上。</p>
<p>然后，对于每个窗格（pane），代码可以像这样：</p>
<pre><code class="language-js">pane.insertAdjacentHTML(<span class="hljs-string">&quot;afterbegin&quot;</span>, <span class="hljs-string">&#x27;&lt;button class=&quot;remove-button&quot;&gt;[x]&lt;/button&gt;&#x27;</span>);</code></pre>
<p>然后 <code>&lt;button&gt;</code> 变成了 <code>pane.firstChild</code>，因此我们可以像这样为它添加处理程序：</p>
<pre><code class="language-js">pane.firstChild.onclick = <span class="hljs-function">() =&gt;</span> pane.remove();</code></pre>

      </fieldset>
      
      <fieldset id='_b3cAst'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="添加关闭按钮">添加关闭按钮</h1>
<p>有一个消息列表。</p>
<p>使用 JavaScript 在每条消息的右上角添加一个关闭按钮。</p>
<p>结果应该如下所示：</p>
<p>[iframe src=&quot;solution&quot; height=450]</p>

      </fieldset>
      
      <fieldset id='_3AYUNq'>
      <legend>solution</legend>
      <p>图像带可以表示为图像 <code>&lt;img&gt;</code> 的 <code>ul/li</code> 列表。</p>
<p>通常，这样的图像带是很宽的，但我们在其周围放置了一个固定大小的 <code>&lt;div&gt;</code> 来“剪切”它，因此，只有图像带的一部分是可见的：</p>
<p><img src="carousel1.svg" alt=""></p>
<p>为了使列表水平显示，我们需要为 <code>&lt;li&gt;</code> 应用正确的 CSS 属性，例如 <code>display: inline-block</code>。</p>
<p>对于 <code>&lt;img&gt;</code> 来说，我们应该调整 <code>display</code>，因为默认情况下它是 <code>inline</code>。在 <code>inline</code> 元素下方为 &quot;letter tails&quot; 保留了额外的空间，因此，我们可以使用 <code>display:block</code> 来将其删除。</p>
<p>我们可以移动 <code>&lt;ul&gt;</code> 来进行滚动。有很多方法可以实现这一点，例如，通过修改 <code>margin-left</code> 或者使用 <code>transform: translateX()</code>（性能更好）：</p>
<p><img src="carousel2.svg" alt=""></p>
<p>外部的 <code>&lt;div&gt;</code> 具有固定的宽度，因此，会裁剪掉“多余”的图像。</p>
<p>整个轮播图是页面上的一个独立的“图形组件”，因此我们最好将其包装到一个单独的 <code>&lt;div class=&quot;carousel&quot;&gt;</code> 中，并在其中对其进行样式设置。</p>

      </fieldset>
      
      <fieldset id='_Ht82vX'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="轮播图">轮播图</h1>
<p>创建一个“轮播图（carousel）” —— 一条可以通过点击箭头来滚动图像的图像带。</p>
<p>[iframe height=200 src=&quot;solution&quot;]</p>
<p>之后，我们可以为其添加更多功能：无限滚动，动态加载等。</p>
<p>P.S. 对于这个任务，HTML/CSS 结构实际上占解决方案的 90%。</p>

      </fieldset>
      
      <fieldset id='_aiDRlt'>
      <legend>article</legend>
      <h1 id="浏览器事件简介">浏览器事件简介</h1>
<p><strong>事件</strong> 是某事发生的信号。所有的 DOM 节点都生成这样的信号（但事件不仅限于 DOM）。</p>
<p>这是最有用的 DOM 事件的列表，你可以浏览一下：</p>
<p><strong>鼠标事件：</strong></p>
<ul>
<li><code>click</code> —— 当鼠标点击一个元素时（触摸屏设备会在点击时生成）。</li>
<li><code>contextmenu</code> —— 当鼠标右键点击一个元素时。</li>
<li><code>mouseover</code> / <code>mouseout</code> —— 当鼠标指针移入/离开一个元素时。</li>
<li><code>mousedown</code> / <code>mouseup</code> —— 当在元素上按下/释放鼠标按钮时。</li>
<li><code>mousemove</code> —— 当鼠标移动时。</li>
</ul>
<p><strong>键盘事件</strong>：</p>
<ul>
<li><code>keydown</code> 和 <code>keyup</code> —— 当按下和松开一个按键时。</li>
</ul>
<p><strong>表单（form）元素事件</strong>：</p>
<ul>
<li><code>submit</code> —— 当访问者提交了一个 <code>&lt;form&gt;</code> 时。</li>
<li><code>focus</code> —— 当访问者聚焦于一个元素时，例如聚焦于一个 <code>&lt;input&gt;</code>。</li>
</ul>
<p><strong>Document 事件</strong>：</p>
<ul>
<li><code>DOMContentLoaded</code> —— 当 HTML 的加载和处理均完成，DOM 被完全构建完成时。</li>
</ul>
<p><strong>CSS 事件</strong>：</p>
<ul>
<li><code>transitionend</code> —— 当一个 CSS 动画完成时。</li>
</ul>
<p>还有很多其他事件。我们将在下一章中详细介绍具体事件。</p>
<h2 id="事件处理程器">事件处理程器</h2>
<p>为了对事件作出响应，我们可以分配一个 <strong>处理程序（handler）</strong>—— 一个在事件发生时运行的函数。</p>
<p>处理程序是在发生用户行为（action）时运行 JavaScript 代码的一种方式。</p>
<p>有几种分配处理程序的方法。让我们来看看，从最简单的开始。</p>
<h3 id="html-特性">HTML 特性</h3>
<p>处理程序可以设置在 HTML 中名为 <code>on&lt;event&gt;</code> 的特性（attribute）中。</p>
<p>例如，要为一个 <code>input</code> 分配一个 <code>click</code> 处理程序，我们可以使用 <code>onclick</code>，像这样；</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Click me&quot;</span> *!*<span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;Click!&#x27;)&quot;</span>*/!* <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span></code></pre>
<p>在鼠标点击时，<code>onclick</code> 中的代码就会运行。</p>
<p>请注意，在 <code>onclick</code> 中，我们使用单引号，因为特性本身使用的是双引号。如果我们忘记了代码是在特性中的，而使用了双引号，像这样：<code>onclick=&quot;alert(&quot;Click!&quot;)&quot;</code>，那么它就无法正确运行。</p>
<p>HTML 特性不是编写大量代码的好位置，因此我们最好创建一个 JavaScript 函数，然后在 HTML 特性中调用这个函数。</p>
<p>在这里点击会运行 <code>countRabbits()</code>：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countRabbits</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">3</span>; i++</span>)</span> {
      alert(<span class="hljs-string">&quot;Rabbit number &quot;</span> + i);
    }
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> *!*<span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;countRabbits()&quot;</span>*/!* <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Count rabbits!&quot;</span>&gt;</span></code></pre>
<p>我们知道，HTML 特性名是大小写不敏感的，所以 <code>ONCLICK</code> 和 <code>onClick</code> 以及 <code>onCLICK</code> 都一样可以运行。但是特性通常是小写的：<code>onclick</code>。</p>
<h3 id="dom-属性">DOM 属性</h3>
<p>我们可以使用 DOM 属性（property）<code>on&lt;event&gt;</code> 来分配处理程序。</p>
<p>例如 <code>elem.onclick</code>：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;elem&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Click me&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
*!*
  elem.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    alert(<span class="hljs-string">&#x27;Thank you&#x27;</span>);
  };
*/!*
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>如果一个处理程序是通过 HTML 特性（attribute）分配的，那么随后浏览器读取它，并从特性的内容创建一个新函数，并将这个函数写入 DOM 属性（property）。</p>
<p>因此，这种方法实际上与前一种方法相同。</p>
<p>这两段代码工作相同：</p>
<ol>
<li><p>只有 HTML：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> *!*<span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;Click!&#x27;)&quot;</span>*/!* <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Button&quot;</span>&gt;</span></code></pre>
</li>
<li><p>HTML + JS：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Button&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
*!*
  button.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    alert(<span class="hljs-string">&#x27;Click!&#x27;</span>);
  };
*/!*
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
</li>
</ol>
<p>在第一个例子中，<code>button.onclick</code> 是通过 HTML 特性（attribute）初始化的，而在第二个例子中是通过脚本初始化的。这是它们唯一的不同之处。</p>
<p><strong>因为这里只有一个 <code>onclick</code> 属性，所以我们无法分配更多事件处理程序。</strong></p>
<p>在下面这个示例中，我们使用 JavaScript 添加了一个处理程序，覆盖了现有的处理程序：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;elem&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;Before&#x27;)&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Click me&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
*!*
  elem.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// 覆盖了现有的处理程序</span>
    alert(<span class="hljs-string">&#x27;After&#x27;</span>); <span class="hljs-comment">// 只会显示此内容</span>
  };
*/!*
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>要移除一个处理程序 —— 赋值 <code>elem.onclick = null</code>。</p>
<h2 id="访问元素：this">访问元素：this</h2>
<p>处理程序中的 <code>this</code> 的值是对应的元素。就是处理程序所在的那个元素。</p>
<p>下面这行代码中的 <code>button</code> 使用 <code>this.innerHTML</code> 来显示它的内容：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(this.innerHTML)&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre>
<h2 id="可能出现的错误">可能出现的错误</h2>
<p>如果你刚开始写事件 —— 请注意一些细微之处。</p>
<p>我们可以将一个现存的函数用作处理程序：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayThanks</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-string">&#x27;Thanks!&#x27;</span>);
}

elem.onclick = sayThanks;</code></pre>
<p>但要注意：函数应该是以 <code>sayThanks</code> 的形式进行赋值，而不是 <code>sayThanks()</code>。</p>
<pre><code class="language-js"><span class="hljs-comment">// 正确</span>
button.onclick = sayThanks;

<span class="hljs-comment">// 错误</span>
button.onclick = sayThanks();</code></pre>
<p>如果我们添加了括号，那么 <code>sayThanks()</code> 就变成了一个函数调用。所以，最后一行代码实际上获得的是函数执行的 <strong>结果</strong>，即 <code>undefined</code>（因为这个函数没有返回值）。此代码不会工作。</p>
<p>……但在标记（markup）中，我们确实需要括号：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;sayThanks()&quot;</span>&gt;</span></code></pre>
<p>这个区别很容易解释。当浏览器读取 HTML 特性（attribute）时，浏览器将会使用 <strong>特性中的内容</strong> 创建一个处理程序。</p>
<p>所以，标记（markup）会生成下面这个属性：</p>
<pre><code class="language-js">button.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
*!*
  sayThanks(); <span class="hljs-comment">// &lt;-- 特性（attribute）中的内容变到了这里</span>
*/!*
};</code></pre>
<p><strong>不要对处理程序使用 <code>setAttribute</code>。</strong></p>
<p>这样的调用会失效：</p>
<pre><code class="language-js"><span class="hljs-comment">// 点击 &lt;body&gt; 将产生 error，</span>
<span class="hljs-comment">// 因为特性总是字符串的，函数变成了一个字符串</span>
<span class="hljs-built_in">document</span>.body.setAttribute(<span class="hljs-string">&#x27;onclick&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ alert(<span class="hljs-number">1</span>) });</code></pre>
<p><strong>DOM 属性是大小写敏感的。</strong></p>
<p>将处理程序分配给 <code>elem.onclick</code>，而不是 <code>elem.ONCLICK</code>，因为 DOM 属性是大小写敏感的。</p>
<h2 id="addeventlistener">addEventListener</h2>
<p>上述分配处理程序的方式的根本问题是 —— 我们不能为一个事件分配多个处理程序。</p>
<p>假设，在我们点击了一个按钮时，我们代码中的一部分想要高亮显示这个按钮，另一部分则想要显示一条消息。</p>
<p>我们想为此事件分配两个处理程序。但是，新的 DOM 属性将覆盖现有的 DOM 属性：</p>
<pre><code class="language-js">input.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ alert(<span class="hljs-number">1</span>); }
<span class="hljs-comment">// ...</span>
input.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ alert(<span class="hljs-number">2</span>); } <span class="hljs-comment">// 替换了前一个处理程序</span></code></pre>
<p>Web 标准的开发者很早就了解到了这一点，并提出了一种使用特殊方法 <code>addEventListener</code> 和 <code>removeEventListener</code> 来管理处理程序的替代方法。它们没有这样的问题。</p>
<p>添加处理程序的语法：</p>
<pre><code class="language-js">element.addEventListener(event, handler[, options]);</code></pre>
<p><code>event</code>
: 事件名，例如：<code>&quot;click&quot;</code>。</p>
<p><code>handler</code>
: 处理程序。</p>
<p><code>options</code>
: 具有以下属性的附加可选对象：
    - <code>once</code>：如果为 <code>true</code>，那么会在被触发后自动删除监听器。
    - <code>capture</code>：事件处理的阶段，我们稍后将在 <a href="info:bubbling-and-capturing">info:bubbling-and-capturing</a> 一章中介绍。由于历史原因，<code>options</code> 也可以是 <code>false/true</code>，它与 <code>{capture: false/true}</code> 相同。
    - <code>passive</code>：如果为 <code>true</code>，那么处理程序将不会调用 <code>preventDefault()</code>，我们稍后将在 <a href="info:default-browser-action">info:default-browser-action</a> 一章中介绍。</p>
<p>要移除处理程序，可以使用 <code>removeEventListener</code>：</p>
<pre><code class="language-js">element.removeEventListener(event, handler[, options]);</code></pre>
<pre><code class="language-warn">要移除处理程序，我们需要传入与分配的函数完全相同的函数。

这不起作用：

```js no-beautify
elem.addEventListener( &quot;click&quot; , () =&gt; alert(&#x27;Thanks!&#x27;));
// ....
elem.removeEventListener( &quot;click&quot;, () =&gt; alert(&#x27;Thanks!&#x27;));
```

处理程序不会被移除，因为 `removeEventListener` 获取了另一个函数 —— 使用相同的代码，但这并不起作用，因为它是一个不同的函数对象。

下面是正确方法：

```js
function handler() {
  alert( &#x27;Thanks!&#x27; );
}

input.addEventListener(&quot;click&quot;, handler);
// ....
input.removeEventListener(&quot;click&quot;, handler);
```

请注意 —— 如果我们不将函数存储在一个变量中，那么我们就无法移除它。由 `addEventListener` 分配的处理程序将无法被“读回”。</code></pre>
<p>多次调用 <code>addEventListener</code> 允许添加多个处理程序，如下所示：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;elem&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Click me&quot;</span>/&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handler1</span>(<span class="hljs-params"></span>) </span>{
    alert(<span class="hljs-string">&#x27;Thanks!&#x27;</span>);
  };

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handler2</span>(<span class="hljs-params"></span>) </span>{
    alert(<span class="hljs-string">&#x27;Thanks again!&#x27;</span>);
  }

*!*
  elem.onclick = <span class="hljs-function">() =&gt;</span> alert(<span class="hljs-string">&quot;Hello&quot;</span>);
  elem.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, handler1); <span class="hljs-comment">// Thanks!</span>
  elem.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, handler2); <span class="hljs-comment">// Thanks again!</span>
*/!*
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>正如我们在上面这个例子中所看到的，我们可以 <strong>同时</strong> 使用 DOM 属性和 <code>addEventListener</code> 来设置处理程序。但通常我们只使用其中一种方式。</p>
<p>````warn header=&quot;对于某些事件，只能通过 <code>addEventListener</code> 设置处理程序&quot;
有些事件无法通过 DOM 属性进行分配。只能使用 <code>addEventListener</code>。</p>
<p>例如，<code>DOMContentLoaded</code> 事件，该事件在文档加载完成并且 DOM 构建完成时触发。</p>
<pre><code class="language-js"><span class="hljs-comment">// 永远不会运行</span>
<span class="hljs-built_in">document</span>.onDOMContentLoaded = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-string">&quot;DOM built&quot;</span>);
};</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// 这种方式可以运行</span>
<span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&quot;DOMContentLoaded&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-string">&quot;DOM built&quot;</span>);
});</code></pre>
<p>所以 <code>addEventListener</code> 更通用。虽然这样的事件是特例而不是规则。</p>
<pre><code>
## 事件对象

为了正确处理事件，我们需要更深入地了解发生了什么。不仅仅是 &quot;click&quot; 或 &quot;keydown&quot;，还包括鼠标指针的坐标是什么？按下了哪个键？等等。

当事件发生时，浏览器会创建一个 **`event` 对象**，将详细信息放入其中，并将其作为参数传递给处理程序。

下面是一个从 `event` 对象获取鼠标指针的坐标的示例：

```html run
&lt;input type=&quot;button&quot; value=&quot;Click me&quot; id=&quot;elem&quot;&gt;

&lt;script&gt;
  elem.onclick = function(*!*event*/!*) {
    // 显示事件类型、元素和点击的坐标
    alert(event.type + &quot; at &quot; + event.currentTarget);
    alert(&quot;Coordinates: &quot; + event.clientX + &quot;:&quot; + event.clientY);
  };
&lt;/script&gt;
```

`event` 对象的一些属性：

`event.type`
: 事件类型，这里是 `&quot;click&quot;`。

`event.currentTarget`
: 处理事件的元素。这与 `this` 相同，除非处理程序是一个箭头函数，或者它的 `this` 被绑定到了其他东西上，之后我们就可以从 `event.currentTarget` 获取元素了。

`event.clientX / event.clientY`
: 指针事件（pointer event）的指针的窗口相对坐标。

还有很多属性。其中很多都取决于事件类型：键盘事件具有一组属性，指针事件具有另一组属性，稍后我们将详细讨论不同事件，那时我们再对其进行详细研究。

````smart header=&quot;`event` 对象在 HTML 处理程序中也可用&quot;
如果我们在 HTML 中分配了一个处理程序，那么我们也可以使用 `event` 对象，像这样：

```html autorun height=60
&lt;input type=&quot;button&quot; onclick=&quot;*!*alert(event.type)*/!*&quot; value=&quot;Event type&quot;&gt;
```

这是可能的，因为当浏览器读取特性（attribute）时，它会创建像这样的处理程序：`function(event) { alert(event.type) }`。也就是说：它的第一个参数是 `&quot;event&quot;`，而主体取自于该特性（attribute）。</code></pre>
<h2 id="对象处理程序：handleevent">对象处理程序：handleEvent</h2>
<p>我们不仅可以分配函数，还可以使用 <code>addEventListener</code> 将一个对象分配为事件处理程序。当事件发生时，就会调用该对象的 <code>handleEvent</code> 方法。</p>
<p>例如：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;elem&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">let</span> obj = {
    <span class="hljs-function"><span class="hljs-title">handleEvent</span>(<span class="hljs-params">event</span>)</span> {
      alert(event.type + <span class="hljs-string">&quot; at &quot;</span> + event.currentTarget);
    }
  };

  elem.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, obj);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>正如我们所看到的，当 <code>addEventListener</code> 接收一个对象作为处理程序时，在事件发生时，它就会调用 <code>obj.handleEvent(event)</code> 来处理事件。</p>
<p>我们也可以对此使用一个类：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;elem&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Menu</span> </span>{
    <span class="hljs-function"><span class="hljs-title">handleEvent</span>(<span class="hljs-params">event</span>)</span> {
      <span class="hljs-function"><span class="hljs-title">switch</span>(<span class="hljs-params">event.type</span>)</span> {
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;mousedown&#x27;</span>:
          elem.innerHTML = <span class="hljs-string">&quot;Mouse button pressed&quot;</span>;
          <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;mouseup&#x27;</span>:
          elem.innerHTML += <span class="hljs-string">&quot;...and released.&quot;</span>;
          <span class="hljs-keyword">break</span>;
      }
    }
  }

*!*
  <span class="hljs-keyword">let</span> menu = <span class="hljs-keyword">new</span> Menu();
  elem.addEventListener(<span class="hljs-string">&#x27;mousedown&#x27;</span>, menu);
  elem.addEventListener(<span class="hljs-string">&#x27;mouseup&#x27;</span>, menu);
*/!*
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>这里，同一个对象处理两个事件。请注意，我们需要使用 <code>addEventListener</code> 来显示设置事件，以指明要监听的事件。这里的 <code>menu</code> 对象只监听 <code>mousedown</code> 和 <code>mouseup</code>，而没有任何其他类型的事件。</p>
<p><code>handleEvent</code> 方法不必通过自身完成所有的工作。它可以调用其他特定于事件的方法，例如：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;elem&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Menu</span> </span>{
    <span class="hljs-function"><span class="hljs-title">handleEvent</span>(<span class="hljs-params">event</span>)</span> {
      <span class="hljs-comment">// mousedown -&gt; onMousedown</span>
      <span class="hljs-keyword">let</span> method = <span class="hljs-string">&#x27;on&#x27;</span> + event.type[<span class="hljs-number">0</span>].toUpperCase() + event.type.slice(<span class="hljs-number">1</span>);
      <span class="hljs-built_in">this</span>[method](event);
    }

    <span class="hljs-function"><span class="hljs-title">onMousedown</span>(<span class="hljs-params"></span>)</span> {
      elem.innerHTML = <span class="hljs-string">&quot;Mouse button pressed&quot;</span>;
    }

    <span class="hljs-function"><span class="hljs-title">onMouseup</span>(<span class="hljs-params"></span>)</span> {
      elem.innerHTML += <span class="hljs-string">&quot;...and released.&quot;</span>;
    }
  }

  <span class="hljs-keyword">let</span> menu = <span class="hljs-keyword">new</span> Menu();
  elem.addEventListener(<span class="hljs-string">&#x27;mousedown&#x27;</span>, menu);
  elem.addEventListener(<span class="hljs-string">&#x27;mouseup&#x27;</span>, menu);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>现在事件处理程序已经明确地分离了出来，这样更容易进行代码编写和后续维护。</p>
<h2 id="总结">总结</h2>
<p>这里有 3 种分配事件处理程序的方式：</p>
<ol>
<li>HTML 特性（attribute）：<code>onclick=&quot;...&quot;</code>。</li>
<li>DOM 属性（property）：<code>elem.onclick = function</code>。</li>
<li>方法（method）：<code>elem.addEventListener(event, handler[, phase])</code> 用于添加，<code>removeEventListener</code> 用于移除。</li>
</ol>
<p>HTML 特性很少使用，因为 HTML 标签中的 JavaScript 看起来有些奇怪且陌生。而且也不能在里面写太多代码。</p>
<p>DOM 属性用起来还可以，但我们无法为特定事件分配多个处理程序。在许多场景中，这种限制并不严重。</p>
<p>最后一种方式是最灵活的，但也是写起来最长的。有少数事件只能使用这种方式。例如 <code>transtionend</code> 和 <code>DOMContentLoaded</code>（上文中讲到了）。<code>addEventListener</code> 也支持对象作为事件处理程序。在这种情况下，如果发生事件，则会调用 <code>handleEvent</code> 方法。</p>
<p>无论你如何分类处理程序 —— 它都会将获得一个事件对象作为第一个参数。该对象包含有关所发生事件的详细信息。</p>
<p>在下一章中，我们将学习更多关于一般事件和不同类型事件的内容。</p>

      </fieldset>
      
      <fieldset id='_PPZVIo'>
      <legend>article</legend>
      <h1 id="冒泡和捕获">冒泡和捕获</h1>
<p>让我们从一个示例开始。</p>
<p>处理程序（handler）被分配给了 <code>&lt;div&gt;</code>，但是如果你点击任何嵌套的标签（例如 <code>&lt;em&gt;</code> 或 <code>&lt;code&gt;</code>），该处理程序也会运行：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;The handler!&#x27;)&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>If you click on <span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>EM<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>, the handler on <span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>DIV<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span> runs.<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>这是不是有点奇怪？如果实际上点击的是 <code>&lt;em&gt;</code>，为什么在 <code>&lt;div&gt;</code> 上的处理程序会运行？</p>
<h2 id="冒泡">冒泡</h2>
<p>冒泡（bubbling）原理很简单。</p>
<p><strong>当一个事件发生在一个元素上，它会首先运行在该元素上的处理程序，然后运行其父元素上的处理程序，然后一直向上到其他祖先上的处理程序。</strong></p>
<p>假设我们有 3 层嵌套 <code>FORM &gt; DIV &gt; P</code>，它们各自拥有一个处理程序：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
  <span class="hljs-selector-tag">body</span> * {
    <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;
    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid blue;
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;form&#x27;)&quot;</span>&gt;</span>FORM
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;div&#x27;)&quot;</span>&gt;</span>DIV
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;p&#x27;)&quot;</span>&gt;</span>P<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre>
<p>点击内部的 <code>&lt;p&gt;</code> 会首先运行 <code>onclick</code>：</p>
<ol>
<li>在该 <code>&lt;p&gt;</code> 上的。</li>
<li>然后是外部 <code>&lt;div&gt;</code> 上的。</li>
<li>然后是外部 <code>&lt;form&gt;</code> 上的。</li>
<li>以此类推，直到最后的 <code>document</code> 对象。</li>
</ol>
<p><img src="event-order-bubbling.svg" alt=""></p>
<p>因此，如果我们点击 <code>&lt;p&gt;</code>，那么我们将看到 3 个 alert：<code>p</code> -&gt; <code>div</code> -&gt; <code>form</code>。</p>
<p>这个过程被称为“冒泡（bubbling）”，因为事件从内部元素“冒泡”到所有父级，就像在水里的气泡一样。</p>
<pre><code class="language-warn">这句话中的关键词是“几乎”。

例如，`focus` 事件不会冒泡。同样，我们以后还会遇到其他例子。但这仍然是例外，而不是规则，大多数事件的确都是冒泡的。</code></pre>
<h2 id="eventtarget">event.target</h2>
<p>父元素上的处理程序始终可以获取事件实际发生位置的详细信息。</p>
<p><strong>引发事件的那个嵌套层级最深的元素被称为目标元素,可以通过 <code>event.target</code> 访问。</strong></p>
<p>注意与 <code>this</code>（=<code>event.currentTarget</code>）之间的区别：</p>
<ul>
<li><code>event.target</code> —— 是引发事件的“目标”元素，它在冒泡过程中不会发生变化。</li>
<li><code>this</code> —— 是“当前”元素，其中有一个当前正在运行的处理程序。</li>
</ul>
<p>例如，如果我们有一个处理程序 <code>form.onclick</code>，那么它可以“捕获”表单内的所有点击。无论点击发生在哪里，它都会冒泡到 <code>&lt;form&gt;</code> 并运行处理程序。</p>
<p>在 <code>form.onclick</code> 处理程序中：</p>
<ul>
<li><code>this</code>（=<code>event.currentTarget</code>）是 <code>&lt;form&gt;</code> 元素，因为处理程序在它上面运行。</li>
<li><code>event.target</code> 是表单中实际被点击的元素。</li>
</ul>
<p>一探究竟：</p>
<p>[codetabs height=220 src=&quot;bubble-target&quot;]</p>
<p><code>event.target</code> 可能会等于 <code>this</code> —— 当点击事件发生在 <code>&lt;form&gt;</code> 元素上时，就会发生这种情况。</p>
<h2 id="停止冒泡">停止冒泡</h2>
<p>冒泡事件从目标元素开始向上冒泡。通常，它会一直上升到 <code>&lt;html&gt;</code>，然后再到 <code>document</code> 对象，有些事件甚至会到达 <code>window</code>，它们会调用路径上所有的处理程序。</p>
<p>但是任意处理程序都可以决定事件已经被完全处理，并停止冒泡。</p>
<p>用于停止冒泡的方法是 <code>event.stopPropagation()</code>。</p>
<p>例如，如果你点击 <code>&lt;button&gt;</code>，这里的 <code>body.onclick</code> 不会工作：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(`the bubbling doesn&#x27;t reach here`)&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;event.stopPropagation()&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<pre><code class="language-smart">如果一个元素在一个事件上有多个处理程序，即使其中一个停止冒泡，其他处理程序仍会执行。

换句话说，`event.stopPropagation()` 停止向上移动，但是当前元素上的其他处理程序都会继续运行。

有一个 `event.stopImmediatePropagation()` 方法，可以用于停止冒泡，并阻止当前元素上的处理程序运行。使用该方法之后，其他处理程序就不会被执行。</code></pre>
<pre><code class="language-warn">冒泡很方便。不要在没有真实需求时阻止它：除非是显而易见的，并且在架构上经过深思熟虑的。

有时 `event.stopPropagation()` 会产生隐藏的陷阱，以后可能会成为问题。

例如：

1. 我们创建了一个嵌套菜单，每个子菜单各自处理对自己的元素的点击事件，并调用 `stopPropagation`，以便不会触发外部菜单。
2. 之后，我们决定捕获在整个窗口上的点击，以追踪用户的行为（用户点击的位置）。有些分析系统会这样做。通常，代码会使用 `document.addEventListener(&#x27;click&#x27;…)` 来捕获所有的点击。
3. 我们的分析不适用于被 `stopPropagation` 所阻止点击的区域。太伤心了，我们有一个“死区”。

通常，没有真正的必要去阻止冒泡。一项看似需要阻止冒泡的任务，可以通过其他方法解决。其中之一就是使用自定义事件，稍后我们会介绍它们此外，我们还可以将我们的数据写入一个处理程序中的 `event` 对象，并在另一个处理程序中读取该数据，这样我们就可以向父处理程序传递有关下层处理程序的信息。</code></pre>
<h2 id="捕获">捕获</h2>
<p>事件处理的另一个阶段被称为“捕获（capturing）”。它很少被用在实际开发中，但有时是有用的。</p>
<p><a href="http://www.w3.org/TR/DOM-Level-3-Events/">DOM 事件</a>标准描述了事件传播的 3 个阶段：</p>
<ol>
<li>捕获阶段（Capturing phase）—— 事件（从 Window）向下走近元素。</li>
<li>目标阶段（Target phase）—— 事件到达目标元素。</li>
<li>冒泡阶段（Bubbling phase）—— 事件从元素上开始冒泡。</li>
</ol>
<p>下面是在表格中点击 <code>&lt;td&gt;</code> 的图片，摘自规范：</p>
<p><img src="eventflow.svg" alt=""></p>
<p>也就是说：点击 <code>&lt;td&gt;</code>，事件首先通过祖先链向下到达元素（捕获阶段），然后到达目标（目标阶段），最后上升（冒泡阶段），在途中调用处理程序。</p>
<p><strong>之前，我们只讨论了冒泡，因为捕获阶段很少被使用。通常我们看不到它。</strong></p>
<p>使用 <code>on&lt;event&gt;</code> 属性或使用 HTML 特性（attribute）或使用两个参数的 <code>addEventListener(event, handler)</code> 添加的处理程序，对捕获一无所知，它们仅在第二阶段和第三阶段运行。</p>
<p>为了在捕获阶段捕获事件，我们需要将处理程序的 <code>capture</code> 选项设置为 <code>true</code>：</p>
<pre><code class="language-js">elem.addEventListener(..., {<span class="hljs-attr">capture</span>: <span class="hljs-literal">true</span>})
<span class="hljs-comment">// 或者，用 {capture: true} 的别名 &quot;true&quot;</span>
elem.addEventListener(..., <span class="hljs-literal">true</span>)</code></pre>
<p><code>capture</code> 选项有两个可能的值：</p>
<ul>
<li>如果为 <code>false</code>（默认值），则在冒泡阶段设置处理程序。</li>
<li>如果为 <code>true</code>，则在捕获阶段设置处理程序。</li>
</ul>
<p>请注意，虽然形式上有 3 个阶段，但第 2 阶段（“目标阶段”：事件到达元素）没有被单独处理：捕获阶段和冒泡阶段的处理程序都在该阶段被触发。</p>
<p>让我们来看看捕获和冒泡：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
  <span class="hljs-selector-tag">body</span> * {
    <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;
    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid blue;
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span>FORM
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>DIV
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>P<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> elem <span class="hljs-keyword">of</span> <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;*&#x27;</span>)</span>)</span> {
    elem.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> alert(<span class="hljs-string">`Capturing: <span class="hljs-subst">${elem.tagName}</span>`</span>), <span class="hljs-literal">true</span>);
    elem.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> alert(<span class="hljs-string">`Bubbling: <span class="hljs-subst">${elem.tagName}</span>`</span>));
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>上面这段代码为文档中的 <strong>每个</strong> 元素都设置了点击处理程序，以查看哪些元素上的点击事件处理程序生效了。</p>
<p>如果你点击了 <code>&lt;p&gt;</code>，那么顺序是：</p>
<ol>
<li><code>HTML</code> -&gt; <code>BODY</code> -&gt; <code>FORM</code> -&gt; <code>DIV</code>（捕获阶段第一个监听器）：</li>
<li><code>P</code>（目标阶段，触发两次，因为我们设置了两个监听器：捕获和冒泡）</li>
<li><code>DIV</code> -&gt; <code>FORM</code> -&gt; <code>BODY</code> -&gt; <code>HTML</code>（冒泡阶段，第二个监听器）。</li>
</ol>
<p>有一个属性 <code>event.eventPhase</code>，它告诉我们捕获事件的阶段数。但它很少被使用，因为我们通常是从处理程序中了解到它。</p>
<p>```smart header=&quot;要移除处理程序，<code>removeEventListener</code> 需要同一阶段&quot;
如果我们 <code>addEventListener(..., true)</code>，那么我们应该在 <code>removeEventListener(..., true)</code> 中提到同一阶段，以正确删除处理程序。</p>
<pre><code>
````smart header=&quot;同一元素的同一阶段的监听器按其设置顺序运行&quot;
如果我们在同一阶段有多个事件处理程序，并通过 `addEventListener` 分配给了相同的元素，则它们的运行顺序与创建顺序相同：

```js
elem.addEventListener(&quot;click&quot;, e =&gt; alert(1)); // 会先被触发
elem.addEventListener(&quot;click&quot;, e =&gt; alert(2));</code></pre>
<pre><code>

## 总结

当一个事件发生时 —— 发生该事件的嵌套最深的元素被标记为“目标元素”（`event.target`）。

- 然后，事件从文档根节点向下移动到 `event.target`，并在途中调用分配了 `addEventListener(..., true)` 的处理程序（`true` 是 `{capture: true}` 的一个简写形式）。
- 然后，在目标元素自身上调用处理程序。
- 然后，事件从 `event.target` 向上移动到根，调用使用 `on&lt;event&gt;` 和没有第三个参数的，或者第三个参数为 `false/{capture:false}` 的 `addEventListener` 分配的处理程序。

每个处理程序都可以访问 `event` 对象的属性：

- `event.target` —— 引发事件的层级最深的元素。
- `event.currentTarget`（=`this`）—— 处理事件的当前元素（具有处理程序的元素）
- `event.eventPhase` —— 当前阶段（capturing=1，target=2，bubbling=3）。

任何事件处理程序都可以通过调用 `event.stopPropagation()` 来停止事件，但不建议这样做，因为我们不确定是否确实不需要冒泡上来的事件，也许是用于完全不同的事情。

捕获阶段很少使用，通常我们会在冒泡时处理事件。这背后有一个逻辑。

在现实世界中，当事故发生时，当地警方会首先做出反应。他们最了解发生这件事的地方。然后，如果需要，上级主管部门再进行处理。

事件处理程序也是如此。在特定元素上设置处理程序的代码，了解有关该元素最详尽的信息。特定于 `&lt;td&gt;` 的处理程序可能恰好适合于该 `&lt;td&gt;`，这个处理程序知道关于该元素的所有信息。所以该处理程序应该首先获得机会。然后，它的直接父元素也了解相关上下文，但了解的内容会少一些，以此类推，直到处理一般性概念并最后运行的最顶部的元素为止。

冒泡和捕获为“事件委托”奠定了基础 —— 一种非常强大的事件处理模式，我们将在下一章中进行研究。</code></pre>

      </fieldset>
      
      <fieldset id='_yfCdMe'>
      <legend>solution</legend>
      
      </fieldset>
      
      <fieldset id='_pEypbT'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="使用委托隐藏消息">使用委托隐藏消息</h1>
<p>有一个带有移除按钮 <code>[x]</code> 的消息列表。让按钮可以工作。</p>
<p>就像这样：</p>
<p>[iframe src=&quot;solution&quot; height=420]</p>
<p>P.S. 在容器上应该只有一个事件监听器，请使用事件委托。</p>

      </fieldset>
      
      <fieldset id='_G6ro2b'>
      <legend>solution</legend>
      <p>解决方案分为两个部分。</p>
<ol>
<li>将每个树节点的标题都包装到 <code>&lt;span&gt;</code> 中。然后我们可以在 <code>:hover</code> 上使用 CSS 样式，并精确地处理文本上的点击事件，因为 <code>&lt;span&gt;</code> 的宽度恰好是文本的宽度（与没有宽度不同）。</li>
<li>为 <code>tree</code> 的根节点设置一个处理程序，来处理 <code>&lt;span&gt;</code> 标题上的点击事件。</li>
</ol>

      </fieldset>
      
      <fieldset id='_tTuT8C'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="树形菜单">树形菜单</h1>
<p>创建一个点击可以显示/隐藏子节点的树形菜单：</p>
<p>[iframe border=1 src=&quot;solution&quot;]</p>
<p>要求：</p>
<ul>
<li>只能有一个事件处理程序（使用委托）。</li>
<li>对节点标题以外（在空白处）的点击不会做任何处理。</li>
</ul>

      </fieldset>
      
      <fieldset id='_KOIad7'>
      <legend>solution</legend>
      
      </fieldset>
      
      <fieldset id='_BRd0yQ'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="可排序的表格">可排序的表格</h1>
<p>使表格可排序：点击 <code>&lt;th&gt;</code> 元素，应按对应的列对表格进行排序。</p>
<p>每个 <code>&lt;th&gt;</code> 的特性（attribute）中都有类型，如下所示：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;grid&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
*!*
      <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">data-type</span>=<span class="hljs-string">&quot;number&quot;</span>&gt;</span>Age<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">data-type</span>=<span class="hljs-string">&quot;string&quot;</span>&gt;</span>Name<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
*/!*
    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>John<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Ann<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
    ...
  <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre>
<p>在上面的示例中，第一列为数字，第二列为字符串。排序函数应根据类型进行排序。</p>
<p>应该只支持 <code>&quot;string&quot;</code> 和 <code>&quot;number&quot;</code> 类型。</p>
<p>运行示例：</p>
<p>[iframe border=1 src=&quot;solution&quot; height=190]</p>
<p>P.S. 表格可以更大，有任意数量的行和列。</p>

      </fieldset>
      
      <fieldset id='_LcOH27'>
      <legend>solution</legend>
      
      </fieldset>
      
      <fieldset id='_MBAiO9'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="工具提示行为">工具提示行为</h1>
<p>编写工具提示（tooltip）行为的 JavaScript 代码。</p>
<p>当鼠标在带有 <code>data-tooltip</code> 的元素的上方时，工具提示应显示在其上方，当鼠标移开时，工具提示将隐藏起来。</p>
<p>带有注释的 HTML 示例：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">data-tooltip</span>=<span class="hljs-string">&quot;the tooltip is longer than the element&quot;</span>&gt;</span>Short button<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">data-tooltip</span>=<span class="hljs-string">&quot;HTML&lt;br&gt;tooltip&quot;</span>&gt;</span>One more button<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre>
<p>运行效果如下：</p>
<p>[iframe src=&quot;solution&quot; height=200 border=1]</p>
<p>在此任务中，我们假设所有具有 <code>data-tooltip</code> 的元素中都只有文本。尚无嵌套标签。</p>
<p>详情：</p>
<ul>
<li>元素和工具提示之间的距离应为 <code>5px</code>。</li>
<li>如果可能，工具提示应相对于元素居中。</li>
<li>工具提示不应与窗口边缘交叉。通常，它应该在元素的上方，但是如果元素位于页面顶部，并且没有工具提示的空间，则应该在元素的下方。</li>
<li>工具提示的内容在 <code>data-tooltip</code> 属性中给定。它可以是任意 HTML。</li>
</ul>
<p>在这里你将需要两个事件：</p>
<ul>
<li><code>mouseover</code> 当鼠标指针出现在元素上方时触发。</li>
<li><code>mouseout</code> 当鼠标指针离开元素时触发。</li>
</ul>
<p>请使用事件委托：在 <code>document</code> 上设置两个处理程序，以跟踪带有 <code>data-tooltip</code> 的元素中的所有 &quot;over&quot; 和 &quot;out&quot;，并从那里管理工具提示。</p>
<p>在实现了该行为后，即使不熟悉 JavaScript 的人也可以添加带注释的元素。</p>
<p>P.S. 一次只能显示一个工具提示。</p>

      </fieldset>
      
      <fieldset id='_ynIoBx'>
      <legend>article</legend>
      <h1 id="事件委托">事件委托</h1>
<p>捕获和冒泡允许我们实现一种被称为 <strong>事件委托</strong> 的强大的事件处理模式。</p>
<p>这个想法是，如果我们有许多以类似方式处理的元素，那么就不必为每个元素分配一个处理程序 —— 而是将单个处理程序放在它们的共同祖先上。</p>
<p>在处理程序中，我们获得 <code>event.target</code>，查看事件实际发生的位置并进行处理。</p>
<p>让我们看一个示例 —— 反映中国古代哲学的 <a href="http://en.wikipedia.org/wiki/Ba_gua">八卦图</a>。</p>
<p>如下所示：</p>
<p>[iframe height=350 src=&quot;bagua&quot; edit link]</p>
<p>其 HTML 如下所示：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>Bagua<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span> Chart: Direction, Element, Color, Meaning
    <span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nw&quot;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>Northwest<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>Metal<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>Silver<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>Elders
    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;n&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ne&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
    ...2 more lines of this kind...
  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
    ...2 more lines of this kind...
  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre>
<p>该表格有 9 个单元格（cell），但可以有 99 个或 9999 个单元格，这都不重要。</p>
<p><strong>我们的任务是在点击时高亮显示被点击的单元格 <code>&lt;td&gt;</code>。</strong></p>
<p>与其为每个 <code>&lt;td&gt;</code>（可能有很多）分配一个 <code>onclick</code> 处理程序 —— 我们可以在 <code>&lt;table&gt;</code> 元素上设置一个“捕获所有”的处理程序。</p>
<p>它将使用 <code>event.target</code> 来获取点击的元素并高亮显示它。</p>
<p>代码如下：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> selectedTd;

*!*
table.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
  <span class="hljs-keyword">let</span> target = event.target; <span class="hljs-comment">// 在哪里点击的？</span>

  <span class="hljs-keyword">if</span> (target.tagName != <span class="hljs-string">&#x27;TD&#x27;</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 不在 TD 上？那么我们就不会在意</span>

  highlight(target); <span class="hljs-comment">// 高亮显示它</span>
};
*/!*

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">highlight</span>(<span class="hljs-params">td</span>) </span>{
  <span class="hljs-keyword">if</span> (selectedTd) { <span class="hljs-comment">// 移除现有的高亮显示，如果有的话</span>
    selectedTd.classList.remove(<span class="hljs-string">&#x27;highlight&#x27;</span>);
  }
  selectedTd = td;
  selectedTd.classList.add(<span class="hljs-string">&#x27;highlight&#x27;</span>); <span class="hljs-comment">// 高亮显示新的 td</span>
}</code></pre>
<p>此代码不会关心在表格中有多少个单元格。我们可以随时动态添加/移除 <code>&lt;td&gt;</code>，高亮显示仍然有效。</p>
<p>尽管如此，但还是存在缺陷。</p>
<p>点击可能不是发生在 <code>&lt;td&gt;</code> 上，而是发生在其内部。</p>
<p>在我们的例子中，如果我们看一下 HTML 内部，我们可以看到 <code>&lt;td&gt;</code> 内还有嵌套的标签，例如 <code>&lt;strong&gt;</code>：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
  *!*
  <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>Northwest<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span>
  */!* ...
<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></code></pre>
<p>自然地，如果在该 <code>&lt;strong&gt;</code> 上点击，那么它将成为 <code>event.target</code> 的值。</p>
<p><img src="bagua-bubble.svg" alt=""></p>
<p>在处理程序 <code>table.onclick</code> 中，我们应该接受这样的 <code>event.target</code>，并确定该点击是否在 <code>&lt;td&gt;</code> 内。</p>
<p>下面是改进后的代码：</p>
<pre><code class="language-js">table.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
  <span class="hljs-keyword">let</span> td = event.target.closest(<span class="hljs-string">&quot;td&quot;</span>); <span class="hljs-comment">// (1)</span>

  <span class="hljs-keyword">if</span> (!td) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// (2)</span>

  <span class="hljs-keyword">if</span> (!table.contains(td)) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// (3)</span>

  highlight(td); <span class="hljs-comment">// (4)</span>
};</code></pre>
<p>解释：</p>
<ol>
<li><code>elem.closest(selector)</code> 方法返回与 <code>selector</code> 匹配的最近的祖先。在我们的例子中，我们从源元素开始向上寻找 <code>&lt;td&gt;</code>。</li>
<li>如果 <code>event.target</code> 不在任何 <code>&lt;td&gt;</code> 中，那么调用将立即返回，因为这里没有什么事儿可做。</li>
<li>对于嵌套的表格，<code>event.target</code> 可能是一个 <code>&lt;td&gt;</code>，但位于当前表格之外。因此我们需要检查它是否是 <strong>我们的表格中的</strong> <code>&lt;td&gt;</code>。</li>
<li>如果是的话，就高亮显示它。</li>
</ol>
<p>最终，我们得到了一个快速、高效的用于高亮显示的代码，该代码与表格中的 <code>&lt;td&gt;</code> 的数量无关。</p>
<h2 id="委托示例：标记中的行为">委托示例：标记中的行为</h2>
<p>事件委托还有其他用途。（译注：本节标题中的“标记中的行为”即 action in markup）</p>
<p>例如，我们想要编写一个有“保存”、“加载”和“搜索”等按钮的菜单。并且，这里有一个具有 <code>save</code>、<code>load</code> 和 <code>search</code> 等方法的对象。如何匹配它们？</p>
<p>第一个想法可能是为每个按钮分配一个单独的处理程序。但是有一个更优雅的解决方案。我们可以为整个菜单添加一个处理程序，并为具有方法调用的按钮添加 <code>data-action</code> 特性（attribute）：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> *!*<span class="hljs-attr">data-action</span>=<span class="hljs-string">&quot;save&quot;</span>*/!*&gt;</span>Click to Save<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre>
<p>处理程序读取特性（attribute）并执行该方法。工作示例如下：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;menu&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">data-action</span>=<span class="hljs-string">&quot;save&quot;</span>&gt;</span>Save<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">data-action</span>=<span class="hljs-string">&quot;load&quot;</span>&gt;</span>Load<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">data-action</span>=<span class="hljs-string">&quot;search&quot;</span>&gt;</span>Search<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Menu</span> </span>{
      <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">elem</span>)</span> {
        <span class="hljs-built_in">this</span>._elem = elem;
        elem.onclick = <span class="hljs-built_in">this</span>.onClick.bind(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// (*)</span>
      }

      <span class="hljs-function"><span class="hljs-title">save</span>(<span class="hljs-params"></span>)</span> {
        alert(<span class="hljs-string">&#x27;saving&#x27;</span>);
      }

      <span class="hljs-function"><span class="hljs-title">load</span>(<span class="hljs-params"></span>)</span> {
        alert(<span class="hljs-string">&#x27;loading&#x27;</span>);
      }

      <span class="hljs-function"><span class="hljs-title">search</span>(<span class="hljs-params"></span>)</span> {
        alert(<span class="hljs-string">&#x27;searching&#x27;</span>);
      }

      <span class="hljs-function"><span class="hljs-title">onClick</span>(<span class="hljs-params">event</span>)</span> {
  *!*
        <span class="hljs-keyword">let</span> action = event.target.dataset.action;
        <span class="hljs-keyword">if</span> (action) {
          <span class="hljs-built_in">this</span>[action]();
        }
  */!*
      };
    }

    <span class="hljs-keyword">new</span> Menu(menu);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>请注意，<code>this.onClick</code> 在 <code>(*)</code> 行中被绑定到了 <code>this</code>。这很重要，因为否则内部的 <code>this</code> 将引用 DOM 元素（<code>elem</code>），而不是 <code>Menu</code> 对象，那样的话，<code>this[action]</code> 将不是我们所需要的。</p>
<p>那么，这里的委托给我们带来了什么好处？</p>
<pre><code class="language-compare">+ 我们不需要编写代码来为每个按钮分配一个处理程序。只需要创建一个方法并将其放入标记（markup）中即可。
+ HTML 结构非常灵活，我们可以随时添加/移除按钮。</code></pre>
<p>我们也可以使用 <code>.action-save</code>，<code>.action-load</code> 类，但 <code>data-action</code> 特性（attribute）在语义上更好。我们也可以在 CSS 规则中使用它。</p>
<h2 id="行为模式">“行为”模式</h2>
<p>我们还可以使用事件委托将“行为（behavior）”以 <strong>声明方式</strong> 添加到具有特殊特性（attribute）和类的元素中。</p>
<p>行为模式分为两个部分：</p>
<ol>
<li>我们将自定义特性添加到描述其行为的元素。</li>
<li>用文档范围级的处理程序追踪事件，如果事件发生在具有特定特性的元素上 —— 则执行行为（action）。</li>
</ol>
<h3 id="行为：计数器">行为：计数器</h3>
<p>例如，这里的特性 <code>data-counter</code> 给按钮添加了一个“点击增加”的行为。</p>
<pre><code class="language-html">Counter: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">data-counter</span> /&gt;</span> One more counter:
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">data-counter</span> /&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
    <span class="hljs-keyword">if</span> (event.target.dataset.counter != <span class="hljs-literal">undefined</span>) {
      <span class="hljs-comment">// 如果这个特性存在...</span>
      event.target.value++;
    }
  });
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>如果我们点击按钮 —— 它的值就会增加。但不仅仅是按钮，一般的方法在这里也很重要。</p>
<p>我们可以根据需要使用 <code>data-counter</code> 特性，多少都可以。我们可以随时向 HTML 添加新的特性。使用事件委托，我们属于对 HTML 进行了“扩展”，添加了描述新行为的特性。</p>
<p>对于文档级的处理程序 —— 始终使用的是 <code>addEventListener</code>&quot; 当我们将事件处理程序分配给 <code>document</code>对象时，我们应该始终使用<code>addEventListener</code>，
而不是 <code>document.on&lt;event&gt;</code>，因为后者会引起冲突：新的处理程序会覆盖旧的处理程序。</p>
<p>对于实际项目来说。在 <code>document</code> 上有许多由代码的不同部分设置的处理程序，这是很正常的。</p>
<h3 id="行为：切换器">行为：切换器</h3>
<p>再举一个例子。点击一个具有 <code>data-toggle-id</code> 特性的元素将显示/隐藏具有给定 <code>id</code> 的元素：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">data-toggle-id</span>=<span class="hljs-string">&quot;subscribe-mail&quot;</span>&gt;</span>Show the subscription form<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;subscribe-mail&quot;</span> <span class="hljs-attr">hidden</span>&gt;</span>Your mail: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
    <span class="hljs-keyword">let</span> id = event.target.dataset.toggleId;
    <span class="hljs-keyword">if</span> (!id) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">let</span> elem = <span class="hljs-built_in">document</span>.getElementById(id);

    elem.hidden = !elem.hidden;
  });
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>让我们再次注意我们做了什么。现在，要向元素添加切换功能 —— 无需了解 JavaScript，只需要使用特性 <code>data-toggle-id</code> 即可。</p>
<p>这可能变得非常方便 —— 无需为每个这样的元素编写 JavaScript。只需要使用行为。文档级处理程序使其适用于页面的任意元素。</p>
<p>我们也可以组合单个元素上的多个行为。</p>
<p>“行为”模式可以替代 JavaScript 的小片段。</p>
<h2 id="总结">总结</h2>
<p>事件委托真的很酷！这是 DOM 事件最有用的模式之一。</p>
<p>它通常用于为许多相似的元素添加相同的处理，但不仅限于此。</p>
<p>算法：</p>
<ol>
<li>在容器（container）上放一个处理程序。</li>
<li>在处理程序中 —— 检查源元素 <code>event.target</code>。</li>
<li>如果事件发生在我们感兴趣的元素内，那么处理该事件。</li>
</ol>
<p>好处：</p>
<pre><code class="language-compare">+ 简化初始化并节省内存：无需添加许多处理程序。
+ 更少的代码：添加或移除元素时，无需添加/移除处理程序。
+ DOM 修改 ：我们可以使用 `innerHTML` 等，来批量添加/移除元素。</code></pre>
<p>事件委托也有其局限性：</p>
<pre><code class="language-compare">- 首先，事件必须冒泡。而有些事件不会冒泡。此外，低级别的处理程序不应该使用 `event.stopPropagation()`。
- 其次，委托可能会增加 CPU 负载，因为容器级别的处理程序会对容器中任意位置的事件做出反应，而不管我们是否对该事件感兴趣。但是，通常负载可以忽略不计，所以我们不考虑它。</code></pre>

      </fieldset>
      
      <fieldset id='_Aq5Ta5'>
      <legend>solution</legend>
      <p>当浏览器读取诸如 <code>onclick</code> 之类的 <code>on*</code> 特性（attribute）时，浏览器会根据其内容创建对应的处理程序。</p>
<p>对于 <code>onclick=&quot;handler()&quot;</code> 来说，函数是：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
  handler() <span class="hljs-comment">// onclick 的内容</span>
}</code></pre>
<p>现在我们可以看到 <code>handler()</code> 的返回值并没有被使用，也没有对结果产生影响。</p>
<p>修复起来很简单：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handler</span>(<span class="hljs-params"></span>) </span>{
    alert(<span class="hljs-string">&quot;...&quot;</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://w3.org&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;*!*return handler()*/!*&quot;</span>&gt;</span>w3.org<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre>
<p>我们也可以使用 <code>event.preventDefault()</code>，像这样：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
*!*
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handler</span>(<span class="hljs-params">event</span>) </span>{
    alert(<span class="hljs-string">&quot;...&quot;</span>);
    event.preventDefault();
  }
*/!*
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://w3.org&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;*!*handler(event)*/!*&quot;</span>&gt;</span>w3.org<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre>

      </fieldset>
      
      <fieldset id='_ZH7xMJ'>
      <legend>task</legend>
      <p>importance: 3</p>
<hr>
<h1 id="为什么-return-false-不起作用？">为什么 &quot;return false&quot; 不起作用？</h1>
<p>为什么下面这段代码中的 <code>return false</code> 不起作用？</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handler</span>(<span class="hljs-params"></span>) </span>{
    alert( <span class="hljs-string">&quot;...&quot;</span> );
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://w3.org&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;handler()&quot;</span>&gt;</span>the browser will go to w3.org<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre>
<p>浏览器在点击时会根据 URL 进行跳转，但这不是我们想要的。</p>
<p>如何修复它？</p>

      </fieldset>
      
      <fieldset id='_6C2i6B'>
      <legend>solution</legend>
      <p>这是一个很好的使用事件委托模式的案例。</p>
<p>在现实生活中，我们可以向服务器发送一个 &quot;logging&quot; 请求而不是询问，该请求会保存关于访问者离开位置的信息。或者，我们可以加载内容，并将其显示在页面中（如果允许的话）。</p>
<p>我们只需要捕获 <code>contents.onclick</code>，然后使用 <code>confirm</code> 来询问用户。一个好主意是使用 <code>link.getAttribute(&#39;href&#39;)</code> 来代替 <code>link.href</code>。详情请参见解决方案。</p>

      </fieldset>
      
      <fieldset id='_k3Io5P'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="捕获元素中的链接">捕获元素中的链接</h1>
<p>使所有包含 <code>id=&quot;contents&quot;</code> 的元素内的链接询问用户是否真的要离开。如果用户不想离开，那就不离开。</p>
<p>像这样：</p>
<p>[iframe height=100 border=1 src=&quot;solution&quot;]</p>
<p>细节：</p>
<ul>
<li>元素内的 HTML 可以被随时动态加载或重新生成，因此，我们无法找到所有链接并为其添加处理程序。这里使用事件委托。</li>
<li>内容中可能有嵌套的标签。链接中也是，例如 <code>&lt;a href=&quot;..&quot;&gt;&lt;i&gt;...&lt;/i&gt;&lt;/a&gt;</code>。</li>
</ul>

      </fieldset>
      
      <fieldset id='_QtKCOg'>
      <legend>solution</legend>
      <p>解决方案是将处理程序分配给容器，并追踪点击。如果点击在 <code>&lt;a&gt;</code> 链接上，则将 <code>#largeImg</code> 的 <code>src</code> 修改为该缩略图的 <code>href</code>。</p>

      </fieldset>
      
      <fieldset id='_3m0Ufe'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="图册">图册</h1>
<p>创建一个图册，通过点击缩略图可以更改主图片。</p>
<p>像这样：</p>
<p>[iframe src=&quot;solution&quot; height=600]</p>
<p>P.S. 使用事件委托。</p>

      </fieldset>
      
      <fieldset id='_RvFyx6'>
      <legend>article</legend>
      <h1 id="浏览器默认行为">浏览器默认行为</h1>
<p>许多事件会自动触发浏览器执行某些行为。</p>
<p>例如：</p>
<ul>
<li>点击一个链接 —— 触发导航（navigation）到该 URL。</li>
<li>点击表单的提交按钮 —— 触发提交到服务器的行为。</li>
<li>在文本上按下鼠标按钮并移动 —— 选中文本。</li>
</ul>
<p>如果我们使用 JavaScript 处理一个事件，那么我们通常不希望发生相应的浏览器行为。而是想要实现其他行为进行替代。</p>
<h2 id="阻止浏览器行为">阻止浏览器行为</h2>
<p>有两种方式来告诉浏览器我们不希望它执行默认行为：</p>
<ul>
<li>主流的方式是使用 <code>event</code> 对象。有一个 <code>event.preventDefault()</code> 方法。</li>
<li>如果处理程序是使用 <code>on&lt;event&gt;</code>（而不是 <code>addEventListener</code>）分配的，那返回 <code>false</code> 也同样有效。</li>
</ul>
<p>在下面这个示例中，点击链接不会触发导航（navigation），浏览器不会执行任何操作：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;return false&quot;</span>&gt;</span>Click here<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
or
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;event.preventDefault()&quot;</span>&gt;</span>here<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre>
<p>在下一个示例中，我们将使用此技术来创建 JavaScript 驱动的菜单。</p>
<p>```warn header=&quot;从处理程序返回 <code>false</code> 是一个例外&quot;
事件处理程序返回的值通常会被忽略。</p>
<p>唯一的例外是从使用 <code>on&lt;event&gt;</code> 分配的处理程序中返回的 <code>return false</code>。</p>
<p>在所有其他情况下，<code>return</code> 值都会被忽略。并且，返回 <code>true</code> 没有意义。</p>
<pre><code>
### 示例：菜单

考虑一个网站菜单，如下所示：

```html
&lt;ul id=&quot;menu&quot; class=&quot;menu&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;/html&quot;&gt;HTML&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/javascript&quot;&gt;JavaScript&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/css&quot;&gt;CSS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</code></pre>
<p>下面经过 CSS 渲染的外观：</p>
<p>[iframe height=70 src=&quot;menu&quot; link edit]</p>
<p>菜单项是通过使用 HTML 链接 <code>&lt;a&gt;</code> 实现的，而不是使用按钮 <code>&lt;button&gt;</code>。这样做有几个原因，例如：</p>
<ul>
<li>许多人喜欢使用“右键单击” —— “在一个新窗口打开链接”。如果我们使用 <code>&lt;button&gt;</code> 或 <code>&lt;span&gt;</code>，这个效果就无法实现。</li>
<li>搜索引擎在建立索引时遵循 <code>&lt;a href=&quot;...&quot;&gt;</code> 链接。</li>
</ul>
<p>因为我们在标记（markup）中使用了 <code>&lt;a&gt;</code>。但通常我们打算处理 JavaScript 中的点击。因此，我们应该阻止浏览器默认行为。</p>
<p>像这样：</p>
<pre><code class="language-js">menu.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
  <span class="hljs-keyword">if</span> (event.target.nodeName != <span class="hljs-string">&#x27;A&#x27;</span>) <span class="hljs-keyword">return</span>;

  <span class="hljs-keyword">let</span> href = event.target.getAttribute(<span class="hljs-string">&#x27;href&#x27;</span>);
  alert( href ); <span class="hljs-comment">// ...可以从服务器加载，UI 生成等</span>

*!*
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 阻止浏览器行为（不前往访问 URL）</span>
*/!*
};</code></pre>
<p>如果我们省略 <code>return false</code>，那么在我们的代码执行完毕后，浏览器将执行它的“默认行为” —— 导航至在 <code>href</code> 中的 URL。</p>
<p>顺便说一句，这里使用事件委托会使我们的菜单更灵活。我们可以添加嵌套列表并使用 CSS 对其进行样式设置来实现 &quot;slide down&quot; 的效果。</p>
<pre><code class="language-smart">某些事件会相互转化。如果我们阻止了第一个事件，那就没有第二个事件了。

例如，在 `&lt;input&gt;` 字段上的 `mousedown` 会导致在其中获得焦点，以及 `focus` 事件。如果我们阻止 `mousedown` 事件，在这就没有焦点了。

尝试点击下面的第一个 `&lt;input&gt;` —— 会发生 `focus` 事件。但是如果你点击第二个，则没有聚焦。

```html run autorun
&lt;input value=&quot;Focus works&quot; onfocus=&quot;this.value=&#x27;&#x27;&quot;&gt;
&lt;input *!*onmousedown=&quot;return false&quot;*/!* onfocus=&quot;this.value=&#x27;&#x27;&quot; value=&quot;Click me&quot;&gt;
```

这是因为浏览器行为在 `mousedown` 上被取消。如果我们用另一种方式进行输入，则仍然可以进行聚焦。例如，可以使用 `key:Tab` 键从第一个输入切换到第二个输入。但鼠标点击则不行。</code></pre>
<h2 id="处理程序选项-passive">处理程序选项 &quot;passive&quot;</h2>
<p><code>addEventListener</code> 的可选项 <code>passive: true</code> 向浏览器发出信号，表明处理程序将不会调用 <code>preventDefault()</code>。</p>
<p>为什么需要这样做？</p>
<p>移动设备上会发生一些事件，例如 <code>touchmove</code>（当用户在屏幕上移动手指时），默认情况下会导致滚动，但是可以使用处理程序的 <code>preventDefault()</code> 来阻止滚动。</p>
<p>因此，当浏览器检测到此类事件时，它必须首先处理所有处理程序，然后如果没有任何地方调用 <code>preventDefault</code>，则页面可以继续滚动。但这可能会导致 UI 中不必要的延迟和“抖动”。</p>
<p><code>passive: true</code> 选项告诉浏览器，处理程序不会取消滚动。然后浏览器立即滚动页面以提供最大程度的流畅体验，并通过某种方式处理事件。</p>
<p>对于某些浏览器（Firefox，Chrome），默认情况下，<code>touchstart</code> 和 <code>touchmove</code> 事件的 <code>passive</code> 为 <code>true</code>。</p>
<h2 id="eventdefaultprevented">event.defaultPrevented</h2>
<p>如果默认行为被阻止，那么 <code>event.defaultPrevented</code> 属性为 <code>true</code>，否则为 <code>false</code>。</p>
<p>这儿有一个有趣的用例。</p>
<p>你还记得我们在 <a href="info:bubbling-and-capturing">info:bubbling-and-capturing</a> 一章中讨论过的 <code>event.stopPropagation()</code>，以及为什么停止冒泡是不好的吗？</p>
<p>有时我们可以使用 <code>event.defaultPrevented</code> 来代替，来通知其他事件处理程序，该事件已经被处理。</p>
<p>我们来看一个实际的例子。</p>
<p>默认情况下，浏览器在 <code>contextmenu</code> 事件（单击鼠标右键）时，显示带有标准选项的上下文菜单。我们可以阻止它并显示我们自定义的菜单，就像这样：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>Right-click shows browser context menu<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">button</span> *!*<span class="hljs-attr">oncontextmenu</span>=<span class="hljs-string">&quot;alert(&#x27;Draw our menu&#x27;); return false&quot;</span>*/!*&gt;</span>
  Right-click shows our context menu
<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre>
<p>现在，除了该上下文菜单外，我们还想实现文档范围的上下文菜单。</p>
<p>右键单击时，应该显示最近的上下文菜单：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Right-click here for the document context menu<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;elem&quot;</span>&gt;</span>Right-click here for the button context menu<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  elem.oncontextmenu = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
    event.preventDefault();
    alert(<span class="hljs-string">&quot;Button context menu&quot;</span>);
  };

  <span class="hljs-built_in">document</span>.oncontextmenu = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
    event.preventDefault();
    alert(<span class="hljs-string">&quot;Document context menu&quot;</span>);
  };
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>问题是，当我们点击 <code>elem</code> 时，我们会得到两个菜单：按钮级和文档级（事件冒泡）的菜单。</p>
<p>如何修复呢？其中一个解决方案是：“当我们在按钮处理程序中处理鼠标右键单击事件时，我们阻止其冒泡”，使用 <code>event.stopPropagation()</code>：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Right-click for the document menu<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;elem&quot;</span>&gt;</span>Right-click for the button menu (fixed with event.stopPropagation)<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  elem.oncontextmenu = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
    event.preventDefault();
*!*
    event.stopPropagation();
*/!*
    alert(<span class="hljs-string">&quot;Button context menu&quot;</span>);
  };

  <span class="hljs-built_in">document</span>.oncontextmenu = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
    event.preventDefault();
    alert(<span class="hljs-string">&quot;Document context menu&quot;</span>);
  };
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>现在按钮级菜单如期工作。但是代价太大，我们永远拒绝访问外部代码中的有关右键单击的信息，包括收集统计信息的计数器等。这是非常不明智的。</p>
<p>另一个替代方案是，检查 <code>document</code> 处理程序是否阻止了浏览器的默认行为？如果阻止了，那么该事件已经得到了处理，我们无需再对此事件做出反应。</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Right-click for the document menu (added a check for event.defaultPrevented)<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;elem&quot;</span>&gt;</span>Right-click for the button menu<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  elem.oncontextmenu = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
    event.preventDefault();
    alert(<span class="hljs-string">&quot;Button context menu&quot;</span>);
  };

  <span class="hljs-built_in">document</span>.oncontextmenu = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
*!*
    <span class="hljs-keyword">if</span> (event.defaultPrevented) <span class="hljs-keyword">return</span>;
*/!*

    event.preventDefault();
    alert(<span class="hljs-string">&quot;Document context menu&quot;</span>);
  };
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>现在一切都可以正常工作了。如果我们有嵌套的元素，并且每个元素都有自己的上下文菜单，那么这也是可以运行的。只需确保检查每个 <code>contextmenu</code> 处理程序中的 <code>event.defaultPrevented</code>。</p>
<pre><code class="language-smart">正如我们所看到的，`event.stopPropagation()` 和 `event.preventDefault()`（也被认为是 `return false`）是两个不同的东西。它们之间毫无关联。</code></pre>
<pre><code class="language-smart">还有其他实现嵌套上下文菜单的方式。其中之一是拥有一个具有 `document.oncontextmenu` 处理程序的全局对象，以及使我们能够在其中存储其他处理程序的方法。

该对象将捕获任何右键单击，浏览存储的处理程序并运行适当的处理程序。

但是，每段需要上下文菜单的代码都应该了解该对象，并使用它的帮助，而不是使用自己的 `contextmenu` 处理程序。</code></pre>
<h2 id="总结">总结</h2>
<p>有很多默认的浏览器行为：</p>
<ul>
<li><code>mousedown</code> —— 开始选择（移动鼠标进行选择）。</li>
<li>在 <code>&lt;input type=&quot;checkbox&quot;&gt;</code> 上的 <code>click</code> —— 选中/取消选中的 <code>input</code>。</li>
<li><code>submit</code> —— 点击 <code>&lt;input type=&quot;submit&quot;&gt;</code> 或者在表单字段中按下 <code>key:Enter</code> 键会触发该事件，之后浏览器将提交表单。</li>
<li><code>keydown</code> —— 按下一个按键会导致将字符添加到字段，或者触发其他行为。</li>
<li><code>contextmenu</code> —— 事件发生在鼠标右键单击时，触发的行为是显示浏览器上下文菜单。</li>
<li>……还有更多……</li>
</ul>
<p>如果我们只想通过 JavaScript 来处理事件，那么所有默认行为都是可以被阻止的。</p>
<p>想要阻止默认行为 —— 可以使用 <code>event.preventDefault()</code> 或 <code>return false</code>。第二个方法只适用于通过 <code>on&lt;event&gt;</code> 分配的处理程序。</p>
<p><code>addEventListener</code> 的 <code>passive: true</code> 选项告诉浏览器该行为不会被阻止。这对于某些移动端的事件（像 <code>touchstart</code> 和 <code>touchmove</code>）很有用，用以告诉浏览器在滚动之前不应等待所有处理程序完成。</p>
<p>如果默认行为被阻止，<code>event.defaultPrevented</code> 的值会变成 <code>true</code>，否则为 <code>false</code>。</p>
<pre><code class="language-warn">从技术上来说，通过阻止默认行为并添加 JavaScript，我们可以自定义任何元素的行为。例如，我们可以使链接 `&lt;a&gt;` 像按钮一样工作，而按钮 `&lt;button&gt;` 也可以像链接那样工作（重定向到另一个 URL 等）。

但我们通常应该保留 HTML 元素的语义。例如 `&lt;a&gt;` 应该表现为导航（navigation），而不是按钮。

除了“只是一件好事”之外，这还会使你的 HTML 具有更好的可访问性。

另外，如果我们考虑使用带有 `&lt;a&gt;` 的示例，那么请注意：浏览器允许我们在新窗口中打开此类链接（通过右键单击它们以及其他方式）。大家都喜欢这么做。但是，如果我们使用 JavaScript 让按钮行为表现得像链接，甚至使用 CSS 将其样式设置成看起来也像链接，即使这样，但仍然无法在按钮上使用特定于 `&lt;a&gt;` 的浏览器功能。</code></pre>

      </fieldset>
      
      <fieldset id='_7bd5nT'>
      <legend>article</legend>
      <h1 id="创建自定义事件">创建自定义事件</h1>
<p>我们不仅可以分配事件处理程序，还可以从 JavaScript 生成事件。</p>
<p>自定义事件可用于创建“图形组件”。例如，我们自己的基于 JavaScript 的菜单的根元素可能会触发 <code>open</code>（打开菜单），<code>select</code>（有一项被选中）等事件来告诉菜单发生了什么。另一个代码可能会监听事件，并观察菜单发生了什么。</p>
<p>我们不仅可以生成出于自身目的而创建的全新事件，还可以生成例如 <code>click</code> 和 <code>mousedown</code> 等内建事件。这可能会有助于自动化测试。</p>
<h2 id="事件构造器">事件构造器</h2>
<p>内建事件类形成一个层次结构（hierarchy），类似于 DOM 元素类。根是内建的 <a href="http://www.w3.org/TR/dom/#event">Event</a> 类。</p>
<p>我们可以像这样创建 <code>Event</code> 对象：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> event = <span class="hljs-keyword">new</span> Event(type[, options]);</code></pre>
<p>参数：</p>
<ul>
<li><p><strong>type</strong> —— 事件类型，可以是像这样 <code>&quot;click&quot;</code> 的字符串，或者我们自己的像这样 <code>&quot;my-event&quot;</code> 的参数。</p>
</li>
<li><p><strong>options</strong> —— 具有两个可选属性的对象：</p>
<ul>
<li><code>bubbles: true/false</code> —— 如果为 <code>true</code>，那么事件会冒泡。</li>
<li><code>cancelable: true/false</code> —— 如果为 <code>true</code>，那么“默认行为”就会被阻止。稍后我们会看到对于自定义事件，它意味着什么。</li>
</ul>
<p>默认情况下，以上两者都为 false：<code>{bubbles: false, cancelable: false}</code>。</p>
</li>
</ul>
<h2 id="dispatchevent">dispatchEvent</h2>
<p>事件对象被创建后，我们应该使用 <code>elem.dispatchEvent(event)</code> 调用在元素上“运行”它。</p>
<p>然后，处理程序会对它做出反应，就好像它是一个常规的浏览器事件一样。如果事件是用 <code>bubbles</code> 标志创建的，那么它会冒泡。</p>
<p>在下面这个示例中，<code>click</code> 事件是用 JavaScript 初始化创建的。处理程序工作方式和点击按钮的方式相同：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;elem&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;Click!&#x27;);&quot;</span>&gt;</span>Autoclick<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">let</span> event = <span class="hljs-keyword">new</span> Event(<span class="hljs-string">&quot;click&quot;</span>);
  elem.dispatchEvent(event);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<pre><code class="language-smart">有一种方法可以区分“真实”用户事件和通过脚本生成的事件。

对于来自真实用户操作的事件，`event.isTrusted` 属性为 `true`，对于脚本生成的事件，`event.isTrusted` 属性为 `false`。</code></pre>
<h2 id="冒泡示例">冒泡示例</h2>
<p>我们可以创建一个名为 <code>&quot;hello&quot;</code> 的冒泡事件，并在 <code>document</code> 上捕获它。</p>
<p>我们需要做的就是将 <code>bubbles</code> 设置为 <code>true</code>：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;elem&quot;</span>&gt;</span>Hello from the script!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-comment">// 在 document 上捕获...</span>
  <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{ <span class="hljs-comment">// (1)</span>
    alert(<span class="hljs-string">&quot;Hello from &quot;</span> + event.target.tagName); <span class="hljs-comment">// Hello from H1</span>
  });

  <span class="hljs-comment">// ...在 elem 上 dispatch！</span>
  <span class="hljs-keyword">let</span> event = <span class="hljs-keyword">new</span> Event(<span class="hljs-string">&quot;hello&quot;</span>, {<span class="hljs-attr">bubbles</span>: <span class="hljs-literal">true</span>}); <span class="hljs-comment">// (2)</span>
  elem.dispatchEvent(event);

  <span class="hljs-comment">// 在 document 上的处理程序将被激活，并显示消息。</span>

</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>注意：</p>
<ol>
<li>我们应该对我们的自定义事件使用 <code>addEventListener</code>，因为 <code>on&lt;event&gt;</code> 仅存在于内建事件中，<code>document.onhello</code> 则无法运行。</li>
<li>必须设置 <code>bubbles:true</code>，否则事件不会向上冒泡。</li>
</ol>
<p>内建事件（<code>click</code>）和自定义事件（<code>hello</code>）的冒泡机制相同。自定义事件也有捕获阶段和冒泡阶段。</p>
<h2 id="mouseevent，keyboardevent-及其他">MouseEvent，KeyboardEvent 及其他</h2>
<p>这是一个摘自于 <a href="https://www.w3.org/TR/uievents">UI 事件规范</a> 的一个简短的 UI 事件类列表：</p>
<ul>
<li><code>UIEvent</code></li>
<li><code>FocusEvent</code></li>
<li><code>MouseEvent</code></li>
<li><code>WheelEvent</code></li>
<li><code>KeyboardEvent</code></li>
<li>...</li>
</ul>
<p>如果我们想要创建这样的事件，我们应该使用它们而不是 <code>new Event</code>。例如，<code>new MouseEvent(&quot;click&quot;)</code>。</p>
<p>正确的构造器允许为该类型的事件指定标准属性。</p>
<p>就像鼠标事件的 <code>clientX/clientY</code> 一样：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> event = <span class="hljs-keyword">new</span> MouseEvent(<span class="hljs-string">&quot;click&quot;</span>, {
  <span class="hljs-attr">bubbles</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">cancelable</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">clientX</span>: <span class="hljs-number">100</span>,
  <span class="hljs-attr">clientY</span>: <span class="hljs-number">100</span>
});

*!*
alert(event.clientX); <span class="hljs-comment">// 100</span>
*/!*</code></pre>
<p>请注意：通用的 <code>Event</code> 构造器不允许这样做。</p>
<p>让我们试试：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> event = <span class="hljs-keyword">new</span> Event(<span class="hljs-string">&quot;click&quot;</span>, {
  <span class="hljs-attr">bubbles</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 构造器 Event 中只有 bubbles 和 cancelable 可以工作</span>
  <span class="hljs-attr">cancelable</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">clientX</span>: <span class="hljs-number">100</span>,
  <span class="hljs-attr">clientY</span>: <span class="hljs-number">100</span>
});

*!*
alert(event.clientX); <span class="hljs-comment">// undefined，未知的属性被忽略了！</span>
*/!*</code></pre>
<p>从技术上讲，我们可以通过在创建后直接分配 <code>event.clientX=100</code> 来解决这个问题。所以，这是一个方便和遵守规则的问题。浏览器生成的事件始终具有正确的类型。</p>
<p>规范中提供了不同 UI 事件的属性的完整列表，例如 <a href="https://www.w3.org/TR/uievents/#mouseevent">MouseEvent</a>。</p>
<h2 id="自定义事件">自定义事件</h2>
<p>对于我们自己的全新事件类型，例如 <code>&quot;hello&quot;</code>，我们应该使用 <code>new CustomEvent</code>。从技术上讲，<a href="https://dom.spec.whatwg.org/#customevent">CustomEvent</a> 和 <code>Event</code> 一样。除了一点不同。</p>
<p>在第二个参数（对象）中，我们可以为我们想要与事件一起传递的任何自定义信息添加一个附加的属性 <code>detail</code>。</p>
<p>例如：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;elem&quot;</span>&gt;</span>Hello for John!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-comment">// 事件附带给处理程序的其他详细信息</span>
  elem.addEventListener(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
    alert(*!*event.detail.name*/!*);
  });

  elem.dispatchEvent(<span class="hljs-keyword">new</span> CustomEvent(<span class="hljs-string">&quot;hello&quot;</span>, {
*!*
    detail: { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> }
*/!*
  }));
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p><code>detail</code> 属性可以有任何数据。从技术上讲，我们可以不用，因为我们可以在创建后将任何属性分配给常规的 <code>new Event</code> 对象中。但是 <code>CustomEvent</code> 提供了特殊的 <code>detail</code> 字段，以避免与其他事件属性的冲突。</p>
<p>此外，事件类描述了它是“什么类型的事件”，如果事件是自定义的，那么我们应该使用 <code>CustomEvent</code> 来明确它是什么。</p>
<h2 id="eventpreventdefault">event.preventDefault()</h2>
<p>许多浏览器事件都有“默认行为”，例如，导航到链接，开始一个选择，等。</p>
<p>对于新的，自定义的事件，绝对没有默认的浏览器行为，但是分派（dispatch）此类事件的代码可能有自己的计划，触发该事件之后应该做什么。</p>
<p>通过调用 <code>event.preventDefault()</code>，事件处理程序可以发出一个信号，指出这些行为应该被取消。</p>
<p>在这种情况下，<code>elem.dispatchEvent(event)</code> 的调用会返回 <code>false</code>。那么分派（dispatch）该事件的代码就会知道不应该再继续。</p>
<p>让我们看一个实际的例子 —— 一只隐藏的兔子（可以是关闭菜单或者其他）。</p>
<p>在下面，你可以看到一个在其上分派了 <code>&quot;hide&quot;</code> 事件的 <code>#rabbit</code> 和 <code>hide()</code> 函数，以使所有感兴趣的各方面都知道这只兔子要隐藏起来。</p>
<p>任何处理程序都可以使用 <code>rabbit.addEventListener(&#39;hide&#39;,...)</code> 来监听该事件，并在需要时使用 <code>event.preventDefault()</code> 来取消该行为。然后兔子就不会藏起来了：</p>
<pre><code class="language-html">&lt;pre id=&quot;rabbit&quot;&gt;
  |\   /|
   \|_|/
   /. .\
  =\_Y_/=
   {&gt;o&lt;}
&lt;/pre&gt;
&lt;button onclick=&quot;hide()&quot;&gt;Hide()&lt;/button&gt;

&lt;script&gt;
  // hide() 将在 2 秒后被自动调用
  function hide() {
    let event = new CustomEvent(&quot;hide&quot;, {
      cancelable: true // 没有这个标志，preventDefault 将不起作用
    });
    if (!rabbit.dispatchEvent(event)) {
      alert(&#x27;The action was prevented by a handler&#x27;);
    } else {
      rabbit.hidden = true;
    }
  }

  rabbit.addEventListener(&#x27;hide&#x27;, function(event) {
    if (confirm(&quot;Call preventDefault?&quot;)) {
      event.preventDefault();
    }
  });
&lt;/script&gt;</code></pre>
<p>请注意：该事件必须具有 <code>cancelable: true</code> 标志，否则 <code>event.preventDefault()</code> 调用将会被忽略。</p>
<h2 id="事件中的事件是同步的">事件中的事件是同步的</h2>
<p>通常事件是在队列中处理的。也就是说：如果浏览器正在处理 <code>onclick</code>，这时发生了一个新的事件，例如鼠标移动了，那么它会被排入队列，相应的 <code>mousemove</code> 处理程序将在 <code>onclick</code> 事件处理完成后被调用。</p>
<p>值得注意的例外情况就是，一个事件是在另一个事件中发起的。例如使用 <code>dispatchEvent</code>。这类事件将会被立即处理，即在新的事件处理程序被调用之后，恢复到当前的事件处理程序。</p>
<p>例如，在下面的代码中，<code>menu-open</code> 事件是在 <code>onclick</code> 事件执行过程中被调用的。</p>
<p>它会被立即执行，而不必等待 <code>onclick</code> 处理程序结束：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;menu&quot;</span>&gt;</span>Menu (click me)<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  menu.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    alert(<span class="hljs-number">1</span>);

    menu.dispatchEvent(<span class="hljs-keyword">new</span> CustomEvent(<span class="hljs-string">&quot;menu-open&quot;</span>, {
      <span class="hljs-attr">bubbles</span>: <span class="hljs-literal">true</span>
    }));

    alert(<span class="hljs-number">2</span>);
  };

  <span class="hljs-comment">// 在 1 和 2 之间触发</span>
  <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;menu-open&#x27;</span>, <span class="hljs-function">() =&gt;</span> alert(<span class="hljs-string">&#x27;nested&#x27;</span>));
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>输出顺序为：1 -&gt; nested -&gt; 2。</p>
<p>请注意，嵌套事件 <code>menu-open</code> 会在 <code>document</code> 上被捕获。嵌套事件的传播（propagation）和处理先被完成，然后处理过程才会返回到外部代码（<code>onclick</code>）。</p>
<p>这不只是与 <code>dispatchEvent</code> 有关，还有其他情况。如果一个事件处理程序进一步触发了其它的事件 —— 它们同样也会被以嵌套的方式同步处理。</p>
<p>不过有时候，这并不是我们期望的结果。我们想让 <code>onclick</code> 不受 <code>menu-open</code> 或者其它嵌套事件的影响，优先被处理完毕。</p>
<p>那么，我们就可以将 <code>dispatchEvent</code>（或另一个触发事件的调用）放在 <code>onclick</code> 末尾，或者最好将其包装到零延迟的 <code>setTimeout</code> 中：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;menu&quot;</span>&gt;</span>Menu (click me)<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  menu.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    alert(<span class="hljs-number">1</span>);

    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> menu.dispatchEvent(<span class="hljs-keyword">new</span> CustomEvent(<span class="hljs-string">&quot;menu-open&quot;</span>, {
      <span class="hljs-attr">bubbles</span>: <span class="hljs-literal">true</span>
    })));

    alert(<span class="hljs-number">2</span>);
  };

  <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;menu-open&#x27;</span>, <span class="hljs-function">() =&gt;</span> alert(<span class="hljs-string">&#x27;nested&#x27;</span>));
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>现在，<code>dispatchEvent</code> 在当前代码执行完成之后异步运行，包括 <code>mouse.onclick</code>，因此，事件处理程序是完全独立的。</p>
<p>输出顺序变成：1 -&gt; 2 -&gt; nested。</p>
<h2 id="总结">总结</h2>
<p>要从代码生成一个事件，我们首先需要创建一个事件对象。</p>
<p>通用的 <code>Event(name, options)</code> 构造器接受任意事件名称和具有两个属性的 <code>options</code> 对象：</p>
<ul>
<li>如果事件应该冒泡，则 <code>bubbles: true</code>。</li>
<li>如果 <code>event.preventDefault()</code> 应该有效，则 <code>cancelable: true</code>。</li>
</ul>
<p>其他像 <code>MouseEvent</code> 和 <code>KeyboardEvent</code> 这样的原生事件的构造器，都接受特定于该事件类型的属性。例如，鼠标事件的 <code>clientX</code>。</p>
<p>对于自定义事件，我们应该使用 <code>CustomEvent</code> 构造器。它有一个名为 <code>detail</code> 的附加选项，我们应该将事件特定的数据分配给它。然后，所有处理程序可以以 <code>event.detail</code> 的形式来访问它。</p>
<p>尽管技术上有可能生成像 <code>click</code> 或 <code>keydown</code> 这样的浏览器事件，但我们还是应谨慎使用。</p>
<p>我们不应该生成浏览器事件，因为这是运行处理程序的一种怪异（hacky）方式。大多数时候，这都是一种糟糕的架构。</p>
<p>可以生成原生事件：</p>
<ul>
<li>如果第三方程序库不提供其他交互方式，那么这是使第三方程序库工作所需的一种肮脏手段。</li>
<li>对于自动化测试，要在脚本中“点击按钮”并查看接口是否正确响应。</li>
</ul>
<p>使用我们自己的名称的自定义事件通常是出于架构的目的而创建的，以指示发生在菜单（menu），滑块（slider），轮播（carousel）等内部发生了什么。</p>

      </fieldset>
      
      <fieldset id='_1mT5Nf'>
      <legend>solution</legend>
      
      </fieldset>
      
      <fieldset id='_Hmr8WL'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="可选列表">可选列表</h1>
<p>创建一个可以选择元素的列表，例如在文件管理器中。</p>
<ul>
<li>点击列表元素，只选择该元素（添加 <code>.selected</code> 类），取消选择其他所有元素。</li>
<li>如果点击时，按键 <code>key:Ctrl</code>（在 Mac 中为 <code>key:Cmd</code>）是被按下的，则选择会被切换到被点击的元素上，但其他元素不会被改动。</li>
</ul>
<p>示例：</p>
<p>[iframe border=&quot;1&quot; src=&quot;solution&quot; height=180]</p>
<p>P.S. 对于此任务，我们可以假设列表项是纯文本的。没有嵌套标签。</p>
<p>P.P.S. 防止点击时浏览器原生的文本选择。</p>

      </fieldset>
      
      <fieldset id='_2NX9zk'>
      <legend>article</legend>
      <h1 id="鼠标事件">鼠标事件</h1>
<p>在本章中，我们将详细介绍鼠标事件及其属性。</p>
<p>请注意：此类事件不仅可能来自于“鼠标设备”，还可能来自于对此类操作进行了模拟以实现兼容性的其他设备，例如手机和平板电脑。</p>
<h2 id="鼠标事件类型">鼠标事件类型</h2>
<p>我们已经见过了其中一些事件：</p>
<p><code>mousedown/mouseup</code>
: 在元素上点击/释放鼠标按钮。</p>
<p><code>mouseover/mouseout</code>
: 鼠标指针从一个元素上移入/移出。</p>
<p><code>mousemove</code>
: 鼠标在元素上的每个移动都会触发此事件。</p>
<p><code>click</code>
: 如果使用的是鼠标左键，则在同一个元素上的 <code>mousedown</code> 及 <code>mouseup</code> 相继触发后，触发该事件。</p>
<p><code>dblclick</code>
: 在短时间内双击同一元素后触发。如今已经很少使用了。</p>
<p><code>contextmenu</code>
: 在鼠标右键被按下时触发。还有其他打开上下文菜单的方式，例如使用特殊的键盘按键，在这种情况下它也会被触发，因此它并不完全是鼠标事件。</p>
<p>……还有其他几种事件，我们稍后会学习它们。</p>
<h2 id="事件顺序">事件顺序</h2>
<p>从上面的列表中我们可以看到，一个用户操作可能会触发多个事件。</p>
<p>例如，点击鼠标左键，在鼠标左键被按下时，会首先触发 <code>mousedown</code>，然后当鼠标左键被释放时，会触发 <code>mouseup</code> 和 <code>click</code>。</p>
<p>在单个动作触发多个事件时，事件的顺序是固定的。也就是说，会遵循 <code>mousedown</code> -&gt; <code>mouseup</code> -&gt; <code>click</code> 的顺序调用处理程序。</p>
<pre><code class="language-online">点击（译注：即单击）下面的按钮，你会看到事件。并尝试双击它。

在测试台下面记录了所有的鼠标事件，如果它们之间的延迟时间超过 1 秒，那么它们会被水平分割线分开。

我们还可以看出 `button` 属性允许检测鼠标按钮，演示示例如下。

&lt;input onmousedown=&quot;return logMouse(event)&quot; onmouseup=&quot;return logMouse(event)&quot; onclick=&quot;return logMouse(event)&quot; oncontextmenu=&quot;return logMouse(event)&quot; ondblclick=&quot;return logMouse(event)&quot; value=&quot;Click me with the right or the left mouse button&quot; type=&quot;button&quot;&gt; &lt;input onclick=&quot;logClear(&#x27;test&#x27;)&quot; value=&quot;Clear&quot; type=&quot;button&quot;&gt; &lt;form id=&quot;testform&quot; name=&quot;testform&quot;&gt; &lt;textarea style=&quot;font-size:12px;height:150px;width:360px;&quot;&gt;&lt;/textarea&gt;&lt;/form&gt;</code></pre>
<h2 id="鼠标按钮">鼠标按钮</h2>
<p>与点击相关的事件始终具有 <code>button</code> 属性，该属性允许获取确切的鼠标按钮。 </p>
<p>通常我们不在 <code>click</code> 和 <code>contextmenu</code> 事件中使用这一属性，因为前者只在单击鼠标左键时触发，后者只在单击鼠标右键时触发。</p>
<p>不过，在 <code>mousedown</code> 和 <code>mouseup</code> 事件中则可能需要用到 <code>event.button</code>，因为这两个事件在任何按键上都会触发，所以我们可以使用 <code>button</code> 属性来区分是左键单击还是右键单击。</p>
<p><code>event.button</code> 的所有可能值如下：</p>
<table>
<thead>
<tr>
<th>鼠标按键状态</th>
<th><code>event.button</code></th>
</tr>
</thead>
<tbody><tr>
<td>左键 (主要按键)</td>
<td>0</td>
</tr>
<tr>
<td>中键 (辅助按键)</td>
<td>1</td>
</tr>
<tr>
<td>右键 (次要按键)</td>
<td>2</td>
</tr>
<tr>
<td>X1 键 (后退按键)</td>
<td>3</td>
</tr>
<tr>
<td>X2 键 (前进按键)</td>
<td>4</td>
</tr>
</tbody></table>
<p>大多数鼠标设备只有左键和右键，对应的值就是 <code>0</code> 和 <code>2</code>。触屏设备中的点按操作也会触发类似的事件。</p>
<p>另外，还有一个 <code>event.buttons</code> 属性，其中以整数的形式存储着当前所有按下的鼠标按键，每个按键一个比特位。在实际开发中，很少会用到这个属性，如果有需要的话，你可以在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/buttons">MDN</a> 中找到更多细节。</p>
<p>```warn header=&quot;过时的 <code>event.which</code>&quot;
一些老代码可能会使用 <code>event.which</code> 属性来获得按下的按键。这是一个古老的非标准的方式，具有以下可能值：</p>
<ul>
<li><code>event.which == 1</code> —— 鼠标左键，</li>
<li><code>event.which == 2</code> —— 鼠标中键，</li>
<li><code>event.which == 3</code> —— 鼠标右键。</li>
</ul>
<p>现在，<code>event.which</code> 已经被弃用了，不应再使用它。</p>
<pre><code>
## 组合键：shift，alt，ctrl，meta

所有的鼠标事件都包含有关按下的组合键的信息。

事件属性：

- `shiftKey`：`key:Shift`
- `altKey`：`key:Alt`（或对于 Mac 是 `key:Opt`）
- `ctrlKey`：`key:Ctrl`
- `metaKey`：对于 Mac 是 `key:Cmd`

如果在事件期间按下了相应的键，则它们为 `true`。

比如，下面这个按钮仅在 `key:Alt+Shift`+click 时才有效：

```html autorun height=60
&lt;button id=&quot;button&quot;&gt;Alt+Shift+Click on me!&lt;/button&gt;

&lt;script&gt;
  button.onclick = function(event) {
*!*
    if (event.altKey &amp;&amp; event.shiftKey) {
*/!*
      alert(&#x27;Hooray!&#x27;);
    }
  };
&lt;/script&gt;</code></pre>
<p>```warn header=&quot;注意：在 Mac 上我们通常使用 <code>Cmd</code> 代替 <code>Ctrl</code>&quot;
在 Windows 和 Linux 上有 <code>key:Alt</code>，<code>key:Shift</code> 和 <code>key:Ctrl</code>。在 Mac 上还有：<code>key:Cmd</code>，它对应于属性 <code>metaKey</code>。</p>
<p>在大多数情况下，当在 Windows/Linux 上使用 <code>key:Ctrl</code> 时，在 Mac 是使用 <code>key:Cmd</code>。</p>
<p>也就说：当 Windows 用户按下 <code>key:Ctrl+Enter</code> 或 <code>key:Ctrl+A</code> 时，Mac 用户会按下 <code>key:Cmd+Enter</code> 或 <code>key:Cmd+A</code>，以此类推。</p>
<p>因此，如果我们想支持 <code>key:Ctrl</code>+click，那么对于 Mac 应该使用 <code>key:Cmd</code>+click。对于 Mac 用户而言，这更舒适。</p>
<p>即使我们想强制 Mac 用户使用 <code>key:Ctrl</code>+click —— 这非常困难。问题是：在 MacOS 上左键单击和 <code>key:Ctrl</code> 一起使用会被解释为 <strong>右键单击</strong>，并且会生成 <code>contextmenu</code> 事件，而不是像 Windows/Linux 中的 <code>click</code> 事件。</p>
<p>因此，如果我们想让所有操作系统的用户都感到舒适，那么我们应该将 <code>ctrlKey</code> 与 <code>metaKey</code> 一起进行检查。</p>
<p>对于 JS 代码，这意味着我们应该检查 <code>if (event.ctrlKey || event.metaKey)</code>。</p>
<pre><code>
```warn header=&quot;还有移动设备&quot;
键盘组合是工作流的一个补充。这样，如果访客使用键盘操作 —— 它们就会起作用。

但是，如果访客的设备没有键盘 —— 那么这里应该有另一种不使用键盘也能做到这一点的方式。</code></pre>
<h2 id="坐标：clientxy，pagexy">坐标：clientX/Y，pageX/Y</h2>
<p>所有的鼠标事件都提供了两种形式的坐标：</p>
<ol>
<li>相对于窗口的坐标：<code>clientX</code> 和 <code>clientY</code>。</li>
<li>相对于文档的坐标：<code>pageX</code> 和 <code>pageY</code>。</li>
</ol>
<p>我们已经在 <a href="info:coordinates">info:coordinates</a> 中解释过它们之间的区别。</p>
<p>简而言之，相对于文档的坐标 <code>pageX/Y</code> 以文档的左上角为参照物，并且同一位置的坐标不随页面的滚动而改变。相对于窗口的坐标 <code>clientX/Y</code> 以当前窗口的左上角为参照物，并且同一位置的坐标会随着页面的滚动而改变。</p>
<p>例如，如果我们有一个大小为 500x500 的窗口，并且鼠标在左上角，那么 <code>clientX</code> 和 <code>clientY</code> 均为 <code>0</code>，无论页面如何滚动。</p>
<p>如果鼠标位于中间，那么 <code>clientX</code> 和 <code>clientY</code> 均为 <code>250</code>。这与它在文档中的位置无关。在这方面，它们类似于 <code>position:fixed</code>。</p>
<pre><code class="language-online">将鼠标移动到输入字段上，可以看到 `clientX/clientY`（此示例位于 `iframe` 中，因此坐标是相对于 `iframe` 的）：

```html autorun height=50
&lt;input onmousemove=&quot;this.value=event.clientX+&#x27;:&#x27;+event.clientY&quot; value=&quot;Mouse over me&quot;&gt;
```</code></pre>
<h2 id="防止在鼠标按下时的选择">防止在鼠标按下时的选择</h2>
<p>双击鼠标会有副作用，在某些界面中可能会出现干扰：它会选择文本。</p>
<p>比如，双击下面的文本，除了我们的处理程序外，还会选择文本：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">ondblclick</span>=<span class="hljs-string">&quot;alert(&#x27;dblclick&#x27;)&quot;</span>&gt;</span>Double-click me<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre>
<p>如果按下鼠标左键，并在不松开的情况下移动鼠标，这也常常会造成不必要的选择。</p>
<p>有多种防止选择的方法，你可以在 <a href="info:selection-range">info:selection-range</a> 一章中详细阅读。</p>
<p>在这种情况下，最合理的方式是防止浏览器对 <code>mousedown</code> 进行操作。这样能够阻止刚刚提到的两种选择：</p>
<pre><code class="language-html">Before...
<span class="hljs-tag">&lt;<span class="hljs-name">b</span> <span class="hljs-attr">ondblclick</span>=<span class="hljs-string">&quot;alert(&#x27;Click!&#x27;)&quot;</span> *!*<span class="hljs-attr">onmousedown</span>=<span class="hljs-string">&quot;return false&quot;</span>*/!*&gt;</span>
  Double-click me
<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span>
...After</code></pre>
<p>现在，在双击时，粗体元素不会被选中，并且在粗体元素上按下鼠标左键也不会开始选择。</p>
<p>请注意：其中的文本仍然是可选择的。但是，选择不应该开始于该文本自身，而应该在该文本之前或之后开始。通常，这对用户来说挺好的。</p>
<pre><code class="language-smart">如果我们想禁用选择以保护我们页面的内容不被复制粘贴，那么我们可以使用另一个事件：`oncopy`。

```html autorun height=80 no-beautify
&lt;div *!*oncopy=&quot;alert(&#x27;Copying forbidden!&#x27;);return false&quot;*/!*&gt;
  Dear user,
  The copying is forbidden for you.
  If you know JS or HTML, then you can get everything from the page source though.
&lt;/div&gt;
```
如果你试图在 `&lt;div&gt;` 中复制一段文本，这是行不通的，因为默认行为 `oncopy` 被阻止了。

当然，用户可以访问页面的 HTML 源码，并且可以从那里获取内容，但并不是每个人都知道如何做到这一点。</code></pre>
<h2 id="总结">总结</h2>
<p>鼠标事件有以下属性：</p>
<ul>
<li><p>按钮：<code>button</code>。</p>
</li>
<li><p>组合键（如果被按下则为 <code>true</code>）：<code>altKey</code>，<code>ctrlKey</code>，<code>shiftKey</code> 和 <code>metaKey</code>（Mac）。</p>
<ul>
<li>如果你想处理 <code>key:Ctrl</code>，那么不要忘记 Mac 用户，他们通常使用的是 <code>key:Cmd</code>，所以最好检查 <code>if (e.metaKey || e.ctrlKey)</code>。</li>
</ul>
</li>
<li><p>窗口相对坐标：<code>clientX/clientY</code>。</p>
</li>
<li><p>文档相对坐标：<code>pageX/pageY</code>。</p>
</li>
</ul>
<p><code>mousedown</code> 的默认浏览器操作是文本选择，如果它对界面不利，则应避免它。</p>
<p>在下一章中，我们将看到有关鼠标指针移动后的事件，以及如何跟踪其下元素变化的更多详细信息。</p>

      </fieldset>
      
      <fieldset id='_iihVv5'>
      <legend>solution</legend>
      
      </fieldset>
      
      <fieldset id='_RLroBe'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="改进的工具提示行为">改进的工具提示行为</h1>
<p>编写 JavaScript，在带有 <code>data-tooltip</code> 特性（attribute）的元素上显示一个工具提示。该特性的值应该成为工具提示的文本。</p>
<p>与任务 <a href="info:task/behavior-tooltip">info:task/behavior-tooltip</a> 类似，但这里可以嵌套带有注解（annotated）的元素。并且显示的是嵌套最深的工具提示。</p>
<p>同一时间只能显示一个工具提示。</p>
<p>例如：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-tooltip</span>=<span class="hljs-string">&quot;Here – is the house interior&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;house&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-tooltip</span>=<span class="hljs-string">&quot;Here – is the roof&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;roof&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  ...
  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://en.wikipedia.org/wiki/The_Three_Little_Pigs&quot;</span> <span class="hljs-attr">data-tooltip</span>=<span class="hljs-string">&quot;Read on…&quot;</span>&gt;</span>Hover over me<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>在 iframe 中的结果：</p>
<p>[iframe src=&quot;solution&quot; height=300 border=1]</p>

      </fieldset>
      
      <fieldset id='_cpQIOk'>
      <legend>solution</legend>
      <p>算法看起来很简单：</p>
<ol>
<li>将 <code>onmouseover/out</code> 处理程序放在元素上。在这里也可以使用 <code>onmouseenter/leave</code>，但是它们的通用性较差，如果我们想引入事件委托时，它则无法使用。</li>
<li>当鼠标指针进入元素时，开始测量 <code>mousemove</code> 上的速度。</li>
<li>如果速度慢，则运行 <code>over</code>。</li>
<li>当我们的鼠标指针要移出元素，并且 <code>over</code> 也执行了，则会运行 <code>out</code>。</li>
</ol>
<p>但是如何测量速度？</p>
<p>第一个想法是：每 <code>100ms</code> 运行一次函数，并测量前坐标和新坐标之间的距离。如果很小，那么速度就很小。</p>
<p>不幸的是，在 JavaScript 中无法获取“鼠标当前坐标”。没有像 <code>getCurrentMouseCoordinates()</code> 这样的函数。</p>
<p>获取坐标的唯一方法是监听例如 <code>mousemove</code> 这样的鼠标事件。</p>
<p>因此，我们可以在 <code>mousemove</code> 上设置一个处理程序来跟踪坐标并记住它们。然后我每 <code>100ms</code> 比较一次。</p>
<p>P.S. 请注意：解决方案测试使用 <code>dispatchEvent</code> 来检查工具提示是否正确。</p>

      </fieldset>
      
      <fieldset id='_Ra5Sy8'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="智能工具提示">“智能”工具提示</h1>
<p>编写一个函数，该函数仅在访问者将鼠标 <strong>移至</strong> 元素而不是 <strong>移过</strong> 元素的情况下，在该元素上显示工具提示。</p>
<p>换句话说，如果访问者将鼠标移至元素上，并停下来 —— 显示工具提示。如果他们只是将鼠标移过元素，那就没必要显示，谁想要多余的闪烁呢？</p>
<p>从技术上说，我们可以测量元素上的鼠标移动速度，如果速度很慢，那么我们就假定它 <strong>在元素上</strong>，并显示工具提示，如果速度很快 —— 那么我们就忽略它。</p>
<p>为此，我们创建一个通用对象 <code>new HoverIntent(options)</code>。</p>
<p>其 <code>options</code>：</p>
<ul>
<li><code>elem</code> —— 要跟踪的元素。</li>
<li><code>over</code> —— 鼠标移动到元素上时要调用的函数：即，鼠标在元素上的移动速度很慢，或者停在该元素上。</li>
<li><code>out</code> —— 当鼠标离开元素时调用的函数（如果 <code>over</code> 已经被调用过了）。</li>
</ul>
<p>在工具提示中使用此类对象的示例：</p>
<pre><code class="language-js"><span class="hljs-comment">// 一个简单的工具提示</span>
<span class="hljs-keyword">let</span> tooltip = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);
tooltip.className = <span class="hljs-string">&quot;tooltip&quot;</span>;
tooltip.innerHTML = <span class="hljs-string">&quot;Tooltip&quot;</span>;

<span class="hljs-comment">// 该对象将跟踪鼠标，并调用 over/out</span>
<span class="hljs-keyword">new</span> HoverIntent({
  elem,
  <span class="hljs-function"><span class="hljs-title">over</span>(<span class="hljs-params"></span>)</span> {
    tooltip.style.left = elem.getBoundingClientRect().left + <span class="hljs-string">&#x27;px&#x27;</span>;
    tooltip.style.top = elem.getBoundingClientRect().bottom + <span class="hljs-number">5</span> + <span class="hljs-string">&#x27;px&#x27;</span>;
    <span class="hljs-built_in">document</span>.body.append(tooltip);
  },
  <span class="hljs-function"><span class="hljs-title">out</span>(<span class="hljs-params"></span>)</span> {
    tooltip.remove();
  }
});</code></pre>
<p>示例：</p>
<p>[iframe src=&quot;solution&quot; height=140]</p>
<p>如果你将鼠标快速地从“时钟”上移动过去，那么什么都不会发生，如果你使用鼠标在“时钟”上慢慢移动，或者停在“时钟”上，则会出现一个工具提示。</p>
<p>请注意：当鼠标指针在“时钟”的元素之间移动时，工具提示不会“闪烁”</p>

      </fieldset>
      
      <fieldset id='_mMX8Sj'>
      <legend>article</legend>
      <h1 id="移动鼠标：mouseoverout，mouseenterleave">移动鼠标：mouseover/out，mouseenter/leave</h1>
<p>我们将深入研究鼠标在元素之间移动时发生的事件。</p>
<h2 id="事件-mouseovermouseout，relatedtarget">事件 mouseover/mouseout，relatedTarget</h2>
<p>当鼠标指针移到某个元素上时，<code>mouseover</code> 事件就会发生，而当鼠标离开该元素时，<code>mouseout</code> 事件就会发生。</p>
<p><img src="./root/event-details/mousemove-mouseover-mouseout-mouseenter-mouseleave/mouseover-mouseout.svg" alt=""></p>
<p>这些事件很特别，因为它们具有 <code>relatedTarget</code> 属性。此属性是对 <code>target</code> 的补充</p>
<p>对于 <code>mouseover</code>：</p>
<ul>
<li><code>event.target</code> —— 是鼠标移过的那个元素。</li>
<li><code>event.relatedTarget</code> —— 是鼠标来自的那个元素（<code>relatedTarget</code> -&gt; <code>target</code>）。</li>
</ul>
<p><code>mouseout</code> 则与之相反：</p>
<ul>
<li><code>event.target</code> —— 是鼠标离开的元素。</li>
<li><code>event.relatedTarget</code> —— 是鼠标移动到的，当前指针位置下的元素（<code>target</code> -&gt; <code>relatedTarget</code>）。</li>
</ul>
<iframe src="./root/event-details/mousemove-mouseover-mouseout-mouseenter-mouseleave/mouseoverout.view/index.html" height="300" width="100%"></iframe>

<p><code>relatedTarget</code>属性可以为<code>null</code>。这是正常现象，仅仅是意味着鼠标不是来自另一个元素，而是来自窗口之外。或者它离开了窗口。</p>
<h2 id="跳过元素">跳过元素</h2>
<p>当鼠标移动时，就会触发 <code>mousemove</code> 事件。但这并不意味着每个像素都会导致一个事件。如果访问者非常快地移动鼠标，那么某些 DOM 元素就可能被跳过：</p>
<p><img src="./root/event-details/mousemove-mouseover-mouseout-mouseenter-mouseleave/mouseover-mouseout-over-elems.svg" alt=""></p>
<p>如果鼠标从上图所示的 <code>#FROM</code> 快速移动到 <code>#TO</code> 元素，则中间的 <code>&lt;div&gt;</code>（或其中的一些）元素可能会被跳过。<code>mouseout</code> 事件可能会在 <code>#FROM</code> 上被触发，然后立即在 <code>#TO</code> 上触发 <code>mouseover</code>。</p>
<p>这对性能很有好处，因为可能有很多中间元素。我们并不真的想要处理每一个移入和离开的过程。</p>
<p>特别是，鼠标指针可能会从窗口外跳到页面的中间。在这种情况下，<code>relatedTarget</code> 为 <code>null</code>：</p>
<p><img src="./root/event-details/mousemove-mouseover-mouseout-mouseenter-mouseleave/mouseover-mouseout-from-outside.svg" alt=""></p>
<iframe src="./root/event-details/mousemove-mouseover-mouseout-mouseenter-mouseleave/mouseoverout-fast.view/index.html" height="400" width="100%"></iframe>

<p>如果 <code>mouseover</code>被触发了，则必须有<code>mouseout</code>&quot; 在鼠标快速移动的情况下，中间元素可能会被忽略，
但是我们可以肯定一件事：如果鼠标指针“正式地”进入了一个元素（生成了 <code>mouseover</code>事件），那么一旦它离开，我们就会得到<code>mouseout</code>。</p>
<h2 id="当移动到一个子元素时-mouseout">当移动到一个子元素时 mouseout</h2>
<p><code>mouseout</code> 的一个重要功能 —— 当鼠标指针从元素移动到其后代时触发，例如在下面的这个 HTML 中，从 <code>#parent</code> 到 <code>#child</code>：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>如果我们在 <code>#parent</code> 上，然后将鼠标指针更深入地移入 <code>#child</code>，但是在 <code>#parent</code> 上会得到 <code>mouseout</code>！</p>
<p><img src="./root/event-details/mousemove-mouseover-mouseout-mouseenter-mouseleave/mouseover-to-child.svg" alt=""></p>
<p>因此，如果它转到另一个元素（甚至是一个后代），那么它将离开前一个元素。</p>
<p>请注意事件处理的另一个重要的细节。后代的 <code>mouseover</code> 事件会冒泡。因此，如果 <code>#parent</code> 具有 <code>mouseover</code> 处理程序，它将被触发：</p>
<p><img src="./root/event-details/mousemove-mouseover-mouseout-mouseenter-mouseleave/mouseover-bubble-nested.svg" alt=""></p>
<p>你可以在下面这个示例中很清晰地看到这一点：<code>&lt;div id=&quot;child&quot;&gt;</code> 位于 <code>&lt;div id=&quot;parent&quot;&gt;</code> 内部。<code>#parent</code> 元素上有 <code>mouseover/out</code> 的处理程序，这些处理程序用于输出事件详细信息。</p>
<p>如果你将鼠标从 <code>#parent</code> 移动到 <code>#child</code>，那么你会看到在 <code>#parent</code> 上有两个事件:</p>
<ol>
<li><code>mouseout [target: parent]</code>（离开 parent），然后</li>
<li><code>mouseover [target: child]</code>（来到 child，冒泡）。</li>
</ol>
<iframe src="./root/event-details/mousemove-mouseover-mouseout-mouseenter-mouseleave/mouseoverout-child.view/index.html" height="400" width="100%"></iframe>

<p>如上例所示，当鼠标指针从 <code>#parent</code> 元素移动到 <code>#child</code> 时，会在父元素上触发两个处理程序：<code>mouseout</code> 和 <code>mouseover</code>：</p>
<pre><code class="language-js">parent.onmouseout = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
  <span class="hljs-comment">/* event.target: parent element */</span>
};
parent.onmouseover = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
  <span class="hljs-comment">/* event.target: child element (bubbled) */</span>
};</code></pre>
<p><strong>如果我们不检查处理程序中的 <code>event.target</code>，那么似乎鼠标指针离开了 <code>#parent</code> 元素，然后立即回到了它上面。</strong></p>
<p>但是事实并非如此！鼠标指针仍然位于父元素上，它只是更深入地移入了子元素。</p>
<p>如果离开父元素时有一些行为（action），例如一个动画在 <code>parent.onmouseout</code> 中运行，当鼠标指针深入 <code>#parent</code> 时，我们并不希望发生这种行为。</p>
<p>为了避免它，我们可以在处理程序中检查 <code>relatedTarget</code>，如果鼠标指针仍在元素内，则忽略此类事件。</p>
<p>另外，我们可以使用其他事件：<code>mouseenter</code> 和 <code>mouseleave</code>，它们没有此类问题，接下来我们就对其进行详细介绍。</p>
<h2 id="事件-mouseenter-和-mouseleave">事件 mouseenter 和 mouseleave</h2>
<p>事件 <code>mouseenter/mouseleave</code> 类似于 <code>mouseover/mouseout</code>。它们在鼠标指针进入/离开元素时触发。</p>
<p>但是有两个重要的区别：</p>
<ol>
<li>元素内部与后代之间的转换不会产生影响。</li>
<li>事件 <code>mouseenter/mouseleave</code> 不会冒泡。</li>
</ol>
<p>这些事件非常简单。</p>
<p>当鼠标指针进入一个元素时 —— 会触发 <code>mouseenter</code>。而鼠标指针在元素或其后代中的确切位置无关紧要。</p>
<p>当鼠标指针离开该元素时，事件 <code>mouseleave</code> 才会触发。</p>
<iframe src="./root/event-details/mousemove-mouseover-mouseout-mouseenter-mouseleave/mouseleave.view/index.html" height="400" width="100%"></iframe>

<h2 id="事件委托">事件委托</h2>
<p>假设我们要处理表格的单元格的鼠标进入/离开。并且这里有数百个单元格。</p>
<p>通常的解决方案是在 <code>&lt;table&gt;</code> 中设置处理程序，并在那里处理事件。</p>
<p><code>mouseenter/leave</code> 的处理程序仅在鼠标指针进入/离开整个表格时才会触发,不会冒泡，无法获得<code>&lt;table&gt;</code>内部的任何信息，我们不能使用它们来进行事件委托。</p>
<p>因此，让我们使用 <code>mouseover/mouseout</code>。</p>
<p>让我们从高亮显示鼠标指针下的元素的简单处理程序开始：</p>
<pre><code class="language-js"><span class="hljs-comment">// 高亮显示鼠标指针下的元素</span>
table.onmouseover = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
  <span class="hljs-keyword">let</span> target = event.target;
  target.style.background = <span class="hljs-string">&quot;pink&quot;</span>;
};

table.onmouseout = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
  <span class="hljs-keyword">let</span> target = event.target;
  target.style.background = <span class="hljs-string">&quot;&quot;</span>;
};</code></pre>
<iframe src="./root/event-details/mousemove-mouseover-mouseout-mouseenter-mouseleave/mouseenter-mouseleave-delegation.view/index.html" height="500" width="100%"></iframe>

<p>我们只关心单元格<code>&lt;td&gt;</code>，就需把其他过滤掉。</p>
<p>我们可以这样做：</p>
<ul>
<li>在变量中记住当前被高亮显示的 <code>&lt;td&gt;</code>，让我们称它为 <code>currentElem</code>。</li>
<li><code>mouseover</code> —— 如果我们仍然在当前的 <code>&lt;td&gt;</code> 中，则忽略该事件。</li>
<li><code>mouseout</code> —— 如果没有离开当前的 <code>&lt;td&gt;</code>，则忽略。</li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">// 现在位于鼠标下方的 &lt;td&gt;（如果有）</span>
<span class="hljs-keyword">let</span> currentElem = <span class="hljs-literal">null</span>;

table.onmouseover = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
  <span class="hljs-comment">// 在进入一个新的元素前，鼠标总是会先离开前一个元素</span>
  <span class="hljs-comment">// 如果设置了 currentElem，那么我们就没有鼠标所悬停在的前一个 &lt;td&gt;，</span>
  <span class="hljs-comment">// 忽略此事件</span>
  <span class="hljs-keyword">if</span> (currentElem) <span class="hljs-keyword">return</span>;

  <span class="hljs-keyword">let</span> target = event.target.closest(<span class="hljs-string">&quot;td&quot;</span>);

  <span class="hljs-comment">// 我们移动到的不是一个 &lt;td&gt; —— 忽略</span>
  <span class="hljs-keyword">if</span> (!target) <span class="hljs-keyword">return</span>;

  <span class="hljs-comment">// 现在移动到了 &lt;td&gt; 上，但在处于了我们表格的外部（可能因为是嵌套的表格）</span>
  <span class="hljs-comment">// 忽略</span>
  <span class="hljs-keyword">if</span> (!table.contains(target)) <span class="hljs-keyword">return</span>;

  <span class="hljs-comment">// 给力！我们进入了一个新的 &lt;td&gt;</span>
  currentElem = target;
  onEnter(currentElem);
};

table.onmouseout = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
  <span class="hljs-comment">// 如果我们现在处于所有 &lt;td&gt; 的外部，则忽略此事件</span>
  <span class="hljs-comment">// 这可能是一个表格内的移动，但是在 &lt;td&gt; 外，</span>
  <span class="hljs-comment">// 例如从一个 &lt;tr&gt; 到另一个 &lt;tr&gt;</span>
  <span class="hljs-keyword">if</span> (!currentElem) <span class="hljs-keyword">return</span>;

  <span class="hljs-comment">// 我们将要离开这个元素 —— 去哪儿？可能是去一个后代？</span>
  <span class="hljs-keyword">let</span> relatedTarget = event.relatedTarget;

  <span class="hljs-keyword">while</span> (relatedTarget) {
    <span class="hljs-comment">// 到父链上并检查 —— 我们是否还在 currentElem 内</span>
    <span class="hljs-comment">// 然后发现，这只是一个内部移动 —— 忽略它</span>
    <span class="hljs-keyword">if</span> (relatedTarget == currentElem) <span class="hljs-keyword">return</span>;

    relatedTarget = relatedTarget.parentNode;
  }

  <span class="hljs-comment">// 我们离开了 &lt;td&gt;。真的。</span>
  onLeave(currentElem);
  currentElem = <span class="hljs-literal">null</span>;
};

<span class="hljs-comment">// 任何处理进入/离开一个元素的函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onEnter</span>(<span class="hljs-params">elem</span>) </span>{
  elem.style.background = <span class="hljs-string">&quot;pink&quot;</span>;

  <span class="hljs-comment">// 在文本区域显示它</span>
  text.value += <span class="hljs-string">`over -&gt; <span class="hljs-subst">${currentElem.tagName}</span>.<span class="hljs-subst">${currentElem.className}</span>\n`</span>;
  text.scrollTop = <span class="hljs-number">1e6</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onLeave</span>(<span class="hljs-params">elem</span>) </span>{
  elem.style.background = <span class="hljs-string">&quot;&quot;</span>;

  <span class="hljs-comment">// 在文本区域显示它</span>
  text.value += <span class="hljs-string">`out &lt;- <span class="hljs-subst">${elem.tagName}</span>.<span class="hljs-subst">${elem.className}</span>\n`</span>;
  text.scrollTop = <span class="hljs-number">1e6</span>;
}</code></pre>
<p>再次，重要的功能是：</p>
<ol>
<li>它使用事件委托来处理表格中任何 <code>&lt;td&gt;</code> 的进入/离开。因此，它依赖于 <code>mouseover/out</code> 而不是 <code>mouseenter/leave</code>，<code>mouseenter/leave</code> 不会冒泡，因此也不允许事件委托。</li>
<li>额外的事件，例如在 <code>&lt;td&gt;</code> 的后代之间移动都会被过滤掉，因此 <code>onEnter/Leave</code> 仅在鼠标指针进入/离开 <code>&lt;td&gt;</code> 整体时才会运行。</li>
</ol>
<iframe src="./root/event-details/mousemove-mouseover-mouseout-mouseenter-mouseleave/mouseenter-mouseleave-delegation-2.view/index.html" height="500" width="100%"></iframe>

      </fieldset>
      
      <fieldset id='_62bW9u'>
      <legend>solution</legend>
      <p>正如我们从 HTML/CSS 中所看到的，滑动条就是一个带有彩色背景的 <code>&lt;div&gt;</code>，其中包含一个滑块 —— 另一个具有 <code>position:relative</code> 的 <code>&lt;div&gt;</code>。</p>
<p>为了对滑块进行定位，我们使用 <code>position:relative</code> 来提供相对于其父元素的坐标，在这儿它比 <code>position:absolute</code> 更方便。</p>
<p>然后我们通过限制宽度来实现仅水平方向的拖放。</p>

      </fieldset>
      
      <fieldset id='_ycbfkZ'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="滑动条">滑动条</h1>
<p>创建一个滑动条（slider）：</p>
<p>[iframe src=&quot;solution&quot; height=60 border=1]</p>
<p>用鼠标拖动蓝色的滑块（thumb）并移动它。</p>
<p>重要的细节：</p>
<ul>
<li>当鼠标按钮被按下时，在滑动过程中，鼠标指针可能会移动到滑块的上方或下方。此时滑块仍会继续移动（方便用户）。</li>
<li>如果鼠标非常快地向左边或者向右边移动，那么滑块应该恰好停在边缘。</li>
</ul>

      </fieldset>
      
      <fieldset id='_2HX8x1'>
      <legend>solution</legend>
      <p>要拖动元素，我们可以使用 <code>position:fixed</code>，它使坐标更易于管理。最后，我们应该将其切换回 <code>position:absolute</code>，以使元素放置到文档中。</p>
<p>当坐标位于窗口顶端/底端时，我们使用 <code>window.scrollTo</code> 来滚动它。</p>
<p>更多细节请见代码注释。</p>

      </fieldset>
      
      <fieldset id='_Wltepe'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="将超级英雄放置在足球场周围">将超级英雄放置在足球场周围</h1>
<p>这个任务可以帮助你检查你对拖放和 DOM 的一些方面的理解程度。</p>
<p>使所有元素都具有类 <code>draggable</code> —— 可拖动。就像本章中的球一样。</p>
<p>要求：</p>
<ul>
<li>使用事件委托来跟踪拖动的开始：一个在 <code>document</code> 上的用于 <code>mousedown</code> 的处理程序。</li>
<li>如果元素被拖动到了窗口的顶端/末端 —— 页面会向上/向下滚动以允许进一步的拖动。</li>
<li>没有水平滚动（这使本任务更简单，但添加水平滚动也很简单）。</li>
<li>即使在快速移动鼠标后，可拖动元素或该元素的部分也绝不应该离开窗口。</li>
</ul>
<p>这个示例太大了，不适合放在这里，所以在下面给出了示例链接。</p>
<p>[demo src=&quot;solution&quot;]</p>

      </fieldset>
      
      <fieldset id='_RQ7XPp'>
      <legend>article</legend>
      <h1 id="鼠标拖放事件">鼠标拖放事件</h1>
<p>拖放（Drag&#39;n&#39;Drop）是一个很赞的界面解决方案。取某件东西并将其拖放是执行许多东西的一种简单明了的方式，从复制和移动文档（如在文件管理器中）到订购（将物品放入购物车）。</p>
<p>在现代 HTML 标准中有一个 <a href="https://html.spec.whatwg.org/multipage/interaction.html#dnd">关于拖放的部分</a>，其中包含了例如 <code>dragstart</code> 和 <code>dragend</code> 等特殊事件。</p>
<p>这些事件使我们能够支持特殊类型的拖放，例如处理从 OS 文件管理器中拖动文件，并将其拖放到浏览器窗口中。之后，JavaScript 便可以访问此类文件中的内容。</p>
<p>但是，原生的拖放事件也有其局限性。例如，我们无法阻止从特定区域的拖动。并且，我们无法将拖动变成“水平”或“竖直”的。还有很多其他使用它们无法完成的拖放任务。并且，移动设备对此类事件的支持非常有限。</p>
<p>因此，在这里我们将看到，如何使用鼠标事件来实现拖放。</p>
<h2 id="拖放算法">拖放算法</h2>
<p>基础的拖放算法如下所示：</p>
<ol>
<li>在 <code>mousedown</code> 上 —— 根据需要准备要移动的元素（也许创建一个它的副本，向其中添加一个类或其他任何东西）。</li>
<li>然后在 <code>mousemove</code> 上，通过更改 <code>position:absolute</code> 情况下的 <code>left/top</code> 来移动它。</li>
<li>在 <code>mouseup</code> 上 —— 执行与完成的拖放相关的所有行为。</li>
</ol>
<p>这些都是基础内容。稍后，我们将看到如何实现其他功能，例如当我们将一个东西拖动到一个元素上方时，高亮显示该元素。</p>
<p>下面是拖放一个球的实现代码：</p>
<pre><code class="language-js">ball.onmousedown = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
  <span class="hljs-comment">// (1) 准备移动：确保 absolute，并通过设置 z-index 以确保球在顶部</span>
  ball.style.position = <span class="hljs-string">&#x27;absolute&#x27;</span>;
  ball.style.zIndex = <span class="hljs-number">1000</span>;

  <span class="hljs-comment">// 将其从当前父元素中直接移动到 body 中</span>
  <span class="hljs-comment">// 以使其定位是相对于 body 的</span>
  <span class="hljs-built_in">document</span>.body.append(ball);  

  <span class="hljs-comment">// 现在球的中心在 (pageX, pageY) 坐标上</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">moveAt</span>(<span class="hljs-params">pageX, pageY</span>) </span>{
    ball.style.left = pageX - ball.offsetWidth / <span class="hljs-number">2</span> + <span class="hljs-string">&#x27;px&#x27;</span>;
    ball.style.top = pageY - ball.offsetHeight / <span class="hljs-number">2</span> + <span class="hljs-string">&#x27;px&#x27;</span>;
  }

  <span class="hljs-comment">// 将我们绝对定位的球移到指针下方</span>
  moveAt(event.pageX, event.pageY);

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onMouseMove</span>(<span class="hljs-params">event</span>) </span>{
    moveAt(event.pageX, event.pageY);
  }

  <span class="hljs-comment">// (2) 在 mousemove 事件上移动球</span>
  <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;mousemove&#x27;</span>, onMouseMove);

  <span class="hljs-comment">// (3) 放下球，并移除不需要的处理程序</span>
  ball.onmouseup = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">document</span>.removeEventListener(<span class="hljs-string">&#x27;mousemove&#x27;</span>, onMouseMove);
    ball.onmouseup = <span class="hljs-literal">null</span>;
  };

};</code></pre>
<p>如果我们运行这段代码，我们会发现一些奇怪的事情。在拖放的一开始，球“分叉”了：我们开始拖动它的“克隆”。</p>
<pre><code class="language-online">这是一个正在运行中的示例：

[iframe src=&quot;ball&quot; height=230]

尝试使用鼠标进行拖放，你会看到这种奇怪的行为。</code></pre>
<p>这是因为浏览器有自己的对图片和一些其他元素的拖放处理。它会在我们进行拖放操作时自动运行，并与我们的拖放处理产生了冲突。</p>
<p>禁用它：</p>
<pre><code class="language-js">ball.ondragstart = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
};</code></pre>
<p>现在一切都正常了。</p>
<pre><code class="language-online">这是一个正在运行中的示例：

[iframe src=&quot;ball2&quot; height=230]</code></pre>
<p>另一个重要的方面是 —— 我们在 <code>document</code> 上跟踪 <code>mousemove</code>，而不是在 <code>ball</code> 上。乍一看，鼠标似乎总是在球的上方，我们可以将 <code>mousemove</code> 放在球上。</p>
<p>但正如我们所记得的那样，<code>mousemove</code> 会经常被触发，但不会针对每个像素都如此。因此，在快速移动鼠标后，鼠标指针可能会从球上跳转至文档中间的某个位置（甚至跳转至窗口外）。</p>
<p>因此，我们应该监听 <code>document</code> 以捕获它。</p>
<h2 id="修正定位">修正定位</h2>
<p>在上述示例中，球在移动时，球的中心始终位于鼠标指针下方：</p>
<pre><code class="language-js">ball.style.left = pageX - ball.offsetWidth / <span class="hljs-number">2</span> + <span class="hljs-string">&#x27;px&#x27;</span>;
ball.style.top = pageY - ball.offsetHeight / <span class="hljs-number">2</span> + <span class="hljs-string">&#x27;px&#x27;</span>;</code></pre>
<p>不错，但这存在副作用。要启动拖放，我们可以在球上的任意位置 <code>mousedown</code>。但是，如果从球的边缘“抓住”球，那么球会突然“跳转”以使球的中心位于鼠标指针下方。</p>
<p>如果我们能够保持元素相对于鼠标指针的初始偏移，那就更好了。</p>
<p>例如，我们按住球的边缘处开始拖动，那么在拖动时，鼠标指针应该保持在一开始所按住的边缘位置上。</p>
<p><img src="ball_shift.svg" alt=""></p>
<p>让我们更新一下我们的算法：</p>
<ol>
<li><p>当访问者按下按钮（<code>mousedown</code>）时 —— 我们可以在变量 <code>shiftX/shiftY</code> 中记住鼠标指针到球左上角的距离。我们应该在拖动时保持这个距离。</p>
<p> 我们可以通过坐标相减来获取这个偏移：</p>
<pre><code class="language-js"><span class="hljs-comment">// onmousedown</span>
<span class="hljs-keyword">let</span> shiftX = event.clientX - ball.getBoundingClientRect().left;
<span class="hljs-keyword">let</span> shiftY = event.clientY - ball.getBoundingClientRect().top;</code></pre>
</li>
<li><p>然后，在拖动球时，我们将鼠标指针相对于球的这个偏移也考虑在内，像这样：</p>
<pre><code class="language-js"><span class="hljs-comment">// onmousemove</span>
<span class="hljs-comment">// 球具有 position:absoute</span>
ball.style.left = event.pageX - *!*shiftX*/!* + <span class="hljs-string">&#x27;px&#x27;</span>;
ball.style.top = event.pageY - *!*shiftY*/!* + <span class="hljs-string">&#x27;px&#x27;</span>;</code></pre>
</li>
</ol>
<p>能够更好地进行定位的最终代码：</p>
<pre><code class="language-js">ball.onmousedown = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{

*!*
  <span class="hljs-keyword">let</span> shiftX = event.clientX - ball.getBoundingClientRect().left;
  <span class="hljs-keyword">let</span> shiftY = event.clientY - ball.getBoundingClientRect().top;
*/!*

  ball.style.position = <span class="hljs-string">&#x27;absolute&#x27;</span>;
  ball.style.zIndex = <span class="hljs-number">1000</span>;
  <span class="hljs-built_in">document</span>.body.append(ball);

  moveAt(event.pageX, event.pageY);

  <span class="hljs-comment">// 移动现在位于坐标 (pageX, pageY) 上的球</span>
  <span class="hljs-comment">// 将初始的偏移考虑在内</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">moveAt</span>(<span class="hljs-params">pageX, pageY</span>) </span>{
    ball.style.left = pageX - *!*shiftX*/!* + <span class="hljs-string">&#x27;px&#x27;</span>;
    ball.style.top = pageY - *!*shiftY*/!* + <span class="hljs-string">&#x27;px&#x27;</span>;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onMouseMove</span>(<span class="hljs-params">event</span>) </span>{
    moveAt(event.pageX, event.pageY);
  }

  <span class="hljs-comment">// 在 mousemove 事件上移动球</span>
  <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;mousemove&#x27;</span>, onMouseMove);

  <span class="hljs-comment">// 放下球，并移除不需要的处理程序</span>
  ball.onmouseup = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">document</span>.removeEventListener(<span class="hljs-string">&#x27;mousemove&#x27;</span>, onMouseMove);
    ball.onmouseup = <span class="hljs-literal">null</span>;
  };

};

ball.ondragstart = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
};</code></pre>
<pre><code class="language-online">In action (inside `&lt;iframe&gt;`):

[iframe src=&quot;ball3&quot; height=230]</code></pre>
<p>如果我们按住球的右下角来进行拖动，这种差异会尤其明显。在前面的示例中，球会在鼠标指针下“跳转”一下。现在，更新后的代码可以让我们从当前位置流畅地跟随鼠标。</p>
<h2 id="潜在的放置目标">潜在的放置目标</h2>
<p>在前面的示例中，球可以被放置（drop）到“任何地方”。在实际中，我们通常是将一个元素放到另一个元素上。例如，将一个“文件”放置到一个“文件夹”或者其他地方。</p>
<p>抽象地讲，我们取一个 &quot;draggable&quot; 的元素，并将其放在 &quot;droppable&quot; 的元素上。</p>
<p>我们需要知道：</p>
<ul>
<li>在拖放结束时，所拖动的元素要放在哪里 —— 执行相应的行为</li>
<li>并且，最好知道我们所拖动到的 &quot;droppable&quot; 的元素的位置，并高亮显示 &quot;droppable&quot; 的元素。</li>
</ul>
<p>这个解决方案很有意思，只是有点麻烦，所以我们在这儿对此进行介绍。</p>
<p>第一个想法是什么？可能是将 <code>onmouseover/mouseup</code> 处理程序放在潜在的 &quot;droppable&quot; 的元素中？</p>
<p>但这行不通。</p>
<p>问题在于，当我们拖动时，可拖动元素一直是位于其他元素上的。而鼠标事件只发生在顶部元素上，而不是发生在那些下面的元素。</p>
<p>例如，下面有两个 <code>&lt;div&gt;</code> 元素，红色的在蓝色的上面（完全覆盖）。这里，在蓝色的 <code>&lt;div&gt;</code> 中没有办法来捕获事件，因为红色的 <code>&lt;div&gt;</code> 在它上面：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
  <span class="hljs-selector-tag">div</span> {
    <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;
    <span class="hljs-attribute">position</span>: absolute;
    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background:blue&quot;</span> <span class="hljs-attr">onmouseover</span>=<span class="hljs-string">&quot;alert(&#x27;never works&#x27;)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background:red&quot;</span> <span class="hljs-attr">onmouseover</span>=<span class="hljs-string">&quot;alert(&#x27;over red!&#x27;)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>与可拖动的元素相同。球始终位于其他元素之上，因此事件会发生在球上。无论我们在较低的元素上设置什么处理程序，它们都不会起作用。</p>
<p>这就是一开始的那个想法，将处理程序放在潜在的 &quot;droppable&quot; 的元素，在实际操作中不起作用的原因。它们不会运行。</p>
<p>那么，该怎么办？</p>
<p>有一个叫做 <code>document.elementFromPoint(clientX, clientY)</code> 的方法。它会返回在给定的窗口相对坐标处的嵌套的最深的元素（如果给定的坐标在窗口外，则返回 <code>null</code>）。</p>
<p>我们可以在我们的任何鼠标事件处理程序中使用它，以检测鼠标指针下的潜在的 &quot;droppable&quot; 的元素，就像这样：</p>
<pre><code class="language-js"><span class="hljs-comment">// 在一个鼠标事件处理程序中</span>
ball.hidden = <span class="hljs-literal">true</span>; <span class="hljs-comment">// (*) 隐藏我们拖动的元素</span>

<span class="hljs-keyword">let</span> elemBelow = <span class="hljs-built_in">document</span>.elementFromPoint(event.clientX, event.clientY);
<span class="hljs-comment">// elemBelow 是球下方的元素，可能是 droppable 的元素</span>

ball.hidden = <span class="hljs-literal">false</span>;</code></pre>
<p>请注意：我们需要在调用 <code>(*)</code> 之前隐藏球。否则，我们通常会在这些坐标上有一个球，因为它是在鼠标指针下的最顶部的元素：<code>elemBelow=ball</code>。</p>
<p>我们可以使用该代码来检查我们正在“飞过”的元素是什么。并在放置（drop）时，对放置进行处理。</p>
<p>基于 <code>onMouseMove</code> 扩展的代码，用于查找 &quot;droppable&quot; 的元素：</p>
<pre><code class="language-js"><span class="hljs-comment">// 我们当前正在飞过的潜在的 droppable 的元素</span>
<span class="hljs-keyword">let</span> currentDroppable = <span class="hljs-literal">null</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onMouseMove</span>(<span class="hljs-params">event</span>) </span>{
  moveAt(event.pageX, event.pageY);

  ball.hidden = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">let</span> elemBelow = <span class="hljs-built_in">document</span>.elementFromPoint(event.clientX, event.clientY);
  ball.hidden = <span class="hljs-literal">false</span>;

  <span class="hljs-comment">// mousemove 事件可能会在窗口外被触发（当球被拖出屏幕时）</span>
  <span class="hljs-comment">// 如果 clientX/clientY 在窗口外，那么 elementfromPoint 会返回 null</span>
  <span class="hljs-keyword">if</span> (!elemBelow) <span class="hljs-keyword">return</span>;

  <span class="hljs-comment">// 潜在的 droppable 的元素被使用 &quot;droppable&quot; 类进行标记（也可以是其他逻辑）</span>
  <span class="hljs-keyword">let</span> droppableBelow = elemBelow.closest(<span class="hljs-string">&#x27;.droppable&#x27;</span>);

  <span class="hljs-keyword">if</span> (currentDroppable != droppableBelow) {
    <span class="hljs-comment">// 我们正在飞入或飞出...</span>
    <span class="hljs-comment">// 注意：它们两个的值都可能为 null</span>
    <span class="hljs-comment">//   currentDroppable=null —— 如果我们在此事件之前，鼠标指针不是在一个 droppable 的元素上（例如空白处）</span>
    <span class="hljs-comment">//   droppableBelow=null —— 如果现在，在当前事件中，我们的鼠标指针不是在一个 droppable 的元素上</span>

    <span class="hljs-keyword">if</span> (currentDroppable) {
      <span class="hljs-comment">// 处理“飞出” droppable 的元素时的处理逻辑（移除高亮）</span>
      leaveDroppable(currentDroppable);
    }
    currentDroppable = droppableBelow;
    <span class="hljs-keyword">if</span> (currentDroppable) {
      <span class="hljs-comment">// 处理“飞入” droppable 的元素时的逻辑</span>
      enterDroppable(currentDroppable);
    }
  }
}</code></pre>
<p>在下面这个示例中，当球被拖到球门上时，球门会被高亮显示。</p>
<p>[codetabs height=250 src=&quot;ball4&quot;]</p>
<p>现在，我们在整个处理过程中，在当前变量 <code>currentDroppable</code> 中都存储了当前的“放置目标”，可以用它来进行高亮显示或者其他操作。</p>
<h2 id="总结">总结</h2>
<p>我们考虑了一种基础的拖放算法。</p>
<p>关键部分：</p>
<ol>
<li>事件流：<code>ball.mousedown</code> -&gt; <code>document.mousemove</code> -&gt; <code>ball.mouseup</code>（不要忘记取消原生 <code>ondragstart</code>）。</li>
<li>在拖动开始时 —— 记住鼠标指针相对于元素的初始偏移（shift）：<code>shiftX/shiftY</code>，并在拖动过程中保持它不变。</li>
<li>使用 <code>document.elementFromPoint</code> 检测鼠标指针下的 &quot;droppable&quot; 的元素。</li>
</ol>
<p>我们可以在此基础上做很多事情。</p>
<ul>
<li>在 <code>mouseup</code> 上，我们可以智能地完成放置（drop）：更改数据，移动元素。</li>
<li>我们可以高亮我们正在“飞过”的元素。</li>
<li>我们可以将拖动限制在特定的区域或者方向。</li>
<li>我们可以对 <code>mousedown/up</code> 使用事件委托。一个大范围的用于检查 <code>event.target</code> 的事件处理程序可以管理数百个元素的拖放。</li>
<li>等。</li>
</ul>
<p>有一些在此基础上已经将体系结构构建好的框架：<code>DragZone</code>，<code>Droppable</code>，<code>Draggable</code> 及其他 class。它们中的大多数做的都是与上述类似的事情，所以现在你应该很容易理解它们了。或者自己动手实现。正如你所看到的，其实挺简单的，有时候比基于第三方解决方案进行改写还容易。</p>

      </fieldset>
      
      <fieldset id='_VXHP9I'>
      <legend>article</legend>
      <h1 id="指针事件">指针事件</h1>
<p>指针事件（Pointer Events）是一种用于处理来自各种输入设备（例如鼠标、触控笔和触摸屏等）的输入信息的现代化解决方案。</p>
<h2 id="一段简史">一段简史</h2>
<p>让我们先做一个简短的概览，以便你对指针事件及其在其它事件类型中所处位置有个粗略认识。</p>
<ul>
<li><p>很早以前，浏览器只存在鼠标事件。</p>
<p>后来，触屏设备出现了。为了让以前的代码正常运行，触屏设备也沿用了鼠标事件。比如，轻触屏幕就会触发 <code>mousedown</code> 事件。但由于触摸设备在诸多方面都更加强大，而鼠标事件就显得心有余而力不足了。比如，我们可以同时触控多点，而鼠标事件并没有相关属性。</p>
</li>
<li><p>为了实现一些触摸屏特有的特性（这里不再赘述这些特性，因为指针事件更加完善），人们引入了触摸事件，例如 <code>touchstart</code>、<code>touchend</code>、<code>touchmove</code>。</p>
<p>不过这还是不够完美。因为很多其他输入设备（如触控笔）都有自己的特性。而且同时维护两份分别处理鼠标事件和触摸事件的代码，显得有些笨重了。</p>
</li>
<li><p>为了解决这些问题，人们引入了全新的规范「指针事件」。它为各种指针输入设备提供了一套统一的事件。</p>
</li>
</ul>
<p>目前，各大主流浏览器已经支持了 <a href="https://www.w3.org/TR/pointerevents2/">Pointer Events Level 2</a> 标准，<a href="https://w3c.github.io/pointerevents/">Pointer Events Level 3</a> 也已经在路上了。所以，除非你专门为 IE 10 或 Safari 12 以下版本的浏览器构建代码，否则无需继续使用鼠标事件或触摸事件，你可以安全地使用指针事件。</p>
<p>话虽如此，指针事件仍然有一些重要的奇怪特性，你应当对它们有所了解以避免一些意料之外的错误。我们会在本文中一一介绍。</p>
<h2 id="指针事件类型">指针事件类型</h2>
<p>指针事件的命名方式和鼠标事件类似：</p>
<table>
<thead>
<tr>
<th>指针事件</th>
<th>鼠标事件</th>
</tr>
</thead>
<tbody><tr>
<td><code>pointerdown</code></td>
<td><code>mousedown</code></td>
</tr>
<tr>
<td><code>pointerup</code></td>
<td><code>mouseup</code></td>
</tr>
<tr>
<td><code>pointermove</code></td>
<td><code>mousemove</code></td>
</tr>
<tr>
<td><code>pointerover</code></td>
<td><code>mouseover</code></td>
</tr>
<tr>
<td><code>pointerout</code></td>
<td><code>mouseout</code></td>
</tr>
<tr>
<td><code>pointerenter</code></td>
<td><code>mouseenter</code></td>
</tr>
<tr>
<td><code>pointerleave</code></td>
<td><code>mouseleave</code></td>
</tr>
<tr>
<td><code>pointercancel</code></td>
<td>-</td>
</tr>
<tr>
<td><code>gotpointercapture</code></td>
<td>-</td>
</tr>
<tr>
<td><code>lostpointercapture</code></td>
<td>-</td>
</tr>
</tbody></table>
<p>不难发现，每一个 <code>mouse&lt;event&gt;</code> 都有与之相对应的 <code>pointer&lt;event&gt;</code>。同时还有 3 个额外的事件没有相应的 <code>mouse...</code>，我们会在稍后详细解释它们。</p>
<p>在代码中用 <code>pointer&lt;event&gt;</code> 替换 <code>mouse&lt;event&gt;</code>&quot;
我们可以把代码中的 <code>mouse&lt;event&gt;</code> 都替换成 <code>pointer&lt;event&gt;</code>，程序仍然正常兼容鼠标设备。</p>
<p>替换之后，程序对触屏设备的支持会“魔法般”地提升。但你可能需要在 CSS 中添加一行规则 <code>touch-action: none</code>。我们会在下文 <code>pointercancel</code> 一节中描述这里面的细节。</p>
<h2 id="指针事件属性">指针事件属性</h2>
<p>指针事件具备和鼠标事件完全相同的属性，包括 <code>clientX/Y</code> 和 <code>target</code> 等，以及一些额外的属性：</p>
<ul>
<li><p><code>pointerId</code> —— 触发当前事件的指针唯一标识符。
可以用来处理多指针的情况，比如带有触控笔和多点触控功能（将在下文详述）的触摸屏。</p>
</li>
<li><p><code>pointerType</code> —— 指针的设备类型，必须为一个字符串。可以是：&quot;mouse&quot;、&quot;pen&quot; 或 &quot;touch&quot;。</p>
<p>我们可以使用这个属性来针对不同类型的指针输入做出不同响应。</p>
</li>
<li><p><code>isPrimary</code> —— 当指针为首要指针（多点触控时按下的第一根手指）时为 <code>true</code>。</p>
</li>
</ul>
<p>对于一些能够测量接触面积和点按压力的指针（例如一根手指压在触屏上），这些额外属性会比较有用：</p>
<ul>
<li><code>width</code> —— 触摸接触面积的宽度。对于不支持的设备（如鼠标），这个值总是 <code>1</code>。</li>
<li><code>height</code> —— 触摸接触面积的长度。对于不支持的设备，这个值总是 <code>1</code>。</li>
<li><code>pressure</code> —— 触摸压力，是一个介于 0 到 1 之间的浮点数。对于不支持压力检测的设备，这个值总是 <code>0.5</code>（按下时）或 <code>0</code>。</li>
<li><code>tangentialPressure</code> —— 归一化后的切向压力（tangential pressure）。</li>
<li><code>tiltX</code>, <code>tiltY</code>, <code>twist</code> —— 针对触摸笔的几个属性，用于描述笔和屏幕表面的相对位置。</li>
</ul>
<p>这些属性在不同设备上的支持并不完善，所以使用得比较少。在需要时你可以查看指针事件的 <a href="https://w3c.github.io/pointerevents/#pointerevent-interface">规范文档</a>。</p>
<h2 id="多点触控">多点触控</h2>
<p>多点触控（用户同时在手机或平板上点击若干个位置执行特殊手势）是鼠标事件完全不支持的功能之一。</p>
<p>指针事件通过 <code>pointerId</code> 和 <code>isPrimary</code> 属性让我们能够处理多点触控。</p>
<p>这里是当用户先后在两个地方按下手指时发生的事情：</p>
<ol>
<li>第一个触摸：<ul>
<li><code>pointerdown</code> 事件触发，<code>isPrimary=true</code>，并且被指派了一个 <code>pointerId</code>。</li>
</ul>
</li>
<li>第二个和后续的更多触摸：<ul>
<li><code>pointerdown</code> 事件触发，<code>isPrimary=false</code>，并且每一个触摸都被指派了不同的 <code>pointerId</code>。</li>
</ul>
</li>
</ol>
<p>请注意：<code>pointerId</code> 不是分配给整个设备的，而是分配给每一个触摸的。如果 5 根手指同时触摸屏幕，我们会得到 5 个 <code>pointerdown</code> 事件和相应的坐标以及 5 个不同的 <code>pointerId</code>。</p>
<p>和第一个触摸相关联的事件总有 <code>isPrimary=true</code>。</p>
<p>利用 <code>pointerId</code>，我们可以追踪多根正在触摸屏幕的手指。当用户移动或抬起某根手指时，我们会得到和 <code>pointerdown</code> 事件具有相同 <code>pointerId</code> 的 <code>pointermove</code> 或 <code>pointerup</code> 事件。</p>
<p>这是一个记录 <code>pointerdown</code> 和 <code>pointerup</code> 事件的演示:</p>
<iframe src="https://liaojunjun.github.io/nice/root/event-details/pointer-events/multitouch.view/index.html" width="100%" height="400"></iframe>

<p>请注意：你使用的必须是一个多点触控设备（如平板或手机）才能看到区别。对于使用鼠标这样的单点触控设备，所有指针事件都会具有相同的 <code>pointerId</code> 和 <code>isPrimary=true</code> 属性。</p>
<h2 id="事件：pointercancel">事件：pointercancel</h2>
<p>我们之前提及过 <code>touch-action: none</code> 的重要性。现在让我们来解释一下它，因为略过它可能会导致在我们的交互中产生许多误操作。</p>
<p><code>pointercancel</code> 事件将会在一个正处于活跃状态的指针交互由于某些原因被中断时触发。也就是在这个事件之后，该指针就不会继续触发更多事件了。</p>
<p>导致指针中断的可能原因如下：</p>
<ul>
<li>指针设备硬件被禁用。</li>
<li>设备方向旋转（例如给平板转了个方向）。</li>
<li>浏览器打算自行处理这一交互，比如将其看作是一个专门的鼠标手势或缩放操作等。</li>
</ul>
<p>我们会用一个实际例子来阐释 <code>pointercancel</code> 的影响。</p>
<p>例如，我们想要实现一个像鼠标拖放事件中开头提到的那样的一个对球的拖放操作。</p>
<p>用户的操作流和对应的事件如下：</p>
<ol>
<li>用户在一张图片上按下鼠标，开始拖拽<ul>
<li><code>pointerdown</code> 事件触发</li>
</ul>
</li>
<li>用户开始拖动图片<ul>
<li><code>pointermove</code> 事件触发，可能触发多次</li>
</ul>
</li>
<li>想不到吧！浏览器有自己原生的图片拖放操作，接管了之前的拖放过程，于是触发了 <code>pointercancel</code> 事件。<ul>
<li>现在拖放图片的操作由浏览器自行实现。用户甚至可能会把图片拖出浏览器，放进他们的邮件程序或文件管理器。</li>
<li>我们不会再得到 <code>pointermove</code> 事件了。</li>
</ul>
</li>
</ol>
<p>这里的问题就在于浏览器”劫持“了这一个互动操作，触发了 <code>pointercancel</code> 事件，而 <code>pointermove</code> 事件不再继续触发。</p>
<p>这里是一个指针事件的演示（只包含 <code>up/down</code>、<code>move</code> 和 `cancel），事件的触发被记录在了文本框中：</p>
<iframe src="https://liaojunjun.github.io/nice/root/event-details/pointer-events/ball.view/index.html" width="100%" height="400"></iframe>

<p>我们想要实现自己的拖放操作，所以让我们来看看如何告诉浏览器不要接管拖放操作。</p>
<p><strong>阻止浏览器的默认行为来防止 <code>pointercancel</code> 触发。</strong></p>
<p>我们需要做两件事：</p>
<ol>
<li>阻止原生的拖放操作发生：<ul>
<li>正如我们在 鼠标拖放事件中描述的那样，可以通过设置 <code>ball.ondragstart = () =&gt; false</code> 来实现。</li>
<li>这种方式也适用于鼠标事件。</li>
</ul>
</li>
<li>对于触屏设备，浏览器同样有和触摸相关的行为。在这里我们也会遇到类似的问题。<ul>
<li>我们可以通过在 CSS 中设置 <code>#ball { touch-action: none }</code> 来阻止它们。</li>
<li>之后我们的代码便可以在触屏设备中正常工作了。</li>
</ul>
</li>
</ol>
<p>经过上述操作，事件将会按照我们预期的方式触发，浏览器也不会劫持拖放过程来产生一个 <code>pointercancel</code> 事件。</p>
<p>这个演示增加了以下几行：</p>
<iframe src="https://liaojunjun.github.io/nice/root/event-details/pointer-events/ball-2.view/index.html" width="100%" height="400"></iframe>

<p>可以看到，<code>pointercancel</code> 事件不再被触发。</p>
<p>现在我们就可以添加让球的位置移动的代码了，并且我们的代码对鼠标和触控设备都有效。</p>
<h2 id="指针捕获">指针捕获</h2>
<p>指针捕获（Pointer capturing）是针对指针事件的一个特性。</p>
<p>这其中的主要思想是，我们可以通过一个特定的 <code>pointerId</code> 来把所有事件绑定（bind）到一个元素。这样之后，所有具有相同 <code>pointerId</code> 的后续事件都将被重定向到同一个元素。也就是说：浏览器会把那个元素作为目标和相关处理程序的触发器，无论这些指针事件实际上是在何处发生的。</p>
<p>相关的方法有：</p>
<ul>
<li><code>elem.setPointerCapture(pointerId)</code> —— 把给定的 <code>pointerId</code> 绑定到 <code>elem</code>。</li>
<li><code>elem.releasePointerCapture(pointerId)</code> —— 把给定的 <code>pointerId</code> 从 <code>elem</code> 取消绑定。</li>
</ul>
<p>这种绑定操作不会持续太长时间。在 <code>pointerup</code> 或 <code>pointercancel</code> 事件触发，或者目标元素 <code>elem</code> 被移除后，这种绑定都会被自动取消。</p>
<p>我们在什么情况下需要指针捕获呢？</p>
<p><strong>指针捕获被用于简化拖放类的操作。</strong></p>
<p>让我们来回忆一下在鼠标拖放事件中提到的写一个自定义滑动条时所遇到的问题。</p>
<ol>
<li>首先，用户按下滑块，触发 <code>pointerdown</code> 事件，用户开始拖动滑块。</li>
<li>……但随着指针的移动，用户的指针可能会离开滑动条，移动到滑动条之上或之下的位置。</li>
</ol>
<p>但我们会想要继续追踪 <code>pointermove</code> 事件，移动滑块直到 <code>pointerup</code> 事件，即便指针已经不再位于滑动条上了。</p>
<p>之前的解决方案，为了处理滑块之外的 <code>pointermove</code> 事件，我们监听了整个 <code>document</code> 的 <code>pointermove</code> 事件。</p>
<p>指针捕获提供了第二种解决方案：我们可以在 <code>pointerdown</code> 事件的处理程序中调用 <code>thumb.setPointerCapture(event.pointerId)</code>，这样接下来在 <code>pointerup</code> 之前发生的所有指针事件都会被重定向到 <code>thumb</code> 上。</p>
<p>也就是说，<code>thumb</code> 上的事件处理程序会被调用，并且 <code>event.target</code> 始终会是 <code>thumb</code>，即便用户在文档任意地方移动指针。所以，我们可以继续在 <code>thumb</code> 上监听 <code>pointermove</code>，无论其是在何处发生的。</p>
<p>主要代码如下：</p>
<pre><code class="language-js">thumb.onpointerdown = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
  <span class="hljs-comment">// 把所有指针事件（pointerup 之前发生的）重定向到自己</span>
  thumb.setPointerCapture(event.pointerId);
};

thumb.onpointermove = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
  <span class="hljs-comment">// 移动滑动条：在 thumb 上监听即可，因为所有事件都被重定向到了 thumb</span>
  <span class="hljs-keyword">let</span> newLeft = event.clientX - slider.getBoundingClientRect().left;
  thumb.style.left = newLeft + <span class="hljs-string">&quot;px&quot;</span>;
};

<span class="hljs-comment">// 注意：无需调用 thumb.releasePointerCapture，</span>
<span class="hljs-comment">// 它会在 pointerup 时自动调用</span></code></pre>
<iframe src="https://liaojunjun.github.io/nice/root/event-details/pointer-events/slider.view/index.html" width="100%" height="400"></iframe>

<p><strong>言而总之：由于我们无需再在整个 <code>document</code> 上添加/移除处理程序，代码就变得整洁多了。这就是指针捕获的意义所在。</strong></p>
<p>还有两个相关的指针捕获事件:</p>
<ul>
<li><code>gotpointercapture</code> 会在一个元素使用 <code>setPointerCapture</code> 来启用捕获后触发。</li>
<li><code>lostpointercapture</code> 会在捕获被释放后触发：其触发可能是由于 <code>releasePointerCapture</code> 的显式调用，或是 <code>pointerup</code>/<code>pointercancel</code> 事件触发后的自动调用。</li>
</ul>
<h2 id="总结">总结</h2>
<p>指针事件允许我们同时处理鼠标、触摸和触控笔事件。</p>
<p>指针事件是鼠标事件的拓展。我们可以在事件名称中用 <code>pointer</code> 替换 <code>mouse</code> 来让我们的代码既能继续支持鼠标，也能更好地支持其他类型的设备。</p>
<p>记得在 CSS 中为涉及到的元素添加 <code>touch-events: none</code>。否则浏览器会劫持很多类型的触摸互动，导致指针事件无法正常触发。</p>
<p>指针事件还额外具备以下能力：</p>
<ul>
<li>基于 <code>pointerId</code> 和 <code>isPrimary</code> 的多点触控支持。</li>
<li>针对特定设备的属性，例如 <code>pressure</code> 和 <code>width/height</code> 等。</li>
<li>指针捕获：我们可以把 <code>pointerup</code>/<code>pointercancel</code> 之前的所有指针事件重定向到一个特定的元素。</li>
</ul>
<p>目前，指针事件已经被各大主流浏览器支持，所以如果不需要支持 IE10 和 Safari 12 以下的版本，我们可以放心地使用它们。不过即便是针对这些老式浏览器，也可以通过 polyfill 来让它们支持指针事件。</p>

      </fieldset>
      
      <fieldset id='_hKuC49'>
      <legend>solution</legend>
      <p>我们应该使用两个处理程序：<code>document.onkeydown</code> 和 <code>document.onkeyup</code>。</p>
<p>让我们创建一个集合 <code>pressed = new Set()</code> 来保存当前被按下的键。</p>
<p>第一个处理程序把当前被按下的键添加到集合中，而第二个处理程序将被松开的按键从集合中移除。我们每次在 <code>keydown</code> 上检查我们是否按下了足够多的键，如果是，则运行函数 <code>func</code>。</p>

      </fieldset>
      
      <fieldset id='_hSDHF7'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="扩展热键">扩展热键</h1>
<p>创建一个 <code>runOnKeys(func, code1, code2, ... code_n)</code> 函数，在同时按下 <code>code1, code2, ... code_n</code> 键时运行函数 <code>func</code>。</p>
<p>例如，当按键 <code>&quot;Q&quot;</code> 和 <code>&quot;W&quot;</code> 被一起按下时（任何语言中，无论是否 CapsLock），下面的代码将显示 <code>alert</code>：</p>
<pre><code class="language-js">runOnKeys(
  <span class="hljs-function">() =&gt;</span> alert(<span class="hljs-string">&quot;Hello!&quot;</span>),
  <span class="hljs-string">&quot;KeyQ&quot;</span>,
  <span class="hljs-string">&quot;KeyW&quot;</span>
);</code></pre>
<p>[demo src=&quot;solution&quot;]</p>

      </fieldset>
      
      <fieldset id='_wb5mVm'>
      <legend>article</legend>
      <h1 id="键盘：keydown-和-keyup">键盘：keydown 和 keyup</h1>
<p>在我们开始学习键盘的相关内容之前，请注意，在现代设备上，还有其他“输入内容”的方法。例如，人们使用语音识别（尤其是在移动端设备上）或用鼠标复制/粘贴。</p>
<p>因此，如果我们想要跟踪 <code>&lt;input&gt;</code> 字段中的所有输入，那么键盘事件是不够的。无论如何，还需要一个名为 <code>input</code> 的事件来跟踪 <code>&lt;input&gt;</code> 字段中的更改。对于这样的任务来说，这可能是一个更好的选择。稍后我们将在[事件：change，input，cut，copy，paste ]一章中介绍它们。</p>
<p>当我们想要处理键盘行为时，应该使用键盘事件（虚拟键盘也算）。例如，对方向键 <code>key:Up</code> 和 <code>key:Down</code> 或热键（包括按键的组合）作出反应。</p>
<h2 id="测试台-keyboard-test-stand">测试台 [#keyboard-test-stand]</h2>
<iframe src="https://liaojunjun.github.io/nice/root/event-details/keyboard-events/keyboard-dump.view/index.html" width="100%" height="400"></iframe>

<h2 id="keydown-和-keyup">Keydown 和 keyup</h2>
<p>当一个按键被按下时，会触发 <code>keydown</code> 事件，而当按键被释放时，会触发 <code>keyup</code> 事件。</p>
<h3 id="eventcode-和-eventkey">event.code 和 event.key</h3>
<p>事件对象的 <code>key</code> 属性允许获取字符，而事件对象的 <code>code</code> 属性则允许获取“物理按键代码”。</p>
<p>例如，同一个按键 <code>key:Z</code>，可以与或不与 <code>Shift</code> 一起按下。我们会得到两个不同的字符：小写的 <code>z</code> 和大写的 <code>Z</code>。</p>
<p><code>event.key</code> 正是这个字符，并且它将是不同的。但是，<code>event.code</code> 是相同的：</p>
<table>
<thead>
<tr>
<th>Key</th>
<th><code>event.key</code></th>
<th><code>event.code</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>key:Z</code></td>
<td><code>z</code>（小写）</td>
<td><code>KeyZ</code></td>
</tr>
<tr>
<td><code>key:Shift+Z</code></td>
<td><code>Z</code>（大写）</td>
<td><code>KeyZ</code></td>
</tr>
</tbody></table>
<p>如果按键没有给出任何字符呢？例如，<code>key:Shift</code> 或 <code>key:F1</code> 或其他。对于这些按键，它们的 <code>event.key</code> 与 <code>event.code</code> 大致相同：</p>
<table>
<thead>
<tr>
<th>Key</th>
<th><code>event.key</code></th>
<th><code>event.code</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>key:F1</code></td>
<td><code>F1</code></td>
<td><code>F1</code></td>
</tr>
<tr>
<td><code>key:Backspace</code></td>
<td><code>Backspace</code></td>
<td><code>Backspace</code></td>
</tr>
<tr>
<td><code>key:Shift</code></td>
<td><code>Shift</code></td>
<td><code>ShiftRight</code> 或 <code>ShiftLeft</code></td>
</tr>
</tbody></table>
<p>请注意，<code>event.code</code> 准确地标明了哪个键被按下了。例如，大多数键盘有两个 <code>key:Shift</code> 键，一个在左边，一个在右边。<code>event.code</code> 会准确地告诉我们按下了哪个键，而 <code>event.key</code> 对按键的“含义”负责：它是什么（一个 &quot;Shift&quot;）。</p>
<p>假设，我们要处理一个热键：<code>key:Ctrl+Z</code>（或 Mac 上的 <code>key:Cmd+Z</code>）。大多数文本编辑器将“撤销”行为挂在其上。我们可以在 <code>keydown</code> 上设置一个监听器，并检查哪个键被按下了。</p>
<p>这里有个难题：在这样的监听器中，我们应该检查 <code>event.key</code> 的值还是 <code>event.code</code> 的值？</p>
<p>一方面，<code>event.key</code> 的值是一个字符，它随语言而改变。如果访问者在 OS 中使用多种语言，并在它们之间进行切换，那么相同的按键将给出不同的字符。
因此检查 <code>event.code</code> 会更好，因为它总是相同的。</p>
<p>像这样：</p>
<pre><code class="language-js"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&quot;keydown&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
  <span class="hljs-keyword">if</span> (event.code == <span class="hljs-string">&quot;KeyZ&quot;</span> &amp;&amp; (event.ctrlKey || event.metaKey)) {
    alert(<span class="hljs-string">&quot;Undo!&quot;</span>);
  }
});</code></pre>
<h2 id="自动重复">自动重复</h2>
<p>如果按下一个键足够长的时间，它就会开始“自动重复”：<code>keydown</code> 会被一次又一次地触发，然后当按键被释放时，我们最终会得到 <code>keyup</code>。因此，有很多 <code>keydown</code> 却只有一个 <code>keyup</code> 是很正常的。</p>
<p>对于由自动重复触发的事件，<code>event</code> 对象的 <code>event.repeat</code> 属性被设置为 <code>true</code>。</p>
<h2 id="默认行为">默认行为</h2>
<p>默认行为各不相同，因为键盘可能会启动许多可能的东西。</p>
<p>例如：</p>
<ul>
<li>出现在屏幕上的一个字符（最明显的结果）。</li>
<li>一个字符被删除（<code>key:Delete</code> 键）。</li>
<li>滚动页面（<code>key:PageDown</code> 键）。</li>
<li>浏览器打开“保存页面”对话框（<code>key:Ctrl+S</code>）</li>
<li>……等。</li>
</ul>
<p>阻止对 <code>keydown</code> 的默认行为可以取消大多数的行为，但基于 OS 的特殊按键除外。例如，在 Windows 中，<code>key:Alt+F4</code> 会关闭当前浏览器窗口。并且无法通过在 JavaScript 中阻止默认行为来阻止它。</p>
<p>例如，下面的这个 <code>&lt;input&gt;</code> 期望输入的内容为一个电话号码，因此它不会接受除数字，<code>+</code>，<code>()</code> 和 <code>-</code> 以外的按键：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkPhoneKey</span>(<span class="hljs-params">key</span>) </span>{
    <span class="hljs-keyword">return</span> (
      (key &gt;= <span class="hljs-string">&quot;0&quot;</span> &amp;&amp; key &lt;= <span class="hljs-string">&quot;9&quot;</span>) ||
      key == <span class="hljs-string">&quot;+&quot;</span> ||
      key == <span class="hljs-string">&quot;(&quot;</span> ||
      key == <span class="hljs-string">&quot;)&quot;</span> ||
      key == <span class="hljs-string">&quot;-&quot;</span>
    );
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span>
  <span class="hljs-attr">onkeydown</span>=<span class="hljs-string">&quot;return checkPhoneKey(event.key)&quot;</span>
  <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;tel&quot;</span>
  <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;tel&quot;</span>
/&gt;</span></code></pre>
<p>请注意，像 <code>key:Backspace</code>，<code>key:Left</code>，<code>key:Right</code>，<code>key:Ctrl+V</code> 这样的特殊按键在输入中无效。这是严格过滤器 <code>checkPhoneKey</code> 的副作用。</p>
<p>让我们将过滤条件放松一下：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkPhoneKey</span>(<span class="hljs-params">key</span>) </span>{
    <span class="hljs-keyword">return</span> (
      (key &gt;= <span class="hljs-string">&quot;0&quot;</span> &amp;&amp; key &lt;= <span class="hljs-string">&quot;9&quot;</span>) ||
      key == <span class="hljs-string">&quot;+&quot;</span> ||
      key == <span class="hljs-string">&quot;(&quot;</span> ||
      key == <span class="hljs-string">&quot;)&quot;</span> ||
      key == <span class="hljs-string">&quot;-&quot;</span> ||
      key == <span class="hljs-string">&quot;ArrowLeft&quot;</span> ||
      key == <span class="hljs-string">&quot;ArrowRight&quot;</span> ||
      key == <span class="hljs-string">&quot;Delete&quot;</span> ||
      key == <span class="hljs-string">&quot;Backspace&quot;</span>
    );
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span>
  <span class="hljs-attr">onkeydown</span>=<span class="hljs-string">&quot;return checkPhoneKey(event.key)&quot;</span>
  <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Phone, please&quot;</span>
  <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;tel&quot;</span>
/&gt;</span></code></pre>
<p>现在方向键和删除键都能正常使用了。</p>
<p>……但我们仍然可以使用鼠标右键单击 + 粘贴来输入任何内容。因此，这个过滤器并不是 100% 可靠。我们可以让它就这样吧，因为大多数情况下它是有效的。或者，另一种方式是跟踪 <code>input</code> 事件 —— 在任何修改后触发。这样我们就可以检查新值，并在其无效时高亮/修改它。</p>
<h2 id="遗存">遗存</h2>
<p>过去曾经有一个 <code>keypress</code> 事件，还有事件对象的 <code>keyCode</code>、<code>charCode</code> 和 <code>which</code> 属性。</p>
<p>大多数浏览器对它们都存在兼容性问题，以致使该规范的开发者不得不弃用它们并创建新的现代的事件（本文上面所讲的这些事件），除此之外别无选择。旧的代码仍然有效，因为浏览器还在支持它们，但现在完全没必要再使用它们。</p>

      </fieldset>
      
      <fieldset id='_gyyqIA'>
      <legend>solution</legend>
      <p>解决方案的核心是一个函数，当我们在页面末端时，该函数可以向页面添加更多日期（或者在实际开发中是加载更多内容）。</p>
<p>我们可以立即调用它，并将其添加为 <code>window.onscroll</code> 处理程序。</p>
<p>最重要的问题是：“如何检测页面滚动到了末端？”</p>
<p>让我们使用相对于窗口的坐标。</p>
<p>文档（document）在 <code>&lt;html&gt;</code> 标签中被表示（被包含）为 <code>document.documentElement</code>。</p>
<p>我们可以通过 <code>document.documentElement.getBoundingClientRect()</code> 来获取整个文档相对于窗口的坐标。<code>bottom</code> 属性将是文档末端的相对于窗口的坐标。</p>
<p>例如，如果整个 HTML 文档的高度是 <code>2000px</code>，那么：</p>
<pre><code class="language-js"><span class="hljs-comment">// 当我们在页面顶端时</span>
<span class="hljs-comment">// 相对于窗口 top = 0</span>
<span class="hljs-built_in">document</span>.documentElement.getBoundingClientRect().top = <span class="hljs-number">0</span>

<span class="hljs-comment">// 相对于窗口 bottom = 2000</span>
<span class="hljs-comment">// 如果文档太长，那么可能会远远超出窗口底部</span>
<span class="hljs-built_in">document</span>.documentElement.getBoundingClientRect().bottom = <span class="hljs-number">2000</span></code></pre>
<p>如果我们向下滚动 <code>500px</code>，那么：</p>
<pre><code class="language-js"><span class="hljs-comment">// 文档顶端在窗口之方 500px</span>
<span class="hljs-built_in">document</span>.documentElement.getBoundingClientRect().top = -<span class="hljs-number">500</span>
<span class="hljs-comment">// 文档末端相对于窗口近了 500px</span>
<span class="hljs-built_in">document</span>.documentElement.getBoundingClientRect().bottom = <span class="hljs-number">1500</span></code></pre>
<p>当我们滚动到文档末端时，假设窗口高度为 <code>600px</code>：</p>
<pre><code class="language-js"><span class="hljs-comment">// 文档顶端在窗口上方 -1400px</span>
<span class="hljs-built_in">document</span>.documentElement.getBoundingClientRect().top = -<span class="hljs-number">1400</span>
<span class="hljs-comment">// 文档末端相对于窗口坐标为 600px</span>
<span class="hljs-built_in">document</span>.documentElement.getBoundingClientRect().bottom = <span class="hljs-number">600</span></code></pre>
<p>请注意，<code>bottom</code> 不能为 <code>0</code>，因为它永远不会到达窗口顶部。<code>bottom</code> 坐标的最低限度是窗口高度（我们假设其为 <code>600</code>），我们无法再向上滚动了。</p>
<p>我们可以获得窗口的高度为 <code>document.documentElement.clientHeight</code>。</p>
<p>对于本任务，我们需要知道何时文档末端距窗口底部不超过 <code>100px</code>（即，如果窗口高度为 <code>600px</code>，则为 <code>600-700px</code>）。</p>
<p>所以，函数如下：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">populate</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-params"><span class="hljs-literal">true</span></span>)</span> {
    <span class="hljs-comment">// 文档末端</span>
    <span class="hljs-keyword">let</span> windowRelativeBottom = <span class="hljs-built_in">document</span>.documentElement.getBoundingClientRect().bottom;

    <span class="hljs-comment">// 如果用户将页面滚动了足够远（文档末端距窗口底部 &lt;100px）</span>
    <span class="hljs-keyword">if</span> (windowRelativeBottom &lt; <span class="hljs-built_in">document</span>.documentElement.clientHeight + <span class="hljs-number">100</span>) {
      <span class="hljs-comment">// 让我们添加更多数据</span>
      <span class="hljs-built_in">document</span>.body.insertAdjacentHTML(<span class="hljs-string">&quot;beforeend&quot;</span>, <span class="hljs-string">`&lt;p&gt;Date: <span class="hljs-subst">${<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()}</span>&lt;/p&gt;`</span>);
    }
  }
}</code></pre>

      </fieldset>
      
      <fieldset id='_khQeyD'>
      <legend>task</legend>
      <h1 id="无限的页面">无限的页面</h1>
<p>创建一个无限的页面。当访问者滚动到页面末端时，它会自动将当期日期时间附加到文本中（以便访问者可以滚动更多内容）。</p>
<p>像这样：</p>
<iframe src="./root/event-details/onscroll/endless-page/solution.view/index.html" height="200" width="100%"></iframe>

<p>请注意滚动的两个重要特性：</p>
<ol>
<li><strong>滚动是“弹性的”</strong>。在某些浏览器/设备中，我们可以在文档的顶端或末端稍微多滚动出一点（超出部分显示的是空白区域，然后文档将自动“弹回”到正常状态）。</li>
<li><strong>滚动并不精确</strong>。当我们滚动到页面末端时，实际上我们可能距真实的文档末端约 0-50px。</li>
</ol>
<p>因此，“滚动到末端”应该意味着访问者离文档末端的距离不超过 100px。</p>
<p>P.S. 在现实生活中，我们可能希望显示“更多信息”或“更多商品”。</p>

      </fieldset>
      
      <fieldset id='_ubJyfN'>
      <legend>solution</legend>
      
      </fieldset>
      
      <fieldset id='_CKB6kQ'>
      <legend>task</legend>
      <h1 id="updown-按钮">Up/down 按钮</h1>
<p>创建一个“到顶部”按钮来帮助页面滚动。</p>
<p>它应该像这样运行：</p>
<ul>
<li>页面向下滚动的距离没有超过窗口高度时 —— 按钮不可见。</li>
<li>当页面向下滚动距离超过窗口高度时 —— 在左上角出现一个“向上”的箭头。如果页面回滚回去，箭头就会消失。</li>
<li>单击箭头时，页面将滚动到顶部。</li>
</ul>
<p>像这样（左上角，滚动查看）：</p>
<iframe src="./root/event-details/onscroll/updown-button/task.view/index.html" height="200" width="100%"></iframe>

      </fieldset>
      
      <fieldset id='_TireCC'>
      <legend>solution</legend>
      <p><code>onscroll</code> 处理程序应该检查哪些图像是可见的，并显示它们。</p>
<p>我们还希望在页面加载时运行它，以检测即将可见的图像并加载它们。</p>
<p>该代码应该在文档加载完成时执行，以便可以访问文档内容。</p>
<p>或者将该代码放在 <code>&lt;body&gt;</code> 底部：</p>
<pre><code class="language-js"><span class="hljs-comment">// ...页面内容在上面...</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isVisible</span>(<span class="hljs-params">elem</span>) </span>{

  <span class="hljs-keyword">let</span> coords = elem.getBoundingClientRect();

  <span class="hljs-keyword">let</span> windowHeight = <span class="hljs-built_in">document</span>.documentElement.clientHeight;

  <span class="hljs-comment">// 顶部元素边缘可见吗？</span>
  <span class="hljs-keyword">let</span> topVisible = coords.top &gt; <span class="hljs-number">0</span> &amp;&amp; coords.top &lt; windowHeight;

  <span class="hljs-comment">// 底部元素边缘可见吗？</span>
  <span class="hljs-keyword">let</span> bottomVisible = coords.bottom &lt; windowHeight &amp;&amp; coords.bottom &gt; <span class="hljs-number">0</span>;

  <span class="hljs-keyword">return</span> topVisible || bottomVisible;
}</code></pre>
<p><code>showVisible()</code> 函数使用通过 <code>isVisible()</code> 实现的可见性检查，来加载可见图像：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showVisible</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> img <span class="hljs-keyword">of</span> <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;img&#x27;</span>)) {
    <span class="hljs-keyword">let</span> realSrc = img.dataset.src;
    <span class="hljs-keyword">if</span> (!realSrc) <span class="hljs-keyword">continue</span>;

    <span class="hljs-keyword">if</span> (isVisible(img)) {
      img.src = realSrc;
      img.dataset.src = <span class="hljs-string">&#x27;&#x27;</span>;
    }
  }
}

*!*
showVisible();
<span class="hljs-built_in">window</span>.onscroll = showVisible;
*/!*</code></pre>
<p>P.S. 此解决方案还有一个 <code>isVisible</code> 的变体，可以“预加载”当前文档滚动上方/下方 1 页内的图像</p>

      </fieldset>
      
      <fieldset id='_vyxSUQ'>
      <legend>task</legend>
      <h1 id="加载可视化图像">加载可视化图像</h1>
<p>假设我们有一个速度较慢的客户端，并且希望节省它们在移动端的流量。</p>
<p>为此，我们决定不立即显示图像，而是将其替换为占位符，如下所示：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;placeholder.svg&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;128&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;128&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;real.jpg&quot;</span> * /&gt;</span></code></pre>
<p>因此，最初所有图像均为 <code>placeholder.svg</code>。当页面滚动到用户可以看到图像位置时 —— 我们就会将 <code>src</code> 更改为 <code>data-src</code> 的 <code>src</code>，从而加载图像。</p>
<p>这是在 <code>iframe</code> 中的一个示例：</p>
<iframe src="./root/event-details/onscroll/load-visible-img/solution.view/index.html" height="200" width="100%"></iframe>

<p>滚动它可以看到图像是“按需”加载的。</p>
<p>要求：</p>
<ul>
<li>加载页面时，屏幕上的那些图像应该在滚动之前立即加载。</li>
<li>有些图像可能是常规图像，没有 <code>data-src</code>。代码不应该改动它们。</li>
<li>一旦图像被加载，它就不应该在滚动进/出时被重新加载。</li>
</ul>
<p>P.S. 如果你有能力，可以创建一个更高级的解决方案，以“预加载”当前位置下方/之后一页的图像。</p>
<p>P.P.S. 仅处理垂直滚动，不处理水平滚动。</p>

      </fieldset>
      
      <fieldset id='_QB9NZF'>
      <legend>article</legend>
      <h1 id="滚动">滚动</h1>
<p><code>scroll</code> 事件允许对页面或元素滚动作出反应。我们可以在这里做一些有用的事情。</p>
<p>例如：</p>
<ul>
<li>根据用户在文档中的位置显示/隐藏其他控件或信息。</li>
<li>当用户向下滚动到页面末端时加载更多数据。</li>
</ul>
<p>这是一个显示当前滚动的小函数：</p>
<pre><code class="language-js"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;scroll&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;showScroll&quot;</span>).innerHTML = <span class="hljs-built_in">window</span>.pageYOffset + <span class="hljs-string">&quot;px&quot;</span>;
});</code></pre>
<p><code>scroll</code> 事件在 <code>window</code> 和可滚动元素上都可以运行。</p>
<h2 id="防止滚动">防止滚动</h2>
<p>我们如何使某些东西变成不可滚动？</p>
<p>我们不能通过在 <code>onscroll</code> 监听器中使用 <code>event.preventDefault()</code> 来阻止滚动，因为它会在滚动发生 <strong>之后</strong> 才触发。</p>
<p>但是我们可以在导致滚动的事件上，例如在 <code>key:pageUp</code> 和 <code>key:pageDown</code> 的 <code>keydown</code> 事件上，使用 <code>event.preventDefault()</code> 来阻止滚动。</p>
<p>如果我们向这些事件中添加事件处理程序，并向其中添加 <code>event.preventDefault()</code>，那么滚动就不会开始。</p>
<p>启动滚动的方式有很多，使用 CSS 的 <code>overflow</code> 属性更加可靠。</p>
<p>有几个练习题，你可以解决或者浏览以下几个任务来看一下 <code>onscroll</code> 的应用。</p>

      </fieldset>
      
      <fieldset id='_N5iKTE'>
      <legend>solution</legend>
      <p>解决方案，分步进行：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;genres&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;rock&quot;</span>&gt;</span>Rock<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;blues&quot;</span> <span class="hljs-attr">selected</span>&gt;</span>Blues<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-comment">// 1)</span>
  <span class="hljs-keyword">let</span> selectedOption = genres.options[genres.selectedIndex];
  alert( selectedOption.value );

  <span class="hljs-comment">// 2)</span>
  <span class="hljs-keyword">let</span> newOption = <span class="hljs-keyword">new</span> Option(<span class="hljs-string">&quot;Classic&quot;</span>, <span class="hljs-string">&quot;classic&quot;</span>);
  genres.append(newOption);

  <span class="hljs-comment">// 3)</span>
  newOption.selected = <span class="hljs-literal">true</span>;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>

      </fieldset>
      
      <fieldset id='_v0NzpJ'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="在-select-元素中添加一个选项">在 select 元素中添加一个选项</h1>
<p>下面是一个 <code>&lt;select&gt;</code> 元素：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;genres&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;rock&quot;</span>&gt;</span>Rock<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;blues&quot;</span> <span class="hljs-attr">selected</span>&gt;</span>Blues<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre>
<p>使用 JavaScript 来实现：</p>
<ol>
<li>显示所选选项的值和文本。</li>
<li>添加一个选项：<code>&lt;option value=&quot;classic&quot;&gt;Classic&lt;/option&gt;</code>。</li>
<li>使之变为可选的。</li>
</ol>
<p>请注意，如果你已正确完成所有事项，那么 <code>alert</code> 应该显示 <code>blues</code>。</p>

      </fieldset>
      
      <fieldset id='_RK3yCf'>
      <legend>article</legend>
      <h1 id="表单属性和方法">表单属性和方法</h1>
<p>表单（form）以及例如 <code>&lt;input&gt;</code> 的控件（control）元素有许多特殊的属性和事件。</p>
<p>当我们学习了这些相关内容后，处理表单会变得更加方便。</p>
<h2 id="导航：表单和元素">导航：表单和元素</h2>
<p>文档中的表单是特殊集合 <code>document.forms</code> 的成员。</p>
<p>这就是所谓的“命名的集合”：既是被命名了的，也是有序的。我们既可以使用名字，也可以使用在文档中的编号来获取表单。</p>
<pre><code class="language-js"><span class="hljs-built_in">document</span>.forms.my - name=<span class="hljs-string">&quot;my&quot;</span> 的表单
<span class="hljs-built_in">document</span>.forms[<span class="hljs-number">0</span>] - 文档中的第一个表单</code></pre>
<p>当我们有了一个表单时，其中的任何元素都可以通过命名的集合 <code>form.elements</code> 来获取到。</p>
<p>例如：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;my&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;one&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;two&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-comment">// 获取表单</span>
  <span class="hljs-keyword">let</span> form = <span class="hljs-built_in">document</span>.forms.my; <span class="hljs-comment">// &lt;form name=&quot;my&quot;&gt; 元素</span>

  <span class="hljs-comment">// 获取表单中的元素</span>
  <span class="hljs-keyword">let</span> elem = form.elements.one; <span class="hljs-comment">// &lt;input name=&quot;one&quot;&gt; 元素</span>

  alert(elem.value); <span class="hljs-comment">// 1</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>可能会有多个名字相同的元素，这种情况经常在处理单选按钮中出现。</p>
<p>在这种情况下，<code>form.elements[name]</code> 将会是一个集合，例如：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> *!*<span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span>*/!* <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> *!*<span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span>*/!* <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">let</span> form = <span class="hljs-built_in">document</span>.forms[<span class="hljs-number">0</span>];

<span class="hljs-keyword">let</span> ageElems = form.elements.age;

*!*
alert(ageElems[<span class="hljs-number">0</span>]); <span class="hljs-comment">// [object HTMLInputElement]</span>
*/!*
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>这些导航（navigation）属性并不依赖于标签的结构。所有的控件元素，无论它们在表单中有多深，都可以通过 <code>form.elements</code> 获取到。</p>
<pre><code class="language-smart">一个表单内会有一个或多个 `&lt;fieldset&gt;` 元素。它们也具有 `elements` 属性，该属性列出了 `&lt;fieldset&gt;` 中的表单控件。

例如：

```html run height=80
&lt;body&gt;
  &lt;form id=&quot;form&quot;&gt;
    &lt;fieldset name=&quot;userFields&quot;&gt;
      &lt;legend&gt;info&lt;/legend&gt;
      &lt;input name=&quot;login&quot; type=&quot;text&quot;&gt;
    &lt;/fieldset&gt;
  &lt;/form&gt;

  &lt;script&gt;
    alert(form.elements.login); // &lt;input name=&quot;login&quot;&gt;

*!*
    let fieldset = form.elements.userFields;
    alert(fieldset); // HTMLFieldSetElement

    // 我们可以通过名字从表单和 fieldset 中获取 input
    alert(fieldset.elements.login == form.elements.login); // true
*/!*
  &lt;/script&gt;
&lt;/body&gt;
```</code></pre>
<p>````warn header=&quot;更简短的表示方式：<code>form.name</code>&quot;
还有一个更简短的表示方式：我们可以通过 <code>form[index/name]</code> 来访问元素。</p>
<p>换句话说，我们可以将 <code>form.elements.login</code> 写成 <code>form.login</code>。</p>
<p>这也有效，但是会有一个小问题：如果我们访问一个元素，然后修改它的 <code>name</code>，之后它仍然可以被通过旧的 <code>name</code> 访问到（当然也能通过新的 <code>name</code> 访问）。</p>
<p>我们可以很直观地通过一个例子看到这个情况：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;form&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;login&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  alert(form.elements.login == form.login); <span class="hljs-comment">// true，与 &lt;input&gt; 相同</span>

  form.login.name = <span class="hljs-string">&quot;username&quot;</span>; <span class="hljs-comment">// 修改 input 的 name</span>

  <span class="hljs-comment">// form.elements 更新了 name：</span>
  alert(form.elements.login); <span class="hljs-comment">// undefined</span>
  alert(form.elements.username); <span class="hljs-comment">// input</span>

*!*
  <span class="hljs-comment">// form 允许我们使用两个名字：新的名字和旧的名字</span>
  alert(form.username == form.login); <span class="hljs-comment">// true</span>
*/!*
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>这通常来说并不是一个问题，因为我们很少修改表单元素的名字。</p>
<pre><code>
## 反向引用：element.form

对于任何元素，其对应的表单都可以通过 `element.form` 访问到。因此，表单引用了所有元素，元素也引用了表单。

这是一张示意图：

![](form-navigation.svg)

例如：

```html run height=40
&lt;form id=&quot;form&quot;&gt;
  &lt;input type=&quot;text&quot; name=&quot;login&quot;&gt;
&lt;/form&gt;

&lt;script&gt;
*!*
  // form -&gt; element
  let login = form.login;

  // element -&gt; form
  alert(login.form); // HTMLFormElement
*/!*
&lt;/script&gt;
```

## 表单元素

让我们来谈谈表单控件。

### input 和 textarea

我们可以通过 `input.value`（字符串）或 `input.checked`（布尔值）来访问复选框（checkbox）中的它们的 `value`。

像这样：

```js
input.value = &quot;New value&quot;;
textarea.value = &quot;New text&quot;;

input.checked = true; // 对于复选框（checkbox）或单选按钮（radio button）
```

```warn header=&quot;使用 `textarea.value` 而不是 `textarea.innerHTML`&quot;
请注意，即使 `&lt;textarea&gt;...&lt;/textarea&gt;` 将它们的 `value` 作为嵌套的 HTML 标签来保存，我们也绝不应该使用 `textarea.innerHTML` 来访问它。

它仅存储最初在页面上的 HTML，而不是存储的当前 `value`。
```

### select 和 option

一个 `&lt;select&gt;` 元素有 3 个重要的属性：

1. `select.options` —— `&lt;option&gt;` 的子元素的集合，
2. `select.value` —— 当前所选择的 `&lt;option&gt;` 的 `value`，
3. `select.selectedIndex` —— 当前所选择的 `&lt;option&gt;` 的编号。

它们提供了三种为 `&lt;select&gt;` 设置 `value` 的不同方式：

1. 找到对应的 `&lt;option&gt;` 元素，并将 `option.selected` 设置为 `true`。
2. 将 `select.value` 设置为对应的 `value`。
3. 将 `select.selectedIndex` 设置为对应 `&lt;option&gt;` 的编号。

第一个方式最明显，但是 `(2)` 和 `(3)` 通常来说会更方便。

下面是一个例子：

```html run
&lt;select id=&quot;select&quot;&gt;
  &lt;option value=&quot;apple&quot;&gt;Apple&lt;/option&gt;
  &lt;option value=&quot;pear&quot;&gt;Pear&lt;/option&gt;
  &lt;option value=&quot;banana&quot;&gt;Banana&lt;/option&gt;
&lt;/select&gt;

&lt;script&gt;
  // 所有这三行做的是同一件事
  select.options[2].selected = true;
  select.selectedIndex = 2;
  select.value = &#x27;banana&#x27;;
&lt;/script&gt;
```

和大多数其它控件不同，如果 `&lt;select&gt;` 具有 `multiple` 特性（attribute），则允许多选。这个功能很少使用。在这种情况下，我们需要使用第一种方式：从 `&lt;option&gt;` 的子元素中添加/移除 `selected` 属性。

我们可以通过 `select.options` 来获取它们的集合，例如：

```html run
&lt;select id=&quot;select&quot; *!*multiple*/!*&gt;
  &lt;option value=&quot;blues&quot; selected&gt;Blues&lt;/option&gt;
  &lt;option value=&quot;rock&quot; selected&gt;Rock&lt;/option&gt;
  &lt;option value=&quot;classic&quot;&gt;Classic&lt;/option&gt;
&lt;/select&gt;

&lt;script&gt;
  // 从 multi-select 中获取所有选定的 `value`
  let selected = Array.from(select.options)
    .filter(option =&gt; option.selected)
    .map(option =&gt; option.value);

  alert(selected); // blues,rock  
&lt;/script&gt;
```

`&lt;select&gt;` 元素的完整规范可以在规范 &lt;https://html.spec.whatwg.org/multipage/forms.html#the-select-element&gt; 中找到。

### new Option

这很少单独使用。但它仍然是一个有趣的东西。

在 [规范](https://html.spec.whatwg.org/multipage/forms.html#the-option-element) 中，有一个很好的简短语法可以创建 `&lt;option&gt;` 元素：

```js
option = new Option(text, value, defaultSelected, selected);
```

参数：

- `text` —— `&lt;option&gt;` 中的文本，
- `value` —— `&lt;option&gt;` 的 `value`，
- `defaultSelected` —— 如果为 `true`，那么 `selected` HTML-特性（attribute）就会被创建，
- `selected` —— 如果为 `true`，那么这个 `&lt;option&gt;` 就会被选中。

你可能会对 `defaultSelected` 和 `selected` 有一些疑惑。这很简单：`defaultSelected` 设置的是 HTML-特性（attribute），我们可以使用 `option.getAttribute(&#x27;selected&#x27;)` 来获得。而 `selected` —— 无论这个 `option` 是否被选则，它都很重要。通常，这两个值都设置为 `true`，或者都不设置（与设置为 `false` 是一样的）。

例如：

```js
let option = new Option(&quot;Text&quot;, &quot;value&quot;);
// 创建 &lt;option value=&quot;value&quot;&gt;Text&lt;/option&gt;
```

选择相同的元素：

```js
let option = new Option(&quot;Text&quot;, &quot;value&quot;, true, true);
```

`&lt;option&gt;` 元素具有以下属性：

`option.selected`
: `&lt;option&gt;` 是否被选择。

`option.index`
: `&lt;option&gt;` 在其所属的 `&lt;select&gt;` 中的编号。

`option.text`
: `&lt;option&gt;` 的文本内容（可以被访问者看到）。

## 参考资料

- 规范：&lt;https://html.spec.whatwg.org/multipage/forms.html&gt;.

## 总结

表单导航：

`document.forms`
: 一个表单元素可以通过 `document.forms[name/index]` 访问到。

`form.elements`  
: 表单元素可以通过 `form.elements[name/index]` 的方式访问，或者也可以使用 `form[name/index]`。`elements` 属性也适用于 `&lt;fieldset&gt;`。

`element.form`
: 元素通过 `form` 属性来引用它们所属的表单。

`value` 可以被通过 `input.value`，`textarea.value`，`select.value` 等来获取到，对于单选按钮和复选框来说可以使用 `input.checked`。

对于 `&lt;select&gt;` 元素，们可以通过索引 `select.selectedIndex` 来获取它的 `value`，也可以通过 `&lt;option&gt;` 集合 `select.options`。

这些是开始使用表单的基础。我们将在本教程中进一步介绍更多示例。

在下一章中，我们将介绍可能在任何元素上出现，但主要在表单上处理的 `focus` 和 `blur` 事件。</code></pre>

      </fieldset>
      
      <fieldset id='_VoHuHY'>
      <legend>solution</legend>
      
      </fieldset>
      
      <fieldset id='_8C44Hd'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="可编辑的-div">可编辑的 div</h1>
<p>创建一个 <code>&lt;div&gt;</code>，它在被点击后变成 <code>&lt;textarea&gt;</code>。</p>
<p>文本区域（textarea）允许我们编辑 <code>&lt;div&gt;</code> 里的 HTML。</p>
<p>当用户按下 <code>key:Enter</code> 键，或者 <code>&lt;textarea&gt;</code> 失去焦点时，<code>&lt;textarea&gt;</code> 会变回 <code>&lt;div&gt;</code>，并且 <code>&lt;textarea&gt;</code> 中的内容会变成 <code>&lt;div&gt;</code> 中的 HTML。</p>
<p>[demo src=&quot;solution&quot;]</p>

      </fieldset>
      
      <fieldset id='_OuyQo8'>
      <legend>solution</legend>
      <ol>
<li>在点击时 —— 用相同尺寸且无边框的 <code>&lt;textarea&gt;</code> 替换单元格的 <code>innerHTML</code>。可以使用 JavaScript 或 CSS 设置正确的尺寸。</li>
<li>将 <code>textarea.value</code> 设置为 <code>td.innerHTML</code>。</li>
<li>聚焦在文本区域（textarea）。</li>
<li>在单元格下方应该显示 OK/CANCEL 按钮，并处理对它们的点击事件。</li>
</ol>

      </fieldset>
      
      <fieldset id='_APIBWQ'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="点击即可编辑单元格">点击即可编辑单元格</h1>
<p>使单元格在点击时可编辑。</p>
<ul>
<li>点击时 —— 单元格应该变成“可编辑的”（在里面会出现文本区域），我们修改其中的 HTML。在这不调整单元格大小，所有几何形状保持不变。</li>
<li>OK 和 CANCEL 按钮会出现在单元格的下面，用以完成/取消编辑。</li>
<li>同一时刻只有一个单元格可被编辑。当一个 <code>&lt;td&gt;</code> 处于“编辑模式”时，在其它单元格上的点击会被忽略。</li>
<li>该表格可能有很多单元格。请使用事件委托。</li>
</ul>
<p>示例：</p>
<p>[iframe src=&quot;solution&quot; height=400]</p>

      </fieldset>
      
      <fieldset id='_mg73JQ'>
      <legend>solution</legend>
      <p>我们可以使用 <code>mouse.onclick</code> 来处理点击，并将老鼠设置为 <code>position:fixed</code>，然后使用 <code>mouse.onkeydown</code> 来处理键盘的方向键。</p>
<p>唯一的缺陷是 <code>keydown</code> 仅会在聚焦的元素上触发。因此，我们需要向元素添加 <code>tabindex</code>。因为我们禁止更改 HTML，所以我们可以使用 <code>mouse.tabIndex</code> 属性。</p>
<p>P.S. 我们也可以使用 <code>mouse.onfocus</code> 代替 <code>mouse.onclick</code>。</p>

      </fieldset>
      
      <fieldset id='_V75aRE'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="键盘移动老鼠">键盘移动老鼠</h1>
<p>聚焦在老鼠上。然后使用键盘的方向键移动它：</p>
<p>[demo src=&quot;solution&quot;]</p>
<p>P.S. 除了 <code>#mouse</code> 元素外，不要在任何地方放置事件处理程序。
P.P.S. 不要修改 HTML/CSS，这个方法应该是通用的，可以用于任何元素。</p>

      </fieldset>
      
      <fieldset id='_wGtfPN'>
      <legend>article</legend>
      <h1 id="聚焦：focusblur">聚焦：focus/blur</h1>
<p>当用户点击某个元素或使用键盘上的 <code>key:Tab</code> 键选中时，该元素将会获得聚焦（focus）。当网页加载时，HTML-特性（attribute）<code>autofocus</code> 也可以让一个焦点落在元素上，不仅如此，还有其它途径可以获得焦点。</p>
<p>聚焦到一个元素通常意味着：“准备在此处接受数据”，所以，这正是我们可以运行代码以初始化所需功能的时刻。</p>
<p>失去焦点的时刻（“blur”）可能更为重要。它可能发生在用户点击页面的其它地方，或者按下 <code>key:Tab</code> 键跳转到下一个表单字段，亦或是其它途径的时候。</p>
<p>失去焦点通常意味着：“数据已经输入完成”，所以我们可以运行代码来检查它，甚至可以将其保存到服务器上，或进行其他操作。</p>
<p>当处理焦点事件时，有一些重要的特性。我们将尽力把这些内容介绍完整。</p>
<h2 id="focusblur-事件">focus/blur 事件</h2>
<p>当元素聚焦时，会触发 <code>focus</code> 事件，当元素失去焦点时，会触发 <code>blur</code> 事件。</p>
<p>让我们使用它们来校验一个 <code>input</code> 字段。</p>
<p>在下面这个示例中：</p>
<ul>
<li><code>blur</code> 事件处理程序检查这个字段是否输入了电子邮箱，如果没有输入，则显示一个 error。</li>
<li><code>focus</code> 事件处理程序隐藏 error 信息（在 <code>blur</code> 事件处理程序上会被再检查一遍）：</li>
</ul>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
  <span class="hljs-selector-class">.invalid</span> { <span class="hljs-attribute">border-color</span>: red; }
  <span class="hljs-selector-id">#error</span> { <span class="hljs-attribute">color</span>: red }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

Your email please: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;input&quot;</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;error&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
*!*input.onblur*/!* = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (!input.value.includes(<span class="hljs-string">&#x27;@&#x27;</span>)) { <span class="hljs-comment">// not email</span>
    input.classList.add(<span class="hljs-string">&#x27;invalid&#x27;</span>);
    error.innerHTML = <span class="hljs-string">&#x27;Please enter a correct email.&#x27;</span>
  }
};

*!*input.onfocus*/!* = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.classList.contains(<span class="hljs-string">&#x27;invalid&#x27;</span>)) {
    <span class="hljs-comment">// 移除 &quot;error&quot; 指示，因为用户想要重新输入一些内容</span>
    <span class="hljs-built_in">this</span>.classList.remove(<span class="hljs-string">&#x27;invalid&#x27;</span>);
    error.innerHTML = <span class="hljs-string">&quot;&quot;</span>;
  }
};
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>现代 HTML 允许我们使用 <code>input</code> 特性（attribute）进行许多验证：<code>required</code>，<code>pattern</code> 等。有时它们正是我们所需要的。当我们需要更大的灵活性时，可以使用 JavaScript。如果数据是正确的，我们可以把它自动发送到服务器。</p>
<h2 id="focusblur-方法">focus/blur 方法</h2>
<p><code>elem.focus()</code> 和 <code>elem.blur()</code> 方法可以设置和移除元素上的焦点。</p>
<p>例如，如果输入值无效，我们可以让焦点无法离开这个 <code>input</code> 字段：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
  <span class="hljs-selector-class">.error</span> {
    <span class="hljs-attribute">background</span>: red;
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

Your email please: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;input&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:220px&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;make email invalid and try to focus here&quot;</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  input.onblur = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.value.includes(<span class="hljs-string">&#x27;@&#x27;</span>)) { <span class="hljs-comment">// not email</span>
      <span class="hljs-comment">// 显示 error</span>
      <span class="hljs-built_in">this</span>.classList.add(<span class="hljs-string">&quot;error&quot;</span>);
*!*
      <span class="hljs-comment">// ...将焦点放回来</span>
      input.focus();
*/!*
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-built_in">this</span>.classList.remove(<span class="hljs-string">&quot;error&quot;</span>);
    }
  };
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>这段代码在除了火狐（<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=53579">bug</a>）之外的浏览器上都可以正常工作。</p>
<p>如果我们在 <code>input</code> 中输入一些内容，然后尝试使用 <code>key:Tab</code> 键或点击远离 <code>&lt;input&gt;</code> 的位置，那么 <code>onblur</code> 事件处理程序会把焦点重新设置到这个 <code>input</code> 字段上。</p>
<p>请注意，我们无法通过在 <code>onblur</code> 事件处理程序中调用 <code>event.preventDefault()</code> 来“阻止失去焦点”，因为 <code>onblur</code> 事件处理程序是在元素失去焦点 <strong>之后</strong> 运行的。</p>
<pre><code class="language-warn">很多种原因可以导致焦点丢失。

其中之一就是用户点击了其它位置。当然 JavaScript 自身也可能导致焦点丢失，例如：

- 一个 `alert` 会将焦点移至自身，因此会导致元素失去焦点（触发 `blur` 事件），而当 `alert` 对话框被取消时，焦点又回重新回到原元素上（触发 `focus` 事件）。
- 如果一个元素被从 DOM 中移除，那么也会导致焦点丢失。如果稍后它被重新插入到 DOM，焦点也不会回到它身上。

这些特性有时候会导致 `focus/blur` 处理程序发生异常 —— 在不需要它们时触发。

最好的秘诀就是在使用这些事件时小心点。如果我们想要跟踪用户导致的焦点丢失，则应该避免自己造成的焦点丢失。</code></pre>
<h2 id="允许在任何元素上聚焦：tabindex">允许在任何元素上聚焦：tabindex</h2>
<p>默认情况下，很多元素不支持聚焦。</p>
<p>列表（list）在不同的浏览器表现不同，但有一件事总是正确的：<code>focus/blur</code> 保证支持那些用户可以交互的元素：<code>&lt;button&gt;</code>，<code>&lt;input&gt;</code>，<code>&lt;select&gt;</code>，<code>&lt;a&gt;</code> 等。</p>
<p>另一方面，为了格式化某些东西而存在的元素像 <code>&lt;div&gt;</code>，<code>&lt;span&gt;</code> 和 <code>&lt;table&gt;</code> —— 默认是不能被聚焦的。<code>elem.focus()</code> 方法不适用于它们，并且 <code>focus/blur</code> 事件也绝不会被触发。</p>
<p>使用 HTML-特性（attribute）<code>tabindex</code> 可以改变这种情况。</p>
<p>任何具有 <code>tabindex</code> 特性的元素，都会变成可聚焦的。该特性的 <code>value</code> 是当使用 <code>key:Tab</code>（或类似的东西）在元素之间进行切换时，元素的顺序号。</p>
<p>也就是说：如果我们有两个元素，第一个具有 <code>tabindex=&quot;1&quot;</code>，第二个具有 <code>tabindex=&quot;2&quot;</code>，然后当焦点在第一个元素的时候，按下 <code>key:Tab</code> 键，会使焦点移动到第二个元素身上。</p>
<p>切换顺序为：从 <code>1</code> 开始的具有 <code>tabindex</code> 的元素排在前面（按 <code>tabindex</code> 顺序），然后是不具有 <code>tabindex</code> 的元素（例如常规的 <code>&lt;input&gt;</code>）。</p>
<p>具有 <code>tabindex</code> 的元素按文档源顺序（默认顺序）切换。</p>
<p>这里有两个特殊的值：</p>
<ul>
<li><p><code>tabindex=&quot;0&quot;</code> 会使该元素被与那些不具有 <code>tabindex</code> 的元素放在一起。也就是说，当我们切换元素时，具有 <code>tabindex=&quot;0&quot;</code> 的元素将排在那些具有 <code>tabindex ≥ 1</code> 的元素的后面。</p>
<p>  通常，它用于使元素具有焦点，但是保留默认的切换顺序。使元素成为与 <code>&lt;input&gt;</code> 一样的表单的一部分。</p>
</li>
<li><p><code>tabindex=&quot;-1&quot;</code> 只允许以编程的方式聚焦于元素。<code>key:Tab</code> 键会忽略这样的元素，但是 <code>elem.focus()</code> 有效。</p>
</li>
</ul>
<p>举个例子，这里有一个列表。点击第一项，然后按 <code>key:Tab</code> 键：</p>
<pre><code class="language-html">点击第一项，然后按 Tab 键。跟踪顺序。请注意，多按几次 Tab 键后，会将焦点移到这个通过 iframe 嵌入的示例的外面。
<span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">tabindex</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>One<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">tabindex</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span>Zero<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">tabindex</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>Two<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">tabindex</span>=<span class="hljs-string">&quot;-1&quot;</span>&gt;</span>Minus one<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
  <span class="hljs-selector-tag">li</span> { <span class="hljs-attribute">cursor</span>: pointer; }
  <span class="hljs-selector-pseudo">:focus</span> { <span class="hljs-attribute">outline</span>: <span class="hljs-number">1px</span> dashed green; }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre>
<p>顺序就像这样：<code>1 - 2 - 0</code>。通常，<code>&lt;li&gt;</code> 不支持聚焦，但 <code>tabindex</code> 可以使它能聚焦，使这成为可能，并且还带有事件以及 <code>:focus</code> 样式。</p>
<p>```smart header=&quot;属性 <code>elem.tabIndex</code> 也有效&quot;
我们可以使用 <code>elem.tabIndex</code> 通过 JavaScript 来添加 <code>tabindex</code>。效果是一样的。</p>
<pre><code>
## focus/blur 委托

`focus` 和 `blur` 事件不会向上冒泡。

例如，我们不能把 `onfocus` 放在 `&lt;form&gt;` 上来对其进行高亮，像这样：

```html autorun height=80
&lt;!-- on focusing in the form -- add the class --&gt;
&lt;form *!*onfocus=&quot;this.className=&#x27;focused&#x27;&quot;*/!*&gt;
  &lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;Name&quot;&gt;
  &lt;input type=&quot;text&quot; name=&quot;surname&quot; value=&quot;Surname&quot;&gt;
&lt;/form&gt;

&lt;style&gt; .focused { outline: 1px solid red; } &lt;/style&gt;</code></pre>
<p>上面这个示例并不工作，因为当用户聚焦于 <code>&lt;input&gt;</code> 时，<code>focus</code> 事件只会在该 <code>&lt;input&gt;</code> 上触发。它不会向上冒泡。所以 <code>form.onfocus</code> 永远不会触发。</p>
<p>这里有两个解决方案。</p>
<p>方案一，有一个遗留下来的有趣的特性（feature）：<code>focus/blur</code> 不会向上冒泡，但会在捕获阶段向下传播。</p>
<p>这样可以生效：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;form&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Name&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;surname&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Surname&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"> <span class="hljs-selector-class">.focused</span> { <span class="hljs-attribute">outline</span>: <span class="hljs-number">1px</span> solid red; } </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
*!*
  <span class="hljs-comment">// 将处理程序置于捕获阶段（最后一个参数为 true）</span>
  form.addEventListener(<span class="hljs-string">&quot;focus&quot;</span>, <span class="hljs-function">() =&gt;</span> form.classList.add(<span class="hljs-string">&#x27;focused&#x27;</span>), <span class="hljs-literal">true</span>);
  form.addEventListener(<span class="hljs-string">&quot;blur&quot;</span>, <span class="hljs-function">() =&gt;</span> form.classList.remove(<span class="hljs-string">&#x27;focused&#x27;</span>), <span class="hljs-literal">true</span>);
*/!*
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>方案二，可以使用 <code>focusin</code> 和 <code>focusout</code> 事件 —— 与 <code>focus/blur</code> 事件完全一样，只是它们会冒泡。</p>
<p>值得注意的是，必须使用 <code>elem.addEventListener</code> 来分配它们，而不是 <code>on&lt;event&gt;</code>。</p>
<p>所以，这是另一个可行的变体：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;form&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Name&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;surname&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Surname&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"> <span class="hljs-selector-class">.focused</span> { <span class="hljs-attribute">outline</span>: <span class="hljs-number">1px</span> solid red; } </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
*!*
  form.addEventListener(<span class="hljs-string">&quot;focusin&quot;</span>, <span class="hljs-function">() =&gt;</span> form.classList.add(<span class="hljs-string">&#x27;focused&#x27;</span>));
  form.addEventListener(<span class="hljs-string">&quot;focusout&quot;</span>, <span class="hljs-function">() =&gt;</span> form.classList.remove(<span class="hljs-string">&#x27;focused&#x27;</span>));
*/!*
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h2 id="总结">总结</h2>
<p>在元素获得/失去焦点时会触发 <code>focus</code> 和 <code>blur</code> 事件。</p>
<p>它们的特点是：</p>
<ul>
<li>它们不会冒泡。但是可以改为在捕获阶段触发，或者使用 <code>focusin/focusout</code>。</li>
<li>大多数元素默认不支持聚焦。使用 <code>tabindex</code> 可以使任何元素变成可聚焦的。</li>
</ul>
<p>可以通过 <code>document.activeElement</code> 来获取当前所聚焦的元素。</p>

      </fieldset>
      
      <fieldset id='_1Lu8l9'>
      <legend>solution</legend>
      
      </fieldset>
      
      <fieldset id='_We99pV'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="存款计算器">存款计算器</h1>
<p>创建一个界面，允许输入银行存款总额以及存款利率，然后计算在给定时间段后，钱会变成多少。</p>
<p>这是示例：</p>
<p>[iframe src=&quot;solution&quot; height=&quot;350&quot; border=&quot;1&quot;]</p>
<p>当输入有变化时，应立即进行处理。</p>
<p>公式如下：</p>
<pre><code class="language-js"><span class="hljs-comment">// initial: 总存款的初始值</span>
<span class="hljs-comment">// interest: 例如 0.05 意味着每年涨幅 5% </span>
<span class="hljs-comment">// years: 要等待多少年</span>
<span class="hljs-keyword">let</span> result = <span class="hljs-built_in">Math</span>.round(initial * (<span class="hljs-number">1</span> + interest * years));</code></pre>

      </fieldset>
      
      <fieldset id='_vA6dvg'>
      <legend>article</legend>
      <h1 id="事件：change，input，cut，copy，paste">事件：change，input，cut，copy，paste</h1>
<p>让我们介绍一下伴随数据更新的各种事件。</p>
<h2 id="事件：change">事件：change</h2>
<p>当元素更改完成时，将触发 <code>change</code> 事件。</p>
<p>对于文本输入框，当其失去焦点时，就会触发 <code>change</code> 事件。</p>
<p>例如，当我们在下面的文本字段中键入内容时 —— 不会触发 <code>change</code> 事件。但是，当我们将焦点移到其他位置时，例如，点击按钮 —— 就会触发 <code>change</code> 事件：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">onchange</span>=<span class="hljs-string">&quot;alert(this.value)&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Button&quot;</span>&gt;</span></code></pre>
<p>对于其它元素：<code>select</code>，<code>input type=checkbox/radio</code>，会在选项更改后立即触发 <code>change</code> 事件。</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">onchange</span>=<span class="hljs-string">&quot;alert(this.value)&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>Select something<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>Option 1<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>Option 2<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span>Option 3<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre>
<h2 id="事件：input">事件：input</h2>
<p>每当用户对输入值进行修改后，就会触发 <code>input</code> 事件。</p>
<p>与键盘事件不同，只要值改变了，<code>input</code> 事件就会触发，即使那些不涉及键盘行为（action）的值的更改也是如此：使用鼠标粘贴，或者使用语音识别来输入文本。</p>
<p>例如：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;input&quot;</span>&gt;</span> oninput: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;result&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  input.oninput = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    result.innerHTML = input.value;
  };
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>如果我们想要处理对 <code>&lt;input&gt;</code> 的每次更改，那么此事件是最佳选择。</p>
<p>另一方面，<code>input</code> 事件不会在那些不涉及值更改的键盘输入或其他行为上触发，例如在输入时按方向键 <code>key:⇦</code> <code>key:⇨</code>。</p>
<p>```smart header=&quot;无法阻止 <code>oninput</code> 中的任何事件&quot;
当输入值更改后，就会触发 <code>input</code> 事件。</p>
<p>所以，我们无法使用 <code>event.preventDefault()</code> —— 已经太迟了，不会起任何作用了。</p>
<pre><code>
## 事件：cut，copy，paste

这些事件发生于剪切/拷贝/粘贴一个值的时候。

它们属于 [ClipboardEvent](https://www.w3.org/TR/clipboard-apis/#clipboard-event-interfaces) 类，并提供了对拷贝/粘贴的数据的访问方法。

我们也可以使用 `event.preventDefault()` 来中止行为，然后什么都不会被复制/粘贴。

例如，下面的代码阻止了所有的这样的事件，并显示出了我们所尝试剪切/拷贝/粘贴的内容：

```html autorun height=40 run
&lt;input type=&quot;text&quot; id=&quot;input&quot;&gt;
&lt;script&gt;
  input.oncut = input.oncopy = input.onpaste = function(event) {
    alert(event.type + &#x27; - &#x27; + event.clipboardData.getData(&#x27;text/plain&#x27;));
    return false;
  };
&lt;/script&gt;</code></pre>
<p>请注意，不仅可以复制/粘贴文本，还可以复制/粘贴所有内容。例如，我们可以在 OS 文件管理器中复制一个文件并粘贴它。</p>
<p><a href="https://www.w3.org/TR/clipboard-apis/#dfn-datatransfer">在规范中</a> 有一系列方法，这些方法可用于不同的数据类型，包括文件，对剪贴板（clipboard）进行读/写。</p>
<p>但是请注意，剪贴板是“全局”操作系统级别的。安全起见，大多数浏览器仅在特定的用户行为下，才允许对剪贴板进行读/写，例如在 <code>onclick</code> 事件处理程序中。</p>
<p>并且，除火狐（Firefox）浏览器外，所有浏览器都禁止使用 <code>dispatchEvent</code> 生成“自定义”剪贴板事件。</p>
<h2 id="总结">总结</h2>
<p>数据更改事件:</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>描述</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td><code>change</code></td>
<td>值被改变。</td>
<td>对于文本输入，当失去焦点时触发。</td>
</tr>
<tr>
<td><code>input</code></td>
<td>文本输入的每次更改。</td>
<td>立即触发，与 <code>change</code> 不同。</td>
</tr>
<tr>
<td><code>cut/copy/paste</code></td>
<td>剪贴/拷贝/粘贴行为。</td>
<td>行为可以被阻止。<code>event.clipboardData</code> 属性可以用于读/写剪贴板。</td>
</tr>
</tbody></table>

      </fieldset>
      
      <fieldset id='_1ca83x'>
      <legend>solution</legend>
      <p>可以使用一个覆盖整个窗口的半透明 <code>&lt;div id=&quot;cover-div&quot;&gt;</code> 来实现模态框窗口，如下所示：</p>
<pre><code class="language-css"><span class="hljs-selector-id">#cover-div</span> {
  <span class="hljs-attribute">position</span>: fixed;
  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">z-index</span>: <span class="hljs-number">9000</span>;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">background-color</span>: gray;
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.3</span>;
}</code></pre>
<p>由于 <code>&lt;div&gt;</code> 遮盖了所有的元素，所以它会获取到所有的点击，而它下面的元素就无法获取这些点击了。</p>
<p>我们也可以设置 <code>body.style.overflowY=&#39;hidden&#39;</code> 来阻止页面的滚动。</p>
<p>表单元素不应该在 <code>&lt;div&gt;</code> 中，而应在它下边，因为我们不想让表单具有 <code>opacity</code> 属性。</p>

      </fieldset>
      
      <fieldset id='_mzwbLw'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="模态框表单">模态框表单</h1>
<p>创建一个函数 <code>showPrompt(html, callback)</code>，该函数显示一个表单，里面有消息 <code>html</code>，一个 <code>input</code> 字段和 <code>OK/CANCEL</code> 按钮。</p>
<ul>
<li>用户应该在文本字段中输入一些内容，然后按下 <code>key:Enter</code> 键或点击 OK 按钮，然后 <code>callback(value)</code> 就会被调用，参数为输入的值。</li>
<li>否则，如果用户按下 <code>key:Esc</code> 键或点击 CANCEL 按钮，那么 <code>callback(null)</code> 就会被调用。</li>
</ul>
<p>在这两种情况下，输入过程都会结束，并移除表单。</p>
<p>要求：</p>
<ul>
<li>表单应该在窗口的正中心。</li>
<li>表单是 <strong>模态框（modal）</strong>。换句话说，在用户关闭模态框之前，用户无法与页面的其它部分进行任何交互。</li>
<li>当表单显示后，焦点应该在用户需要进行输入的 <code>&lt;input&gt;</code> 输入框中。</li>
<li>按键 <code>key:Tab</code>/<code>key:Shift+Tab</code> 应该能在表单字段之间切换焦点，不允许焦点离开表单字段到页面的其它元素上。</li>
</ul>
<p>使用示例：</p>
<pre><code class="language-js">showPrompt(<span class="hljs-string">&quot;Enter something&lt;br&gt;...smart :)&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
  alert(value);
});</code></pre>
<p>使用 iframe 嵌入的一个示例：</p>
<p>[iframe src=&quot;solution&quot; height=160 border=1]</p>
<p>P.S. 源文档有给表单设定了固定位置的 HTML/CSS，但是做成模态框的方式取决于你。</p>

      </fieldset>
      
      <fieldset id='_L3Om4s'>
      <legend>article</legend>
      <h1 id="表单：事件和方法提交">表单：事件和方法提交</h1>
<p>提交表单时，会触发 <code>submit</code> 事件，它通常用于在将表单发送到服务器之前对表单进行校验，或者中止提交，并使用 JavaScript 来处理表单。</p>
<p><code>form.submit()</code> 方法允许从 JavaScript 启动表单发送。我们可以使用此方法动态地创建表单，并将其发送到服务器。</p>
<p>让我们看看它们的更多细节。</p>
<h2 id="事件：submit">事件：submit</h2>
<p>提交表单主要有两种方式：</p>
<ol>
<li>第一种 —— 点击 <code>&lt;input type=&quot;submit&quot;&gt;</code> 或 <code>&lt;input type=&quot;image&quot;&gt;</code>。</li>
<li>第二种 —— 在 <code>input</code> 字段中按下 <code>key:Enter</code> 键。</li>
</ol>
<p>这两个行为都会触发表单的 <code>submit</code> 事件。处理程序可以检查数据，如果有错误，就显示出来，并调用 <code>event.preventDefault()</code>，这样表单就不会被发送到服务器了。</p>
<p>在下面的表单中：</p>
<ol>
<li>在文本字段中按下 <code>key:Enter</code> 键。</li>
<li>点击 <code>&lt;input type=&quot;submit&quot;&gt;</code>。</li>
</ol>
<p>这两种行为都会显示 <code>alert</code>，而因为代码中的 <code>return false</code>，表单不会被发送到别处：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onsubmit</span>=<span class="hljs-string">&quot;alert(&#x27;submit!&#x27;);return false&quot;</span>&gt;</span>
  First: Enter in the input field <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>
  Second: Click &quot;submit&quot;: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre>
<p>````smart header=&quot;<code>submit</code> 和 <code>click</code> 的关系&quot;
在输入框中使用 <code>key:Enter</code> 发送表单时，会在 <code>&lt;input type=&quot;submit&quot;&gt;</code> 上触发一次 <code>click</code> 事件。</p>
<p>这很有趣，因为实际上根本没有点击。</p>
<p>这是一个示例：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onsubmit</span>=<span class="hljs-string">&quot;return false&quot;</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;30&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Focus here and press enter&quot;</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit&quot;</span> *!*<span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;click&#x27;)&quot;</span>*/!*&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre>
<pre><code>
## 方法：submit

如果要手动将表单提交到服务器，我们可以调用 `form.submit()`。

这样就不会产生 `submit` 事件。这里假设如果开发人员调用 `form.submit()`，就意味着此脚本已经进行了所有相关处理。

有时该方法被用来手动创建和发送表单，如下所示：

```js run
let form = document.createElement(&#x27;form&#x27;);
form.action = &#x27;https://google.com/search&#x27;;
form.method = &#x27;GET&#x27;;

form.innerHTML = &#x27;&lt;input name=&quot;q&quot; value=&quot;test&quot;&gt;&#x27;;

// 该表单必须在文档中才能提交
document.body.append(form);

form.submit();
```</code></pre>

      </fieldset>
      
      <fieldset id='_D40N7R'>
      <legend>article</legend>
      <h1 id="页面生命周期：domcontentloaded，load，beforeunload，unload">页面生命周期：DOMContentLoaded，load，beforeunload，unload</h1>
<p>HTML 页面的生命周期包含三个重要事件：</p>
<ul>
<li><code>DOMContentLoaded</code> —— 浏览器已完全加载 HTML，并构建了 DOM 树，但像 <code>&lt;img&gt;</code> 和样式表之类的外部资源可能尚未加载完成。</li>
<li><code>load</code> —— 浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等。</li>
<li><code>beforeunload/unload</code> —— 当用户正在离开页面时。</li>
</ul>
<p>每个事件都是有用的：</p>
<ul>
<li><code>DOMContentLoaded</code> 事件 —— DOM 已经就绪，因此处理程序可以查找 DOM 节点，并初始化接口。</li>
<li><code>load</code> 事件 —— 外部资源已加载完成，样式已被应用，图片大小也已知了。</li>
<li><code>beforeunload</code> 事件 —— 用户正在离开：我们可以检查用户是否保存了更改，并询问他是否真的要离开。</li>
<li><code>unload</code> 事件 —— 用户几乎已经离开了，但是我们仍然可以启动一些操作，例如发送统计数据。</li>
</ul>
<p>我们探索一下这些事件的细节。</p>
<h2 id="domcontentloaded">DOMContentLoaded</h2>
<p><code>DOMContentLoaded</code> 事件发生在 <code>document</code> 对象上。</p>
<p>我们必须使用 <code>addEventListener</code> 来捕获它：</p>
<pre><code class="language-js"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&quot;DOMContentLoaded&quot;</span>, ready);
<span class="hljs-comment">// 不是 &quot;document.onDOMContentLoaded = ...&quot;</span></code></pre>
<p>例如：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ready</span>(<span class="hljs-params"></span>) </span>{
    alert(<span class="hljs-string">&#x27;DOM is ready&#x27;</span>);

    <span class="hljs-comment">// 图片目前尚未加载完成（除非已经被缓存），所以图片的大小为 0x0</span>
    alert(<span class="hljs-string">`Image size: <span class="hljs-subst">${img.offsetWidth}</span>x<span class="hljs-subst">${img.offsetHeight}</span>`</span>);
  }

*!*
  <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&quot;DOMContentLoaded&quot;</span>, ready);
*/!*
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;img&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://en.js.cx/clipart/train.gif?speed=1&amp;cache=0&quot;</span>&gt;</span></code></pre>
<p>在示例中，<code>DOMContentLoaded</code> 处理程序在文档加载完成后触发，所以它可以查看所有元素，包括它下面的 <code>&lt;img&gt;</code> 元素。</p>
<p>但是，它不会等待图片加载。因此，<code>alert</code> 显示其大小为零。</p>
<p>乍一看，<code>DOMContentLoaded</code> 事件非常简单。DOM 树准备就绪 —— 这是它的触发条件。它并没有什么特别之处。</p>
<h3 id="domcontentloaded-和脚本">DOMContentLoaded 和脚本</h3>
<p>当浏览器处理一个 HTML 文档，并在文档中遇到 <code>&lt;script&gt;</code> 标签时，就会在继续构建 DOM 之前运行它。这是一种防范措施，因为脚本可能想要修改 DOM，甚至对其执行 <code>document.write</code> 操作，所以 <code>DOMContentLoaded</code> 必须等待脚本执行结束。</p>
<p>因此，<code>DOMContentLoaded</code> 肯定在下面的这些脚本执行结束之后发生：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&quot;DOMContentLoaded&quot;</span>, <span class="hljs-function">() =&gt;</span> {
    alert(<span class="hljs-string">&quot;DOM ready!&quot;</span>);
  });
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  alert(<span class="hljs-string">&quot;Library loaded, inline script executed&quot;</span>);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>在上面这个例子中，我们首先会看到 &quot;Library loaded...&quot;，然后才会看到 &quot;DOM ready!&quot;（所有脚本都已经执行结束）。</p>
<p>```warn header=&quot;不会阻塞 <code>DOMContentLoaded</code> 的脚本&quot;
此规则有两个例外：</p>
<ol>
<li>具有 <code>async</code> 特性（attribute）的脚本不会阻塞 <code>DOMContentLoaded</code>，<a href="info:script-async-defer">稍后</a> 我们会讲到。</li>
<li>使用 <code>document.createElement(&#39;script&#39;)</code> 动态生成并添加到网页的脚本也不会阻塞 <code>DOMContentLoaded</code>。<pre><code></code></pre>
</li>
</ol>
<h3 id="domcontentloaded-和样式">DOMContentLoaded 和样式</h3>
<p>外部样式表不会影响 DOM，因此 <code>DOMContentLoaded</code> 不会等待它们。</p>
<p>但这里有一个陷阱。如果在样式后面有一个脚本，那么该脚本必须等待样式表加载完成：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;style.css&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-comment">// 在样式表加载完成之前，脚本都不会执行</span>
  alert(getComputedStyle(<span class="hljs-built_in">document</span>.body).marginTop);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>原因是，脚本可能想要获取元素的坐标和其他与样式相关的属性，如上例所示。因此，它必须等待样式加载完成。</p>
<p>当 <code>DOMContentLoaded</code> 等待脚本时，它现在也在等待脚本前面的样式。</p>
<h3 id="浏览器内建的自动填充">浏览器内建的自动填充</h3>
<p>Firefox，Chrome 和 Opera 都会在 <code>DOMContentLoaded</code> 中自动填充表单。</p>
<p>例如，如果页面有一个带有登录名和密码的表单，并且浏览器记住了这些值，那么在 <code>DOMContentLoaded</code> 上，浏览器会尝试自动填充它们（如果得到了用户允许）。</p>
<p>因此，如果 <code>DOMContentLoaded</code> 被需要加载很长时间的脚本延迟触发，那么自动填充也会等待。你可能在某些网站上看到过（如果你使用浏览器自动填充）—— 登录名/密码字段不会立即自动填充，而是在页面被完全加载前会延迟填充。这实际上是 <code>DOMContentLoaded</code> 事件之前的延迟。</p>
<h2 id="windowonload-window-onload">window.onload [#window-onload]</h2>
<p>当整个页面，包括样式、图片和其他资源被加载完成时，会触发 <code>window</code> 对象上的 <code>load</code> 事件。可以通过 <code>onload</code> 属性获取此事件。</p>
<p>下面的这个示例正确显示了图片大小，因为 <code>window.onload</code> 会等待所有图片加载完毕：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// 与此相同 window.addEventListener(&#x27;load&#x27;, (event) =&gt; {</span>
    alert(<span class="hljs-string">&#x27;Page loaded&#x27;</span>);

    <span class="hljs-comment">// 此时图片已经加载完成</span>
    alert(<span class="hljs-string">`Image size: <span class="hljs-subst">${img.offsetWidth}</span>x<span class="hljs-subst">${img.offsetHeight}</span>`</span>);
  };
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;img&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://en.js.cx/clipart/train.gif?speed=1&amp;cache=0&quot;</span>&gt;</span></code></pre>
<h2 id="windowonunload">window.onunload</h2>
<p>当访问者离开页面时，<code>window</code> 对象上的 <code>unload</code> 事件就会被触发。我们可以在那里做一些不涉及延迟的操作，例如关闭相关的弹出窗口。</p>
<p>有一个值得注意的特殊情况是发送分析数据。</p>
<p>假设我们收集有关页面使用情况的数据：鼠标点击，滚动，被查看的页面区域等。</p>
<p>自然地，当用户要离开的时候，我们希望通过 <code>unload</code> 事件将数据保存到我们的服务器上。</p>
<p>有一个特殊的 <code>navigator.sendBeacon(url, data)</code> 方法可以满足这种需求，详见规范 <a href="https://w3c.github.io/beacon/">https://w3c.github.io/beacon/</a>。</p>
<p>它在后台发送数据，转换到另外一个页面不会有延迟：浏览器离开页面，但仍然在执行 <code>sendBeacon</code>。</p>
<p>使用方式如下：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> analyticsData = { <span class="hljs-comment">/* 带有收集的数据的对象 */</span> };

<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;unload&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  navigator.sendBeacon(<span class="hljs-string">&quot;/analytics&quot;</span>, <span class="hljs-built_in">JSON</span>.stringify(analyticsData));
};</code></pre>
<ul>
<li>请求以 POST 方式发送。</li>
<li>我们不仅能发送字符串，还能发送表单以及其他格式的数据，在 <a href="info:fetch">info:fetch</a> 一章有详细讲解，但通常它是一个字符串化的对象。</li>
<li>数据大小限制在 64kb。</li>
</ul>
<p>当 <code>sendBeacon</code> 请求完成时，浏览器可能已经离开了文档，所以就无法获取服务器响应（对于分析数据来说通常为空）。</p>
<p>还有一个 <code>keep-alive</code> 标志，该标志用于在 <a href="info:fetch">fetch</a> 方法中为通用的网络请求执行此类“离开页面后”的请求。你可以在 <a href="info:fetch-api">info:fetch-api</a> 一章中找到更多相关信息。</p>
<p>如果我们要取消跳转到另一页面的操作，在这里做不到。但是我们可以使用另一个事件 —— <code>onbeforeunload</code>。</p>
<h2 id="windowonbeforeunload-windowonbeforeunload">window.onbeforeunload [#window.onbeforeunload]</h2>
<p>如果访问者触发了离开页面的导航（navigation）或试图关闭窗口，<code>beforeunload</code> 处理程序将要求进行更多确认。</p>
<p>如果我们要取消事件，浏览器会询问用户是否确定。</p>
<p>你可以通过运行下面这段代码，然后重新加载页面来进行尝试：</p>
<pre><code class="language-js"><span class="hljs-built_in">window</span>.onbeforeunload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
};</code></pre>
<p>由于历史原因，返回非空字符串也被视为取消事件。在以前，浏览器曾经将其显示为消息，但是根据 <a href="https://html.spec.whatwg.org/#unloading-documents">现代规范</a> 所述，它们不应该这样。</p>
<p>这里有个例子：</p>
<pre><code class="language-js"><span class="hljs-built_in">window</span>.onbeforeunload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;There are unsaved changes. Leave now?&quot;</span>;
};</code></pre>
<p>它的行为已经改变了，因为有些站长通过显示误导性和恶意信息滥用了此事件处理程序。所以，目前一些旧的浏览器可能仍将其显示为消息，但除此之外 —— 无法自定义显示给用户的消息。</p>
<h2 id="readystate">readyState</h2>
<p>如果我们将 <code>DOMContentLoaded</code> 事件处理程序设置在文档加载完成之后，会发生什么？</p>
<p>很自然地，它永远不会运行。</p>
<p>在某些情况下，我们不确定文档是否已经准备就绪。我们希望我们的函数在 DOM 加载完成时执行，无论现在还是以后。</p>
<p><code>document.readyState</code> 属性可以为我们提供当前加载状态的信息。</p>
<p>它有 3 个可能值：</p>
<ul>
<li><code>loading</code> —— 文档正在被加载。</li>
<li><code>interactive</code> —— 文档被全部读取。</li>
<li><code>complete</code> —— 文档被全部读取，并且所有资源（例如图片等）都已加载完成。</li>
</ul>
<p>所以，我们可以检查 <code>document.readyState</code> 并设置一个处理程序，或在代码准备就绪时立即执行它。</p>
<p>像这样：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">work</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">/*...*/</span> }

<span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>.readyState == <span class="hljs-string">&#x27;loading&#x27;</span>) {
  <span class="hljs-comment">// 仍在加载，等待事件</span>
  <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, work);
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// DOM 已就绪！</span>
  work();
}</code></pre>
<p>还有一个 <code>readystatechange</code> 事件，会在状态发生改变时触发，因此我们可以打印所有这些状态，就像这样：</p>
<pre><code class="language-js"><span class="hljs-comment">// 当前状态</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">document</span>.readyState);

<span class="hljs-comment">// 状态改变时打印它</span>
<span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;readystatechange&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">document</span>.readyState));</code></pre>
<p><code>readystatechange</code> 事件是跟踪文档加载状态的另一种机制，它很早就存在了。现在则很少被使用。</p>
<p>但是为了完整起见，让我们看看完整的事件流。</p>
<p>这是一个带有 <code>&lt;iframe&gt;</code>，<code>&lt;img&gt;</code> 和记录事件的处理程序的文档：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  log(<span class="hljs-string">&#x27;initial readyState:&#x27;</span> + <span class="hljs-built_in">document</span>.readyState);

  <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;readystatechange&#x27;</span>, <span class="hljs-function">() =&gt;</span> log(<span class="hljs-string">&#x27;readyState:&#x27;</span> + <span class="hljs-built_in">document</span>.readyState));
  <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, <span class="hljs-function">() =&gt;</span> log(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>));

  <span class="hljs-built_in">window</span>.onload = <span class="hljs-function">() =&gt;</span> log(<span class="hljs-string">&#x27;window onload&#x27;</span>);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;iframe.html&quot;</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;log(&#x27;iframe onload&#x27;)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://en.js.cx/clipart/train.gif&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;img&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  img.onload = <span class="hljs-function">() =&gt;</span> log(<span class="hljs-string">&#x27;img onload&#x27;</span>);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>此示例运行 <a href="sandbox:readystate">在 sandbox 中</a>。</p>
<p>典型输出：</p>
<ol>
<li>[1] initial readyState:loading</li>
<li>[2] readyState:interactive</li>
<li>[2] DOMContentLoaded</li>
<li>[3] iframe onload</li>
<li>[4] img onload</li>
<li>[4] readyState:complete</li>
<li>[4] window onload</li>
</ol>
<p>方括号中的数字表示发生这种情况的大致时间。标有相同数字的事件几乎是同时发生的（+- 几毫秒）。</p>
<ul>
<li>在 <code>DOMContentLoaded</code> 之前，<code>document.readyState</code> 会立即变成 <code>interactive</code>。它们俩的意义实际上是相同的。</li>
<li>当所有资源（<code>iframe</code> 和 <code>img</code>）都加载完成后，<code>document.readyState</code> 变成 <code>complete</code>。这里我们可以发现，它与 <code>img.onload</code>（<code>img</code> 是最后一个资源）和 <code>window.onload</code> 几乎同时发生。转换到 <code>complete</code> 状态的意义与 <code>window.onload</code> 相同。区别在于 <code>window.onload</code> 始终在所有其他 <code>load</code> 处理程序之后运行。</li>
</ul>
<h2 id="总结">总结</h2>
<p>页面生命周期事件：</p>
<ul>
<li>当 DOM 准备就绪时，<code>document</code> 上的 <code>DOMContentLoaded</code> 事件就会被触发。在这个阶段，我们可以将 JavaScript 应用于元素。<ul>
<li>诸如 <code>&lt;script&gt;...&lt;/script&gt;</code> 或 <code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code> 之类的脚本会阻塞  <code>DOMContentLoaded</code>，浏览器将等待它们执行结束。</li>
<li>图片和其他资源仍然可以继续被加载。</li>
</ul>
</li>
<li>当页面和所有资源都加载完成时，<code>window</code> 上的 <code>load</code> 事件就会被触发。我们很少使用它，因为通常无需等待那么长时间。</li>
<li>当用户想要离开页面时，<code>window</code> 上的 <code>beforeunload</code> 事件就会被触发。如果我们取消这个事件，浏览器就会询问我们是否真的要离开（例如，我们有未保存的更改）。</li>
<li>当用户最终离开时，<code>window</code> 上的 <code>unload</code> 事件就会被触发。在处理程序中，我们只能执行不涉及延迟或询问用户的简单操作。正是由于这个限制，它很少被使用。我们可以使用 <code>navigator.sendBeacon</code> 来发送网络请求。</li>
<li><code>document.readyState</code> 是文档的当前状态，可以在 <code>readystatechange</code> 事件中跟踪状态更改：<ul>
<li><code>loading</code> —— 文档正在被加载。</li>
<li><code>interactive</code> —— 文档已被解析完成，与 <code>DOMContentLoaded</code> 几乎同时发生，但是在 <code>DOMContentLoaded</code> 之前发生。</li>
<li><code>complete</code> —— 文档和资源均已加载完成，与 <code>window.onload</code> 几乎同时发生，但是在 <code>window.onload</code> 之前发生。</li>
</ul>
</li>
</ul>

      </fieldset>
      
      <fieldset id='_pri3bU'>
      <legend>article</legend>
      <h1 id="脚本：async，defer">脚本：async，defer</h1>
<p>现代的网站中，脚本往往比 HTML 更“重”：它们的大小通常更大，处理时间也更长。</p>
<p>当浏览器加载 HTML 时遇到 <code>&lt;script&gt;...&lt;/script&gt;</code> 标签，浏览器就不能继续构建 DOM。它必须立刻执行此脚本。对于外部脚本 <code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code> 也是一样的：浏览器必须等脚本下载完，并执行结束，之后才能继续处理剩余的页面。</p>
<p>这会导致两个重要的问题：</p>
<ol>
<li>脚本不能访问到位于它们下面的 DOM 元素，因此，脚本无法给它们添加处理程序等。</li>
<li>如果页面顶部有一个笨重的脚本，它会“阻塞页面”。在该脚本下载并执行结束前，用户都不能看到页面内容：</li>
</ol>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>...content before script...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://javascript.info/article/script-async-defer/long.js?speed=1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-comment">&lt;!-- This isn&#x27;t visible until the script loads --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>...content after script...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre>
<p>这里有一些解决办法。例如，我们可以把脚本放在页面底部。此时，它可以访问到它上面的元素，并且不会阻塞页面显示内容：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  ...all content is above the script...

  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://javascript.info/article/script-async-defer/long.js?speed=1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p>但是这种解决方案远非完美。例如，浏览器只有在下载了完整的 HTML 文档之后才会注意到该脚本（并且可以开始下载它）。对于长的 HTML 文档来说，这样可能会造成明显的延迟。</p>
<p>这对于使用高速连接的人来说，这不值一提，他们不会感受到这种延迟。但是这个世界上仍然有很多地区的人们所使用的网络速度很慢，并且使用的是远非完美的移动互联网连接。</p>
<p>幸运的是，这里有两个 <code>&lt;script&gt;</code> 特性（attribute）可以为我们解决这个问题：<code>defer</code> 和 <code>async</code>。</p>
<h2 id="defer">defer</h2>
<p><code>defer</code> 特性告诉浏览器它应该继续处理页面，并“在后台”下载脚本，然后等页面加载完成后，再执行此脚本。</p>
<p>这是与上面那个相同的示例，但是带有 <code>defer</code> 特性：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>...content before script...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://javascript.info/article/script-async-defer/long.js?speed=1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 立即可见 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>...content after script...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre>
<ul>
<li>具有 <code>defer</code> 特性的脚本不会阻塞页面。</li>
<li>具有 <code>defer</code> 特性的脚本总是要等到 DOM 解析完毕，但在 <code>DOMContentLoaded</code> 事件之前执行。</li>
</ul>
<p>下面这个示例演示了这一过程：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>...content before scripts...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, <span class="hljs-function">() =&gt;</span> alert(<span class="hljs-string">&quot;DOM ready after defer!&quot;</span>)); <span class="hljs-comment">// (2)</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://javascript.info/article/script-async-defer/long.js?speed=1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>...content after scripts...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre>
<ol>
<li>页面内容立即显示。</li>
<li><code>DOMContentLoaded</code> 等待具有 <code>defer</code> 特性的脚本执行完成。<code>DOMContentLoaded</code> 仅在脚本 <code>(2)</code> 下载且执行结束后才会被触发。</li>
</ol>
<p>具有 <code>defer</code> 特性的脚本保持其相对顺序，就像常规脚本一样。</p>
<p>因此，如果我们有一个长脚本在前，一个短脚本在后，那么后者就会等待前者。</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://javascript.info/article/script-async-defer/long.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://javascript.info/article/script-async-defer/small.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<pre><code class="language-smart">浏览器扫描页面寻找脚本，然后并行下载它们，以提高性能。因此，在上面的示例中，两个脚本是并行下载的。`small.js` 可能会先下载完成。

但是规范要求脚本按照文档顺序执行，因此，它需要等到 `long.js` 执行结束才会被执行。</code></pre>
<p>```smart header=&quot;<code>defer</code> 特性仅适用于外部脚本&quot;
如果 <code>&lt;script&gt;</code> 脚本没有 <code>src</code>，则会忽略 <code>defer</code> 特性。</p>
<pre><code>

## async

`async` 特性意味着脚本是完全独立的：

- 页面不会等待异步脚本，它会继续处理并显示页面内容。
- `DOMContentLoaded` 和异步脚本不会彼此等待：
    - `DOMContentLoaded` 可能会发生在异步脚本之前（如果异步脚本在页面完成后才加载完成）
    - `DOMContentLoaded` 也可能发生在异步脚本之后（如果异步脚本很短，或者是从 HTTP 缓存中加载的）
- 其他脚本不会等待 `async` 脚本加载完成，同样，`async` 脚本也不会等待其他脚本。


因此，如果我们有几个 `async` 脚本，它们可能按任意次序执行。总之是先加载完成的就先执行：

```html run height=100
&lt;p&gt;...content before scripts...&lt;/p&gt;

&lt;script&gt;
  document.addEventListener(&#x27;DOMContentLoaded&#x27;, () =&gt; alert(&quot;DOM ready!&quot;));
&lt;/script&gt;

&lt;script async src=&quot;https://javascript.info/article/script-async-defer/long.js&quot;&gt;&lt;/script&gt;
&lt;script async src=&quot;https://javascript.info/article/script-async-defer/small.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;...content after scripts...&lt;/p&gt;</code></pre>
<ol>
<li>页面内容立刻显示出来：加载写有 <code>async</code> 的脚本不会阻塞页面渲染。</li>
<li><code>DOMContentLoaded</code> 可能在 <code>async</code> 之前或之后触发，不能保证谁先谁后。</li>
<li>异步脚本不会等待彼此。较小的脚本 <code>small.js</code> 排在第二位，但可能会比 <code>long.js</code> 这个长脚本先加载完成，所以 <code>small.js</code> 会先执行。这被称为“加载优先”顺序。</li>
</ol>
<p>当我们将独立的第三方脚本集成到页面时，此时采用异步加载方式是非常棒的：计数器，广告等，因为它们不依赖于我们的脚本，我们的脚本也不应该等待它们：</p>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- Google Analytics 脚本通常是这样嵌入页面的 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://google-analytics.com/analytics.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h2 id="动态脚本">动态脚本</h2>
<p>我们也可以使用 JavaScript 动态地添加脚本：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);
script.src = <span class="hljs-string">&quot;/article/script-async-defer/long.js&quot;</span>;
<span class="hljs-built_in">document</span>.body.append(script); <span class="hljs-comment">// (*)</span></code></pre>
<p>当脚本被附加到文档 <code>(*)</code> 时，脚本就会立即开始加载。</p>
<p><strong>默认情况下，动态脚本的行为是“异步”的。</strong></p>
<p>也就是说：</p>
<ul>
<li>它们不会等待任何东西，也没有什么东西会等它们。</li>
<li>先加载完成的脚本先执行（“加载优先”顺序）。</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);
script.src = <span class="hljs-string">&quot;/article/script-async-defer/long.js&quot;</span>;

*!*
script.async = <span class="hljs-literal">false</span>;
*/!*

<span class="hljs-built_in">document</span>.body.append(script);</code></pre>
<p>我们可以通过将 <code>async</code> 特性显式地修改为 <code>false</code>，以将脚本的加载顺序更改为文档顺序（就像常规脚本一样）：</p>
<p>例如，这里我们添加了两个脚本。在没有设置 <code>script.async=false</code> 时，它们执行顺序为加载优先顺序（即 <code>small.js</code> 可能先执行）。但是当设置了 <code>script.async=false</code> 后，脚本执行顺序就变成了“脚本在文档中的顺序”：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadScript</span>(<span class="hljs-params">src</span>) </span>{
  <span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);
  script.src = src;
  script.async = <span class="hljs-literal">false</span>;
  <span class="hljs-built_in">document</span>.body.append(script);
}

<span class="hljs-comment">// long.js 先执行，因为代码中设置了 async=false</span>
loadScript(<span class="hljs-string">&quot;/article/script-async-defer/long.js&quot;</span>);
loadScript(<span class="hljs-string">&quot;/article/script-async-defer/small.js&quot;</span>);</code></pre>
<h2 id="总结">总结</h2>
<p><code>async</code> 和 <code>defer</code> 有一个共同点：加载这样的脚本都不会阻塞页面的渲染。因此，用户可以立即阅读并了解页面内容。</p>
<p>但是，它们之间也存在一些本质的区别：</p>
<table>
<thead>
<tr>
<th></th>
<th>顺序</th>
<th><code>DOMContentLoaded</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>async</code></td>
<td><strong>加载优先顺序</strong>。脚本在文档中的顺序不重要 —— 先加载完成先执行</td>
<td>不相关。可能在文档加载完成前加载并执行完毕。如果脚本很小或者来自于缓存，同时文档足够长，就会发生这种情况。</td>
</tr>
<tr>
<td><code>defer</code></td>
<td><strong>文档顺序</strong>（它们在文档中的顺序）</td>
<td>在文档加载和解析完成之后（如果需要，则会等待），即在 <code>DOMContentLoaded</code> 之前执行。</td>
</tr>
</tbody></table>
<pre><code class="language-warn">请注意，如果你使用的是 `defer`，那么该页面在脚本加载之前就“可见”。

因此，用户可以阅读这个页面的内容，但是某些图形组件可能尚未准备好。

所以，我们应该在页面适当位置添加“正在加载”的指示，并且被禁用的按钮也应该这样显示，这样用户就可以清晰地看到什么准备好了，什么还没准备好。</code></pre>
<p>在实际开发中，<code>defer</code> 用于需要整个 DOM 的脚本，和/或脚本的相对执行顺序很重要的时候。<code>async</code> 用于独立脚本，例如计数器或广告，这些脚本的相对执行顺序无关紧要。</p>

      </fieldset>
      
      <fieldset id='_Fi550J'>
      <legend>solution</legend>
      <p>算法：</p>
<ol>
<li>为每个资源创建 <code>img</code>。</li>
<li>为每个图片添加 <code>onload/onerror</code>。</li>
<li>在 <code>onload</code> 或 <code>onerror</code> 被触发时，增加计数器。</li>
<li>当计数器值等于资源值时 —— 我们完成了：<code>callback()</code>。</li>
</ol>

      </fieldset>
      
      <fieldset id='_UKje1W'>
      <legend>task</legend>
      <p>importance: 4</p>
<hr>
<h1 id="使用回调函数加载图片">使用回调函数加载图片</h1>
<p>通常，图片在被创建时才会被加载。所以，当我们向页面中添加 <code>&lt;img&gt;</code> 时，用户不会立即看到图片。浏览器首先需要加载它。</p>
<p>为了立即显示一张图片，我们可以“提前”创建它，像这样：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> img = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;img&#x27;</span>);
img.src = <span class="hljs-string">&#x27;my.jpg&#x27;</span>;</code></pre>
<p>浏览器开始加载图片，并将其保存到缓存中。以后，当相同图片出现在文档中时（无论怎样），它都会立即显示。</p>
<p><strong>创建一个函数 <code>preloadImages(sources, callback)</code>，来加载来自数组 <code>source</code> 的所有图片，并在准备就绪时运行 <code>callback</code>。</strong></p>
<p>例如，这段代码将在图片加载完成后显示一个 <code>alert</code>：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loaded</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-string">&quot;Images loaded&quot;</span>)
}

preloadImages([<span class="hljs-string">&quot;1.jpg&quot;</span>, <span class="hljs-string">&quot;2.jpg&quot;</span>, <span class="hljs-string">&quot;3.jpg&quot;</span>], loaded);</code></pre>
<p>如果出现错误，函数应该仍假定图片已经“加载完成”。</p>
<p>换句话说，当所有图片都已加载完成，或出现错误输出时，将执行 <code>callback</code>。</p>
<p>例如，当我们计划显示一个包含很多图片的可滚动图册，并希望确保所有图片都已加载完成时，这个函数很有用。</p>
<p>在源文档中，你可以找到指向测试图片的链接，以及检查它们是否已加载完成的代码。它应该输出 <code>300</code>。</p>

      </fieldset>
      
      <fieldset id='_so3xs4'>
      <legend>article</legend>
      <h1 id="资源加载：onload，onerror">资源加载：onload，onerror</h1>
<p>浏览器允许我们跟踪外部资源的加载 —— 脚本，iframe，图片等。</p>
<p>这里有两个事件：</p>
<ul>
<li><code>onload</code> —— 成功加载，</li>
<li><code>onerror</code> —— 出现 error。</li>
</ul>
<h2 id="加载脚本">加载脚本</h2>
<p>假设我们需要加载第三方脚本，并调用其中的函数。</p>
<p>我们可以像这样动态加载它：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);
script.src = <span class="hljs-string">&quot;my.js&quot;</span>;

<span class="hljs-built_in">document</span>.head.append(script);</code></pre>
<p>……但如何运行在该脚本中声明的函数？我们需要等到该脚本加载完成，之后才能调用它。</p>
<pre><code class="language-smart">对于我们自己的脚本，可以使用 [JavaScript module](info:modules)，但是它们并未被广泛应用于第三方库。</code></pre>
<h3 id="scriptonload">script.onload</h3>
<p>我们的得力助手是 <code>load</code> 事件。它会在脚本加载并执行完成时触发。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);

<span class="hljs-comment">// 可以从任意域（domain），加载任意脚本</span>
script.src = <span class="hljs-string">&quot;https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js&quot;</span>
<span class="hljs-built_in">document</span>.head.append(script);

*!*
script.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// 该脚本创建了一个辅助函数 &quot;_&quot;</span>
  alert(_); <span class="hljs-comment">// 该函数可用</span>
};
*/!*</code></pre>
<p>因此，在 <code>onload</code> 中我们可以使用脚本中的变量，运行函数等。</p>
<p>……如果加载失败怎么办？例如，这里没有这样的脚本（error 404）或者服务器宕机（不可用）。</p>
<h3 id="scriptonerror">script.onerror</h3>
<p>发生在脚本加载期间的 error 会被 <code>error</code> 事件跟踪到。</p>
<p>例如，我们请求一个不存在的脚本：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);
script.src = <span class="hljs-string">&quot;https://example.com/404.js&quot;</span>; <span class="hljs-comment">// 没有这个脚本</span>
<span class="hljs-built_in">document</span>.head.append(script);

*!*
script.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-string">&quot;Error loading &quot;</span> + <span class="hljs-built_in">this</span>.src); <span class="hljs-comment">// Error loading https://example.com/404.js</span>
};
*/!*</code></pre>
<p>请注意，在这里我们无法获取更多 HTTP error 的详细信息。我们不知道 error 是 404 还是 500 或者其他情况。只知道是加载失败了。</p>
<pre><code class="language-warn">`onload`/`onerror` 事件仅跟踪加载本身。

在脚本处理和执行期间可能发生的 error 超出了这些事件跟踪的范围。也就是说：如果脚本成功加载，则即使脚本中有编程 error，也会触发 `onload` 事件。如果要跟踪脚本 error，可以使用 `window.onerror` 全局处理程序。</code></pre>
<h2 id="其他资源">其他资源</h2>
<p><code>load</code> 和 <code>error</code> 事件也适用于其他资源，基本上（basically）适用于具有外部 <code>src</code> 的任何资源。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> img = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;img&#x27;</span>);
img.src = <span class="hljs-string">&quot;https://js.cx/clipart/train.gif&quot;</span>; <span class="hljs-comment">// (*)</span>

img.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-string">`Image loaded, size <span class="hljs-subst">${img.width}</span>x<span class="hljs-subst">${img.height}</span>`</span>);
};

img.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-string">&quot;Error occurred while loading image&quot;</span>);
};</code></pre>
<p>但是有一些注意事项：</p>
<ul>
<li>大多数资源在被添加到文档中后，便开始加载。但是 <code>&lt;img&gt;</code> 是个例外。它要等到获得 src <code>(*)</code> 后才开始加载。</li>
<li>对于 <code>&lt;iframe&gt;</code> 来说，iframe 加载完成时会触发 <code>iframe.onload</code> 事件，无论是成功加载还是出现 error。</li>
</ul>
<p>这是出于历史原因。</p>
<h2 id="跨源策略">跨源策略</h2>
<p>这里有一条规则：来自一个网站的脚本无法访问其他网站的内容。例如，位于 <code>https://facebook.com</code> 的脚本无法读取位于 <code>https://gmail.com</code> 的用户邮箱。</p>
<p>或者，更确切地说，一个源（域/端口/协议三者）无法获取另一个源（origin）的内容。因此，即使我们有一个子域，或者仅仅是另一个端口，这都是不同的源，彼此无法相互访问。</p>
<p>这个规则还影响其他域的资源。</p>
<p>如果我们使用的是来自其他域的脚本，并且该脚本中存在 error，那么我们无法获取 error 的详细信息。</p>
<p>例如，让我们使用一个脚本 <code>error.js</code>，该脚本只包含一个（错误）函数调用：</p>
<pre><code class="language-js"><span class="hljs-comment">// 📁 error.js</span>
noSuchFunction();</code></pre>
<p>现在从它所在的同一个网站加载它：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-built_in">window</span>.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">message, url, line, col, errorObj</span>) </span>{
  alert(<span class="hljs-string">`<span class="hljs-subst">${message}</span>\n<span class="hljs-subst">${url}</span>, <span class="hljs-subst">${line}</span>:<span class="hljs-subst">${col}</span>`</span>);
};
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/article/onload-onerror/crossorigin/error.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>我们可以看到一个很好的 error 报告，就像这样：</p>
<pre><code>Uncaught ReferenceError: noSuchFunction is not defined
https://javascript.info/article/onload-onerror/crossorigin/error.js, 1:1</code></pre>
<p>现在，让我们从另一个域中加载相同的脚本：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-built_in">window</span>.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">message, url, line, col, errorObj</span>) </span>{
  alert(<span class="hljs-string">`<span class="hljs-subst">${message}</span>\n<span class="hljs-subst">${url}</span>, <span class="hljs-subst">${line}</span>:<span class="hljs-subst">${col}</span>`</span>);
};
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cors.javascript.info/article/onload-onerror/crossorigin/error.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>此报告与上面那个示例中的不同，就像这样：</p>
<pre><code>Script error.
, 0:0</code></pre>
<p>error 的详细信息可能因浏览器而异，但是原理是相同的：有关脚本内部的任何信息（包括 error 堆栈跟踪）都被隐藏了。正是因为它来自于另一个域。</p>
<p>为什么我们需要 error 的详细信息？</p>
<p>因为有很多服务（我们也可以构建自己的服务）使用 <code>window.onerror</code> 监听全局 error，保存 error 并提供访问和分析 error 的接口。这很好，因为我们可以看到由用户触发的实际中的 error。但是，如果一个脚本来自于另一个源（origin），那么正如我们刚刚看到的那样，其中没有太多有关 error 的信息。</p>
<p>对其他类型的资源也执行类似的跨源策略（CORS）。</p>
<p><strong>要允许跨源访问，<code>&lt;script&gt;</code> 标签需要具有 <code>crossorigin</code> 特性（attribute），并且远程服务器必须提供特殊的 header。</strong></p>
<p>这里有三个级别的跨源访问：</p>
<ol>
<li><strong>无 <code>crossorigin</code> 特性</strong> —— 禁止访问。</li>
<li><strong><code>crossorigin=&quot;anonymous&quot;</code></strong> —— 如果服务器的响应带有包含 <code>*</code> 或我们的源（origin）的 header <code>Access-Control-Allow-Origin</code>，则允许访问。浏览器不会将授权信息和 cookie 发送到远程服务器。</li>
<li><strong><code>crossorigin=&quot;use-credentials&quot;</code></strong> —— 如果服务器发送回带有我们的源的 header <code>Access-Control-Allow-Origin</code> 和 <code>Access-Control-Allow-Credentials: true</code>，则允许访问。浏览器会将授权信息和 cookie 发送到远程服务器。</li>
</ol>
<pre><code class="language-smart">你可以在 &lt;info:fetch-crossorigin&gt; 一章中了解有关跨源访问的更多信息。这一章描述了用于网络请求的 `fetch` 方法，但策略是完全相同的。

诸如 &quot;cookie&quot; 之类的内容超出了本章的范围，但你可以在 &lt;info:cookie&gt; 一章学习它们。</code></pre>
<p>在我们的示例中没有任何跨源特性（attribute）。因此，跨源访问被禁止。让我们来添加它吧。</p>
<p>我们可以在 <code>&quot;anonymous&quot;</code>（不会发送 cookie，需要一个服务器端的 header）和 <code>&quot;use-credentials&quot;</code>（会发送 cookie，需要两个服务器端的 header）之间进行选择。</p>
<p>如果我们不关心 cookie，那么可以选择 <code>&quot;anonymous&quot;</code>：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-built_in">window</span>.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">message, url, line, col, errorObj</span>) </span>{
  alert(<span class="hljs-string">`<span class="hljs-subst">${message}</span>\n<span class="hljs-subst">${url}</span>, <span class="hljs-subst">${line}</span>:<span class="hljs-subst">${col}</span>`</span>);
};
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> *!*<span class="hljs-attr">crossorigin</span>=<span class="hljs-string">&quot;anonymous&quot;</span>*/!* <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cors.javascript.info/article/onload-onerror/crossorigin/error.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>现在，假设服务器提供了 <code>Access-Control-Allow-Origin</code> header，一切都正常。我们有了完整的 error 报告。</p>
<h2 id="总结">总结</h2>
<p>图片 <code>&lt;img&gt;</code>，外部样式，脚本和其他资源都提供了 <code>load</code> 和 <code>error</code> 事件以跟踪它们的加载：</p>
<ul>
<li><code>load</code> 在成功加载时被触发。</li>
<li><code>error</code> 在加载失败时被触发。</li>
</ul>
<p>唯一的例外是 <code>&lt;iframe&gt;</code>：出于历史原因，不管加载成功还是失败，即使页面没有被找到，它都会触发 <code>load</code> 事件。</p>
<p><code>readystatechange</code> 事件也适用于资源，但很少被使用，因为 <code>load/error</code> 事件更简单。</p>

      </fieldset>
      
      <fieldset id='_1owvWO'>
      <legend>article</legend>
      <h1 id="dom-变动观察器（mutation-observer）">DOM 变动观察器（Mutation observer）</h1>
<p><code>MutationObserver</code> 是一个内建对象，它观察 DOM 元素，在其发生更改时触发回调。</p>
<p>我们将首先看一下语法，然后探究一个实际的用例，以了解它在什么地方有用。</p>
<h2 id="语法">语法</h2>
<p><code>MutationObserver</code> 使用简单。</p>
<p>首先，我们创建一个带有回调函数的观察器：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> observer = <span class="hljs-keyword">new</span> MutationObserver(callback);</code></pre>
<p>然后将其附加到一个 DOM 节点：</p>
<pre><code class="language-js">observer.observe(node, config);</code></pre>
<p><code>config</code> 是一个具有布尔选项的对象，该布尔选项表示“将对哪些更改做出反应”：</p>
<ul>
<li><code>childList</code> —— <code>node</code> 的直接子节点的更改，</li>
<li><code>subtree</code> —— <code>node</code> 的所有后代的更改，</li>
<li><code>attributes</code> —— <code>node</code> 的特性（attribute），</li>
<li><code>attributeFilter</code> —— 特性名称数组，只观察选定的特性。</li>
<li><code>characterData</code> —— 是否观察 <code>node.data</code>（文本内容），</li>
</ul>
<p>其他几个选项：</p>
<ul>
<li><code>attributeOldValue</code> —— 如果为 <code>true</code>，则将特性的旧值和新值都传递给回调（参见下文），否则只传新值（需要 <code>attributes</code> 选项），</li>
<li><code>characterDataOldValue</code> —— 如果为 <code>true</code>，则将 <code>node.data</code> 的旧值和新值都传递给回调（参见下文），否则只传新值（需要 <code>characterData</code> 选项）。</li>
</ul>
<p>然后，在发生任何更改后，将执行“回调”：更改被作为一个 <a href="https://dom.spec.whatwg.org/#mutationrecord">MutationRecord</a> 对象列表传入第一个参数，而观察器自身作为第二个参数。</p>
<p><a href="https://dom.spec.whatwg.org/#mutationrecord">MutationRecord</a> 对象具有以下属性：</p>
<ul>
<li><code>type</code> —— 变动类型，以下类型之一：<ul>
<li><code>&quot;attributes&quot;</code>：特性被修改了，</li>
<li><code>&quot;characterData&quot;</code>：数据被修改了，用于文本节点，</li>
<li><code>&quot;childList&quot;</code>：添加/删除了子元素。</li>
</ul>
</li>
<li><code>target</code> —— 更改发生在何处：<code>&quot;attributes&quot;</code> 所在的元素，或 <code>&quot;characterData&quot;</code> 所在的文本节点，或 <code>&quot;childList&quot;</code> 变动所在的元素，</li>
<li><code>addedNodes/removedNodes</code> —— 添加/删除的节点，</li>
<li><code>previousSibling/nextSibling</code> —— 添加/删除的节点的上一个/下一个兄弟节点，</li>
<li><code>attributeName/attributeNamespace</code> —— 被更改的特性的名称/命名空间（用于 XML），</li>
<li><code>oldValue</code> —— 之前的值，仅适用于特性或文本更改，如果设置了相应选项 <code>attributeOldValue</code>/<code>characterDataOldValue</code>。</li>
</ul>
<p>例如，这里有一个 <code>&lt;div&gt;</code>，它具有 <code>contentEditable</code> 特性。该特性使我们可以聚焦和编辑元素。</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">contentEditable</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;elem&quot;</span>&gt;</span>Click and <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>edit<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span>, please<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">let</span> observer = <span class="hljs-keyword">new</span> MutationObserver(<span class="hljs-function"><span class="hljs-params">mutationRecords</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(mutationRecords); <span class="hljs-comment">// console.log(the changes)</span>
});

<span class="hljs-comment">// 观察除了特性之外的所有变动</span>
observer.observe(elem, {
  <span class="hljs-attr">childList</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 观察直接子节点</span>
  <span class="hljs-attr">subtree</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 及其更低的后代节点</span>
  <span class="hljs-attr">characterDataOldValue</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 将旧的数据传递给回调</span>
});
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>如果我们在浏览器中运行上面这段代码，并聚焦到给定的 <code>&lt;div&gt;</code> 上，然后更改 <code>&lt;b&gt;edit&lt;/b&gt;</code> 中的文本，<code>console.log</code> 将显示一个变动：</p>
<pre><code class="language-js">mutationRecords = [{
  <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;characterData&quot;</span>,
  <span class="hljs-attr">oldValue</span>: <span class="hljs-string">&quot;edit&quot;</span>,
  <span class="hljs-attr">target</span>: <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">text</span> <span class="hljs-attr">node</span>&gt;</span>,
  // 其他属性为空
}];</span></code></pre>
<p>如果我们进行更复杂的编辑操作，例如删除 <code>&lt;b&gt;edit&lt;/b&gt;</code>，那么变动事件可能会包含多个变动记录：</p>
<pre><code class="language-js">mutationRecords = [{
  <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;childList&quot;</span>,
  <span class="hljs-attr">target</span>: &lt;div#elem&gt;,
  removedNodes: [&lt;b&gt;],
  nextSibling: &lt;text node&gt;,
  previousSibling: &lt;text node&gt;
  // 其他属性为空
}, {
  type: &quot;characterData&quot;
  target: &lt;text node&gt;
  // ...变动的详细信息取决于浏览器如何处理此类删除
  // 它可能是将两个相邻的文本节点 &quot;edit &quot; 和 &quot;, please&quot; 合并成一个节点，
  // 或者可能将它们留在单独的文本节点中
}];</code></pre>
<p>因此，<code>MutationObserver</code> 允许对 DOM 子树中的任何更改作出反应。</p>
<h2 id="用于集成">用于集成</h2>
<p>在什么时候可能有用？</p>
<p>想象一下，你需要添加一个第三方脚本，该脚本不仅包含有用的功能，还会执行一些我们不想要的操作，例如显示广告 <code>&lt;div class=&quot;ads&quot;&gt;Unwanted ads&lt;/div&gt;</code>。</p>
<p>当然，第三方脚本没有提供删除它的机制。</p>
<p>使用 <code>MutationObserver</code>，我们可以监测到我们不需要的元素何时出现在我们的 DOM 中，并将其删除。</p>
<p>还有一些其他情况，例如第三方脚本会将某些内容添加到我们的文档中，并且我们希望检测出这种情况何时发生，以调整页面，动态调整某些内容的大小等。</p>
<p><code>MutationObserver</code> 使我们能够实现这种需求。</p>
<h2 id="用于架构">用于架构</h2>
<p>从架构的角度来看，在某些情况下，<code>MutationObserver</code> 有不错的作用。</p>
<p>假设我们正在建立一个有关编程的网站。自然地，文章和其他材料中可能包含源代码段。</p>
<p>在 HTML 标记（markup）中的此类片段如下所示：</p>
<pre><code class="language-html">...
<span class="hljs-tag">&lt;<span class="hljs-name">pre</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;language-javascript&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>
  // 这里是代码
  let hello = &quot;world&quot;;
<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>
...</code></pre>
<p>另外，我们还将在网站上使用 JavaScript 高亮显示库，例如 <a href="https://prismjs.com/">Prism.js</a>。调用 <code>Prism.highlightElem(pre)</code> 会检查此类 <code>pre</code> 元素的内容，并在其中添加特殊标签（tag）和样式，以进行彩色语法高亮显示，类似于你在本文的示例中看到的那样。</p>
<p>那什么时候运行该高亮显示方法呢？我们可以在 <code>DOMContentLoaded</code> 事件中或者在页面尾部运行。到那时，我们的 DOM 已准备就绪，我们可以搜索元素 <code>pre[class*=&quot;language&quot;]</code> 并对其调用 <code>Prism.highlightElem</code>：</p>
<pre><code class="language-js"><span class="hljs-comment">// 高亮显示页面上的所有代码段</span>
<span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;pre[class*=&quot;language&quot;]&#x27;</span>).forEach(Prism.highlightElem);</code></pre>
<p>到目前为止，一切都很简单，对吧？HTML 中有 <code>&lt;pre&gt;</code> 代码段，我们高亮显示它们。</p>
<p>现在让我们继续。假设我们要从服务器动态获取资料。我们将 <a href="info:fetch">在本教程的后续章节</a> 中学习进行此操作的方法。目前，只需要关心我们从网络服务器获取 HTML 文章并按需显示：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> article = <span class="hljs-comment">/* 从服务器获取新内容 */</span>
articleElem.innerHTML = article;</code></pre>
<p>新的 <code>article</code> HTML 可能包含代码段。我们需要对其调用 <code>Prism.highlightElem</code>，否则它们将不会被高亮显示。</p>
<p><strong>对于动态加载的文章，应该在何处何时调用 <code>Prism.highlightElem</code>？</strong></p>
<p>我们可以将该调用附加到加载文章的代码中，如下所示：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> article = <span class="hljs-comment">/* 从服务器获取新内容 */</span>
articleElem.innerHTML = article;

*!*
<span class="hljs-keyword">let</span> snippets = articleElem.querySelectorAll(<span class="hljs-string">&#x27;pre[class*=&quot;language-&quot;]&#x27;</span>);
snippets.forEach(Prism.highlightElem);
*/!*</code></pre>
<p>……但是，想象一下，代码中有很多地方可以加载内容：文章，测验，论坛帖子。我们是否需要在每个地方都附加一个高亮显示调用？那不太方便，也很容易忘记。</p>
<p>并且，如果内容是由第三方模块加载的，该怎么办？例如，我们有一个由其他人编写的论坛，该论坛可以动态加载内容，并且我们想为其添加语法高亮显示。没有人喜欢修补第三方脚本。</p>
<p>幸运的是，还有另一种选择。</p>
<p>我们可以使用 <code>MutationObserver</code> 来自动检测何时在页面中插入了代码段，并高亮显示之它们。</p>
<p>因此，我们在一个地方处理高亮显示功能，从而使我们无需集成它。</p>
<h3 id="动态高亮显示示例">动态高亮显示示例</h3>
<p>这是一个工作示例。</p>
<p>如果你运行这段代码，它将开始观察下面的元素，并高亮显示现在此处的所有代码段：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> observer = <span class="hljs-keyword">new</span> MutationObserver(<span class="hljs-function"><span class="hljs-params">mutations</span> =&gt;</span> {

  <span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> mutation <span class="hljs-keyword">of</span> mutations</span>)</span> {
    <span class="hljs-comment">// 检查新节点，有什么需要高亮显示的吗？</span>

    <span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> node <span class="hljs-keyword">of</span> mutation.addedNodes</span>)</span> {
      <span class="hljs-comment">// 我们只跟踪元素，跳过其他节点（例如文本节点）</span>
      <span class="hljs-keyword">if</span> (!(node <span class="hljs-keyword">instanceof</span> HTMLElement)) <span class="hljs-keyword">continue</span>;

      <span class="hljs-comment">// 检查插入的元素是否为代码段</span>
      <span class="hljs-keyword">if</span> (node.matches(<span class="hljs-string">&#x27;pre[class*=&quot;language-&quot;]&#x27;</span>)) {
        Prism.highlightElement(node);
      }

      <span class="hljs-comment">// 或者可能在子树的某个地方有一个代码段？</span>
      <span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> elem <span class="hljs-keyword">of</span> node.querySelectorAll(<span class="hljs-string">&#x27;pre[class*=&quot;language-&quot;]&#x27;</span>)</span>)</span> {
        Prism.highlightElement(elem);
      }
    }
  }

});

<span class="hljs-keyword">let</span> demoElem = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;highlight-demo&#x27;</span>);

observer.observe(demoElem, {<span class="hljs-attr">childList</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">subtree</span>: <span class="hljs-literal">true</span>});</code></pre>
<p>下面有一个 HTML 元素，以及使用 <code>innerHTML</code> 动态填充它的 JavaScript。</p>
<p>请先运行前面那段代码（上面那段，观察元素），然后运行下面这段代码。你将看到 <code>MutationObserver</code> 是如何检测并高亮显示代码段的。</p>
<p id="highlight-demo" style="border: 1px solid #ddd">一个具有 <code>id="highlight-demo"</code> 的示例元素，运行上面那段代码来观察它。</p>

<p>下面这段代码填充了其 <code>innerHTML</code>，这导致 <code>MutationObserver</code> 作出反应，并突出显示其内容：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> demoElem = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;highlight-demo&#x27;</span>);

<span class="hljs-comment">// 动态插入带有代码段的内容</span>
demoElem.innerHTML = <span class="hljs-string">`下面是一个代码段：
  &lt;pre class=&quot;language-javascript&quot;&gt;&lt;code&gt; let hello = &quot;world!&quot;; &lt;/code&gt;&lt;/pre&gt;
  &lt;div&gt;另一个代码段：&lt;/div&gt;
  &lt;div&gt;
    &lt;pre class=&quot;language-css&quot;&gt;&lt;code&gt;.class { margin: 5px; } &lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;
`</span>;</code></pre>
<p>现在我们有了 <code>MutationObserver</code>，它可以跟踪观察到的元素中的，或者整个 <code>document</code> 中的所有高亮显示。我们可以在 HTML 中添加/删除代码段，而无需考虑高亮问题。</p>
<h2 id="其他方法">其他方法</h2>
<p>有一个方法可以停止观察节点：</p>
<ul>
<li><code>observer.disconnect()</code> —— 停止观察。</li>
</ul>
<p>当我们停止观察时，观察器可能尚未处理某些更改。</p>
<ul>
<li><code>observer.takeRecords()</code> —— 获取尚未处理的变动记录列表，表中记录的是已经发生，但回调暂未处理的变动。</li>
</ul>
<p>这些方法可以一起使用，如下所示：</p>
<pre><code class="language-js"><span class="hljs-comment">// 我们想要停止跟踪变动</span>
observer.disconnect();

<span class="hljs-comment">// 处理未处理的变动</span>
<span class="hljs-keyword">let</span> mutationRecords = observer.takeRecords();
...</code></pre>
<pre><code class="language-smart">观察器在内部对节点使用弱引用。也就是说：如果一个节点被从 DOM 中删除了，并且该节点变得不可访问，那么它就会被垃圾回收。

观察到 DOM 节点这一事实并不能阻止垃圾回收。</code></pre>
<h2 id="总结">总结</h2>
<p><code>MutationObserver</code> 可以对 DOM 的变化作出反应：特性（attribute），添加/删除的元素，文本内容。</p>
<p>我们可以用它来跟踪代码其他部分引入的更改，以及与第三方脚本集成。</p>
<p><code>MutationObserver</code> 可以跟踪任何更改。<code>config</code> “要观察的内容”选项用于优化，避免不必要的回调调用以节省资源。</p>

      </fieldset>
      
      <fieldset id='_96Cn9f'>
      <legend>article</legend>
      <p>libs:</p>
<ul>
<li>d3</li>
<li>domtree</li>
</ul>
<hr>
<h1 id="选择（selection）和范围（range）">选择（Selection）和范围（Range）</h1>
<p>在本章中，我们将介绍文档中的选择以及在表单字段（如 <code>&lt;input&gt;</code>）中的选择。</p>
<p>JavaScript 可以获取现有选择，选择/取消全部或部分选择，从文档中删除所选部分，将其包装到一个标签（tag）中，等。</p>
<p>你可以在本文最后的“总结”部分中找到使用方法。但是，如果你阅读整篇内容，将会有更多收获。底层的（underlying）<code>Range</code> 和 <code>Selection</code> 对象很容易掌握，因此，你不需要任何诀窍便可以使用它们做你想要做的事儿。</p>
<h2 id="范围">范围</h2>
<p>选择的基本概念是 <a href="https://dom.spec.whatwg.org/#ranges">Range</a>：本质上是一对“边界点”：范围起点和范围终点。</p>
<p>每个点都被表示为一个带有相对于起点的相对偏移（offset）的父 DOM 节点。如果父节点是元素节点，则偏移量是子节点的编号，对于文本节点，则是文本中的位置。下面举例说明。</p>
<p>让我们选择一些东西。</p>
<p>首先，我们可以创建一个范围（构造器没有参数）：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> range = <span class="hljs-keyword">new</span> Range();</code></pre>
<p>然后，我们可以使用 <code>range.setStart(node, offset)</code> 和 <code>range.setEnd(node, offset)</code> 来设置选择边界。</p>
<p>例如，考虑以下 HTML 片段：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p&quot;</span>&gt;</span>Example: <span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>italic<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> and <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>bold<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre>
<p>这是其 DOM 结构，请注意，这里的文本节点对我们很重要：</p>
<div class="select-p-domtree"></div>

<script>
let selectPDomtree = {
  "name": "P",
  "nodeType": 1,
  "children": [{
    "name": "#text",
    "nodeType": 3,
    "content": "Example: "
  }, {
    "name": "I",
    "nodeType": 1,
    "children": [{
      "name": "#text",
      "nodeType": 3,
      "content": "italic"
    }]
  }, {
    "name": "#text",
    "nodeType": 3,
    "content": " and "
  }, {
    "name": "B",
    "nodeType": 1,
    "children": [{
      "name": "#text",
      "nodeType": 3,
      "content": "bold"
    }]
  }]
}

drawHtmlTree(selectPDomtree, 'div.select-p-domtree', 690, 320);
</script>

<p>让我们来选择 <code>&quot;Example: &lt;i&gt;italic&lt;/i&gt;&quot;</code>。它是 <code>&lt;p&gt;</code> 的前两个子节点（文本节点也算在内）：</p>
<p><img src="range-example-p-0-1.svg" alt=""></p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p&quot;</span>&gt;</span>Example: <span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>italic<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> and <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>bold<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
*!*
  <span class="hljs-keyword">let</span> range = <span class="hljs-keyword">new</span> Range();

  range.setStart(p, <span class="hljs-number">0</span>);
  range.setEnd(p, <span class="hljs-number">2</span>);
*/!*

  <span class="hljs-comment">// 范围的 toString 以文本形式返回其内容（不带标签）</span>
  alert(range); <span class="hljs-comment">// Example: italic</span>

  <span class="hljs-comment">// 将此范围应用于文档选择（后文有解释）</span>
  <span class="hljs-built_in">document</span>.getSelection().addRange(range);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<ul>
<li><code>range.setStart(p, 0)</code> —— 将起点设置为 <code>&lt;p&gt;</code> 的第 0 个子节点（即文本节点 <code>&quot;Example: &quot;</code>）。</li>
<li><code>range.setEnd(p, 2)</code> —— 覆盖范围至（但不包括）<code>&lt;p&gt;</code> 的第 2 个子节点（即文本节点 <code>&quot; and &quot;</code>，但由于不包括末节点，所以最后选择的节点是 <code>&lt;i&gt;</code>）。</li>
</ul>
<p>这是一个更灵活的测试台，你可以在其中尝试更多不同的情况：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p&quot;</span>&gt;</span>Example: <span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>italic<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> and <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>bold<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

From <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;start&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">1</span>&gt;</span> – To <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;end&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">4</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>Click to select<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  button.onclick = <span class="hljs-function">() =&gt;</span> {
  *!*
    <span class="hljs-keyword">let</span> range = <span class="hljs-keyword">new</span> Range();

    range.setStart(p, start.value);
    range.setEnd(p, end.value);
  */!*

    <span class="hljs-comment">// 应用选择，后文有解释</span>
    <span class="hljs-built_in">document</span>.getSelection().removeAllRanges();
    <span class="hljs-built_in">document</span>.getSelection().addRange(range);
  };
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>例如，从 <code>1</code> 到 <code>4</code> 选择得到的范围为 <code>&lt;i&gt;italic&lt;/i&gt; and &lt;b&gt;bold&lt;/b&gt;</code>。</p>
<p><img src="range-example-p-1-3.svg" alt=""></p>
<p>我们不必在 <code>setStart</code> 和 <code>setEnd</code> 中使用相同的节点。一个范围可能跨越许多不相关的节点。唯一要注意的是终点要在起点之后。</p>
<h3 id="选择文本节点的一部分">选择文本节点的一部分</h3>
<p>让我们选择部分文本，像这样：</p>
<p><img src="range-example-p-2-b-3.svg" alt=""></p>
<p>这也是可以做到的，我们只需要将起点和终点设置为文本节点中的相对偏移量即可。</p>
<p>我们需要创建一个范围，它：</p>
<ul>
<li>从 <code>&lt;p&gt;</code> 的第一个子节点的位置 2 开始（选择 &quot;Ex<b>ample:</b> &quot; 中除前两个字母外的所有字母）</li>
<li>到 <code>&lt;b&gt;</code> 的第一个子节点的位置 3 结束（选择 &quot;<b>bol</b>d&quot; 的前三个字母，就这些）：</li>
</ul>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p&quot;</span>&gt;</span>Example: <span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>italic<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> and <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>bold<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">let</span> range = <span class="hljs-keyword">new</span> Range();

  range.setStart(p.firstChild, <span class="hljs-number">2</span>);
  range.setEnd(p.querySelector(<span class="hljs-string">&#x27;b&#x27;</span>).firstChild, <span class="hljs-number">3</span>);

  alert(range); <span class="hljs-comment">// ample: italic and bol</span>

  <span class="hljs-comment">// 使用此范围进行选择（后文有解释）</span>
  <span class="hljs-built_in">window</span>.getSelection().addRange(range);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p><code>range</code> 对象具有以下属性：</p>
<p><img src="range-example-p-2-b-3-range.svg" alt=""></p>
<ul>
<li><code>startContainer</code>，<code>startOffset</code> —— 起始节点和偏移量，<ul>
<li>在上例中：分别是 <code>&lt;p&gt;</code> 中的第一个文本节点和 <code>2</code>。</li>
</ul>
</li>
<li><code>endContainer</code>，<code>endOffset</code> —— 结束节点和偏移量，<ul>
<li>在上例中：分别是 <code>&lt;b&gt;</code> 中的第一个文本节点和 <code>3</code>。</li>
</ul>
</li>
<li><code>collapsed</code> —— 布尔值，如果范围在同一点上开始和结束（所以范围内没有内容）则为 <code>true</code>，<ul>
<li>在上例中：<code>false</code></li>
</ul>
</li>
<li><code>commonAncestorContainer</code> —— 在范围内的所有节点中最近的共同祖先节点，<ul>
<li>在上例中：<code>&lt;p&gt; </code></li>
</ul>
</li>
</ul>
<h2 id="range-方法">Range 方法</h2>
<p>有许多便利的方法可以操纵范围。</p>
<p>设置范围的起点：</p>
<ul>
<li><code>setStart(node, offset)</code> 将起点设置在：<code>node</code> 中的位置 <code>offset</code></li>
<li><code>setStartBefore(node)</code> 将起点设置在：<code>node</code> 前面</li>
<li><code>setStartAfter(node)</code> 将起点设置在：<code>node</code> 后面</li>
</ul>
<p>设置范围的终点（类似的方法）：</p>
<ul>
<li><code>setEnd(node, offset)</code> 将终点设置为：<code>node</code> 中的位置 <code>offset</code></li>
<li><code>setEndBefore(node)</code> 将终点设置为：<code>node</code> 前面</li>
<li><code>setEndAfter(node)</code> 将终点设置为：<code>node</code> 后面</li>
</ul>
<p><strong>如前所述，<code>node</code> 既可以是文本节点，也可以是元素节点：对于文本节点，<code>offset</code> 偏移的是字符数，而对于元素节点则是子节点数。</strong></p>
<p>其他：</p>
<ul>
<li><code>selectNode(node)</code> 设置范围以选择整个 <code>node</code></li>
<li><code>selectNodeContents(node)</code> 设置范围以选择整个 <code>node</code> 的内容</li>
<li><code>collapse(toStart)</code> 如果 <code>toStart=true</code> 则设置 end=start，否则设置 start=end，从而折叠范围</li>
<li><code>cloneRange()</code> 创建一个具有相同起点/终点的新范围</li>
</ul>
<p>如要操纵范围内的内容：</p>
<ul>
<li><code>deleteContents()</code> —— 从文档中删除范围内容</li>
<li><code>extractContents()</code> —— 从文档中删除范围内容，并将删除的内容作为 <a href="info:modifying-document#document-fragment">DocumentFragment</a> 返回</li>
<li><code>cloneContents()</code> —— 复制范围内容，并将复制的内容作为 <a href="info:modifying-document#document-fragment">DocumentFragment</a> 返回</li>
<li><code>insertNode(node)</code> —— 在范围的起始处将 <code>node</code> 插入文档</li>
<li><code>surroundContents(node)</code> —— 使用 <code>node</code> 将所选范围内容包裹起来。要使此操作有效，则该范围必须包含其中所有元素的开始和结束标签：不能像 <code>&lt;i&gt;abc</code> 这样的部分范围。</li>
</ul>
<p>使用这些方法，我们基本上可以对选定的节点执行任何操作。</p>
<p>这是在测试台上看到它们的实际效果：</p>
<pre><code class="language-html">点击按钮运行所选内容上的方法，点击 &quot;resetExample&quot; 进行重置。

<span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p&quot;</span>&gt;</span>Example: <span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>italic<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> and <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>bold<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;result&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">let</span> range = <span class="hljs-keyword">new</span> Range();

  <span class="hljs-comment">// 下面演示了上述的每个方法：</span>
  <span class="hljs-keyword">let</span> methods = {
    <span class="hljs-function"><span class="hljs-title">deleteContents</span>(<span class="hljs-params"></span>)</span> {
      range.deleteContents()
    },
    <span class="hljs-function"><span class="hljs-title">extractContents</span>(<span class="hljs-params"></span>)</span> {
      <span class="hljs-keyword">let</span> content = range.extractContents();
      result.innerHTML = <span class="hljs-string">&quot;&quot;</span>;
      result.append(<span class="hljs-string">&quot;extracted: &quot;</span>, content);
    },
    <span class="hljs-function"><span class="hljs-title">cloneContents</span>(<span class="hljs-params"></span>)</span> {
      <span class="hljs-keyword">let</span> content = range.cloneContents();
      result.innerHTML = <span class="hljs-string">&quot;&quot;</span>;
      result.append(<span class="hljs-string">&quot;cloned: &quot;</span>, content);
    },
    <span class="hljs-function"><span class="hljs-title">insertNode</span>(<span class="hljs-params"></span>)</span> {
      <span class="hljs-keyword">let</span> newNode = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;u&#x27;</span>);
      newNode.innerHTML = <span class="hljs-string">&quot;NEW NODE&quot;</span>;
      range.insertNode(newNode);
    },
    <span class="hljs-function"><span class="hljs-title">surroundContents</span>(<span class="hljs-params"></span>)</span> {
      <span class="hljs-keyword">let</span> newNode = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;u&#x27;</span>);
      <span class="hljs-keyword">try</span> {
        range.surroundContents(newNode);
      } <span class="hljs-function"><span class="hljs-title">catch</span>(<span class="hljs-params">e</span>)</span> { alert(e) }
    },
    <span class="hljs-function"><span class="hljs-title">resetExample</span>(<span class="hljs-params"></span>)</span> {
      p.innerHTML = <span class="hljs-string">`Example: &lt;i&gt;italic&lt;/i&gt; and &lt;b&gt;bold&lt;/b&gt;`</span>;
      result.innerHTML = <span class="hljs-string">&quot;&quot;</span>;

      range.setStart(p.firstChild, <span class="hljs-number">2</span>);
      range.setEnd(p.querySelector(<span class="hljs-string">&#x27;b&#x27;</span>).firstChild, <span class="hljs-number">3</span>);

      <span class="hljs-built_in">window</span>.getSelection().removeAllRanges();  
      <span class="hljs-built_in">window</span>.getSelection().addRange(range);  
    }
  };

  <span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> method <span class="hljs-keyword">in</span> methods</span>)</span> {
    <span class="hljs-built_in">document</span>.write(<span class="hljs-string">`&lt;div&gt;&lt;button onclick=&quot;methods.<span class="hljs-subst">${method}</span>()&quot;&gt;<span class="hljs-subst">${method}</span>&lt;/button&gt;&lt;/div&gt;`</span>);
  }

  methods.resetExample();
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>还有比较范围的方法，但是很少使用。当你需要它们时，请参考 <a href="https://dom.spec.whatwg.org/#interface-range">规范</a> 或 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Range">MDN 手册</a>。</p>
<h2 id="选择">选择</h2>
<p><code>Range</code> 是用于管理选择范围的通用对象。我们可能会创建此类对象，并传递它们 —— 它们在视觉上不会自行选择任何内容。</p>
<p>文档选择是由 <code>Selection</code> 对象表示的，可通过 <code>window.getSelection()</code> 或 <code>document.getSelection()</code> 来获取。</p>
<p>一个选择可以包括零个或多个范围。至少，<a href="https://www.w3.org/TR/selection-api/">Selection API 规范</a> 是这么说的。不过实际上，只有 Firefox 允许使用 <code>key:Ctrl+click</code> (Mac 上用 <code>key:Cmd+click</code>) 在文档中选择多个范围。</p>
<p>这是在 Firefox 中做的一个具有 3 个范围的选择的截图：</p>
<p><img src="selection-firefox.svg" alt=""></p>
<p>其他浏览器最多支持 1 个范围。正如我们将看到的，某些 <code>Selection</code> 方法暗示可能有多个范围，但同样，在除 Firefox 之外的所有浏览器中，范围最多是 1。</p>
<h2 id="选择属性">选择属性</h2>
<p>与范围相似，选择的起点称为“锚点（anchor）”，终点称为“焦点（focus）”。</p>
<p>主要的选择属性有：</p>
<ul>
<li><code>anchorNode</code> —— 选择的起始节点，</li>
<li><code>anchorOffset</code> —— 选择开始的 <code>anchorNode</code> 中的偏移量，</li>
<li><code>focusNode</code> —— 选择的结束节点，</li>
<li><code>focusOffset</code> —— 选择开始处 <code>focusNode</code> 的偏移量，</li>
<li><code>isCollapsed</code> —— 如果未选择任何内容（空范围）或不存在，则为 <code>true</code> 。</li>
<li><code>rangeCount</code> —— 选择中的范围数，除 Firefox 外，其他浏览器最多为 <code>1</code>。</li>
</ul>
<pre><code class="language-smart">有很多选择内容的方式，取决于用户的操作：鼠标，热键，手机上的点击等。

其中的某些方式，例如鼠标，允许从两个方向创建相同的选择：“从左到右”和“从右到左”。

如果在文档中，选择的起点（anchor）在终点（focus）之前，则称此选择具有 &quot;forward&quot; 方向。

例如，如果用户使用鼠标从 &quot;Example&quot; 开始选择到 &quot;italic&quot;：

![](selection-direction-forward.svg)

否则，如果是从 &quot;italic&quot; 的末尾开始选择到 &quot;Example&quot;，则所选内容将被定向为 &quot;backward&quot;，其焦点（focus）将在锚点（anchor）之前：

![](selection-direction-backward.svg)

这与始终指向前方的 `Range` 对象不同：范围的起点不能在终点之后。</code></pre>
<h2 id="选择事件">选择事件</h2>
<p>有一些事件可以跟踪选择：</p>
<ul>
<li><code>elem.onselectstart</code> —— 当选择从 <code>elem</code> 上开始时，例如，用户按下鼠标键并开始移动鼠标。<ul>
<li>阻止默认行为会使选择无法开始。</li>
</ul>
</li>
<li><code>document.onselectionchange</code> —— 当选择变动时。<ul>
<li>请注意：此处理程序只能在 <code>document</code> 上设置。</li>
</ul>
</li>
</ul>
<h3 id="选择跟踪演示">选择跟踪演示</h3>
<p>下面是一个小型演示，它随更改动态显示选择边界：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p&quot;</span>&gt;</span>Select me: <span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>italic<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> and <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>bold<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

From <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;from&quot;</span> <span class="hljs-attr">disabled</span>&gt;</span> – To <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;to&quot;</span> <span class="hljs-attr">disabled</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-built_in">document</span>.onselectionchange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">let</span> {anchorNode, anchorOffset, focusNode, focusOffset} = <span class="hljs-built_in">document</span>.getSelection();

    <span class="hljs-keyword">from</span>.value = <span class="hljs-string">`<span class="hljs-subst">${anchorNode &amp;&amp; anchorNode.data}</span>:<span class="hljs-subst">${anchorOffset}</span>`</span>;
    to.value = <span class="hljs-string">`<span class="hljs-subst">${focusNode &amp;&amp; focusNode.data}</span>:<span class="hljs-subst">${focusOffset}</span>`</span>;
  };
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h3 id="选择获取演示">选择获取演示</h3>
<p>要获取整个选择：</p>
<ul>
<li>作为文本：只需调用 <code>document.getSelection().toString()</code>。</li>
<li>作为 DOM 节点：获取底层的（underlying）范围，并调用它们的 <code>cloneContents()</code> 方法（如果我们不支持 Firefox 多选的话，则仅取第一个范围）。 </li>
</ul>
<p>下面是将选择内容获取为文本和 DOM 节点的演示：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p&quot;</span>&gt;</span>Select me: <span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>italic<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> and <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>bold<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

Cloned: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cloned&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>
As text: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;astext&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-built_in">document</span>.onselectionchange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">let</span> selection = <span class="hljs-built_in">document</span>.getSelection();

    cloned.innerHTML = astext.innerHTML = <span class="hljs-string">&quot;&quot;</span>;

    <span class="hljs-comment">// 从范围复制 DOM 节点（这里我们支持多选）</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; selection.rangeCount; i++) {
      cloned.append(selection.getRangeAt(i).cloneContents());
    }

    <span class="hljs-comment">// 获取为文本形式</span>
    astext.innerHTML += selection;
  };
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h2 id="选择方法">选择方法</h2>
<p>添加/移除范围的选择方法：</p>
<ul>
<li><code>getRangeAt(i)</code> —— 获取从 <code>0</code> 开始的第 i 个范围。在除 Firefox 之外的所有浏览器中，仅使用 <code>0</code>。</li>
<li><code>addRange(range)</code> —— 将 <code>range</code> 添加到选择中。如果选择已有关联的范围，则除 Firefox 外的所有浏览器都将忽略该调用。</li>
<li><code>removeRange(range)</code> —— 从选择中删除 <code>range</code>。</li>
<li><code>removeAllRanges()</code> —— 删除所有范围。</li>
<li><code>empty()</code> —— <code>removeAllRanges</code> 的别名。</li>
</ul>
<p>另外，还有一些方便的方法可以直接操作选择范围，而无需使用 <code>Range</code>：</p>
<ul>
<li><code>collapse(node, offset)</code> —— 用一个新的范围替换选定的范围，该新范围从给定的 <code>node</code> 处开始，到偏移 <code>offset</code> 处结束。</li>
<li><code>setPosition(node, offset)</code> —— <code>collapse</code> 的别名。</li>
<li><code>collapseToStart()</code> —— 折叠（替换为空范围）到选择起点，</li>
<li><code>collapseToEnd()</code> —— 折叠到选择终点，</li>
<li><code>extend(node, offset)</code> —— 将选择的焦点（focus）移到给定的 <code>node</code>，位置偏移 <code>oofset</code>，</li>
<li><code>setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset)</code> —— 用给定的起点 <code>anchorNode/anchorOffset</code> 和终点 <code>focusNode/focusOffset</code> 来替换选择范围。选中它们之间的所有内容。</li>
<li><code>selectAllChildren(node)</code> —— 选择 <code>node</code> 的所有子节点。</li>
<li><code>deleteFromDocument()</code> —— 从文档中删除所选择的内容。</li>
<li><code>containsNode(node, allowPartialContainment = false)</code> —— 检查选择中是否包含 <code>node</code>（特别是如果第二个参数是 <code>true</code> 的话）</li>
</ul>
<p>因此，对于许多任务，我们可以调用 <code>Selection</code> 方法，而无需访问底层的（underlying）<code>Range</code> 对象。</p>
<p>例如，选择段落 <code>&lt;p&gt;</code> 的全部内容：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p&quot;</span>&gt;</span>Select me: <span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>italic<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> and <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>bold<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-comment">// 从 &lt;p&gt; 的第 0 个子节点选择到最后一个子节点</span>
  <span class="hljs-built_in">document</span>.getSelection().setBaseAndExtent(p, <span class="hljs-number">0</span>, p, p.childNodes.length);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>使用范围来完成同一个操作：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p&quot;</span>&gt;</span>Select me: <span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>italic<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> and <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>bold<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">let</span> range = <span class="hljs-keyword">new</span> Range();
  range.selectNodeContents(p); <span class="hljs-comment">// 或者也可以使用 selectNode(p) 来选择 &lt;p&gt; 标签</span>

  <span class="hljs-built_in">document</span>.getSelection().removeAllRanges(); <span class="hljs-comment">// 清除现有选择（如果有的话）</span>
  <span class="hljs-built_in">document</span>.getSelection().addRange(range);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<pre><code class="language-smart">如果选择已存在，则首先使用 `removeAllRanges()` 将其清空。然后添加范围。否则，除 Firefox 外的所有浏览器都将忽略新范围。

某些选择方法例外，它们会替换现有的选择，例如 `setBaseAndExtent`。</code></pre>
<h2 id="表单控件中的选择">表单控件中的选择</h2>
<p>诸如 <code>input</code> 和 <code>textarea</code> 等表单元素提供了 <a href="https://html.spec.whatwg.org/#textFieldSelection">专用的选择 API</a>，没有 <code>Selection</code> 或 <code>Range</code> 对象。由于输入值是纯文本而不是 HTML，因此不需要此类对象，一切都变得更加简单。</p>
<p>属性：</p>
<ul>
<li><code>input.selectionStart</code> —— 选择的起始位置（可写），</li>
<li><code>input.selectionEnd</code> —— 选择的结束位置（可写），</li>
<li><code>input.selectionDirection</code> —— 选择方向，其中之一：&quot;forward&quot;，&quot;backward&quot; 或 &quot;none&quot;（例如使用鼠标双击进行的选择），</li>
</ul>
<p>事件：</p>
<ul>
<li><code>input.onselect</code> —— 当某个东西被选择时触发。</li>
</ul>
<p>方法：</p>
<ul>
<li><p><code>input.select()</code> —— 选择文本控件中的所有内容（可以是 <code>textarea</code> 而不是 <code>input</code>），</p>
</li>
<li><p><code>input.setSelectionRange(start, end, [direction])</code> —— 在给定方向上（可选），从 <code>start</code> 一直选择到 <code>end</code>。</p>
</li>
<li><p><code>input.setRangeText(replacement, [start], [end], [selectionMode])</code> —— 用新文本替换范围中的文本。</p>
<p>  可选参数 <code>start</code> 和 <code>end</code>，如果提供的话，则设置范围的起点和终点，否则使用用户的选择。</p>
<p>  最后一个参数 <code>selectionMode</code> 决定替换文本后如何设置选择。可能的值为：</p>
<ul>
<li><code>&quot;select&quot;</code> —— 将选择新插入的文本。</li>
<li><code>&quot;start&quot;</code> —— 选择范围将在插入的文本之前折叠（光标将在其之前）。</li>
<li><code>&quot;end&quot;</code> —— 选择范围将在插入的文本之后折叠（光标将紧随其后）。</li>
<li><code>&quot;preserve&quot;</code> —— 尝试保留选择。这是默认值。</li>
</ul>
</li>
</ul>
<p>现在，让我们看看这些方法的实际使用。</p>
<h3 id="示例：跟踪选择">示例：跟踪选择</h3>
<p>例如，此段代码使用 <code>onselect</code> 事件来跟踪选择：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;area&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:80%;height:60px&quot;</span>&gt;</span>
Selecting in this text updates values below.
<span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>
From <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;from&quot;</span> <span class="hljs-attr">disabled</span>&gt;</span> – To <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;to&quot;</span> <span class="hljs-attr">disabled</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  area.onselect = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">from</span>.value = area.selectionStart;
    to.value = area.selectionEnd;
  };
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>请注意：</p>
<ul>
<li><code>onselect</code> 是在某项被选择时触发，而在选择被删除时不触发。</li>
<li>根据 <a href="https://w3c.github.io/selection-api/#dfn-selectionchange">规范</a>，发表单控件内的选择不应该触发 <code>document.onselectionchange</code> 事件，因为它与 <code>document</code> 选择和范围不相关。一些浏览器会生成它，但我们不应该依赖它。</li>
</ul>
<h3 id="示例：移动光标">示例：移动光标</h3>
<p>我们可以更改 <code>selectionStart</code> 和 <code>selectionEnd</code>，二者设定了选择。</p>
<p>一个重要的边界情况是 <code>selectionStart</code> 和 <code>selectionEnd</code> 彼此相等。那正是光标位置。或者，换句话说，当未选择任何内容时，选择会折叠在光标位置。</p>
<p>因此，通过将 <code>selectionStart</code> 和 <code>selectionEnd</code> 设置为相同的值，我们可以移动光标。</p>
<p>例如：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;area&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:80%;height:60px&quot;</span>&gt;</span>
Focus on me, the cursor will be at position 10.
<span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  area.onfocus = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 设置零延迟 setTimeout 以在浏览器 &quot;focus&quot; 行为完成后运行</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-comment">// 我们可以设置任何选择</span>
      <span class="hljs-comment">// 如果 start=end，则光标就会在该位置</span>
      area.selectionStart = area.selectionEnd = <span class="hljs-number">10</span>;
    });
  };
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h3 id="示例：修改选择">示例：修改选择</h3>
<p>如要修改选择的内容，我们可以使用 <code>input.setRangeText()</code> 方法。当然，我们可以读取 <code>selectionStart/End</code>，并在了解选择的情况下更改 <code>value</code> 的相应子字符串，但是 <code>setRangeText</code> 功能更强大，通常更方便。</p>
<p>那是一个有点复杂的方法。使用其最简单的单参数形式，它可以替换用户选择的范围并删除该选择。</p>
<p>例如，这里的用户的选择将被包装在 <code>*...*</code> 中：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;input&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:200px&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Select here and click the button&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>Wrap selection in stars *...*<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
button.onclick = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">if</span> (input.selectionStart == input.selectionEnd) {
    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 什么都没选</span>
  }

  <span class="hljs-keyword">let</span> selected = input.value.slice(input.selectionStart, input.selectionEnd);
  input.setRangeText(<span class="hljs-string">`*<span class="hljs-subst">${selected}</span>*`</span>);
};
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>使用更多参数，我们可以设置范围 <code>start</code> 和 <code>end</code>。</p>
<p>在下面这个示例中，我们在输入文本中找到 <code>&quot;THIS&quot;</code>，将其替换，并保持替换文本的选中状态：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;input&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:200px&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Replace THIS in text&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>Replace THIS<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
button.onclick = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">let</span> pos = input.value.indexOf(<span class="hljs-string">&quot;THIS&quot;</span>);
  <span class="hljs-keyword">if</span> (pos &gt;= <span class="hljs-number">0</span>) {
    input.setRangeText(<span class="hljs-string">&quot;*THIS*&quot;</span>, pos, pos + <span class="hljs-number">4</span>, <span class="hljs-string">&quot;select&quot;</span>);
    input.focus(); <span class="hljs-comment">// 聚焦（focus），以使选择可见</span>
  }
};
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h3 id="示例：在光标处插入">示例：在光标处插入</h3>
<p>如果未选择任何内容，或者我们在 <code>setRangeText</code> 中使用了相同的 <code>start</code> 和 <code>end</code>，则仅插入新文本，不会删除任何内容。</p>
<p>我们也可以使用 <code>setRangeText</code> 在“光标处”插入一些东西。</p>
<p>这是一个按钮，按下后会在光标位置插入 <code>&quot;HELLO&quot;</code>，然后光标紧随其后。如果选择不为空，则将其替换（我们可以通过比较 <code>selectionStart!=selectionEnd</code> 来进行检查，为空则执行其他操作）：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;input&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:200px&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Text Text Text Text Text&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>Insert &quot;HELLO&quot; at cursor<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  button.onclick = <span class="hljs-function">() =&gt;</span> {
    input.setRangeText(<span class="hljs-string">&quot;HELLO&quot;</span>, input.selectionStart, input.selectionEnd, <span class="hljs-string">&quot;end&quot;</span>);
    input.focus();
  };    
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h2 id="使不可选">使不可选</h2>
<p>要使某些内容不可选，有三种方式：</p>
<ol>
<li><p>使用 CSS 属性 <code>user-select: none</code>。</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
<span class="hljs-selector-id">#elem</span> {
  <span class="hljs-attribute">user-select</span>: none;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Selectable <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;elem&quot;</span>&gt;</span>Unselectable<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> Selectable<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p> 这样不允许选择从 <code>elem</code> 开始。但是用户可以在其他地方开始选择，并将 <code>elem</code> 包含在内。</p>
<p> 然后 <code>elem</code> 将成为 <code>document.getSelection()</code> 的一部分，因此选择实际发生了，但是在复制粘贴中，其内容通常会被忽略。</p>
</li>
</ol>
<ol start="2">
<li><p>防止 <code>onselectstart</code> 或 <code>mousedown</code> 事件中的默认行为。</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Selectable <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;elem&quot;</span>&gt;</span>Unselectable<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> Selectable<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  elem.onselectstart = <span class="hljs-function">() =&gt;</span> <span class="hljs-literal">false</span>;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p> 这样可以防止在 <code>elem</code> 上开始选择，但是访问者可以在另一个元素上开始选择，然后扩展到 <code>elem</code>。</p>
<p> 当同一行为上有另一个事件处理程序触发选择时（例如 <code>mousedown</code>），这会很方便。因此我们禁用选择以避免冲突，仍然允许复制 <code>elem</code> 内容。</p>
</li>
<li><p>我们还可以使用 <code>document.getSelection().empty()</code> 来在选择发生后清除选择。很少使用这种方法，因为这会在选择项消失时导致不必要的闪烁。</p>
</li>
</ol>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://dom.spec.whatwg.org/#ranges">DOM 规范：范围（Range）</a></li>
<li><a href="https://www.w3.org/TR/selection-api/#dom-globaleventhandlers-onselectstart">选择（Selection）API</a></li>
<li><a href="https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#textFieldSelection">HTML 规范：用于文本控件选择的 API</a></li>
</ul>
<h2 id="总结">总结</h2>
<p>我们介绍了用于选择的两种不同的 API：</p>
<ol>
<li>对于文档：<code>Selection</code> 和 <code>Range</code> 对象。</li>
<li>对于 <code>input</code>，<code>textarea</code>：其他方法和属性。</li>
</ol>
<p>第二个 API 非常简单，因为它处理的是文本。</p>
<p>最常用的方案一般是：</p>
<ol>
<li><p>获取选择：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> selection = <span class="hljs-built_in">document</span>.getSelection();

<span class="hljs-keyword">let</span> cloned = <span class="hljs-comment">/* 要将所选的节点克隆到的元素 */</span>;

<span class="hljs-comment">// 然后将 Range 方法应用于 selection.getRangeAt(0)</span>
<span class="hljs-comment">// 或者，像这样，用于所有范围，以支持多选</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; selection.rangeCount; i++) {
  cloned.append(selection.getRangeAt(i).cloneContents());
}</code></pre>
</li>
<li><p>设置选择</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> selection = <span class="hljs-built_in">document</span>.getSelection();

<span class="hljs-comment">// 直接：</span>
selection.setBaseAndExtent(...from...to...);

<span class="hljs-comment">// 或者我们可以创建一个范围并：</span>
selection.removeAllRanges();
selection.addRange(range);</code></pre>
</li>
</ol>
<p>最后，关于光标。在诸如 <code>&lt;textarea&gt;</code> 之类的可编辑元素中，光标的位置始终位于选择的起点或终点。我们可以通过设置 <code>elem.selectionStart</code> 和 <code>elem.selectionEnd</code> 来获取光标位置或移动光标。</p>

      </fieldset>
      
      <fieldset id='_VSjRl0'>
      <legend>article</legend>
      <h1 id="事件循环：微任务和宏任务">事件循环：微任务和宏任务</h1>
<p>浏览器中 JavaScript 的执行流程和 Node.js 中的流程都是基于 <strong>事件循环</strong> 的。</p>
<p>理解事件循环的工作方式对于代码优化很重要，有时对于正确的架构也很重要。</p>
<p>在本章中，我们首先介绍有关事物工作方式的理论细节，然后介绍该知识的实际应用。</p>
<h2 id="事件循环">事件循环</h2>
<p><strong>事件循环</strong> 的概念非常简单。它是一个在 JavaScript 引擎等待任务，执行任务和进入休眠状态等待更多任务这几个状态之间转换的无限循环。</p>
<p>引擎的一般算法：</p>
<ol>
<li>当有任务时：<ul>
<li>从最先进入的任务开始执行。</li>
</ul>
</li>
<li>休眠直到出现任务，然后转到第 1 步。</li>
</ol>
<p>当我们浏览一个网页时就是上述这种形式。JavaScript 引擎大多数时候不执行任何操作，仅在脚本/处理程序/事件激活时执行。</p>
<p>任务示例：</p>
<ul>
<li>当外部脚本 <code>&lt;script src=&quot;...&quot;&gt;</code> 加载完成时，任务就是执行它。</li>
<li>当用户移动鼠标时，任务就是派生出 <code>mousemove</code> 事件和执行处理程序。</li>
<li>当安排的（scheduled）<code>setTimeout</code> 时间到达时，任务就是执行其回调。</li>
<li>……诸如此类。</li>
</ul>
<p>设置任务 —— 引擎处理它们 —— 然后等待更多任务（即休眠，几乎不消耗 CPU 资源）。</p>
<p>一个任务到来时，引擎可能正处于繁忙状态，那么这个任务就会被排入队列。</p>
<p>多个任务组成了一个队列，即所谓的“宏任务队列”（v8 术语）：</p>
<p><img src="eventLoop.svg" alt=""></p>
<p>例如，当引擎正在忙于执行一段 <code>script</code> 时，用户可能会移动鼠标而产生 <code>mousemove</code> 事件，<code>setTimeout</code> 或许也刚好到期，以及其他任务，这些任务组成了一个队列，如上图所示。</p>
<p>队列中的任务基于“先进先出”的原则执行。当浏览器引擎执行完 <code>script</code> 后，它会处理 <code>mousemove</code> 事件，然后处理 <code>setTimeout</code> 处理程序，依此类推。</p>
<p>到目前为止，很简单，对吧？</p>
<p>两个细节：</p>
<ol>
<li>引擎执行任务时永远不会进行渲染（render）。如果任务执行需要很长一段时间也没关系。仅在任务完成后才会绘制对 DOM 的更改。</li>
<li>如果一项任务执行花费的时间过长，浏览器将无法执行其他任务，无法处理用户事件，因此，在一定时间后浏览器会在整个页面抛出一个如“页面未响应”之类的警报，建议你终止这个任务。这种情况常发生在有大量复杂的计算或导致死循环的程序错误时。</li>
</ol>
<p>以上是理论知识。现在，让我们来看看如何应用这些知识。</p>
<h2 id="用例-1：拆分-cpu-过载任务">用例 1：拆分 CPU 过载任务</h2>
<p>假设我们有一个 CPU 过载任务。</p>
<p>例如，语法高亮（用来给本页面中的示例代码着色）是相当耗费 CPU 资源的任务。为了高亮显示代码，它执行分析，创建很多着了色的元素，然后将它们添加到文档中 —— 对于文本量大的文档来说，需要耗费很长时间。</p>
<p>当引擎忙于语法高亮时，它就无法处理其他 DOM 相关的工作，例如处理用户事件等。它甚至可能会导致浏览器“中断（hiccup）”甚至“挂起（hang）”一段时间，这是不可接受的。</p>
<p>我们可以通过将大任务拆分成多个小任务来避免这个问题。高亮显示前 100 行，然后使用 <code>setTimeout</code>（延时参数为 0）来安排（schedule）后 100 行的高亮显示，依此类推。</p>
<p>为了演示这种方法，简单起见，让我们写一个从 <code>1</code> 数到 <code>1000000000</code> 的函数，而不写文本高亮。</p>
<p>如果你运行下面这段代码，你会看到引擎会“挂起”一段时间。对于服务端 JS 来说这显而易见，并且如果你在浏览器中运行它，尝试点击页面上其他按钮时，你会发现在计数结束之前不会处理其他事件。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;

<span class="hljs-keyword">let</span> start = <span class="hljs-built_in">Date</span>.now();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">count</span>(<span class="hljs-params"></span>) </span>{

  <span class="hljs-comment">// 做一个繁重的任务</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1e9</span>; j++) {
    i++;
  }

  alert(<span class="hljs-string">&quot;Done in &quot;</span> + (<span class="hljs-built_in">Date</span>.now() - start) + <span class="hljs-string">&#x27;ms&#x27;</span>);
}

count();</code></pre>
<p>浏览器甚至可能会显示一个“脚本执行时间过长”的警告。</p>
<p>让我们使用嵌套的 <code>setTimeout</code> 调用来拆分这个任务：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;

<span class="hljs-keyword">let</span> start = <span class="hljs-built_in">Date</span>.now();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">count</span>(<span class="hljs-params"></span>) </span>{

  <span class="hljs-comment">// 做繁重的任务的一部分 (*)</span>
  <span class="hljs-keyword">do</span> {
    i++;
  } <span class="hljs-keyword">while</span> (i % <span class="hljs-number">1e6</span> != <span class="hljs-number">0</span>);

  <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1e9</span>) {
    alert(<span class="hljs-string">&quot;Done in &quot;</span> + (<span class="hljs-built_in">Date</span>.now() - start) + <span class="hljs-string">&#x27;ms&#x27;</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">setTimeout</span>(count); <span class="hljs-comment">// 安排（schedule）新的调用 (**)</span>
  }

}

count();</code></pre>
<p>现在，浏览器界面在“计数”过程中可以正常使用。</p>
<p>单次执行 <code>count</code> 会完成工作 <code>(*)</code> 的一部分，然后根据需要重新安排（schedule）自身的执行 <code>(**)</code>：</p>
<ol>
<li>首先执行计数：<code>i=1...1000000</code>。</li>
<li>然后执行计数：<code>i=1000001..2000000</code>。</li>
<li>……以此类推。</li>
</ol>
<p>现在，如果在引擎忙于执行第一部分时出现了一个新的副任务（例如 <code>onclick</code> 事件），则该任务会被排入队列，然后在第一部分执行结束时，并在下一部分开始执行前，会执行该副任务。周期性地在两次 <code>count</code> 执行期间返回事件循环，这为 JavaScript 引擎提供了足够的“空气”来执行其他操作，以响应其他的用户行为。</p>
<p>值得注意的是这两种变体 —— 是否使用了 <code>setTimeout</code> 对任务进行拆分 —— 在执行速度上是相当的。在执行计数的总耗时上没有多少差异。</p>
<p>为了使两者耗时更接近，让我们来做一个改进。</p>
<p>我们将要把调度（scheduling）移动到 <code>count()</code> 的开头：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;

<span class="hljs-keyword">let</span> start = <span class="hljs-built_in">Date</span>.now();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">count</span>(<span class="hljs-params"></span>) </span>{

  <span class="hljs-comment">// 将调度（scheduling）移动到开头</span>
  <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1e9</span> - <span class="hljs-number">1e6</span>) {
    <span class="hljs-built_in">setTimeout</span>(count); <span class="hljs-comment">// 安排（schedule）新的调用</span>
  }

  <span class="hljs-keyword">do</span> {
    i++;
  } <span class="hljs-keyword">while</span> (i % <span class="hljs-number">1e6</span> != <span class="hljs-number">0</span>);

  <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1e9</span>) {
    alert(<span class="hljs-string">&quot;Done in &quot;</span> + (<span class="hljs-built_in">Date</span>.now() - start) + <span class="hljs-string">&#x27;ms&#x27;</span>);
  }

}

count();</code></pre>
<p>现在，当我们开始调用 <code>count()</code> 时，会看到我们需要对 <code>count()</code> 进行更多调用，我们就会在工作前立即安排（schedule）它。</p>
<p>如果你运行它，你很容易注意到它花费的时间明显减少了。</p>
<p>为什么？</p>
<p>这很简单：你应该还记得，多个嵌套的 <code>setTimeout</code> 调用在浏览器中的最小延迟为 4ms。即使我们设置了 <code>0</code>，但还是 <code>4ms</code>（或者更久一些）。所以我们安排（schedule）得越早，运行速度也就越快。</p>
<p>最后，我们将一个繁重的任务拆分成了几部分，现在它不会阻塞用户界面了。而且其总耗时并不会长很多。</p>
<h2 id="用例-2：进度指示">用例 2：进度指示</h2>
<p>对浏览器脚本中的过载型任务进行拆分的另一个好处是，我们可以显示进度指示。</p>
<p>通常，浏览器会在当前执行的代码完成后进行渲染（render）。任务的执行是否会花费很长时间对此没有影响。对 DOM 的更改只有在任务完成后才会被绘制。</p>
<p>从一方面讲，这非常好，因为我们的函数可能会创建很多元素，将它们一个接一个地插入到文档中，并更改其样式 —— 访问者不会看到任何未完成的“中间态”内容。很重要，对吧？</p>
<p>这是一个示例，对 <code>i</code> 的更改在该函数完成前不会显示出来，所以我们将只会看到最后的值：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;progress&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">count</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1e6</span>; i++) {
      i++;
      progress.innerHTML = i;
    }
  }

  count();
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>……但是我们也可能想在任务执行期间展示一些东西，例如进度条。</p>
<p>如果我们使用 <code>setTimeout</code> 将繁重的任务拆分成几部分，那么变化就会被在它们之间绘制出来。</p>
<p>这看起来更好看：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;progress&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">count</span>(<span class="hljs-params"></span>) </span>{

    <span class="hljs-comment">// 做繁重的任务的一部分 (*)</span>
    <span class="hljs-keyword">do</span> {
      i++;
      progress.innerHTML = i;
    } <span class="hljs-keyword">while</span> (i % <span class="hljs-number">1e3</span> != <span class="hljs-number">0</span>);

    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1e7</span>) {
      <span class="hljs-built_in">setTimeout</span>(count);
    }

  }

  count();
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>现在 <code>div</code> 显示了 <code>i</code> 的值的增长，这就是进度条的一种。</p>
<h2 id="用例-3：在事件之后做一些事情">用例 3：在事件之后做一些事情</h2>
<p>在事件处理程序中，我们可能会决定推迟某些行为，直到事件冒泡并在所有级别上得到处理后。我们可以通过将该代码包装到零延迟的 <code>setTimeout</code> 中来做到这一点。</p>
<p>在 <a href="info:dispatch-events">info:dispatch-events</a> 一章中，我们看到过这样一个例子：自定义事件 <code>menu-open</code> 被在 <code>setTimeout</code> 中分派（dispatched），所以它在 <code>click</code> 事件被处理完成之后发生。</p>
<pre><code class="language-js">menu.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// ...</span>

  <span class="hljs-comment">// 创建一个具有被点击的菜单项的数据的自定义事件</span>
  <span class="hljs-keyword">let</span> customEvent = <span class="hljs-keyword">new</span> CustomEvent(<span class="hljs-string">&quot;menu-open&quot;</span>, {
    <span class="hljs-attr">bubbles</span>: <span class="hljs-literal">true</span>
  });

  <span class="hljs-comment">// 异步分派（dispatch）自定义事件</span>
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> menu.dispatchEvent(customEvent));
};</code></pre>
<h2 id="宏任务和微任务">宏任务和微任务</h2>
<p>除了本章中所讲的 <strong>宏任务（macrotask）</strong> 外，还有在 <a href="info:microtask-queue">info:microtask-queue</a> 一章中提到的 <strong>微任务（microtask）</strong>。</p>
<p>微任务仅来自于我们的代码。它们通常是由 promise 创建的：对 <code>.then/catch/finally</code> 处理程序的执行会成为微任务。微任务也被用于 <code>await</code> 的“幕后”，因为它是 promise 处理的另一种形式。</p>
<p>还有一个特殊的函数 <code>queueMicrotask(func)</code>，它对 <code>func</code> 进行排队，以在微任务队列中执行。</p>
<p><strong>每个宏任务之后，引擎会立即执行微任务队列中的所有任务，然后再执行其他的宏任务，或渲染，或进行其他任何操作。</strong></p>
<p>例如，看看下面这个示例：</p>
<pre><code class="language-js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> alert(<span class="hljs-string">&quot;timeout&quot;</span>));

<span class="hljs-built_in">Promise</span>.resolve()
  .then(<span class="hljs-function">() =&gt;</span> alert(<span class="hljs-string">&quot;promise&quot;</span>));

alert(<span class="hljs-string">&quot;code&quot;</span>);</code></pre>
<p>这里的执行顺序是怎样的？</p>
<ol>
<li><code>code</code> 首先显示，因为它是常规的同步调用。</li>
<li><code>promise</code> 第二个出现，因为 <code>then</code> 会通过微任务队列，并在当前代码之后执行。</li>
<li><code>timeout</code> 最后显示，因为它是一个宏任务。</li>
</ol>
<p>更详细的事件循环图示如下（顺序是从上到下，即：首先是脚本，然后是微任务，渲染等）：</p>
<p><img src="eventLoop-full.svg" alt=""></p>
<p>微任务会在执行任何其他事件处理，或渲染，或执行任何其他宏任务之前完成。</p>
<p>这很重要，因为它确保了微任务之间的应用程序环境基本相同（没有鼠标坐标更改，没有新的网络数据等）。</p>
<p>如果我们想要异步执行（在当前代码之后）一个函数，但是要在更改被渲染或新事件被处理之前执行，那么我们可以使用 <code>queueMicrotask</code> 来对其进行安排（schedule）。</p>
<p>这是一个与前面那个例子类似的，带有“计数进度条”的示例，但是它使用了 <code>queueMicrotask</code> 而不是 <code>setTimeout</code>。你可以看到它在最后才渲染。就像写的是同步代码一样：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;progress&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">count</span>(<span class="hljs-params"></span>) </span>{

    <span class="hljs-comment">// 做繁重的任务的一部分 (*)</span>
    <span class="hljs-keyword">do</span> {
      i++;
      progress.innerHTML = i;
    } <span class="hljs-keyword">while</span> (i % <span class="hljs-number">1e3</span> != <span class="hljs-number">0</span>);

    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1e6</span>) {
  *!*
      queueMicrotask(count);
  */!*
    }

  }

  count();
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h2 id="总结">总结</h2>
<p>事件循环的更详细的算法（尽管与 <a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model">规范</a> 相比仍然是简化过的）：</p>
<ol>
<li>从 <strong>宏任务</strong> 队列（例如 &quot;script&quot;）中出队（dequeue）并执行最早的任务。</li>
<li>执行所有 <strong>微任务</strong>：<ul>
<li>当微任务队列非空时：<ul>
<li>出队（dequeue）并执行最早的微任务。</li>
</ul>
</li>
</ul>
</li>
<li>执行渲染，如果有。</li>
<li>如果宏任务队列为空，则休眠直到出现宏任务。</li>
<li>转到步骤 1。</li>
</ol>
<p>安排（schedule）一个新的 <strong>宏任务</strong>：</p>
<ul>
<li>使用零延迟的 <code>setTimeout(f)</code>。</li>
</ul>
<p>它可被用于将繁重的计算任务拆分成多个部分，以使浏览器能够对用户事件作出反应，并在任务的各部分之间显示任务进度。</p>
<p>此外，也被用于在事件处理程序中，将一个行为（action）安排（schedule）在事件被完全处理（冒泡完成）后。</p>
<p>安排一个新的 <strong>微任务</strong>：</p>
<ul>
<li>使用 <code>queueMicrotask(f)</code>。</li>
<li>promise 处理程序也会通过微任务队列。</li>
</ul>
<p>在微任务之间没有 UI 或网络事件的处理：它们一个立即接一个地执行。</p>
<p>所以，我们可以使用 <code>queueMicrotask</code> 来在保持环境状态一致的情况下，异步地执行一个函数。</p>
<pre><code class="language-smart">对于不应该阻塞事件循环的耗时长的繁重计算任务，我们可以使用 [Web Workers](https://html.spec.whatwg.org/multipage/workers.html)。

这是在另一个并行线程中运行代码的方式。

Web Workers 可以与主线程交换消息，但是它们具有自己的变量和事件循环。

Web Workers 没有访问 DOM 的权限，因此，它们对于同时使用多个 CPU 内核的计算非常有用。</code></pre>

      </fieldset>
      </div><div id="nav"><div style="margin-left:0em"><strong>document</strong><br/></div><div style="margin-left:1em"><strong>browser-environment</strong><br/></div><div style="margin-left:2em"><a href="#_QSncxJ">article</a><br/></div><div style="margin-left:1em"><strong>dom-nodes</strong><br/></div><div style="margin-left:2em"><a href="#_awpr8v">article</a><br/></div><div style="margin-left:1em"><strong>dom-navigation</strong><br/></div><div style="margin-left:2em"><strong>dom-children</strong><br/></div><div style="margin-left:3em"><a href="#_u51xbI">solution</a><br/></div><div style="margin-left:3em"><a href="#_vkHaL2">task</a><br/></div><div style="margin-left:2em"><strong>navigation-links-which-null</strong><br/></div><div style="margin-left:3em"><a href="#_ZuBekJ">solution</a><br/></div><div style="margin-left:3em"><a href="#_eOXcbp">task</a><br/></div><div style="margin-left:2em"><strong>select-diagonal-cells</strong><br/></div><div style="margin-left:3em"><a href="#_OCTNew">solution</a><br/></div><div style="margin-left:3em"><a href="#_avvXrR">task</a><br/></div><div style="margin-left:2em"><a href="#_cHtPyU">article</a><br/></div><div style="margin-left:1em"><strong>searching-elements-dom</strong><br/></div><div style="margin-left:2em"><strong>find-elements</strong><br/></div><div style="margin-left:3em"><a href="#_65GfB1">solution</a><br/></div><div style="margin-left:3em"><a href="#_OhZFXy">task</a><br/></div><div style="margin-left:2em"><a href="#_uOrMem">article</a><br/></div><div style="margin-left:1em"><strong>basic-dom-node-properties</strong><br/></div><div style="margin-left:2em"><strong>lastchild-nodetype-inline</strong><br/></div><div style="margin-left:3em"><a href="#_X5lhbj">solution</a><br/></div><div style="margin-left:3em"><a href="#_mjDba5">task</a><br/></div><div style="margin-left:2em"><strong>tree-info</strong><br/></div><div style="margin-left:3em"><a href="#_eGpPua">solution</a><br/></div><div style="margin-left:3em"><a href="#_h2Sg7z">task</a><br/></div><div style="margin-left:2em"><strong>tag-in-comment</strong><br/></div><div style="margin-left:3em"><a href="#_nVrRy0">solution</a><br/></div><div style="margin-left:3em"><a href="#_ZbiuoF">task</a><br/></div><div style="margin-left:2em"><strong>where-document-in-hierarchy</strong><br/></div><div style="margin-left:3em"><a href="#_V8VKQR">solution</a><br/></div><div style="margin-left:3em"><a href="#_XZfGb3">task</a><br/></div><div style="margin-left:2em"><a href="#_4c7F2l">article</a><br/></div><div style="margin-left:1em"><strong>dom-attributes-and-properties</strong><br/></div><div style="margin-left:2em"><strong>get-user-attribute</strong><br/></div><div style="margin-left:3em"><a href="#_jq8MTj">solution</a><br/></div><div style="margin-left:3em"><a href="#_crdt5O">task</a><br/></div><div style="margin-left:2em"><strong>yellow-links</strong><br/></div><div style="margin-left:3em"><a href="#_iAsEmS">solution</a><br/></div><div style="margin-left:3em"><a href="#_NJXha8">task</a><br/></div><div style="margin-left:2em"><a href="#_05OdF4">article</a><br/></div><div style="margin-left:1em"><strong>modifying-document</strong><br/></div><div style="margin-left:2em"><strong>createtextnode-vs-innerhtml</strong><br/></div><div style="margin-left:3em"><a href="#_3sR0Mm">solution</a><br/></div><div style="margin-left:3em"><a href="#_jreTQb">task</a><br/></div><div style="margin-left:2em"><strong>clock-setinterval</strong><br/></div><div style="margin-left:3em"><a href="#_UQg7X9">solution</a><br/></div><div style="margin-left:3em"><a href="#_tXl4qQ">task</a><br/></div><div style="margin-left:2em"><strong>append-to-list</strong><br/></div><div style="margin-left:3em"><a href="#_32is4V">solution</a><br/></div><div style="margin-left:3em"><a href="#_vETkXX">task</a><br/></div><div style="margin-left:2em"><strong>sort-table</strong><br/></div><div style="margin-left:3em"><a href="#_pjooXP">solution</a><br/></div><div style="margin-left:3em"><a href="#_O2Tif2">task</a><br/></div><div style="margin-left:2em"><strong>clear-elem</strong><br/></div><div style="margin-left:3em"><a href="#_ABsK0P">solution</a><br/></div><div style="margin-left:3em"><a href="#_KzIYHY">task</a><br/></div><div style="margin-left:2em"><strong>why-aaa</strong><br/></div><div style="margin-left:3em"><a href="#_nFj86J">solution</a><br/></div><div style="margin-left:3em"><a href="#_be9gjI">task</a><br/></div><div style="margin-left:2em"><strong>create-list</strong><br/></div><div style="margin-left:3em"><a href="#_WPayqS">solution</a><br/></div><div style="margin-left:3em"><a href="#_TmeuCo">task</a><br/></div><div style="margin-left:2em"><strong>create-object-tree</strong><br/></div><div style="margin-left:3em"><a href="#_mzxcMi">solution</a><br/></div><div style="margin-left:3em"><a href="#_AmjoeY">task</a><br/></div><div style="margin-left:2em"><strong>tree-count</strong><br/></div><div style="margin-left:3em"><a href="#_OdU9hg">solution</a><br/></div><div style="margin-left:3em"><a href="#_el6HcV">task</a><br/></div><div style="margin-left:2em"><strong>calendar-table</strong><br/></div><div style="margin-left:3em"><a href="#_fVVWo3">solution</a><br/></div><div style="margin-left:3em"><a href="#_ttLZxn">task</a><br/></div><div style="margin-left:2em"><a href="#_Ew4yHY">article</a><br/></div><div style="margin-left:1em"><strong>styles-and-classes</strong><br/></div><div style="margin-left:2em"><strong>create-notification</strong><br/></div><div style="margin-left:3em"><a href="#_j2e7rD">solution</a><br/></div><div style="margin-left:3em"><a href="#_qZdZaL">task</a><br/></div><div style="margin-left:2em"><a href="#_dkx8hn">article</a><br/></div><div style="margin-left:1em"><strong>size-and-scroll</strong><br/></div><div style="margin-left:2em"><strong>get-scroll-height-bottom</strong><br/></div><div style="margin-left:3em"><a href="#_82818F">solution</a><br/></div><div style="margin-left:3em"><a href="#_BvaTeh">task</a><br/></div><div style="margin-left:2em"><strong>scrollbar-width</strong><br/></div><div style="margin-left:3em"><a href="#_lGeBCT">solution</a><br/></div><div style="margin-left:3em"><a href="#_y4J9Jk">task</a><br/></div><div style="margin-left:2em"><strong>put-ball-in-center</strong><br/></div><div style="margin-left:3em"><strong>ball-half</strong><br/></div><div style="margin-left:3em"><a href="#_SP9ynq">solution</a><br/></div><div style="margin-left:3em"><a href="#_zQZwUV">task</a><br/></div><div style="margin-left:2em"><strong>width-vs-clientwidth</strong><br/></div><div style="margin-left:3em"><a href="#_OG2cli">solution</a><br/></div><div style="margin-left:3em"><a href="#_DhPn8l">task</a><br/></div><div style="margin-left:2em"><a href="#_KOi1Mw">article</a><br/></div><div style="margin-left:1em"><strong>size-and-scroll-window</strong><br/></div><div style="margin-left:2em"><a href="#_x5KyD5">article</a><br/></div><div style="margin-left:1em"><strong>coordinates</strong><br/></div><div style="margin-left:2em"><strong>find-point-coordinates</strong><br/></div><div style="margin-left:3em"><a href="#_vumhk6">solution</a><br/></div><div style="margin-left:3em"><a href="#_sLVRkf">task</a><br/></div><div style="margin-left:2em"><strong>position-at</strong><br/></div><div style="margin-left:3em"><a href="#_gNBVp8">solution</a><br/></div><div style="margin-left:3em"><a href="#_sVHSuv">task</a><br/></div><div style="margin-left:2em"><strong>position-at-absolute</strong><br/></div><div style="margin-left:3em"><a href="#_P7IwG4">solution</a><br/></div><div style="margin-left:3em"><a href="#_Z9wpSc">task</a><br/></div><div style="margin-left:2em"><strong>position-inside-absolute</strong><br/></div><div style="margin-left:3em"><a href="#_VVB1TK">solution</a><br/></div><div style="margin-left:3em"><a href="#_wEI1MD">task</a><br/></div><div style="margin-left:2em"><a href="#_S9GoHl">article</a><br/></div><div style="margin-left:0em"><strong>events</strong><br/></div><div style="margin-left:1em"><strong>introduction-browser-events</strong><br/></div><div style="margin-left:2em"><strong>hide-other</strong><br/></div><div style="margin-left:3em"><a href="#_ESCPRQ">solution</a><br/></div><div style="margin-left:3em"><a href="#_xsUzhL">task</a><br/></div><div style="margin-left:2em"><strong>hide-self-onclick</strong><br/></div><div style="margin-left:3em"><a href="#_zVbQaZ">solution</a><br/></div><div style="margin-left:3em"><a href="#_lOJeS7">task</a><br/></div><div style="margin-left:2em"><strong>which-handlers-run</strong><br/></div><div style="margin-left:3em"><a href="#_SCqErq">solution</a><br/></div><div style="margin-left:3em"><a href="#_Vfb82x">task</a><br/></div><div style="margin-left:2em"><strong>move-ball-field</strong><br/></div><div style="margin-left:3em"><a href="#_QZLvDw">solution</a><br/></div><div style="margin-left:3em"><a href="#_5AtFEu">task</a><br/></div><div style="margin-left:2em"><strong>sliding-menu</strong><br/></div><div style="margin-left:3em"><a href="#_f907WK">solution</a><br/></div><div style="margin-left:3em"><a href="#_VRAcbM">task</a><br/></div><div style="margin-left:2em"><strong>hide-message</strong><br/></div><div style="margin-left:3em"><a href="#_bIZJQt">solution</a><br/></div><div style="margin-left:3em"><a href="#_b3cAst">task</a><br/></div><div style="margin-left:2em"><strong>carousel</strong><br/></div><div style="margin-left:3em"><a href="#_3AYUNq">solution</a><br/></div><div style="margin-left:3em"><a href="#_Ht82vX">task</a><br/></div><div style="margin-left:2em"><a href="#_aiDRlt">article</a><br/></div><div style="margin-left:1em"><strong>bubbling-and-capturing</strong><br/></div><div style="margin-left:2em"><a href="#_PPZVIo">article</a><br/></div><div style="margin-left:1em"><strong>event-delegation</strong><br/></div><div style="margin-left:2em"><strong>hide-message-delegate</strong><br/></div><div style="margin-left:3em"><a href="#_yfCdMe">solution</a><br/></div><div style="margin-left:3em"><a href="#_pEypbT">task</a><br/></div><div style="margin-left:2em"><strong>sliding-tree</strong><br/></div><div style="margin-left:3em"><a href="#_G6ro2b">solution</a><br/></div><div style="margin-left:3em"><a href="#_tTuT8C">task</a><br/></div><div style="margin-left:2em"><strong>sortable-table</strong><br/></div><div style="margin-left:3em"><a href="#_KOIad7">solution</a><br/></div><div style="margin-left:3em"><a href="#_BRd0yQ">task</a><br/></div><div style="margin-left:2em"><strong>behavior-tooltip</strong><br/></div><div style="margin-left:3em"><a href="#_LcOH27">solution</a><br/></div><div style="margin-left:3em"><a href="#_MBAiO9">task</a><br/></div><div style="margin-left:2em"><a href="#_ynIoBx">article</a><br/></div><div style="margin-left:1em"><strong>default-browser-action</strong><br/></div><div style="margin-left:2em"><strong>why-return-false-fails</strong><br/></div><div style="margin-left:3em"><a href="#_Aq5Ta5">solution</a><br/></div><div style="margin-left:3em"><a href="#_ZH7xMJ">task</a><br/></div><div style="margin-left:2em"><strong>catch-link-navigation</strong><br/></div><div style="margin-left:3em"><a href="#_6C2i6B">solution</a><br/></div><div style="margin-left:3em"><a href="#_k3Io5P">task</a><br/></div><div style="margin-left:2em"><strong>image-gallery</strong><br/></div><div style="margin-left:3em"><a href="#_QtKCOg">solution</a><br/></div><div style="margin-left:3em"><a href="#_3m0Ufe">task</a><br/></div><div style="margin-left:2em"><a href="#_RvFyx6">article</a><br/></div><div style="margin-left:1em"><strong>dispatch-events</strong><br/></div><div style="margin-left:2em"><a href="#_7bd5nT">article</a><br/></div><div style="margin-left:0em"><strong>event-details</strong><br/></div><div style="margin-left:1em"><strong>mouse-events-basics</strong><br/></div><div style="margin-left:2em"><strong>selectable-list</strong><br/></div><div style="margin-left:3em"><a href="#_1mT5Nf">solution</a><br/></div><div style="margin-left:3em"><a href="#_Hmr8WL">task</a><br/></div><div style="margin-left:2em"><a href="#_2NX9zk">article</a><br/></div><div style="margin-left:1em"><strong>mousemove-mouseover-mouseout-mouseenter-mouseleave</strong><br/></div><div style="margin-left:2em"><strong>behavior-nested-tooltip</strong><br/></div><div style="margin-left:3em"><a href="#_iihVv5">solution</a><br/></div><div style="margin-left:3em"><a href="#_RLroBe">task</a><br/></div><div style="margin-left:2em"><strong>hoverintent</strong><br/></div><div style="margin-left:3em"><a href="#_cpQIOk">solution</a><br/></div><div style="margin-left:3em"><a href="#_Ra5Sy8">task</a><br/></div><div style="margin-left:2em"><a href="#_mMX8Sj">article</a><br/></div><div style="margin-left:1em"><strong>mouse-drag-and-drop</strong><br/></div><div style="margin-left:2em"><strong>slider</strong><br/></div><div style="margin-left:3em"><a href="#_62bW9u">solution</a><br/></div><div style="margin-left:3em"><a href="#_ycbfkZ">task</a><br/></div><div style="margin-left:2em"><strong>drag-heroes</strong><br/></div><div style="margin-left:3em"><a href="#_2HX8x1">solution</a><br/></div><div style="margin-left:3em"><a href="#_Wltepe">task</a><br/></div><div style="margin-left:2em"><a href="#_RQ7XPp">article</a><br/></div><div style="margin-left:1em"><strong>pointer-events</strong><br/></div><div style="margin-left:2em"><a href="#_VXHP9I">article</a><br/></div><div style="margin-left:1em"><strong>keyboard-events</strong><br/></div><div style="margin-left:2em"><strong>check-sync-keydown</strong><br/></div><div style="margin-left:3em"><a href="#_hKuC49">solution</a><br/></div><div style="margin-left:3em"><a href="#_hSDHF7">task</a><br/></div><div style="margin-left:2em"><a href="#_wb5mVm">article</a><br/></div><div style="margin-left:1em"><strong>onscroll</strong><br/></div><div style="margin-left:2em"><strong>endless-page</strong><br/></div><div style="margin-left:3em"><a href="#_gyyqIA">solution</a><br/></div><div style="margin-left:3em"><a href="#_khQeyD">task</a><br/></div><div style="margin-left:2em"><strong>updown-button</strong><br/></div><div style="margin-left:3em"><a href="#_ubJyfN">solution</a><br/></div><div style="margin-left:3em"><a href="#_CKB6kQ">task</a><br/></div><div style="margin-left:2em"><strong>load-visible-img</strong><br/></div><div style="margin-left:3em"><a href="#_TireCC">solution</a><br/></div><div style="margin-left:3em"><a href="#_vyxSUQ">task</a><br/></div><div style="margin-left:2em"><a href="#_QB9NZF">article</a><br/></div><div style="margin-left:0em"><strong>forms-controls</strong><br/></div><div style="margin-left:1em"><strong>form-elements</strong><br/></div><div style="margin-left:2em"><strong>add-select-option</strong><br/></div><div style="margin-left:3em"><a href="#_N5iKTE">solution</a><br/></div><div style="margin-left:3em"><a href="#_v0NzpJ">task</a><br/></div><div style="margin-left:2em"><a href="#_RK3yCf">article</a><br/></div><div style="margin-left:1em"><strong>focus-blur</strong><br/></div><div style="margin-left:2em"><strong>editable-div</strong><br/></div><div style="margin-left:3em"><a href="#_VoHuHY">solution</a><br/></div><div style="margin-left:3em"><a href="#_8C44Hd">task</a><br/></div><div style="margin-left:2em"><strong>edit-td-click</strong><br/></div><div style="margin-left:3em"><a href="#_OuyQo8">solution</a><br/></div><div style="margin-left:3em"><a href="#_APIBWQ">task</a><br/></div><div style="margin-left:2em"><strong>keyboard-mouse</strong><br/></div><div style="margin-left:3em"><a href="#_mg73JQ">solution</a><br/></div><div style="margin-left:3em"><a href="#_V75aRE">task</a><br/></div><div style="margin-left:2em"><a href="#_wGtfPN">article</a><br/></div><div style="margin-left:1em"><strong>events-change-input</strong><br/></div><div style="margin-left:2em"><strong>deposit-calculator</strong><br/></div><div style="margin-left:3em"><a href="#_1Lu8l9">solution</a><br/></div><div style="margin-left:3em"><a href="#_We99pV">task</a><br/></div><div style="margin-left:2em"><a href="#_vA6dvg">article</a><br/></div><div style="margin-left:1em"><strong>forms-submit</strong><br/></div><div style="margin-left:2em"><strong>modal-dialog</strong><br/></div><div style="margin-left:3em"><a href="#_1ca83x">solution</a><br/></div><div style="margin-left:3em"><a href="#_mzwbLw">task</a><br/></div><div style="margin-left:2em"><a href="#_L3Om4s">article</a><br/></div><div style="margin-left:0em"><strong>loading</strong><br/></div><div style="margin-left:1em"><strong>onload-ondomcontentloaded</strong><br/></div><div style="margin-left:2em"><a href="#_D40N7R">article</a><br/></div><div style="margin-left:1em"><strong>script-async-defer</strong><br/></div><div style="margin-left:2em"><a href="#_pri3bU">article</a><br/></div><div style="margin-left:1em"><strong>onload-onerror</strong><br/></div><div style="margin-left:2em"><strong>load-img-callback</strong><br/></div><div style="margin-left:3em"><a href="#_Fi550J">solution</a><br/></div><div style="margin-left:3em"><a href="#_UKje1W">task</a><br/></div><div style="margin-left:2em"><a href="#_so3xs4">article</a><br/></div><div style="margin-left:0em"><strong>ui-misc</strong><br/></div><div style="margin-left:1em"><strong>mutation-observer</strong><br/></div><div style="margin-left:2em"><a href="#_1owvWO">article</a><br/></div><div style="margin-left:1em"><strong>selection-range</strong><br/></div><div style="margin-left:2em"><a href="#_96Cn9f">article</a><br/></div><div style="margin-left:1em"><strong>event-loop</strong><br/></div><div style="margin-left:2em"><a href="#_VSjRl0">article</a><br/></div></div>
</body></html>