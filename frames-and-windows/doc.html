<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>create for ggdoc , @author sunyi</title>
    <style>
        .octicon{display:inline-block;fill:currentColor;vertical-align:text-bottom}
        .anchor{float:left;line-height:1;margin-left:-20px;padding-right:4px}
        .anchor:focus{outline:0}
        h1 .octicon-link,h2 .octicon-link,h3 .octicon-link,h4 .octicon-link,h5 .octicon-link,h6 .octicon-link{color:#1b1f23;vertical-align:middle;visibility:hidden}
        h1:hover .anchor,h2:hover .anchor,h3:hover .anchor,h4:hover .anchor,h5:hover .anchor,h6:hover .anchor{text-decoration:none}
        h1:hover .anchor .octicon-link,h2:hover .anchor .octicon-link,h3:hover .anchor .octicon-link,h4:hover .anchor .octicon-link,h5:hover .anchor .octicon-link,h6:hover .anchor .octicon-link{visibility:visible}
        h1:hover .anchor .octicon-link:before,h2:hover .anchor .octicon-link:before,h3:hover .anchor .octicon-link:before,h4:hover .anchor .octicon-link:before,h5:hover .anchor .octicon-link:before,h6:hover .anchor .octicon-link:before{width:16px;height:16px;content:" ";display:inline-block;background-image:url("data:image/svg+xml,%3Csvgxmlns='http://www.w3.org/2000/svg'viewBox='001616'version='1.1'width='16'height='16'aria-hidden='true'%3E%3Cpathfill-rule='evenodd'd='M49h1v1H4c-1.50-3-1.69-3-3.5S2.55343h4c1.45031.6933.501.41-.912.72-23.25V8.59c.58-.451-1.271-2.09C105.228.98484H4c-.980-21.22-22.5S3949zm9-3h-1v1h1c1021.2222.5S13.98121312H9c-.980-2-1.22-2-2.50-.83.42-1.641-2.09V6.25c-1.09.53-21.84-23.25C611.317.5513913h4c1.4503-1.693-3.5S14.56136z'%3E%3C/path%3E%3C/svg%3E")}
        body{-webkit-text-size-adjust:100%;line-height:1.5;color:#24292e;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji;font-size:16px;line-height:1.5;word-wrap:break-word;background-color:#e3e3ef;height:100%;width:100%;margin:0;padding:20px}
        details{display:block}
        summary{display:list-item}
        a{background-color:initial}
        a:active,a:hover{outline-width:0}
        strong{font-weight:inherit;font-weight:bolder}
        h1{font-size:2em;margin:.67em 0}
        img{border-style:none}
        code,kbd,pre{font-family:monospace,monospace;font-size:1em}
        hr{box-sizing:initial;height:0;overflow:visible}
        input{font:inherit;margin:0}
        input{overflow:visible}
        [type="checkbox"]{box-sizing:border-box;padding:0}
        *{box-sizing:border-box}
        input{font-family:inherit;font-size:inherit;line-height:inherit}
        a{color:#0366d6;text-decoration:none}
        a:hover{text-decoration:underline}
        strong{font-weight:600}
        hr{height:0;margin:15px 0;overflow:hidden;background:transparent;border:0;border-bottom:1px solid #dfe2e5}
        hr:after,hr:before{display:table;content:""}
        hr:after{clear:both}
        table{border-spacing:0;border-collapse:collapse}
        td,th{padding:0}
        details summary{cursor:pointer}
        kbd{display:inline-block;padding:3px 5px;font:11px SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;line-height:10px;color:#444d56;vertical-align:middle;background-color:#fafbfc;border:1px solid #d1d5da;border-radius:3px;box-shadow:inset 0 -1px 0 #d1d5da}
        h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:0}
        h1{font-size:32px}
        h1,h2{font-weight:600}
        h2{font-size:24px}
        h3{font-size:20px}
        h3,h4{font-weight:600}
        h4{font-size:16px}
        h5{font-size:14px}
        h5,h6{font-weight:600}
        h6{font-size:12px}
        p{margin-top:0;margin-bottom:10px}
        blockquote{margin:0}
        ol,ul{padding-left:0;margin-top:0;margin-bottom:0}
        ol ol,ul ol{list-style-type:lower-roman}
        ol ol ol,ol ul ol,ul ol ol,ul ul ol{list-style-type:lower-alpha}
        dd{margin-left:0}
        code,pre{font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:12px}
        pre{margin-top:0;margin-bottom:0}
        input::-webkit-inner-spin-button,input::-webkit-outer-spin-button{margin:0;-webkit-appearance:none;appearance:none}
        :checked+.radio-label{position:relative;z-index:1;border-color:#0366d6}
        .border{border:1px solid #e1e4e8!important}
        .border-0{border:0!important}
        .border-bottom{border-bottom:1px solid #e1e4e8!important}
        .rounded-1{border-radius:3px!important}
        .bg-white{background-color:#fff!important}
        .bg-gray-light{background-color:#fafbfc!important}
        .text-gray-light{color:#6a737d!important}
        .mb-0{margin-bottom:0!important}
        .my-2{margin-top:8px!important;margin-bottom:8px!important}
        .pl-0{padding-left:0!important}
        .py-0{padding-top:0!important;padding-bottom:0!important}
        .pl-1{padding-left:4px!important}
        .pl-2{padding-left:8px!important}
        .py-2{padding-top:8px!important;padding-bottom:8px!important}
        .pl-3,.px-3{padding-left:16px!important}
        .px-3{padding-right:16px!important}
        .pl-4{padding-left:24px!important}
        .pl-5{padding-left:32px!important}
        .pl-6{padding-left:40px!important}
        .f6{font-size:12px!important}
        .lh-condensed{line-height:1.25!important}
        .text-bold{font-weight:600!important}
        .pl-c{color:#6a737d}
        .pl-c1,.pl-s .pl-v{color:#005cc5}
        .pl-e,.pl-en{color:#6f42c1}
        .pl-s .pl-s1,.pl-smi{color:#24292e}
        .pl-ent{color:#22863a}
        .pl-k{color:#d73a49}
        .pl-pds,.pl-s,.pl-s .pl-pse .pl-s1,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre{color:#032f62}
        .pl-smw,.pl-v{color:#e36209}
        .pl-bu{color:#b31d28}
        .pl-ii{color:#fafbfc;background-color:#b31d28}
        .pl-c2{color:#fafbfc;background-color:#d73a49}
        .pl-c2:before{content:"^M"}
        .pl-sr .pl-cce{font-weight:700;color:#22863a}
        .pl-ml{color:#735c0f}
        .pl-mh,.pl-mh .pl-en,.pl-ms{font-weight:700;color:#005cc5}
        .pl-mi{font-style:italic;color:#24292e}
        .pl-mb{font-weight:700;color:#24292e}
        .pl-md{color:#b31d28;background-color:#ffeef0}
        .pl-mi1{color:#22863a;background-color:#f0fff4}
        .pl-mc{color:#e36209;background-color:#ffebda}
        .pl-mi2{color:#f6f8fa;background-color:#005cc5}
        .pl-mdr{font-weight:700;color:#6f42c1}
        .pl-ba{color:#586069}
        .pl-sg{color:#959da5}
        .pl-corl{text-decoration:underline;color:#032f62}
        .mb-0{margin-bottom:0!important}
        .my-2{margin-bottom:8px!important}
        .my-2{margin-top:8px!important}
        .pl-0{padding-left:0!important}
        .py-0{padding-top:0!important;padding-bottom:0!important}
        .pl-1{padding-left:4px!important}
        .pl-2{padding-left:8px!important}
        .py-2{padding-top:8px!important;padding-bottom:8px!important}
        .pl-3{padding-left:16px!important}
        .pl-4{padding-left:24px!important}
        .pl-5{padding-left:32px!important}
        .pl-6{padding-left:40px!important}
        .pl-7{padding-left:48px!important}
        .pl-8{padding-left:64px!important}
        .pl-9{padding-left:80px!important}
        .pl-10{padding-left:96px!important}
        .pl-11{padding-left:112px!important}
        .pl-12{padding-left:128px!important}
        hr{border-bottom-color:#eee}
        kbd{display:inline-block;padding:3px 5px;font:11px SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;line-height:10px;color:#444d56;vertical-align:middle;background-color:#fafbfc;border:1px solid #d1d5da;border-radius:3px;box-shadow:inset 0 -1px 0 #d1d5da}
        .markdown-body:after,.markdown-body:before{display:table;content:""}
        .markdown-body:after{clear:both}
        .markdown-body>:first-child{margin-top:0!important}
        .markdown-body>:last-child{margin-bottom:0!important}
        a:not([href]){color:inherit;text-decoration:none}
        blockquote,details,dl,ol,p,pre,table,ul{margin-top:0;margin-bottom:16px}
        hr{height:.25em;padding:0;margin:24px 0;background-color:#e1e4e8;border:0}
        blockquote{padding:0 1em;color:#6a737d;border-left:.25em solid #dfe2e5}
        blockquote>:first-child{margin-top:0}
        blockquote>:last-child{margin-bottom:0}
        h1,h2,h3,h4,h5,h6{margin-top:24px;margin-bottom:16px;font-weight:600;line-height:1.25}
        h1{font-size:2em}
        h1,h2{padding-bottom:.3em;border-bottom:1px solid #eaecef}
        h2{font-size:1.5em}
        h3{font-size:1.25em}
        h4{font-size:1em}
        h5{font-size:.875em}
        h6{font-size:.85em;color:#6a737d}
        ol,ul{padding-left:2em}
        ol ol,ol ul,ul ol,ul ul{margin-top:0;margin-bottom:0}
        li{word-wrap:break-all}
        li>p{margin-top:16px}
        li+li{margin-top:.25em}
        dl{padding:0}
        dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:600}
        dl dd{padding:0 16px;margin-bottom:16px}
        table{display:block;width:100%;overflow:auto}
        table th{font-weight:600}
        table td,table th{padding:6px 13px;border:1px solid #dfe2e5}
        table tr{background-color:#fff;border-top:1px solid #c6cbd1}
        table tr:nth-child(2n){background-color:#f6f8fa}
        img{max-width:100%;box-sizing:initial;background-color:#fff}
        img[align="right"]{padding-left:20px}
        img[align="left"]{padding-right:20px}
        code{padding:.2em .4em;margin:0;font-size:85%;background-color:rgba(27,31,35,0.05);border-radius:3px}
        pre{word-wrap:normal}
        pre>code{padding:0;margin:0;font-size:100%;word-break:normal;white-space:pre;background:transparent;border:0}
        .highlight{margin-bottom:16px}
        .highlight pre{margin-bottom:0;word-break:normal}
        .highlight pre,pre{padding:16px;overflow:auto;font-size:85%;line-height:1.45;background-color:#f6f8fa;border-radius:3px}
        pre code{display:inline;max-width:auto;padding:0;margin:0;overflow:visible;line-height:inherit;word-wrap:normal;background-color:initial;border:0}
        .commit-tease-sha{display:inline-block;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:90%;color:#444d56}
        .full-commit .btn-outline:not(:disabled):hover{color:#005cc5;border-color:#005cc5}
        .blob-wrapper{overflow-x:auto;overflow-y:hidden}
        .blob-wrapper-embedded{max-height:240px;overflow-y:auto}
        .blob-num{width:1%;min-width:50px;padding-right:10px;padding-left:10px;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:12px;line-height:20px;color:rgba(27,31,35,0.3);text-align:right;white-space:nowrap;vertical-align:top;cursor:pointer;user-select:none}
        .blob-num:hover{color:rgba(27,31,35,0.6)}
        .blob-num:before{content:attr(data-line-number)}
        .blob-code{position:relative;padding-right:10px;padding-left:10px;line-height:20px;vertical-align:top}
        .blob-code-inner{overflow:visible;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:12px;color:#24292e;word-wrap:normal;white-space:pre}
        .pl-token.active,.pl-token:hover{cursor:pointer;background:#ffea7f}
        .tab-size[data-tab-size="1"]{-moz-tab-size:1;tab-size:1}
        .tab-size[data-tab-size="2"]{-moz-tab-size:2;tab-size:2}
        .tab-size[data-tab-size="3"]{-moz-tab-size:3;tab-size:3}
        .tab-size[data-tab-size="4"]{-moz-tab-size:4;tab-size:4}
        .tab-size[data-tab-size="5"]{-moz-tab-size:5;tab-size:5}
        .tab-size[data-tab-size="6"]{-moz-tab-size:6;tab-size:6}
        .tab-size[data-tab-size="7"]{-moz-tab-size:7;tab-size:7}
        .tab-size[data-tab-size="8"]{-moz-tab-size:8;tab-size:8}
        .tab-size[data-tab-size="9"]{-moz-tab-size:9;tab-size:9}
        .tab-size[data-tab-size="10"]{-moz-tab-size:10;tab-size:10}
        .tab-size[data-tab-size="11"]{-moz-tab-size:11;tab-size:11}
        .tab-size[data-tab-size="12"]{-moz-tab-size:12;tab-size:12}
        .task-list-item{list-style-type:none}
        .task-list-item+.task-list-item{margin-top:3px}
        .task-list-item input{margin:0 .2em .25em -1.6em;vertical-align:middle}
        #page{width:calc(100% - 500px);margin-left:500px;overflow: hidden;}
        fieldset{display:none;background-color:#fff;border:0;overflow:hidden;box-shadow:2px 2px 10px rgba(128,128,128,0.2);margin-bottom:20px;padding:20px}
        fieldset legend{font-weight:bold;color:green;height:3.5em;margin-left:-20px;padding:0}
        #nav{background:rgb(255 255 255 / .7);padding:20px 10px 100px 20px;position:fixed;top:0;left:0;bottom:0;width:500px;overflow-y:auto;overflow-x: hidden;white-space:nowrap}
        ::-webkit-scrollbar{width:5px}
        ::-webkit-scrollbar-thumb{background-color:#79a5e8}
        @media print,(max-width:900px){
          #nav{display:none!important}
          #page{width:100%!important;margin-left:0!important}
          fieldset{padding-top: 0 !important;padding-bottom: 0 !important;display:block!important;box-shadow:none!important}
          .toggle-hash-btn {display: none !important;}
        }
        .hljs{display:block;overflow-x:auto;padding:.5em;color:#333;background:#f8f8f8}
        .hljs-comment,.hljs-quote{color:#998;font-style:italic}
        .hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:bold}
        .hljs-number,.hljs-literal,.hljs-variable,.hljs-template-variable,.hljs-tag .hljs-attr{color:#008080}
        .hljs-string,.hljs-doctag{color:#d14}
        .hljs-title,.hljs-section,.hljs-selector-id{color:#900;font-weight:bold}
        .hljs-subst{font-weight:normal}
        .hljs-type,.hljs-class .hljs-title{color:#458;font-weight:bold}
        .hljs-tag,.hljs-name,.hljs-attribute{color:#000080;font-weight:normal}
        .hljs-regexp,.hljs-link{color:#009926}
        .hljs-symbol,.hljs-bullet{color:#990073}
        .hljs-built_in,.hljs-builtin-name{color:#0086b3}
        .hljs-meta{color:#999;font-weight:bold}
        .hljs-deletion{background:#fdd}
        .hljs-addition{background:#dfd}
        .hljs-emphasis{font-style:italic}
        .hljs-strong{font-weight:bold}
        .toggle-hash-btn {position: fixed;bottom: 10px;left:10px;z-index: 1000; display: flex; justify-content: space-between;  width: 270px;}
        iframe {border: 5px solid #999;margin:10px;width: 90%;min-height: 50px;}
    </style>
    <script>
          const $ = selector => document.querySelector(selector);
          const $$ = selector => document.querySelectorAll(selector);
          const decode = s => decodeURIComponent(s);
          const domInfo = dom => ({
            offsetParent: dom.offsetParent.className,
            offsetLeft: dom.offsetLeft,
            offsetTop: dom.offsetTop,
            clientWidth: dom.clientWidth,
            offsetWidth: dom.offsetWidth,
            BoundingClientRect: dom.getBoundingClientRect(),
          });
          let openHash = false;
          function viewFieldset() {
            const hash = decode(location.hash);
            if(openHash && hash &&$(`fieldset${hash}`)) {
              Array.from($$('fieldset')).forEach(dom  =>dom.style.display = 'none');
              $(`fieldset${hash}`).style.display = 'block';
            }else {
              Array.from($$('fieldset')).forEach(dom  =>dom.style.display = 'block');
            }
          }
          window.onhashchange = viewFieldset;
          window.onload  = ()=>{
            viewFieldset();
            setATarget();
          };
          
          function toggleHash() {
            openHash = !openHash;
            viewFieldset();
            $('.toggle-hash-btn button').innerText = openHash ? '关闭专注模式' : '开启专注模式';
          }
          function setATarget() {
            $$('#page a').forEach(a=>a.target = '_blank');
          }
    </script>
</head>

<body>
  <div class="toggle-hash-btn">
    <button  onclick="toggleHash()">开启专注模式</button>
  </div><div id="page">
      <fieldset id='_FHO7Cs'>
      <legend>article</legend>
      <h1 id="弹窗和-window-的方法">弹窗和 window 的方法</h1>
<p>弹窗（popup）是向用户显示其他文档的最古老的方法之一。</p>
<p>基本上，你只需要运行：</p>
<pre><code class="language-js"><span class="hljs-built_in">window</span>.open(<span class="hljs-string">&#x27;https://javascript.info/&#x27;</span>)</code></pre>
<p>……它将打开一个具有给定 URL 的新窗口。大多数现代浏览器都配置为打开新选项卡，而不是单独的窗口。</p>
<p>弹窗自古以来就存在。最初的想法是，在不关闭主窗口的情况下显示其他内容。目前为止，还有其他方式可以实现这一点：我们可以使用 <a href="info:fetch">fetch</a> 动态加载内容，并将其显示在动态生成的 <code>&lt;div&gt;</code> 中。弹窗并不是我们每天都会使用的东西。</p>
<p>并且，弹窗在移动设备上非常棘手，因为移动设备无法同时显示多个窗口。</p>
<p>但仍然有一些任务在使用弹窗，例如进行 OAuth 授权（使用 Google/Facebook/... 登陆），因为：</p>
<ol>
<li>弹窗是一个独立的窗口，具有自己的独立 JavaScript 环境。因此，使用弹窗打开一个不信任的第三方网站是安全的。</li>
<li>打开弹窗非常容易。</li>
<li>弹窗可以导航（修改 URL），并将消息发送到 opener 窗口（译注：即打开弹窗的窗口）。</li>
</ol>
<h2 id="阻止弹窗">阻止弹窗</h2>
<p>在过去，很多恶意网站经常滥用弹窗。一个不好的页面可能会打开大量带有广告的弹窗。因此，现在大多数浏览器都会通过阻止弹窗来保护用户。</p>
<p><strong>如果弹窗是在用户触发的事件处理程序（如 <code>onclick</code>）之外调用的，大多数浏览器都会阻止此类弹窗。</strong></p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-comment">// 弹窗被阻止</span>
<span class="hljs-built_in">window</span>.open(<span class="hljs-string">&#x27;https://javascript.info&#x27;</span>);

<span class="hljs-comment">// 弹窗被允许</span>
button.onclick = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-built_in">window</span>.open(<span class="hljs-string">&#x27;https://javascript.info&#x27;</span>);
};</code></pre>
<p>这种方式可以在某种程度上保护用户免受非必要的弹窗的影响，但是并没有完全阻止该功能。</p>
<p>如果弹窗是从 <code>onclick</code> 打开的，但是在 <code>setTimeout</code> 之后，该怎么办？这有点棘手。</p>
<p>试试运行一下这段代码：</p>
<pre><code class="language-js"><span class="hljs-comment">// 3 秒后打开弹窗</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">window</span>.open(<span class="hljs-string">&#x27;http://google.com&#x27;</span>), <span class="hljs-number">3000</span>);</code></pre>
<p>这个弹窗在 Chrome 中会被打开，但是在 Firefox 中会被阻止。</p>
<p>……如果我们减少延迟，则弹窗在 Firefox 中也会被打开：</p>
<pre><code class="language-js"><span class="hljs-comment">// 1 秒后打开弹窗</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">window</span>.open(<span class="hljs-string">&#x27;http://google.com&#x27;</span>), <span class="hljs-number">1000</span>);</code></pre>
<p>区别在于 Firefox 可以接受 2000ms 或更短的延迟，但是超过这个时间 —— 则移除“信任”。所以，第一个弹窗被阻止，而第二个却没有。</p>
<h2 id="windowopen">window.open</h2>
<p>打开一个弹窗的语法是 <code>window.open(url, name, params)</code>：</p>
<p>url
: 要在新窗口中加载的 URL。</p>
<p>name
: 新窗口的名称。每个窗口都有一个 <code>window.name</code>，在这里我们可以指定哪个窗口用于弹窗。如果已经有一个这样名字的窗口 —— 将在该窗口打开给定的 URL，否则会打开一个新窗口。</p>
<p>params
: 新窗口的配置字符串。它包括设置，用逗号分隔。参数之间不能有空格，例如：<code>width:200,height=100</code>。</p>
<p><code>params</code> 的设置项：</p>
<ul>
<li>位置:<ul>
<li><code>left/top</code>（数字）—— 屏幕上窗口的左上角的坐标。这有一个限制：不能将新窗口置于屏幕外（offscreen）。</li>
<li><code>width/height</code>（数字）—— 新窗口的宽度和高度。宽度/高度的最小值是有限制的，因此不可能创建一个不可见的窗口。</li>
</ul>
</li>
<li>窗口功能：<ul>
<li><code>menubar</code>（yes/no）—— 显示或隐藏新窗口的浏览器菜单。</li>
<li><code>toolbar</code>（yes/no）—— 显示或隐藏新窗口的浏览器导航栏（后退，前进，重新加载等）。</li>
<li><code>location</code>（yes/no）—— 显示或隐藏新窗口的 URL 字段。Firefox 和 IE 浏览器不允许默认隐藏它。</li>
<li><code>status</code>（yes/no）—— 显示或隐藏状态栏。同样，大多数浏览器都强制显示它。</li>
<li><code>resizable</code>（yes/no）—— 允许禁用新窗口大小调整。不建议使用。</li>
<li><code>scrollbars</code>（yes/no）—— 允许禁用新窗口的滚动条。不建议使用。</li>
</ul>
</li>
</ul>
<p>还有一些不太受支持的特定于浏览器的功能，通常不使用。通常不使用这些功能。更多示例请见 <a href="https://developer.mozilla.org/en/DOM/window.open">MDN 中的 window.open</a>。</p>
<h2 id="示例：一个最简窗口">示例：一个最简窗口</h2>
<p>让我们打开一个包含最小功能集的新窗口，来看看哪些功能是浏览器允许禁用的：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> params = <span class="hljs-string">`scrollbars=no,resizable=no,status=no,location=no,toolbar=no,menubar=no,
width=0,height=0,left=-1000,top=-1000`</span>;

open(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;test&#x27;</span>, params);</code></pre>
<p>在这里，大多数“窗口功能”都被禁用了，并且窗口位于屏幕外。运行它，看看会发生什么。大多数浏览器都会“修复”奇怪的东西，例如 <code>width/height</code> 为零以及脱离屏幕（offscreen）的 <code>left/top</code> 设置。例如，Chrome 打开了一个全 <code>width/height</code> 的窗口，使其占满整个屏幕。</p>
<p>让我们添加正常的定位选项和合理的 <code>width</code>、<code>height</code>、<code>left</code> 和 <code>top</code> 坐标：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> params = <span class="hljs-string">`scrollbars=no,resizable=no,status=no,location=no,toolbar=no,menubar=no,
width=600,height=300,left=100,top=100`</span>;

open(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;test&#x27;</span>, params);</code></pre>
<p>大多数浏览器会根据要求显示上面的示例。</p>
<p>设置中的省略规则：</p>
<ul>
<li>如果 <code>open</code> 调用中没有第三个参数，或者它是空的，则使用默认的窗口参数。</li>
<li>如果这里有一个参数字符串，但是某些 <code>yes/no</code> 功能被省略了，那么被省略的功能则被默认值为 <code>no</code>。因此，如果你指定参数，请确保将所有必需的功能明确设置为 <code>yes</code>。</li>
<li>如果参数中没有 <code>left/top</code>，那么浏览器会尝试在最后打开的窗口附近打开一个新窗口。</li>
<li>如果没有 <code>width/height</code>，那么新窗口的大小将与上次打开的窗口大小相同。</li>
</ul>
<h2 id="从窗口访问弹窗">从窗口访问弹窗</h2>
<p><code>open</code> 调用会返回对新窗口的引用。它可以用来操纵弹窗的属性，更改位置，甚至更多操作。</p>
<p>在下面这个示例中，我们从 JavaScript 中生成弹窗：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> newWin = <span class="hljs-built_in">window</span>.open(<span class="hljs-string">&quot;about:blank&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;width=200,height=200&quot;</span>);

newWin.document.write(<span class="hljs-string">&quot;Hello, world!&quot;</span>);</code></pre>
<p>这里，我们在其加载完成后，修改其中的内容：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> newWindow = open(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;example&#x27;</span>, <span class="hljs-string">&#x27;width=300,height=300&#x27;</span>)
newWindow.focus();

alert(newWindow.location.href); <span class="hljs-comment">// (*) about:blank，加载尚未开始</span>

newWindow.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> html = <span class="hljs-string">`&lt;div style=&quot;font-size:30px&quot;&gt;Welcome!&lt;/div&gt;`</span>;
*!*
  newWindow.document.body.insertAdjacentHTML(<span class="hljs-string">&#x27;afterbegin&#x27;</span>, html);
*/!*
};</code></pre>
<p>请注意：在刚刚进行了 <code>window.open</code> 的时候，新窗口还没有加载完成。我们可以通过 <code>(*)</code> 行中的 <code>alert</code> 证实这一点。因此，我们需要等待 <code>onload</code> 以对新窗口进行更改。我们也可以对 <code>newWin.document</code> 使用 <code>DOMContentLoaded</code> 处理程序。</p>
<pre><code class="language-warn">只有在窗口是同源的时，窗口才能自由访问彼此的内容（`相同的协议://domain:port`）。

否则，例如，如果主窗口来自于 `site.com`，弹窗来自于 `gmail.com`，则处于安全性考虑，这两个窗口不能访问彼此的内容。有关详细信息，请参见 &lt;info:cross-window-communication&gt; 一章。</code></pre>
<h2 id="从弹窗访问窗口">从弹窗访问窗口</h2>
<p>弹窗也可以使用 <code>window.opener</code> 来访问 opener 窗口。除了弹窗之外，对其他所有窗口来说，<code>window.opener</code> 均为 <code>null</code>。</p>
<p>如果你运行下面这段代码，它将用 &quot;Test&quot; 替换 opener（也就是当前的）窗口的内容：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> newWin = <span class="hljs-built_in">window</span>.open(<span class="hljs-string">&quot;about:blank&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;width=200,height=200&quot;</span>);

newWin.document.write(
  <span class="hljs-string">&quot;&lt;script&gt;window.opener.document.body.innerHTML = &#x27;Test&#x27;&lt;\/script&gt;&quot;</span>
);</code></pre>
<p>所以，窗口之间的连接是双向的：主窗口和弹窗之间相互引用。</p>
<h2 id="关闭弹窗">关闭弹窗</h2>
<p>关闭一个窗口：<code>win.close()</code>。</p>
<p>检查一个窗口是否被关闭：<code>win.closed</code>。</p>
<p>从技术上讲，<code>close()</code> 方法可用于任何 <code>window</code>，但是如果 <code>window</code> 不是通过 <code>window.open()</code> 创建的，那么大多数浏览器都会忽略 <code>window.close()</code>。因此，<code>close()</code> 只对弹窗起作用。</p>
<p>如果窗口被关闭了，那么 <code>closed</code> 属性则为 <code>true</code>。这对于检查弹窗（或主窗口）是否仍处于打开状态很有用。用户可以随时关闭它，我们的代码应该考虑到这种可能性。</p>
<p>这段代码加载并关闭了窗口：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> newWindow = open(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;example&#x27;</span>, <span class="hljs-string">&#x27;width=300,height=300&#x27;</span>);

newWindow.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  newWindow.close();
  alert(newWindow.closed); <span class="hljs-comment">// true</span>
};</code></pre>
<h2 id="滚动和调整大小">滚动和调整大小</h2>
<p>有一些方法可以移动一个窗口，或者调整一个窗口的大小：</p>
<p><code>win.moveBy(x,y)</code>
: 将窗口相对于当前位置向右移动 <code>x</code> 像素，并向下移动 <code>y</code> 像素。允许负值（向上/向左移动）。</p>
<p><code>win.moveTo(x,y)</code>
: 将窗口移动到屏幕上的坐标 <code>(x,y)</code> 处。</p>
<p><code>win.resizeBy(width,height)</code>
: 根据给定的相对于当前大小的 <code>width/height</code> 调整窗口大小。允许负值。</p>
<p><code>win.resizeTo(width,height)</code>
: 将窗口调整为给定的大小。</p>
<p>还有 <code>window.onresize</code> 事件。</p>
<pre><code class="language-warn">为了防止滥用，浏览器通常会阻止这些方法。它们仅在我们打开的，没有其他选项卡的弹窗中能够可靠地工作。</code></pre>
<pre><code class="language-warn">JavaScript 无法最小化或者最大化一个窗口。这些操作系统级别的功能对于前端开发者而言是隐藏的。

移动或者调整大小的方法不适用于最小化/最大化的窗口。</code></pre>
<h2 id="滚动窗口">滚动窗口</h2>
<p>我们已经在 <a href="info:size-and-scroll-window">info:size-and-scroll-window</a> 一章中讨论过了滚动窗口。</p>
<p><code>win.scrollBy(x,y)</code>
: 相对于当前位置，将窗口向右滚动 <code>x</code> 像素，并向下滚动 <code>y</code> 像素。允许负值。</p>
<p><code>win.scrollTo(x,y)</code>
: 将窗口滚动到给定坐标 <code>(x,y)</code>。</p>
<p><code>elem.scrollIntoView(top = true)</code>
: 滚动窗口，使 <code>elem</code> 显示在 <code>elem.scrollIntoView(false)</code> 的顶部（默认）或底部。</p>
<p>这里也有 <code>window.onscroll</code> 事件。</p>
<h2 id="弹窗的聚焦失焦">弹窗的聚焦/失焦</h2>
<p>从理论上讲，使用 <code>window.focus()</code> 和 <code>window.blur()</code> 方法可以使窗口获得或失去焦点。此外，这里还有 <code>focus/blur</code> 事件，可以聚焦窗口并捕获访问者切换到其他地方的瞬间。</p>
<p>在过去，恶意网站滥用了这些方法。例如，看这段代码:</p>
<pre><code class="language-js"><span class="hljs-built_in">window</span>.onblur = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">window</span>.focus();</code></pre>
<p>当用户尝试从窗口切换出去（<code>blur</code>）时，这段代码又让窗口重新获得了焦点。目的是将用户“锁定”在 <code>window</code> 中。</p>
<p>因此，就有了禁用此类代码的措施。保护用户免受广告和恶意页面的侵害的限制有很多。这取决于浏览器。</p>
<p>例如，移动端浏览器通常会完全忽略这种调用。并且，当弹窗是在单独的选项卡而不是新窗口中打开时，也无法进行聚焦。</p>
<p>尽管如此，还是有一些事情可以使用它们来完成。</p>
<p>例如：</p>
<ul>
<li>当我们打开一个弹窗时，在它上面执行 <code>newWindow.focus()</code> 是个好主意。以防万一，对于某些操作系统/浏览器组合（combination），它可以确保用户现在位于新窗口中。</li>
<li>如果我们想要跟踪访问者何时在实际使用我们的 Web 应用程序，我们可以跟踪 <code>window.onfocus/onblur</code>。这使我们可以暂停/恢复页面活动和动画等。但是请注意，<code>blur</code> 事件意味着访问者从窗口切换了出来，但他们仍然可以观察到它。窗口处在背景中，但可能仍然是可见的。</li>
</ul>
<h2 id="总结">总结</h2>
<p>弹窗很少使用，因为有其他选择：在页面内或在 iframe 中加载和显示信息。</p>
<p>如果我们要打开一个弹窗，将其告知用户是一个好的实践。在链接或按钮附近的“打开窗口”图标可以让用户免受焦点转移的困扰，并使用户知道点击它会弹出一个新窗口。</p>
<ul>
<li>可以通过 <code>open(url, name, params)</code> 调用打开一个弹窗。它会返回对新打开的窗口的引用。</li>
<li>浏览器会阻止来自用户行为之外的代码中的 <code>open</code> 调用。通常会显示一条通知，以便用户可以允许它们。</li>
<li>默认情况下，浏览器会打开一个新标签页，但如果提供了窗口大小，那么浏览器将打开一个弹窗。</li>
<li>弹窗可以使用 <code>window.opener</code> 属性访问 opener 窗口（译注：即打开弹窗的窗口）。</li>
<li>如果主窗口和弹窗同源，那么它们可以彼此自由地读取和修改。否则，它们可以更改彼此的地址（location），<a href="info:cross-window-communication">交换消息</a>。</li>
</ul>
<p>要关闭弹窗：使用 <code>close()</code> 调用。用户也可以关闭弹窗（就像任何其他窗口一样）。关闭之后，<code>window.closed</code> 为 <code>true</code>。</p>
<ul>
<li><code>focus()</code> 和 <code>blur()</code> 方法允许聚焦/失焦于窗口。但它们并不是一直都有效。</li>
<li><code>focus </code>和 <code>blur</code> 事件允许跟踪窗口的切换。但是请注意，在 <code>blur</code> 之后，即使窗口在背景状态下，窗口仍有可能是可见的。</li>
</ul>

      </fieldset>
      
      <fieldset id='_Of7aeU'>
      <legend>article</legend>
      <h1 id="跨窗口通信">跨窗口通信</h1>
<p>“同源（Same Origin）”策略限制了窗口（window）和 frame 之间的相互访问。</p>
<p>这个想法出于这样的考虑，如果一个用户有两个打开的页面：一个来自 <code>john-smith.com</code>，另一个是 <code>gmail.com</code>，那么用户将不希望 <code>john-smith.com</code> 的脚本可以读取 <code>gmail.com</code> 中的邮件。所以，“同源”策略的目的是保护用户免遭信息盗窃。</p>
<h2 id="同源-same-origin">同源 [#same-origin]</h2>
<p>如果两个 URL 具有相同的协议，域和端口，则称它们是“同源”的。</p>
<p>以下的几个 URL 都是同源的：</p>
<ul>
<li><code>http://site.com</code></li>
<li><code>http://site.com/</code></li>
<li><code>http://site.com/my/page.html</code></li>
</ul>
<p>但是下面这几个不是：</p>
<ul>
<li><code>http://<b>www.</b>site.com</code>（另一个域：<code>www.</code> 影响）</li>
<li><code>http://<b>site.org</b></code>（另一个域：<code>.org</code> 影响）</li>
<li><code><b>https://</b>site.com</code>（另一个协议：<code>https</code>）</li>
<li><code><a href="http://site.com">http://site.com</a>:<b>8080</b></code>（另一个端口：<code>8080</code>）</li>
</ul>
<p>“同源”策略规定：</p>
<ul>
<li>如果我们有对另外一个窗口（例如，一个使用 <code>window.open</code> 创建的弹窗，或者一个窗口中的 iframe）的引用，并且该窗口是同源的，那么我们就具有对该窗口的全部访问权限。</li>
<li>否则，如果该窗口不是同源的，那么我们就无法访问该窗口中的内容：变量，文档，任何东西。唯一的例外是 <code>location</code>：我们可以修改它（进而重定向用户）。但是我们无法读取 <code>location</code>（因此，我们无法看到用户当前所处的位置，也就不会泄漏任何信息）。</li>
</ul>
<h3 id="实例：iframe">实例：iframe</h3>
<p>一个 <code>&lt;iframe&gt;</code> 标签承载了一个单独的嵌入的窗口，它具有自己的 <code>document</code> 和 <code>window</code>。</p>
<p>我们可以使用以下属性访问它们：</p>
<ul>
<li><code>iframe.contentWindow</code> 来获取 <code>&lt;iframe&gt;</code> 中的 window。</li>
<li><code>iframe.contentDocument</code> 来获取 <code>&lt;iframe&gt;</code> 中的 document，是 <code>iframe.contentWindow.document</code> 的简写形式。</li>
</ul>
<p>当我们访问嵌入的窗口中的东西时，浏览器会检查 iframe 是否具有相同的源。如果不是，则会拒绝访问（对 <code>location</code> 进行写入是一个例外，它是会被允许的）。</p>
<p>例如，让我们尝试对来自另一个源的 <code>&lt;iframe&gt;</code> 进行读取和写入：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://example.com&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iframe&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  iframe.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// 我们可以获取对内部 window 的引用</span>
*!*
    <span class="hljs-keyword">let</span> iframeWindow = iframe.contentWindow; <span class="hljs-comment">// OK</span>
*/!*
    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">// ...但是无法获取其中的文档</span>
*!*
      <span class="hljs-keyword">let</span> doc = iframe.contentDocument; <span class="hljs-comment">// ERROR</span>
*/!*
    } <span class="hljs-function"><span class="hljs-title">catch</span>(<span class="hljs-params">e</span>)</span> {
      alert(e); <span class="hljs-comment">// Security Error（另一个源）</span>
    }

    <span class="hljs-comment">// 并且，我们也无法 **读取** iframe 中页面的 URL</span>
    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">// 无法从 location 对象中读取 URL</span>
*!*
      <span class="hljs-keyword">let</span> href = iframe.contentWindow.location.href; <span class="hljs-comment">// ERROR</span>
*/!*
    } <span class="hljs-function"><span class="hljs-title">catch</span>(<span class="hljs-params">e</span>)</span> {
      alert(e); <span class="hljs-comment">// Security Error</span>
    }

    <span class="hljs-comment">// ...我们可以 **写入** location（所以，在 iframe 中加载了其他内容）！</span>
*!*
    iframe.contentWindow.location = <span class="hljs-string">&#x27;/&#x27;</span>; <span class="hljs-comment">// OK</span>
*/!*

    iframe.onload = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 清空处理程序，在 location 更改后不要再运行它</span>
  };
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>上述代码除了以下操作都会报错：</p>
<ul>
<li>通过 <code>iframe.contentWindow</code> 获取对内部 window 的引用 —— 这是被允许的。</li>
<li>对 <code>location</code> 进行写入</li>
</ul>
<p>与此相反，如果 <code>&lt;iframe&gt;</code> 具有相同的源，我们可以使用它做任何事情：</p>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 来自同一个网站的 iframe --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iframe&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  iframe.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// 可以做任何事儿</span>
    iframe.contentDocument.body.prepend(<span class="hljs-string">&quot;Hello, world!&quot;</span>);
  };
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>```smart header=&quot;<code>iframe.onload</code> vs <code>iframe.contentWindow.onload</code>&quot;
<code>iframe.onload</code> 事件（在 <code>&lt;iframe&gt;</code> 标签上）与 <code>iframe.contentWindow.onload</code>（在嵌入的 window 对象上）基本相同。当嵌入的窗口的所有资源都完全加载完毕时触发。</p>
<p>……但是，我们无法使用 <code>iframe.contentWindow.onload</code> 访问不同源的 iframe。因此，请使用 <code>iframe.onload</code>，</p>
<pre><code>
## 子域上的 window：document.domain

根据定义，两个具有不同域的 URL 具有不同的源。

但是，如果窗口的二级域相同，例如 `john.site.com`，`peter.site.com` 和 `site.com`（它们共同的二级域是 `site.com`），我们可以使浏览器忽略该差异，使得它们可以被作为“同源”的来对待，以便进行跨窗口通信。

为了做到这一点，每个这样的窗口都应该执行下面这行代码：

```js
document.domain = &#x27;site.com&#x27;;</code></pre>
<p>这样就可以了。现在它们可以无限制地进行交互了。但是再强调一遍，这仅适用于具有相同二级域的页面。</p>
<h2 id="iframe：错误文档陷阱">Iframe：错误文档陷阱</h2>
<p>当一个 iframe 来自同一个源时，我们可能会访问其 <code>document</code>，但是这里有一个陷阱。它与跨源无关，但你一定要知道。</p>
<p>在创建 iframe 后，iframe 会立即就拥有了一个文档。但是该文档不同于加载到其中的文档！</p>
<p>因此，如果我们要立即对文档进行操作，就可能出问题。</p>
<p>看一下下面这段代码：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iframe&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">let</span> oldDoc = iframe.contentDocument;
  iframe.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">let</span> newDoc = iframe.contentDocument;
*!*
    <span class="hljs-comment">// 加载的文档与初始的文档不同！</span>
    alert(oldDoc == newDoc); <span class="hljs-comment">// false</span>
*/!*
  };
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>我们不应该对尚未加载完成的 iframe 的文档进行处理，因为那是 <strong>错误的文档</strong>。如果我们在其上设置了任何事件处理程序，它们将会被忽略。</p>
<p>如何检测文档就位（加载完成）的时刻呢？</p>
<p>正确的文档在 <code>iframe.onload</code> 触发时肯定就位了。但是，只有在整个 iframe 和它所有资源都加载完成时，<code>iframe.onload</code> 才会触发。</p>
<p>我们可以尝试通过在 <code>setInterval</code> 中进行检查，以更早地捕获该时刻：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iframe&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">let</span> oldDoc = iframe.contentDocument;

  <span class="hljs-comment">// 每 100ms 检查一次文档是否为新文档</span>
  <span class="hljs-keyword">let</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">let</span> newDoc = iframe.contentDocument;
    <span class="hljs-keyword">if</span> (newDoc == oldDoc) <span class="hljs-keyword">return</span>;

    alert(<span class="hljs-string">&quot;New document is here!&quot;</span>);

    <span class="hljs-built_in">clearInterval</span>(timer); <span class="hljs-comment">// 取消 setInterval，不再需要它做任何事儿</span>
  }, <span class="hljs-number">100</span>);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h2 id="集合：windowframes">集合：window.frames</h2>
<p>获取 <code>&lt;iframe&gt;</code> 的 window 对象的另一个方式是从命名集合 <code>window.frames</code> 中获取：</p>
<ul>
<li>通过索引获取：<code>window.frames[0]</code> —— 文档中的第一个 iframe 的 window 对象。</li>
<li>通过名称获取：<code>window.frames.iframeName</code> —— 获取 <code>name=&quot;iframeName&quot;</code> 的 iframe 的 window 对象。</li>
</ul>
<p>例如：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height:80px&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;win&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iframe&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  alert(iframe.contentWindow == frames[<span class="hljs-number">0</span>]); <span class="hljs-comment">// true</span>
  alert(iframe.contentWindow == frames.win); <span class="hljs-comment">// true</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>一个 iframe 内可能嵌套了其他的 iframe。相应的 <code>window</code> 对象会形成一个层次结构（hierarchy）。</p>
<p>可以通过以下方式获取：</p>
<ul>
<li><code>window.frames</code> —— “子”窗口的集合（用于嵌套的 iframe）。</li>
<li><code>window.parent</code> —— 对“父”（外部）窗口的引用。</li>
<li><code>window.top</code> —— 对最顶级父窗口的引用。</li>
</ul>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-built_in">window</span>.frames[<span class="hljs-number">0</span>].parent === <span class="hljs-built_in">window</span>; <span class="hljs-comment">// true</span></code></pre>
<p>我们可以使用 <code>top</code> 属性来检查当前的文档是否是在 iframe 内打开的：</p>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span> == top) { <span class="hljs-comment">// 当前 window == window.top?</span>
  alert(<span class="hljs-string">&#x27;The script is in the topmost window, not in a frame&#x27;</span>);
} <span class="hljs-keyword">else</span> {
  alert(<span class="hljs-string">&#x27;The script runs in a frame!&#x27;</span>);
}</code></pre>
<h2 id="sandbox-iframe-特性">&quot;sandbox&quot; iframe 特性</h2>
<p><code>sandbox</code> 特性（attribute）允许在 <code>&lt;iframe&gt;</code> 中禁止某些特定行为，以防止其执行不被信任的代码。它通过将 iframe 视为非同源的，或者应用其他限制来实现 iframe 的“沙盒化”。</p>
<p>对于 <code>&lt;iframe sandbox src=&quot;...&quot;&gt;</code>，有一个应用于其上的默认的限制集。但是，我们可以通过提供一个以空格分隔的限制列表作为特性的值，来放宽这些限制，该列表中的各项为不应该应用于这个 iframe 的限制，例如：<code>&lt;iframe sandbox=&quot;allow-forms allow-popups&quot;&gt;</code>。</p>
<p>换句话说，一个空的 <code>&quot;sandbox&quot;</code> 特性会施加最严格的限制，但是我们用一个以空格分隔的列表，列出要移除的限制。</p>
<p>以下是限制的列表：</p>
<p><code>allow-same-origin</code>
: 默认情况下，<code>&quot;sandbox&quot;</code> 会为 iframe 强制实施“不同来源”的策略。换句话说，它使浏览器将 <code>iframe</code> 视为来自另一个源，即使其 <code>src</code> 指向的是同一个网站也是如此。具有所有隐含的脚本限制。此选项会移除这些限制。</p>
<p><code>allow-top-navigation</code>
: 允许 <code>iframe</code> 更改 <code>parent.location</code>。</p>
<p><code>allow-forms</code>
: 允许在 <code>iframe</code> 中提交表单。</p>
<p><code>allow-scripts</code>
: 允许在 <code>iframe</code> 中运行脚本。</p>
<p><code>allow-popups</code>
: 允许在 <code>iframe</code> 中使用 <code>window.open</code> 打开弹窗。</p>
<p>查看 <a href="mdn:/HTML/Element/iframe">官方手册</a> 获取更多内容。</p>
<p>下面的示例演示了一个具有默认限制集的沙盒 iframe：<code>&lt;iframe sandbox src=&quot;...&quot;&gt;</code>。它有一些 JavaScript 代码和一个表单。</p>
<p>请注意，这里没有东西会运行。可见默认设置非常苛刻：</p>
<p>[codetabs src=&quot;sandbox&quot; height=140]</p>
<pre><code class="language-smart">`&quot;sandbox&quot;` 特性的目的仅是 **添加更多** 限制。它无法移除这些限制。尤其是，如果 iframe 来自其他源，则无法放宽同源策略。</code></pre>
<h2 id="跨窗口通信-1">跨窗口通信</h2>
<p><code>postMessage</code> 接口允许窗口之间相互通信，无论它们来自什么源。</p>
<p>因此，这是解决“同源”策略的方式之一。它允许来自于 <code>john-smith.com</code> 的窗口与来自于 <code>gmail.com</code> 的窗口进行通信，并交换信息，但前提是它们双方必须均同意并调用相应的 JavaScript 函数。这可以保护用户的安全。</p>
<p>这个接口有两个部分。</p>
<h3 id="postmessage">postMessage</h3>
<p>想要发送消息的窗口需要调用接收窗口的 <a href="mdn:api/Window.postMessage">postMessage</a> 方法。换句话说，如果我们想把消息发送给 <code>win</code>，我们应该调用 <code>win.postMessage(data, targetOrigin)</code>。</p>
<p>参数：</p>
<p><code>data</code>
: 要发送的数据。可以是任何对象，数据会被通过使用“结构化克隆算法”进行克隆。IE 浏览器只支持字符串，因此我们需要对复杂的对象调用 <code>JSON.stringify</code> 方法进行处理，以支持该浏览器。</p>
<p><code>targetOrigin</code>
: 指定目标窗口的源，以便只有来自给定的源的窗口才能获得该消息。</p>
<p><code>targetOrigin</code> 是一种安全措施。请记住，如果目标窗口是非同源的，我们无法在发送方窗口读取它的 <code>location</code>。因此，我们无法确定当前在预期的窗口中打开的是哪个网站：用户随时可以导航离开，并且发送方窗口对此一无所知。</p>
<p>指定 <code>targetOrigin</code> 可以确保窗口仅在当前仍处于正确的网站时接收数据。在有敏感数据时，这非常重要。</p>
<p>例如，这里的 <code>win</code> 仅在它拥有来自 <code>http://example.com</code> 这个源的文档时，才会接收消息：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://example.com&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">let</span> win = <span class="hljs-built_in">window</span>.frames.example;

  win.postMessage(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;http://example.com&quot;</span>);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>如果我们不希望做这个检查，可以将 <code>targetOrigin</code> 设置为 <code>*</code>。</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://example.com&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">let</span> win = <span class="hljs-built_in">window</span>.frames.example;

*!*
  win.postMessage(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>);
*/!*
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h3 id="onmessage">onmessage</h3>
<p>为了接收消息，目标窗口应该在 <code>message</code> 事件上有一个处理程序。当 <code>postMessage</code> 被调用时触发该事件（并且 <code>targetOrigin</code> 检查成功）。</p>
<p>event 对象具有特殊属性：</p>
<p><code>data</code>
: 从 <code>postMessage</code> 传递来的数据。</p>
<p><code>origin</code>
: 发送方的源，例如 <code>http://javascript.info</code>。</p>
<p><code>source</code>
: 对发送方窗口的引用。如果我们想，我们可以立即 <code>source.postMessage(...)</code> 回去。</p>
<p>要为 <code>message</code> 事件分配处理程序，我们应该使用 <code>addEventListener</code>，简短的语法 <code>window.onmessage</code> 不起作用。</p>
<p>这里有一个例子：</p>
<pre><code class="language-js"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
  <span class="hljs-keyword">if</span> (event.origin != <span class="hljs-string">&#x27;http://javascript.info&#x27;</span>) {
    <span class="hljs-comment">// 来自未知的源的内容，我们忽略它</span>
    <span class="hljs-keyword">return</span>;
  }

  alert( <span class="hljs-string">&quot;received: &quot;</span> + event.data );

  <span class="hljs-comment">// 可以使用 event.source.postMessage(...) 向回发送消息</span>
});</code></pre>
<p>完整示例：</p>
<p>[codetabs src=&quot;postmessage&quot; height=120]</p>
<h2 id="总结">总结</h2>
<p>要调用另一个窗口的方法或者访问另一个窗口的内容，我们应该首先拥有对其的引用。</p>
<p>对于弹窗，我们有两个引用：</p>
<ul>
<li>从打开窗口的（opener）窗口：<code>window.open</code> —— 打开一个新的窗口，并返回对它的引用，</li>
<li>从弹窗：<code>window.opener</code> —— 是从弹窗中对打开此弹窗的窗口（opener）的引用。</li>
</ul>
<p>对于 iframe，我们可以使用以下方式访问父/子窗口：</p>
<ul>
<li><code>window.frames</code> —— 一个嵌套的 window 对象的集合，</li>
<li><code>window.parent</code>，<code>window.top</code> 是对父窗口和顶级窗口的引用，</li>
<li><code>iframe.contentWindow</code> 是 <code>&lt;iframe&gt;</code> 标签内的 window 对象。</li>
</ul>
<p>如果几个窗口的源相同（域，端口，协议），那么这几个窗口可以彼此进行所需的操作。</p>
<p>否则，只能进行以下操作：</p>
<ul>
<li>更改另一个窗口的 <code>location</code>（只能写入）。</li>
<li>向其发送一条消息。</li>
</ul>
<p>例外情况：</p>
<ul>
<li>对于二级域相同的窗口：<code>a.site.com</code> 和 <code>b.site.com</code>。通过在这些窗口中均设置 <code>document.domain=&#39;site.com&#39;</code>，可以使它们处于“同源”状态。 </li>
<li>如果一个 iframe 具有 <code>sandbox</code> 特性（attribute），则它会被强制处于“非同源”状态，除非在其特性值中指定了 <code>allow-same-origin</code>。这可用于在同一网站的 iframe 中运行不受信任的代码。</li>
</ul>
<p><code>postMessage</code> 接口允许两个具有任何源的窗口之间进行通信：</p>
<ol>
<li><p>发送方调用 <code>targetWin.postMessage(data, targetOrigin)</code>。</p>
</li>
<li><p>如果 <code>targetOrigin</code> 不是 <code>&#39;*&#39;</code>，那么浏览器会检查窗口 <code>targetWin</code> 是否具有源 <code>targetOrigin</code>。</p>
</li>
<li><p>如果它具有，<code>targetWin</code> 会触发具有特殊的属性的 <code>message</code> 事件：</p>
<ul>
<li><p><code>origin</code> —— 发送方窗口的源（比如 <code>http://my.site.com</code>）。</p>
</li>
<li><p><code>source</code> —— 对发送方窗口的引用。</p>
</li>
<li><p><code>data</code> —— 数据，可以是任何对象。但是 IE 浏览器只支持字符串，因此我们需要对复杂的对象调用 <code>JSON.stringify</code> 方法进行处理，以支持该浏览器。</p>
<p>我们应该使用 <code>addEventListener</code> 来在目标窗口中设置 <code>message</code> 事件的处理程序。</p>
</li>
</ul>
</li>
</ol>

      </fieldset>
      
      <fieldset id='_yOyluD'>
      <legend>article</legend>
      <h1 id="点击劫持攻击">点击劫持攻击</h1>
<p>“点击劫持”攻击允许恶意页面 <strong>以用户的名义</strong> 点击“受害网站”。</p>
<p>许多网站都被黑客以这种方式攻击过，包括 Twitter、Facebook 和 Paypal 等许多网站。当然，它们都已经被修复了。</p>
<h2 id="原理">原理</h2>
<p>原理十分简单。</p>
<p>我们以 Facebook 为例，解释点击劫持是如何完成的：</p>
<ol>
<li>访问者被恶意页面吸引。怎样吸引的不重要。</li>
<li>页面上有一个看起来无害的链接（例如：“变得富有”或者“点我，超好玩！”）。</li>
<li>恶意页面在该链接上方放置了一个透明的 <code>&lt;iframe&gt;</code>，其 <code>src</code> 来自于 facebook.com，这使得“点赞”按钮恰好位于该链接上面。这通常是通过 <code>z-index</code> 实现的。</li>
<li>用户尝试点击该链接时，实际上点击的是“点赞”按钮。</li>
</ol>
<h2 id="示例">示例</h2>
<p>这是恶意页面看起来的样子。为了清楚起见，我们将 <code>&lt;iframe&gt;</code> 设置成了半透明的（在真正的恶意页面中，它是全透明的）：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>
iframe { /* 来自受害网站的 iframe */
  width: 400px;
  height: 100px;
  position: absolute;
  top:0; left:-20px;
*!*
  opacity: 0.5; /* 在实际中为 opacity:0 */
*/!*
  z-index: 1;
}
<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>点击即可变得富有：<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 来自受害网站的 url --&gt;</span>
*!*
<span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/clickjacking/facebook.html&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>点这里！<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
*/!*

<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>……你很酷（我实际上是一名帅气的黑客）！<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>完整的攻击示例如下：</p>
<p>[codetabs src=&quot;clickjacking-visible&quot; height=160]</p>
<p>在上面这个示例中，我们有一个半透明的 <code>&lt;iframe src=&quot;facebook.html&quot;&gt;</code>，我们可以看到，它位于按钮之上。点击按钮实际上会点击在 iframe 上，但这对用户不可见，因为 iframe 是透明的。</p>
<p>结果，如果访问者登陆了 Facebook（“记住我”通常是打开的），那么这个行为就会点一个“赞”。Twitter 上是 &quot;Follow&quot; 按钮。</p>
<p>下面是相同的示例，但 <code>iframe</code> 的透明度设置为了 <code>opacity:0</code>，更符合实际情况：</p>
<p>[codetabs src=&quot;clickjacking&quot; height=160]</p>
<p>我们进行攻击所需要做的 —— 就是将 <code>&lt;iframe&gt;</code> 放置在恶意页面中，使得按钮恰好位于链接的正上方。这样当用户点击链接时，他们实际上点击的是按钮。这通常可以通过 CSS 实现。</p>
<pre><code class="language-smart">此攻击仅影响鼠标行为（或者类似的行为，例如在手机上的点击）。

键盘输入很难重定向。从技术上讲，我们可以用 iframe 的文本区域覆盖原有的文本区域实现攻击。因此，当访问者试图聚焦页面中的输入时，实际上聚焦的是 iframe 中的输入。

但是这里有个问题。访问者键入的所有内容都会被隐藏，因为该 iframe 是不可见的。

当用户无法在屏幕上看到自己输入的字符时，通常会停止打字。</code></pre>
<h2 id="传统防御（弱-👎）">传统防御（弱 👎）</h2>
<p>最古老的防御措施是一段用于禁止在 frame 中打开页面的 JavaScript 代码（所谓的 “framebusting”）。</p>
<p>它看起来像这样：</p>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (top != <span class="hljs-built_in">window</span>) {
  top.location = <span class="hljs-built_in">window</span>.location;
}</code></pre>
<p>意思是说：如果 window 发现它不在顶部，那么它将自动使其自身位于顶部。</p>
<p>这个方法并不可靠，因为有许多方式可以绕过这个限制。下面我们就介绍几个。</p>
<h3 id="阻止顶级导航">阻止顶级导航</h3>
<p>我们可以阻止因更改 <a href="info:onload-ondomcontentloaded#window.onbeforeunload">beforeunload</a> 事件处理程序中的 <code>top.location</code> 而引起的过渡（transition）。</p>
<p>顶级页面（从属于黑客）在 <code>beforeunload</code> 上设置了一个用于阻止的处理程序，像这样：</p>
<pre><code class="language-js"><span class="hljs-built_in">window</span>.onbeforeunload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
};</code></pre>
<p>当 <code>iframe</code> 试图更改 <code>top.location</code> 时，访问者会收到一条消息，询问他们是否要离开页面。</p>
<p>在大多数情况下，访问者会做出否定的回答，因为他们并不知道还有这么一个 iframe，他们所看到的只有顶级页面，他们没有理由离开。所以 <code>top.location</code> 不会变化！</p>
<p>演示示例：</p>
<p>[codetabs src=&quot;top-location&quot;]</p>
<h3 id="sandbox-特性">Sandbox 特性</h3>
<p><code>sandbox</code> 特性的限制之一就是导航。沙箱化的 iframe 不能更改 <code>top.location</code>。</p>
<p>但我们可以添加具有 <code>sandbox=&quot;allow-scripts allow-forms&quot;</code> 的 iframe。从而放开限制，允许脚本和表单。但我们没添加 <code>allow-top-navigation</code>，因此更改 <code>top.location</code> 是被禁止的。</p>
<p>代码如下：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> *!*<span class="hljs-attr">sandbox</span>=<span class="hljs-string">&quot;allow-scripts allow-forms&quot;</span>*/!* <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;facebook.html&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span></code></pre>
<p>还有其他方式可以绕过这个弱鸡防御。</p>
<h2 id="x-frame-options">X-Frame-Options</h2>
<p>服务器端 header <code>X-Frame-Options</code> 可以允许或禁止在 frame 中显示页面。</p>
<p>它必须被完全作为 HTTP-header 发送：如果浏览器在 HTML <code>&lt;meta&gt;</code> 标签中找到它，则会忽略它。因此，<code>&lt;meta http-equiv=&quot;X-Frame-Options&quot;...&gt;</code> 没有任何作用。</p>
<p>这个 header 可能包含 3 个值：</p>
<p><code>DENY</code>
: 始终禁止在 frame 中显示此页面。</p>
<p><code>SAMEORIGIN</code>
: 允许在和父文档同源的 frame 中显示此页面。</p>
<p><code>ALLOW-FROM domain</code>
: 允许在来自给定域的父文档的 frame 中显示此页面。</p>
<p>例如，Twitter 使用的是 <code>X-Frame-Options: SAMEORIGIN</code>。</p>
<pre><code class="language-online">结果如下：

```html
&lt;iframe src=&quot;https://twitter.com&quot;&gt;&lt;/iframe&gt;
```

&lt;!-- ebook: prerender/ chrome headless dies and timeouts on this iframe --&gt;
&lt;iframe src=&quot;https://twitter.com&quot;&gt;&lt;/iframe&gt;

上面这个 `iframe` 可能为空，或者通过 alert 告知你浏览器不允许以这种方式导航至该页面，这取决于你的浏览器。</code></pre>
<h2 id="显示禁用的功能">显示禁用的功能</h2>
<p><code>X-Frame-Options</code> 有一个副作用。其他的网站即使有充分的理由也无法在 frame 中显示我们的页面。</p>
<p>因此，还有其他解决方案……例如，我们可以用一个样式为 <code>height: 100%; width: 100%;</code> 的 <code>&lt;div&gt;</code> “覆盖”页面，这样它就能拦截所有点击。如果 <code>window == top</code> 或者我们确定不需要保护时，再将该 <code>&lt;div&gt;</code> 移除。</p>
<p>像这样：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
  <span class="hljs-selector-id">#protector</span> {
    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
    <span class="hljs-attribute">position</span>: absolute;
    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;
    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;
    <span class="hljs-attribute">z-index</span>: <span class="hljs-number">99999999</span>;
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;protector&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>前往网站<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-comment">// 如果顶级窗口来自其他源，这里则会出现一个 error</span>
  <span class="hljs-comment">// 但是在本例中没有问题</span>
  <span class="hljs-keyword">if</span> (top.document.domain == <span class="hljs-built_in">document</span>.domain) {
    protector.remove();
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>演示示例：</p>
<p>[codetabs src=&quot;protector&quot;]</p>
<h2 id="samesite-cookie-特性">Samesite cookie 特性</h2>
<p><code>samesite</code> cookie 特性也可以阻止点击劫持攻击。</p>
<p>具有 <code>samesite</code> 特性的 cookie 仅在网站是通过直接方式打开（而不是通过 frame 或其他方式）的情况下才发送到网站。更多细节请见 <a href="info:cookie#samesite">info:cookie#samesite</a>。</p>
<p>如果网站，例如 Facebook，在其身份验证 cookie 中具有 <code>samesite</code> 特性，像这样：</p>
<pre><code>Set-Cookie: authorization=secret; samesite</code></pre>
<p>……那么，当在另一个网站中的 iframe 中打开 Facebook 时，此类 cookie 将不会被发送。因此，攻击将失败。</p>
<p>当不实用 cookie 时，<code>samesite</code> cookie 特性将不会有任何影响。这可以使其他网站能够轻松地在 iframe 中显示我们公开的、未进行身份验证的页面。</p>
<p>然而，这也可能会使得劫持攻击在少数情况下起作用。例如，通过检查 IP 地址来防止重复投票的匿名投票网站仍然会受到点击劫持的攻击，因为它不使用 cookie 对用户身份进行验证。</p>
<h2 id="总结">总结</h2>
<p>点击劫持是一种“诱骗”用户在不知情的情况下点击恶意网站的方式。如果是重要的点击操作，这是非常危险的。</p>
<p>黑客可以通过信息发布指向他的恶意页面的链接，或者通过某些手段引诱访问者访问他的页面。当然还有很多其他变体。</p>
<p>一方面 —— 这种攻击方式是“浅层”的：黑客所做的只是拦截一次点击。但另一方面，如果黑客知道在点击之后将出现另一个控件，则他们可能还会使用狡猾的消息来迫使用户也点击它们。</p>
<p>这种攻击相当危险，因为在设计交互界面时，我们通常不会考虑到可能会有黑客代表用户点击界面。所以，在许多意想不到的地方可能发现攻击漏洞。</p>
<ul>
<li>建议在那些不希望被在 frame 中查看的页面上（或整个网站上）使用 <code>X-Frame-Options: SAMEORIGIN</code>。</li>
<li>如果我们希望允许在 frame 中显示我们的页面，那我们使用一个 <code>&lt;div&gt;</code> 对整个页面进行遮盖，这样也是安全的。</li>
</ul>

      </fieldset>
      </div><div id="nav"><div style="margin-left:0em"><strong>popup-windows</strong><br/></div><div style="margin-left:1em"><a href="#_FHO7Cs">article</a><br/></div><div style="margin-left:0em"><strong>cross-window-communication</strong><br/></div><div style="margin-left:1em"><a href="#_Of7aeU">article</a><br/></div><div style="margin-left:0em"><strong>clickjacking</strong><br/></div><div style="margin-left:1em"><a href="#_yOyluD">article</a><br/></div></div>
</body></html>