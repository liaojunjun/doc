<p>libs:</p>
<ul>
<li>&#39;<a href="https://cdn.jsdelivr.net/npm/idb@3.0.2/build/idb.min.js&#39;">https://cdn.jsdelivr.net/npm/idb@3.0.2/build/idb.min.js&#39;</a></li>
</ul>
<hr>
<h1 id="indexeddb">IndexedDB</h1>
<p>IndexedDB 是一个浏览器内置的数据库，它比 <code>localStorage</code> 强大得多。</p>
<ul>
<li>通过支持多种类型的键，来存储几乎可以是任何类型的值。</li>
<li>支撑事务的可靠性。</li>
<li>支持键范围查询、索引。</li>
<li>和 <code>localStorage</code> 相比，它可以存储更大的数据量。</li>
</ul>
<p>对于传统的 客户端-服务器 应用，这些功能通常是没有必要的。IndexedDB 适用于离线应用，可与 ServiceWorkers 和其他技术相结合使用。</p>
<p>根据规范 <a href="https://www.w3.org/TR/IndexedDB">https://www.w3.org/TR/IndexedDB</a> 中的描述，IndexedDB 的本机接口是基于事件的。</p>
<p>我们还可以在基于 promise 的包装器（wrapper），如 <a href="https://github.com/jakearchibald/idb">https://github.com/jakearchibald/idb</a> 的帮助下使用 <code>async/await</code>。这要方便的多，但是包装器并不完美，它并不能替代所有情况下的事件。因此，我们先练习事件（events），在理解 IndexedDB 之后，我们将使用包装器。</p>
<h2 id="打开数据库">打开数据库</h2>
<p>要想使用 IndexedDB，首先需要 <code>open</code>（连接）一个数据库。</p>
<p>语法：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> openRequest = indexedDB.open(name, version);</code></pre>
<ul>
<li><code>name</code> —— 字符串，即数据库名称。</li>
<li><code>version</code> —— 一个正整数版本，默认为 <code>1</code>（下面解释）。</li>
</ul>
<p>数据库可以有许多不同的名称，但是必须存在于当前的源（域/协议/端口）中。不同的网站不能相互访问对方的数据库。</p>
<p>调用之后会返回 <code>openRequest</code> 对象，我们需要监听该对象上的事件：</p>
<ul>
<li><code>success</code>：数据库准备就绪，<code>openRequest.result</code> 中有了一个数据库对象“Database Object”，使用它进行进一步的调用。</li>
<li><code>error</code>：打开失败。</li>
<li><code>upgradeneeded</code>：数据库已准备就绪，但其版本已过时（见下文）。</li>
</ul>
<p><strong>IndexedDB 具有内建的“模式（scheme）版本控制”机制，这在服务器端数据库中是不存在的。</strong></p>
<p>与服务器端数据库不同，IndexedDB 存在于客户端，数据存储在浏览器中。因此，开发人员无法访问它。因此，当我们发布了新版本的应用程序，用户访问我们的网页，我们可能需要更新该数据库。</p>
<p>如果本地数据库版本低于 <code>open</code> 中指定的版本，会触发一个特殊事件 <code>upgradeneeded</code>。我们可以根据需要比较版本并升级数据结构。</p>
<p>当数据库还不存在时（从技术上讲，该版本为 <code>0</code>），也会触发 <code>upgradeneeded</code> 事件。因此，我们可以执行初始化。</p>
<p>假设我们发布了应用程序的第一个版本。</p>
<p>接下来我们就可以打开版本 <code>1</code> 中的 IndexedDB 数据库，并在 <code>upgradeneeded</code> 处理程序中执行初始化，如下所示：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> openRequest = indexedDB.open(<span class="hljs-string">&quot;store&quot;</span>, *!*<span class="hljs-number">1</span>*/!*);

openRequest.onupgradeneeded = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// 如果客户端没有数据库则触发</span>
  <span class="hljs-comment">// ...执行初始化...</span>
};

openRequest.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;Error&quot;</span>, openRequest.error);
};

openRequest.onsuccess = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> db = openRequest.result;
  <span class="hljs-comment">// 继续使用 db 对象处理数据库</span>
};</code></pre>
<p>之后不久，我们发布了第二个版本。</p>
<p>我们可以打开版本 <code>2</code> 中的 IndexedDB 数据库，并像这样进行升级：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> openRequest = indexedDB.open(<span class="hljs-string">&quot;store&quot;</span>, *!*<span class="hljs-number">2</span>*/!*);

openRequest.onupgradeneeded = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
  <span class="hljs-comment">// 现有的数据库版本小于 2（或不存在）</span>
  <span class="hljs-keyword">let</span> db = openRequest.result;
  <span class="hljs-keyword">switch</span>(event.oldVersion) { <span class="hljs-comment">// 现有的 db 版本</span>
    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
      <span class="hljs-comment">// 版本 0 表示客户端没有数据库</span>
      <span class="hljs-comment">// 执行初始化</span>
    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
      <span class="hljs-comment">// 客户端版本为 1</span>
      <span class="hljs-comment">// 更新</span>
  }
};</code></pre>
<p>请注意：虽然我们目前的版本是 <code>2</code>，<code>onupgradeneeded</code> 处理程序有针对版本 <code>0</code> 的代码分支（适用于初次访问，浏览器中没有数据库的用户）和针对版本 <code>1</code> 的代码分支（用于升级）。</p>
<p>接下来，当且仅当 <code>onupgradeneeded</code> 处理程序没有错误地执行完成，<code>openRequest.onsuccess</code> 被触发，数据库才算是成功打开了。</p>
<p>删除数据库：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> deleteRequest = indexedDB.deleteDatabase(name)
<span class="hljs-comment">// deleteRequest.onsuccess/onerror 追踪（tracks）结果</span></code></pre>
<pre><code class="language-warn">如果当前用户的数据库版本比 `open` 调用的版本更高（比如当前的数据库版本为 `3`，我们却尝试运行 `open(...2)`，就会产生错误并触发 `openRequest.onerror`）。

这有些奇怪，但这样的事情可能会在用户加载了一个过时的 JavaScript 代码时发生（例如用户从一个代理缓存中加载 JS）。在这种情况下，代码是过时的，但数据库却是最新的。

为了防止这样的错误产生，我们应当检查 `db.version` 并建议用户刷新页面。使用正确的 HTTP 缓存头（headers）来防止之前缓存的旧代码被加载。</code></pre>
<h3 id="并行更新问题">并行更新问题</h3>
<p>提到版本控制，有一个相关的小问题。</p>
<p>举个例子：</p>
<ol>
<li>一个用户在一个浏览器标签页中打开了数据库版本为 <code>1</code> 的我们的网站。</li>
<li>接下来我们发布了一个更新，使得代码更新了。</li>
<li>接下来同一个用户在另一个浏览器标签中打开了这个网站。</li>
</ol>
<p>这时，有一个标签页和版本为 <code>1</code> 的数据库建立了一个连接，而另一个标签页试图在其 <code>upgradeneeded</code> 处理程序中将数据库版本升级到 <code>2</code>。</p>
<p>问题是，这两个网页是同一个站点，同一个源，共享同一个数据库。而数据库不能同时为版本 <code>1</code> 和版本 <code>2</code>。要执行版本 <code>2</code> 的更新，必须关闭对版本 <code>1</code> 的所有连接，包括第一个标签页中的那个。</p>
<p>为了解决这一问题，在这种情况下 <code>versionchange</code> 事件会在“过时的”数据库对象上触发。我们需要监听这个事件，关闭对旧版本数据库的连接（还应该建议访问者重新加载页面，以加载最新的代码）。</p>
<p>如果我们不监听 <code>versionchange</code> 事件，也不去关闭旧连接，那么新的连接就不会建立。<code>openRequest</code> 对象会产生 <code>blocked</code> 事件，而不是 <code>success</code> 事件。因此第二个标签页无法正常工作。</p>
<p>下面是能够正确处理并行升级情况的代码。</p>
<p>它在数据库被打开后注入能够关闭旧连接的 <code>onversionchange</code> 处理程序：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> openRequest = indexedDB.open(<span class="hljs-string">&quot;store&quot;</span>, <span class="hljs-number">2</span>);

openRequest.onupgradeneeded = ...;
openRequest.onerror = ...;

openRequest.onsuccess = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> db = openRequest.result;

  *!*
  db.onversionchange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    db.close();
    alert(<span class="hljs-string">&quot;Database is outdated, please reload the page.&quot;</span>)
  };
  */!*

  <span class="hljs-comment">// ……数据库已经准备好，请使用它……</span>
};

*!*
openRequest.onblocked = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// 如果我们正确处理了 onversionchange 事件，这个事件就不应该触发</span>

  <span class="hljs-comment">// 这意味着还有另一个指向同一数据库的连接</span>
  <span class="hljs-comment">// 并且在 db.onversionchange 被触发后，该连接没有被关闭</span>
};
*/!*</code></pre>
<p>在这我们做两件事：</p>
<ol>
<li>成功打开后添加 <code>db.onversionchange</code> 监听器，以得到尝试并行更新的消息。</li>
<li>添加 <code>openRequest.onblocked</code> 监听器来处理旧连接未关闭的情况。如果在 <code>db.onversionchange</code> 中关闭，就不会发生这种情况。</li>
</ol>
<p>还有其他方案。例如，我们可以在 <code>db.onversionchange</code> 中优雅地关闭一些东西，关闭连接之前提示用户保存数据。如果 <code>db.onversionchange</code> 完成但没有关闭，新的连接将立即阻塞。可以要求用户只保留新的网页，关闭旧网页，以此更新数据。</p>
<p>这种更新冲突很少发生，但我们至少应该处理一下。例如使用 <code>onblocked</code> 处理程序，以防程序卡死影响用户体验。</p>
<h2 id="对象库（object-store）">对象库（object store）</h2>
<p>要在 <code>IndexedDB</code> 中存储某些内容，我们需要一个<strong>对象库</strong>。</p>
<p>对象库是 IndexedDB 的核心概念，在其他数据库中对应的对象称为“表”或“集合”。它是储存数据的地方。一个数据库可能有多个存储区：一个用于存储用户数据，另一个用于商品，等等。</p>
<p>尽管被命名为“对象库”，但也可以存储原始类型。</p>
<p><strong>几乎可以存储任何值，包括复杂的对象。</strong></p>
<p>IndexedDB 使用<a href="https://www.w3.org/TR/html53/infrastructure.html#section-structuredserializeforstorage">标准序列化算法</a>来克隆和存储对象。类似于 <code>JSON.stringify</code>，不过功能更加强大，能够存储更多的数据类型。</p>
<p>有一种对象不能被存储：循环引用的对象。此类对象不可序列化，也不能进行 <code>JSON.stringify</code>。</p>
<p><strong>库中的每个值都必须有唯一的键 <code>key</code></strong></p>
<p>键的类型必须为数字、日期、字符串、二进制或数组。它是唯一的标识符：通过键来 搜索/删除/更新 值。</p>
<p><img src="indexeddb-structure.svg" alt=""></p>
<p>类似于 <code>localStorage</code>，我们向存储区添加值时，可以提供一个键。但当我们存储对象时，IndexedDB 允许设置一个对象属性作为键，这就更加方便了。或者，我们可以自动生成键。</p>
<p>但我们需要先创建一个对象库。</p>
<p>创建对象库的语法：</p>
<pre><code class="language-js">db.createObjectStore(name[, keyOptions]);</code></pre>
<p>请注意，操作是同步的，不需要 <code>await</code>。</p>
<ul>
<li><code>name</code> 是存储区名称，例如 <code>&quot;books&quot;</code> 表示书。</li>
<li><code>keyOptions</code> 是具有以下两个属性之一的可选对象：<ul>
<li><code>keyPath</code> —— 对象属性的路径，IndexedDB 将以此路径作为键，例如 <code>id</code>。</li>
<li><code>autoIncrement</code> —— 如果为 <code>true</code>，则自动生成新存储的对象的键，键是一个不断递增的数字。</li>
</ul>
</li>
</ul>
<p>如果我们不提供 <code>keyOptions</code>，那么以后需要在存储对象时，显式地提供一个键。</p>
<p>例如，此对象库使用 <code>id</code> 属性作为键:</p>
<pre><code class="language-js">db.createObjectStore(<span class="hljs-string">&#x27;books&#x27;</span>, {<span class="hljs-attr">keyPath</span>: <span class="hljs-string">&#x27;id&#x27;</span>});</code></pre>
<p><strong>在 <code>upgradeneeded</code> 处理程序中，只有在创建数据库版本时，对象库被才能被 创建/修改。</strong></p>
<p>这是技术上的限制。在 upgradeneedHandler 之外，可以 添加/删除/更新数据，但是只能在版本更新期间 创建/删除/更改对象库。</p>
<p>要执行数据库版本升级，主要有两种方法：</p>
<ol>
<li>我们实现每个版本的升级功能：从 1 到 2，从 2 到 3，从 3 到 4，等等。在 <code>upgradeneeded</code> 中，可以进行版本比较（例如，老版本是 2，需要升级到 4），并针对每个中间版本（2 到 3，然后 3 到 4）逐步运行每个版本的升级。</li>
<li>或者我们可以检查数据库：以 <code>db.objectStoreNames</code> 的形式获取现有对象库的列表。该对象是一个 <a href="https://html.spec.whatwg.org/multipage/common-dom-interfaces.html#domstringlist">DOMStringList</a> 提供 <code>contains(name)</code> 方法来检查 name 是否存在，再根据存在和不存在的内容进行更新。</li>
</ol>
<p>对于小型数据库，第二种方法可能更简单。</p>
<p>下面是第二种方法的演示:</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> openRequest = indexedDB.open(<span class="hljs-string">&quot;db&quot;</span>, <span class="hljs-number">2</span>);

<span class="hljs-comment">// 创建/升级 数据库而无需版本检查</span>
openRequest.onupgradeneeded = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> db = openRequest.result;
  <span class="hljs-keyword">if</span> (!db.objectStoreNames.contains(<span class="hljs-string">&#x27;books&#x27;</span>)) { <span class="hljs-comment">// 如果没有 “books” 数据</span>
    db.createObjectStore(<span class="hljs-string">&#x27;books&#x27;</span>, {<span class="hljs-attr">keyPath</span>: <span class="hljs-string">&#x27;id&#x27;</span>}); <span class="hljs-comment">// 创造它</span>
  }
};</code></pre>
<p>删除对象库：</p>
<pre><code class="language-js">db.deleteObjectStore(<span class="hljs-string">&#x27;books&#x27;</span>)</code></pre>
<h2 id="事务">事务</h2>
<p>术语“事务”是通用的，许多数据库中都有用到。</p>
<p>事务是一组操作，要么全部成功，要么全部失败。</p>
<p>例如，当一个人买东西时，我们需要：</p>
<ol>
<li>从他们的账户中扣除这笔钱。</li>
<li>将该项目添加到他们的清单中。</li>
</ol>
<p>如果完成了第一个操作，但是出了问题，比如停电。这时无法完成第二个操作，这非常糟糕。两件时应该要么都成功（购买完成，好！）或同时失败（这个人保留了钱，可以重新尝试）。</p>
<p>事务可以保证同时完成。</p>
<p><strong>所有数据操作都必须在 IndexedDB 中的事务内进行。</strong></p>
<p>启动事务：</p>
<pre><code class="language-js">db.transaction(store[, type]);</code></pre>
<ul>
<li><code>store</code> 是事务要访问的库名称，例如 <code>&quot;books&quot;</code>。如果我们要访问多个库，则是库名称的数组。</li>
<li><code>type</code> – 事务类型，以下类型之一：<ul>
<li><code>readonly</code> —— 只读，默认值。</li>
<li><code>readwrite</code> —— 只能读取和写入数据，而不能 创建/删除/更改 对象库。</li>
</ul>
</li>
</ul>
<p>还有 <code>versionchange</code> 事务类型：这种事务可以做任何事情，但不能被手动创建。IndexedDB 在打开数据库时，会自动为 <code>updateneeded</code> 处理程序创建 <code>versionchange</code> 事务。这就是它为什么可以更新数据库结构、创建/删除 对象库的原因。</p>
<pre><code class="language-smart">性能是事务需要标记为 `只读（readonly）` 和 `读写（readwrite）` 的原因。

许多只读事务能够同时访问同一存储区，但读写事务不能。因为读写事务会“锁定”存储区进行写操作。下一个事务必须等待前一个事务完成，才能访问相同的存储区。</code></pre>
<p>创建事务后，我们可以将项目添加到库，就像这样：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> transaction = db.transaction(<span class="hljs-string">&quot;books&quot;</span>, <span class="hljs-string">&quot;readwrite&quot;</span>); <span class="hljs-comment">// (1)</span>

<span class="hljs-comment">// 获取对象库进行操作</span>
*!*
<span class="hljs-keyword">let</span> books = transaction.objectStore(<span class="hljs-string">&quot;books&quot;</span>); <span class="hljs-comment">// (2)</span>
*/!*

<span class="hljs-keyword">let</span> book = {
  <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;js&#x27;</span>,
  <span class="hljs-attr">price</span>: <span class="hljs-number">10</span>,
  <span class="hljs-attr">created</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()
};

*!*
<span class="hljs-keyword">let</span> request = books.add(book); <span class="hljs-comment">// (3)</span>
*/!*

request.onsuccess = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// (4)</span>
  <span class="hljs-comment">// 书已添加到存储区</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Book added to the store&quot;</span>, request.result);
};

request.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Error&quot;</span>, request.error);
};</code></pre>
<p>基本有四个步骤：</p>
<ol>
<li>创建一个事务，在（1）表明要访问的所有存储。</li>
<li>使用 <code>transaction.objectStore(name)</code>，在（2）中获取存储对象。</li>
<li>在（3）执行对对象库 <code>books.add(book)</code> 的请求。</li>
<li>……处理请求 成功/错误（4），还可以根据需要发出其他请求。</li>
</ol>
<p>对象库支持两种存储值的方法：</p>
<ul>
<li><p><strong>put(value, [key])</strong>
  将 <code>value</code> 添加到存储区。仅当对象库没有 <code>keyPath</code> 或 <code>autoIncrement</code> 时，才提供 <code>key</code>。如果已经存在具有相同键的值，则将替换该值。</p>
</li>
<li><p><strong>add(value, [key])</strong>
  与 <code>put</code> 相同，但是如果已经有一个值具有相同的键，则请求失败，并生成一个名为 <code>&quot;ConstraInterror&quot;</code> 的错误。</p>
</li>
</ul>
<p>与打开数据库类似，我们可以发送一个请求：<code>books.add(book)</code>，然后等待 <code>success/error</code> 事件。</p>
<ul>
<li><code>add</code> 的 <code>request.result</code> 是新对象的键。</li>
<li>错误在 <code>request.error</code>（如果有的话）中。</li>
</ul>
<h2 id="事务的自动提交">事务的自动提交</h2>
<p>在上面的示例中，我们启动了事务并发出了 <code>add</code> 请求。但正如前面提到的，一个事务可能有多个相关的请求，这些请求必须全部成功或全部失败。那么如何标记事务为已完成，并不再请求呢？</p>
<p>简短的回答是：没有。</p>
<p>在下一个版本 3.0 规范中，可能会有一种手动方式来完成事务，但目前在 2.0 中还没有。</p>
<p><strong>当所有事务的请求完成，并且 <a href="info:microtask-queue">微任务队列</a> 为空时，它将自动提交。</strong></p>
<p>通常，我们可以假设事务在其所有请求完成时提交，并且当前代码完成。</p>
<p>因此，在上面的示例中，不需要任何特殊调用即可完成事务。</p>
<p>事务自动提交原则有一个重要的副作用。不能在事务中间插入 <code>fetch</code>, <code>setTimeout</code> 等异步操作。IndexedDB 不会让事务等待这些操作完成。</p>
<p>在下面的代码中，<code>request2</code> 中的行 <code>(*)</code> 失败，因为事务已经提交，不能在其中发出任何请求:</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> request1 = books.add(book);

request1.onsuccess = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  fetch(<span class="hljs-string">&#x27;/&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
*!*
    <span class="hljs-keyword">let</span> request2 = books.add(anotherBook); <span class="hljs-comment">// (*)</span>
*/!*
    request2.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-built_in">console</span>.log(request2.error.name); <span class="hljs-comment">// TransactionInactiveError</span>
    };
  });
};</code></pre>
<p>这是因为 <code>fetch</code> 是一个异步操作，一个宏任务。事务在浏览器开始执行宏任务之前关闭。</p>
<p>IndexedDB 规范的作者认为事务应该是短期的。主要是性能原因。</p>
<p>值得注意的是，<code>readwrite</code> 事务将存储“锁定”以进行写入。因此，如果应用程序的一部分启动了 <code>books</code> 对象库上的 <code>readwrite</code> 操作，那么希望执行相同操作的另一部分必须等待新事务“挂起”，直到第一个事务完成。如果事务处理需要很长时间，将会导致奇怪的延迟。</p>
<p>那么，该怎么办？</p>
<p>在上面的示例中，我们可以在新请求 <code>(*)</code> 之前创建一个新的 <code>db.transaction</code>。</p>
<p>如果需要在一个事务中把所有操作保持一致，更好的做法是将 IndexedDB 事务和“其他”异步内容分开。</p>
<p>首先，执行 <code>fetch</code>，并根据需要准备数据。然后创建事务并执行所有数据库请求，然后就正常了。</p>
<p>为了检测到成功完成的时刻，我们可以监听 <code>transaction.oncomplete</code> 事件:</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> transaction = db.transaction(<span class="hljs-string">&quot;books&quot;</span>, <span class="hljs-string">&quot;readwrite&quot;</span>);

<span class="hljs-comment">// ……执行操作……</span>

transaction.oncomplete = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Transaction is complete&quot;</span>); <span class="hljs-comment">// 事务执行完成</span>
};</code></pre>
<p>只有 <code>complete</code> 才能保证将事务作为一个整体保存。个别请求可能会成功，但最终的写入操作可能会出错（例如 I/O 错误或其他错误）。</p>
<p>要手动中止事务，请调用：</p>
<pre><code class="language-js">transaction.abort();</code></pre>
<p>取消请求里所做的所有修改，并触发 <code>transaction.onabort</code> 事件。</p>
<h2 id="错误处理">错误处理</h2>
<p>写入请求可能会失败。</p>
<p>这是意料之中的事，不仅是我们可能会犯的粗心失误，还有与事务本身相关的其他原因。例如超过了存储配额。因此，必须做好请求失败的处理。</p>
<p><strong>失败的请求将自动中止事务，并取消所有的更改。</strong></p>
<p>在一些情况下，我们会想自己去处理失败事务（例如尝试另一个请求）并让它继续执行，而不是取消现有的更改。可以调用 <code>request.onerror</code> 处理程序，在其中调用 <code>event.preventDefault()</code> 防止事务中止。</p>
<p>在下面的示例中，添加了一本新书，键 (<code>id</code>) 与现有的书相同。<code>store.add</code> 方法生成一个 <code>&quot;ConstraInterror&quot;</code>。可以在不取消事务的情况下进行处理：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> transaction = db.transaction(<span class="hljs-string">&quot;books&quot;</span>, <span class="hljs-string">&quot;readwrite&quot;</span>);

<span class="hljs-keyword">let</span> book = { <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;js&#x27;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">10</span> };

<span class="hljs-keyword">let</span> request = transaction.objectStore(<span class="hljs-string">&quot;books&quot;</span>).add(book);

request.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
  <span class="hljs-comment">// 有相同 id 的对象存在时，发生 ConstraintError</span>
  <span class="hljs-keyword">if</span> (request.error.name == <span class="hljs-string">&quot;ConstraintError&quot;</span>) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Book with such id already exists&quot;</span>); <span class="hljs-comment">// 处理错误</span>
    event.preventDefault(); <span class="hljs-comment">// 不要中止事务</span>
    <span class="hljs-comment">// 这个 book 用另一个键？</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 意外错误，无法处理</span>
    <span class="hljs-comment">// 事务将中止</span>
  }
};

transaction.onabort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Error&quot;</span>, transaction.error);
};</code></pre>
<h3 id="事件委托">事件委托</h3>
<p>每个请求都需要调用 onerror/onsuccess ？并不，可以使用事件委托来代替。</p>
<p><strong>IndexedDB 事件冒泡：请求 -&gt; 事务 -&gt; 数据库。</strong></p>
<p>所有事件都是 DOM 事件，有捕获和冒泡，但通常只使用冒泡阶段。</p>
<p>因此，出于报告或其他原因，我们可以使用 <code>db.onerror</code> 处理程序捕获所有错误：</p>
<pre><code class="language-js">db.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
  <span class="hljs-keyword">let</span> request = event.target; <span class="hljs-comment">// 导致错误的请求</span>

  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Error&quot;</span>, request.error);
};</code></pre>
<p>……但是错误被完全处理了呢？这种情况不应该被报告。</p>
<p>我们可以通过在 <code>request.onerror</code> 中使用 <code>event.stopPropagation()</code> 来停止冒泡，从而停止 <code>db.onerror</code> 事件。</p>
<pre><code class="language-js">request.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
  <span class="hljs-keyword">if</span> (request.error.name == <span class="hljs-string">&quot;ConstraintError&quot;</span>) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Book with such id already exists&quot;</span>); <span class="hljs-comment">// 处理错误</span>
    event.preventDefault(); <span class="hljs-comment">// 不要中止事务</span>
    event.stopPropagation(); <span class="hljs-comment">// 不要让错误冒泡, 停止它的传播</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 什么都不做</span>
    <span class="hljs-comment">// 事务将中止</span>
    <span class="hljs-comment">// 我们可以解决 transaction.onabort 中的错误</span>
  }
};</code></pre>
<h2 id="通过键搜索">通过键搜索</h2>
<p>对象库有两种主要的搜索类型：</p>
<ol>
<li>通过一个键或一个键范围。即：通过在“books”中存储的 <code>book.id</code>。</li>
<li>另一个对象字段，例如 <code>book.price</code>。</li>
</ol>
<p>首先，让我们来处理键和键范围 <code>(1)</code>。</p>
<p>涉及到的搜索方法，包括支持精确键，也包括所谓的“范围查询” —— <a href="https://www.w3.org/TR/IndexedDB/#keyrange">IDBKeyRange</a> 对象指定一个“键范围”。</p>
<p>使用以下调用函数创建范围：</p>
<ul>
<li><code>IDBKeyRange.lowerBound(lower, [open])</code> 表示：<code>≥lower</code>（如果 <code>open</code> 是 true，表示 <code>&gt;lower</code>）</li>
<li><code>IDBKeyRange.upperBound(upper, [open])</code> 表示：<code>≤upper</code>（如果 <code>open</code> 是 true，表示  <code>&lt;upper</code>）</li>
<li><code>IDBKeyRange.bound(lower, upper, [lowerOpen], [upperOpen])</code> 表示: 在 <code>lower</code> 和 <code>upper</code> 之间。如果 open 为 true，则相应的键不包括在范围中。</li>
<li><code>IDBKeyRange.only(key)</code> —— 仅包含一个键的范围 <code>key</code>，很少使用。</li>
</ul>
<p>所有搜索方法都接受一个查询参数 <code>query</code>，该参数可以是精确键或者键范围：</p>
<ul>
<li><code>store.get(query)</code> —— 按键或范围搜索第一个值。</li>
<li><code>store.getAll([query], [count])</code> —— 搜索所有值。如果 <code>count</code> 给定，则按 <code>count</code> 进行限制。</li>
<li><code>store.getKey(query)</code> —— 搜索满足查询的第一个键，通常是一个范围。</li>
<li><code>store.getAllKeys([query], [count])</code> —— 搜索满足查询的所有键，通常是一个范围。如果 <code>count</code> 给定，则最多为 count。</li>
<li><code>store.count([query])</code> —— 获取满足查询的键的总数，通常是一个范围。</li>
</ul>
<p>例如，我们存储区里有很多书。因为 <code>id</code> 字段是键，因此所有方法都可以按 <code>id</code> 进行搜索。</p>
<p>请求示例：</p>
<pre><code class="language-js"><span class="hljs-comment">// 获取一本书</span>
books.get(<span class="hljs-string">&#x27;js&#x27;</span>)

<span class="hljs-comment">// 获取 &#x27;css&#x27; &lt;= id &lt;= &#x27;html&#x27; 的书</span>
books.getAll(IDBKeyRange.bound(<span class="hljs-string">&#x27;css&#x27;</span>, <span class="hljs-string">&#x27;html&#x27;</span>))

<span class="hljs-comment">// 获取 id &lt; &#x27;html&#x27; 的书</span>
books.getAll(IDBKeyRange.upperBound(<span class="hljs-string">&#x27;html&#x27;</span>, <span class="hljs-literal">true</span>))

<span class="hljs-comment">// 获取所有书</span>
books.getAll()

<span class="hljs-comment">// 获取所有 id &gt; &#x27;js&#x27; 的键</span>
books.getAllKeys(IDBKeyRange.lowerBound(<span class="hljs-string">&#x27;js&#x27;</span>, <span class="hljs-literal">true</span>))</code></pre>
<pre><code class="language-smart">对象库按键对值进行内部排序。

因此，请求的返回值，是按照键的顺序排列的。</code></pre>
<h2 id="通过带索引的字段搜索">通过带索引的字段搜索</h2>
<p>要根据其他对象字段进行搜索，我们需要创建一个名为“索引（index）”的附加数据结构。</p>
<p>索引是存储的&quot;附加项&quot;，用于跟踪给定的对象字段。对于该字段的每个值，它存储有该值的对象的键列表。下面会有更详细的图片。</p>
<p>语法：</p>
<pre><code class="language-js">objectStore.createIndex(name, keyPath, [options]);</code></pre>
<ul>
<li><strong><code>name</code></strong> —— 索引名称。</li>
<li><strong><code>keyPath</code></strong> —— 索引应该跟踪的对象字段的路径（我们将根据该字段进行搜索）。</li>
<li><strong><code>option</code></strong> —— 具有以下属性的可选对象：<ul>
<li><strong><code>unique</code></strong> —— 如果为true，则存储中只有一个对象在 <code>keyPath</code> 上具有给定值。如果我们尝试添加重复项，索引将生成错误。</li>
<li><strong><code>multiEntry</code></strong> —— 只有 <code>keypath</code> 上的值是数组才时使用。这时，默认情况下，索引将默认把整个数组视为键。但是如果 <code>multiEntry</code> 为 true，那么索引将为该数组中的每个值保留一个存储对象的列表。所以数组成员成为了索引键。</li>
</ul>
</li>
</ul>
<p>在我们的示例中，是按照 <code>id</code> 键存储图书的。</p>
<p>假设我们想通过 <code>price</code> 进行搜索。</p>
<p>首先，我们需要创建一个索引。它像对象库一样，必须在 <code>upgradeneeded</code> 中创建完成：</p>
<pre><code class="language-js">openRequest.onupgradeneeded = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// 在 versionchange 事务中，我们必须在这里创建索引</span>
  <span class="hljs-keyword">let</span> books = db.createObjectStore(<span class="hljs-string">&#x27;books&#x27;</span>, {<span class="hljs-attr">keyPath</span>: <span class="hljs-string">&#x27;id&#x27;</span>});
*!*
  <span class="hljs-keyword">let</span> index = inventory.createIndex(<span class="hljs-string">&#x27;price_idx&#x27;</span>, <span class="hljs-string">&#x27;price&#x27;</span>);
*/!*
};</code></pre>
<ul>
<li>该索引将跟踪 <code>price</code> 字段。</li>
<li>价格不是唯一的，可能有多本书价格相同，所以我们不设置唯一 <code>unique</code> 选项。</li>
<li>价格不是一个数组，因此不适用多入口 <code>multiEntry</code> 标志。</li>
</ul>
<p>假设我们的库存里有4本书。下面的图片显示了该索引 <code>index</code> 的确切内容：</p>
<p><img src="indexeddb-index.svg" alt=""></p>
<p>如上所述，每个 price 值的索引（第二个参数）保存具有该价格的键的列表。</p>
<p>索引自动保持最新，所以我们不必关心它。</p>
<p>现在，当我们想要搜索给定的价格时，只需将相同的搜索方法应用于索引：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> transaction = db.transaction(<span class="hljs-string">&quot;books&quot;</span>); <span class="hljs-comment">// 只读</span>
<span class="hljs-keyword">let</span> books = transaction.objectStore(<span class="hljs-string">&quot;books&quot;</span>);
<span class="hljs-keyword">let</span> priceIndex = books.index(<span class="hljs-string">&quot;price_idx&quot;</span>);

*!*
<span class="hljs-keyword">let</span> request = priceIndex.getAll(<span class="hljs-number">10</span>);
*/!*

request.onsuccess = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (request.result !== <span class="hljs-literal">undefined</span>) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Books&quot;</span>, request.result); <span class="hljs-comment">// 价格为 10 的书的数组</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;No such books&quot;</span>);
  }
};</code></pre>
<p>我们还可以使用 <code>IDBKeyRange</code> 创建范围，并查找 便宜/贵 的书：</p>
<pre><code class="language-js"><span class="hljs-comment">// 查找价格 &lt;=5 的书籍</span>
<span class="hljs-keyword">let</span> request = priceIndex.getAll(IDBKeyRange.upperBound(<span class="hljs-number">5</span>));</code></pre>
<p>在我们的例子中，索引是按照被跟踪对象字段价格 <code>price</code> 进行内部排序的。所以当我们进行搜索时，搜索结果也会按照价格排序。</p>
<h2 id="从存储中删除">从存储中删除</h2>
<p><code>delete</code> 方法查找要由查询删除的值，调用格式类似于 <code>getAll</code></p>
<ul>
<li><strong><code>delete(query)</code></strong> —— 通过查询删除匹配的值。</li>
</ul>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-comment">// 删除 id=&#x27;js&#x27; 的书</span>
books.delete(<span class="hljs-string">&#x27;js&#x27;</span>);</code></pre>
<p>如果要基于价格或其他对象字段删除书。首先需要在索引中找到键，然后调用 <code>delete</code>：</p>
<pre><code class="language-js"><span class="hljs-comment">// 找到价格 = 5 的钥匙</span>
<span class="hljs-keyword">let</span> request = priceIndex.getKey(<span class="hljs-number">5</span>);

request.onsuccess = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> id = request.result;
  <span class="hljs-keyword">let</span> deleteRequest = books.delete(id);
};</code></pre>
<p>删除所有内容：</p>
<pre><code class="language-js">books.clear(); <span class="hljs-comment">// 清除存储。</span></code></pre>
<h2 id="光标（cursors）">光标（Cursors）</h2>
<p>像 <code>getAll/getAllKeys</code> 这样的方法，会返回一个 键/值 数组。</p>
<p>但是一个对象库可能很大，比可用的内存还大。这时，<code>getAll</code> 就无法将所有记录作为一个数组获取。</p>
<p>该怎么办呢？</p>
<p>光标提供了解决这一问题的方法。</p>
<p><strong>光标是一种特殊的对象，它在给定查询的情况下遍历对象库，一次返回一个键/值，从而节省内存。</strong></p>
<p>由于对象库是按键在内部排序的，因此光标按键顺序（默认为升序）遍历存储。</p>
<p>语法:</p>
<pre><code class="language-js"><span class="hljs-comment">// 类似于 getAll，但带有光标：</span>
<span class="hljs-keyword">let</span> request = store.openCursor(query, [direction]);

<span class="hljs-comment">// 获取键，而不是值（例如 getAllKeys）：store.openKeyCursor </span></code></pre>
<ul>
<li><strong><code>query</code></strong> 是一个键或键范围，与 <code>getAll</code> 相同。</li>
<li><strong><code>direction</code></strong> 是一个可选参数，使用顺序是：<ul>
<li><code>&quot;next&quot;</code> —— 默认值，光标从有最小索引的记录向上移动。</li>
<li><code>&quot;prev&quot;</code> —— 相反的顺序：从有最大的索引的记录开始下降。</li>
<li><code>&quot;nextunique&quot;</code>，<code>&quot;prevunique&quot;</code> —— 同上，但是跳过键相同的记录 （仅适用于索引上的光标，例如，对于价格为 5 的书，仅返回第一本）。</li>
</ul>
</li>
</ul>
<p><strong>光标对象的主要区别在于 <code>request.onSuccess</code> 多次触发：每个结果触发一次。</strong></p>
<p>这有一个如何使用光标的例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> transaction = db.transaction(<span class="hljs-string">&quot;books&quot;</span>);
<span class="hljs-keyword">let</span> books = transaction.objectStore(<span class="hljs-string">&quot;books&quot;</span>);

<span class="hljs-keyword">let</span> request = books.openCursor();

<span class="hljs-comment">// 为光标找到的每本书调用</span>
request.onsuccess = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> cursor = request.result;
  <span class="hljs-keyword">if</span> (cursor) {
    <span class="hljs-keyword">let</span> key = cursor.key; <span class="hljs-comment">// 书的键（id字段）</span>
    <span class="hljs-keyword">let</span> value = cursor.value; <span class="hljs-comment">// 书本对象</span>
    <span class="hljs-built_in">console</span>.log(key, value);
    cursor.continue();
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;No more books&quot;</span>);
  }
};</code></pre>
<p>主要的光标方法有：</p>
<ul>
<li><code>advance(count)</code> —— 将光标向前移动 <code>count</code> 次，跳过值。</li>
<li><code>continue([key])</code> —— 将光标移至匹配范围中的下一个值（如果给定键，紧接键之后）。</li>
</ul>
<p>无论是否有更多的值匹配光标 —— 调用 <code>onsuccess</code>。结果中，我们可以获得指向下一条记录的光标，或者 <code>undefined</code>。</p>
<p>在上面的示例中，光标是为对象库创建的。</p>
<p>也可以在索引上创建一个光标。索引是允许按对象字段进行搜索的。在索引上的光标与在对象存储上的光标完全相同 — 它们通过一次返回一个值来节省内存。</p>
<p>对于索引上的游标，<code>cursor.key</code> 是索引键（例如：价格），我们应该使用 <code>cursor.primaryKey</code> 属性作为对象的键：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> request = priceIdx.openCursor(IDBKeyRange.upperBound(<span class="hljs-number">5</span>));

<span class="hljs-comment">// 为每条记录调用</span>
request.onsuccess = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> cursor = request.result;
  <span class="hljs-keyword">if</span> (cursor) {
    <span class="hljs-keyword">let</span> key = cursor.primaryKey; <span class="hljs-comment">// 下一个对象存储键（id 字段）</span>
    <span class="hljs-keyword">let</span> value = cursor.value; <span class="hljs-comment">// 下一个对象存储对象（book 对象）</span>
    <span class="hljs-keyword">let</span> key = cursor.key; <span class="hljs-comment">// 下一个索引键（price）</span>
    <span class="hljs-built_in">console</span>.log(key, value);
    cursor.continue();
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;No more books&quot;</span>); <span class="hljs-comment">// 没有书了</span>
  }
};</code></pre>
<h2 id="promise-包装器">Promise 包装器</h2>
<p>将 <code>onsuccess/onerror</code> 添加到每个请求是一项相当麻烦的任务。我们可以通过使用事件委托（例如，在整个事务上设置处理程序）来简化我们的工作，但是 <code>async/await</code> 要方便的多。</p>
<p>在本章，我们会进一步使用一个轻便的承诺包装器 <a href="https://github.com/jakearchibald/idb">https://github.com/jakearchibald/idb</a> 。它使用 <a href="info:promisify">promisified</a> IndexedDB 方法创建全局 <code>idb</code> 对象。 </p>
<p>然后，我们可以不使用 <code>onsuccess/onerror</code>，而是这样写：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> db = <span class="hljs-keyword">await</span> idb.openDb(<span class="hljs-string">&#x27;store&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-function"><span class="hljs-params">db</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (db.oldVersion == <span class="hljs-number">0</span>) {
    <span class="hljs-comment">// 执行初始化</span>
    db.createObjectStore(<span class="hljs-string">&#x27;books&#x27;</span>, {<span class="hljs-attr">keyPath</span>: <span class="hljs-string">&#x27;id&#x27;</span>});
  }
});

<span class="hljs-keyword">let</span> transaction = db.transaction(<span class="hljs-string">&#x27;books&#x27;</span>, <span class="hljs-string">&#x27;readwrite&#x27;</span>);
<span class="hljs-keyword">let</span> books = transaction.objectStore(<span class="hljs-string">&#x27;books&#x27;</span>);

<span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">await</span> books.add(...);
  <span class="hljs-keyword">await</span> books.add(...);

  <span class="hljs-keyword">await</span> transaction.complete;

  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;jsbook saved&#x27;</span>);
} <span class="hljs-keyword">catch</span>(err) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;error&#x27;</span>, err.message);
}
</code></pre>
<p>现在我们有了可爱的“简单异步代码”和「try..catch」捕获的东西。</p>
<h3 id="错误处理-1">错误处理</h3>
<p>如果我们没有捕获到错误，那么程序将一直失败，直到外部最近的 <code>try..catch</code> 捕获到为止。</p>
<p>未捕获的错误将成为 <code>window</code> 对象上的“unhandled promise rejection”事件。</p>
<p>我们可以这样处理这种错误：</p>
<pre><code class="language-js"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;unhandledrejection&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
  <span class="hljs-keyword">let</span> request = event.target; <span class="hljs-comment">// IndexedDB 本机请求对象</span>
  <span class="hljs-keyword">let</span> error = event.reason; <span class="hljs-comment">//  未处理的错误对象，与 request.error 相同</span>
  <span class="hljs-comment">// ……报告错误……</span>
});</code></pre>
<h3 id="非活跃事务陷阱">“非活跃事务”陷阱</h3>
<p>我们都知道，浏览器一旦执行完成当前的代码和<strong>微任务</strong>之后，事务就会自动提交。因此，如果我们在事务中间放置一个类似 <code>fetch</code> 的宏任务，事务只是会自动提交，而不会等待它执行完成。因此，下一个请求会失败。</p>
<p>对于 promise 包装器和 <code>async/await</code>，情况是相同的。</p>
<p>这是在事务中间进行 <code>fetch</code> 的示例：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> transaction = db.transaction(<span class="hljs-string">&quot;inventory&quot;</span>, <span class="hljs-string">&quot;readwrite&quot;</span>);
<span class="hljs-keyword">let</span> inventory = transaction.objectStore(<span class="hljs-string">&quot;inventory&quot;</span>);

<span class="hljs-keyword">await</span> inventory.add({ <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;js&#x27;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">created</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() });

<span class="hljs-keyword">await</span> fetch(...); <span class="hljs-comment">// (*)</span>

<span class="hljs-keyword">await</span> inventory.add({ <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;js&#x27;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">created</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() }); <span class="hljs-comment">// 错误</span></code></pre>
<p><code>fetch</code> <code>(*)</code> 后的下一个 <code>inventory.add</code> 失败，出现“非活动事务”错误，因为这时事务已经被提交并且关闭了。</p>
<p>解决方法与使用本机 IndexedDB 时相同：进行新事务，或者将事情分开。</p>
<ol>
<li>准备数据，先获取所有需要的信息。</li>
<li>然后保存在数据库中。</li>
</ol>
<h3 id="获取本机对象">获取本机对象</h3>
<p>在内部，包装器执行本机 IndexedDB 请求，并添加 <code>onerror/onsuccess</code> 方法，并返回 rejects/resolves 结果的 promise。</p>
<p>在大多数情况下都可以运行， 示例在这 <a href="https://github.com/jakearchibald/idb">https://github.com/jakearchibald/idb</a>。</p>
<p>极少数情况下，我们需要原始的 <code>request</code> 对象。可以将 <code>promise</code> 的 <code>promise.request</code> 属性，当作原始对象进行访问：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> promise = books.add(book); <span class="hljs-comment">// 获取 promise 对象(不要 await 结果)</span>

<span class="hljs-keyword">let</span> request = promise.request; <span class="hljs-comment">// 本地请求对象</span>
<span class="hljs-keyword">let</span> transaction = request.transaction; <span class="hljs-comment">// 本地事务对象</span>

<span class="hljs-comment">// ……做些本地的 IndexedDB 的处理……</span>

<span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> promise; <span class="hljs-comment">// 如果仍然需要</span></code></pre>
<h2 id="总结">总结</h2>
<p>IndexedDB 可以被认为是“localStorage on steroids”。这是一个简单的键值对数据库，功能强大到足以支持离线应用，而且用起来比较简单。</p>
<p>最好的指南是官方文档。<a href="https://w3c.github.io/IndexedDB">目前的版本</a>是2.0，但是<a href="https://w3c.github.io/IndexedDB/">3.0</a>版本中的一些方法（差别不大）也得到部分支持。</p>
<p>基本用法可以用几个短语来描述：</p>
<ol>
<li>获取一个 promise 包装器，比如 <a href="https://github.com/jakearchibald/idb">idb</a>.</li>
<li>打开一个数据库：<code>idb.openDb(name, version, onupgradeneeded)</code><ul>
<li>在 <code>onupgradeneeded</code> 处理程序中创建对象存储和索引，或者根据需要执行版本更新。</li>
</ul>
</li>
<li>对于请求：<ul>
<li>创建事务 <code>db.transaction(&#39;books&#39;)</code>（如果需要的话，设置 readwrite）。</li>
<li>获取对象存储 <code>transaction.objectStore(&#39;books&#39;)</code>。</li>
</ul>
</li>
<li>按键搜索，可以直接调用对象库上的方法。<ul>
<li>要按对象字段搜索，需要创建索引。</li>
</ul>
</li>
<li>如果内存中容纳不下数据，请使用光标。</li>
</ol>
<p>这里有一个小应用程序示例：</p>
<p>[codetabs src=&quot;books&quot; current=&quot;index.html&quot;]</p>
