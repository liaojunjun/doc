<h1 id="可恢复的文件上传">可恢复的文件上传</h1>
<p>使用 <code>fetch</code> 方法来上传文件相当容易。</p>
<p>连接断开后如何恢复上传？这里没有对此的内建选项，但是我们有实现它的一些方式。</p>
<p>对于大文件（如果我们可能需要恢复），可恢复的上传应该带有上传进度提示。由于 <code>fetch</code> 不允许跟踪上传进度，我们将会使用 <a href="info:xmlhttprequest">XMLHttpRequest</a>。</p>
<h2 id="不太实用的进度事件">不太实用的进度事件</h2>
<p>要恢复上传，我们需要知道在连接断开前已经上传了多少。</p>
<p>我们有 <code>xhr.upload.onprogress</code> 来跟踪上传进度。</p>
<p>不幸的是，它不会帮助我们在此处恢复上传，因为它会在数据 <strong>被发送</strong> 时触发，但是服务器是否接收到了？浏览器并不知道。</p>
<p>或许它是由本地网络代理缓冲的（buffered），或者可能是远程服务器进程刚刚终止而无法处理它们，亦或是它在中间丢失了，并没有到达服务器。</p>
<p>这就是为什么此事件仅适用于显示一个好看的进度条。</p>
<p>要恢复上传，我们需要 <strong>确切地</strong> 知道服务器接收的字节数。而且只有服务器能告诉我们，因此，我们将发出一个额外的请求。</p>
<h2 id="算法">算法</h2>
<ol>
<li><p>首先，创建一个文件 id，以唯一地标识我们要上传的文件：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> fileId = file.name + <span class="hljs-string">&#x27;-&#x27;</span> + file.size + <span class="hljs-string">&#x27;-&#x27;</span> + +file.lastModifiedDate;</code></pre>
<p> 在恢复上传时需要用到它，以告诉服务器我们要恢复的内容。</p>
<p> 如果名称，或大小，或最后一次修改事件发生了更改，则将有另一个 <code>fileId</code>。</p>
</li>
<li><p>向服务器发送一个请求，询问它已经有了多少字节，像这样：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;status&#x27;</span>, {
  <span class="hljs-attr">headers</span>: {
    <span class="hljs-string">&#x27;X-File-Id&#x27;</span>: fileId
  }
});

<span class="hljs-comment">// 服务器已有的字节数</span>
<span class="hljs-keyword">let</span> startByte = +<span class="hljs-keyword">await</span> response.text();</code></pre>
<p> 这假设服务器通过 <code>X-File-Id</code> header 跟踪文件上传。应该在服务端实现。</p>
<p> 如果服务器上尚不存在该文件，则服务器响应应为 <code>0</code>。</p>
</li>
<li><p>然后，我们可以使用 <code>Blob</code> 和 <code>slice</code> 方法来发送从 <code>startByte</code> 开始的文件：</p>
<pre><code class="language-js">xhr.open(<span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&quot;upload&quot;</span>, <span class="hljs-literal">true</span>);

<span class="hljs-comment">// 文件 id，以便服务器知道我们要恢复的是哪个文件</span>
xhr.setRequestHeader(<span class="hljs-string">&#x27;X-File-Id&#x27;</span>, fileId);

<span class="hljs-comment">// 发送我们要从哪个字节开始恢复，因此服务器知道我们正在恢复</span>
xhr.setRequestHeader(<span class="hljs-string">&#x27;X-Start-Byte&#x27;</span>, startByte);

xhr.upload.onprogress = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Uploaded <span class="hljs-subst">${startByte + e.loaded}</span> of <span class="hljs-subst">${startByte + e.total}</span>`</span>);
};

<span class="hljs-comment">// 文件可以是来自 input.files[0]，或者另一个源</span>
xhr.send(file.slice(startByte));</code></pre>
<p> 这里我们将文件 id 作为 <code>X-File-Id</code> 发送给服务器，所以服务器知道我们正在上传哪个文件，并且，我们还将起始字节作为 <code>X-Start-Byte</code> 发送给服务器，所以服务器知道我们不是重新上传它，而是恢复其上传。</p>
<p> 服务器应该检查其记录，如果有一个上传的该文件，并且当前已上传的文件大小恰好是 <code>X-Start-Byte</code>，那么就将数据附加到该文件。</p>
</li>
</ol>
<p>这是用 Node.js 写的包含客户端和服务端代码的示例。</p>
<p>在本网站上，它只有部分能工作，因为 Node.js 位于另一个服务 Nginx 后面，该服务器缓冲（buffer）上传的内容，当完全上传后才将其传递给 Node.js。</p>
<p>但是你可以下载这些代码，在本地运行以进行完整演示：</p>
<p>[codetabs src=&quot;upload-resume&quot; height=200]</p>
<p>正如我们所看到的，现代网络方法在功能上已经与文件管理器非常接近 —— 控制 header，进度指示，发送文件片段等。</p>
<p>我们可以实现可恢复的上传等。</p>
