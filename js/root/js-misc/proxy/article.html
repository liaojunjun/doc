<h1 id="proxy-和-reflect">Proxy 和 Reflect</h1>
<p>一个 <code>Proxy</code> 对象包装另一个对象并拦截诸如读取/写入属性和其他操作，可以选择自行处理它们，或者透明地允许该对象处理它们。</p>
<p>Proxy 被用于了许多库和某些浏览器框架。在本文中，我们将看到许多实际应用。</p>
<h2 id="proxy">Proxy</h2>
<p>语法：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler)</code></pre>
<ul>
<li><code>target</code> —— 是要包装的对象，可以是任何东西，包括函数。</li>
<li><code>handler</code> —— 代理配置：带有“捕捉器”（&quot;traps&quot;，即拦截操作的方法）的对象。比如 <code>get</code> 捕捉器用于读取 <code>target</code> 的属性，<code>set</code> 捕捉器用于写入 <code>target</code> 的属性，等等。</li>
</ul>
<p>对 <code>proxy</code> 进行操作，如果在 <code>handler</code> 中存在相应的捕捉器，则它将运行，并且 Proxy 有机会对其进行处理，否则将直接对 target 进行处理。</p>
<p>首先，让我们创建一个没有任何捕捉器的代理（Proxy）：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> target = {};
<span class="hljs-keyword">let</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, {}); <span class="hljs-comment">// 空的 handler 对象</span>

proxy.test = <span class="hljs-number">5</span>; <span class="hljs-comment">// 写入 proxy 对象 (1)</span>
alert(target.test); <span class="hljs-comment">// 5，test 属性出现在了 target 中！</span>

alert(proxy.test); <span class="hljs-comment">// 5，我们也可以从 proxy 对象读取它 (2)</span>

<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> proxy) alert(key); <span class="hljs-comment">// test，迭代也正常工作 (3)</span></code></pre>
<p>由于没有捕捉器，所有对 <code>proxy</code> 的操作都直接转发给了 <code>target</code>。</p>
<ol>
<li>写入操作 <code>proxy.test=</code> 会将值写入 <code>target</code>。</li>
<li>读取操作 <code>proxy.test</code> 会从 <code>target</code> 返回对应的值。</li>
<li>迭代 <code>proxy</code> 会从 <code>target</code> 返回对应的值。</li>
</ol>
<p>我们可以看到，没有任何捕捉器，<code>proxy</code> 是一个 <code>target</code> 的透明包装器（wrapper）。</p>
<p><img src="proxy.svg" alt=""></p>
<p><code>Proxy</code> 是一种特殊的“奇异对象（exotic object）”。它没有自己的属性。如果 <code>handler</code> 为空，则透明地将操作转发给 <code>target</code>。</p>
<p>要激活更多功能，让我们添加捕捉器。</p>
<p>我们可以用它们拦截什么？</p>
<p>对于对象的大多数操作，JavaScript 规范中有一个所谓的“内部方法”，它描述了最底层的工作方式。例如 <code>[[Get]]</code>，用于读取属性的内部方法，<code>[[Set]]</code>，用于写入属性的内部方法，等等。这些方法仅在规范中使用，我们不能直接通过方法名调用它们。</p>
<p>Proxy 捕捉器会拦截这些方法的调用。它们在 <a href="https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots">proxy 规范</a> 和下表中被列出。</p>
<p>对于每个内部方法，此表中都有一个捕捉器：可用于添加到 <code>new Proxy</code> 的 <code>handler</code> 参数中以拦截操作的方法名称：</p>
<table>
<thead>
<tr>
<th>内部方法</th>
<th>Handler 方法</th>
<th>何时触发</th>
</tr>
</thead>
<tbody><tr>
<td><code>[[Get]]</code></td>
<td><code>get</code></td>
<td>读取属性</td>
</tr>
<tr>
<td><code>[[Set]]</code></td>
<td><code>set</code></td>
<td>写入属性</td>
</tr>
<tr>
<td><code>[[HasProperty]]</code></td>
<td><code>has</code></td>
<td><code>in</code> 操作符</td>
</tr>
<tr>
<td><code>[[Delete]]</code></td>
<td><code>deleteProperty</code></td>
<td><code>delete</code> 操作符</td>
</tr>
<tr>
<td><code>[[Call]]</code></td>
<td><code>apply</code></td>
<td>函数调用</td>
</tr>
<tr>
<td><code>[[Construct]]</code></td>
<td><code>construct</code></td>
<td><code>new</code> 操作符</td>
</tr>
<tr>
<td><code>[[GetPrototypeOf]]</code></td>
<td><code>getPrototypeOf</code></td>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf">Object.getPrototypeOf</a></td>
</tr>
<tr>
<td><code>[[SetPrototypeOf]]</code></td>
<td><code>setPrototypeOf</code></td>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf">Object.setPrototypeOf</a></td>
</tr>
<tr>
<td><code>[[IsExtensible]]</code></td>
<td><code>isExtensible</code></td>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible">Object.isExtensible</a></td>
</tr>
<tr>
<td><code>[[PreventExtensions]]</code></td>
<td><code>preventExtensions</code></td>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions">Object.preventExtensions</a></td>
</tr>
<tr>
<td><code>[[DefineOwnProperty]]</code></td>
<td><code>defineProperty</code></td>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties">Object.defineProperties</a></td>
</tr>
<tr>
<td><code>[[GetOwnProperty]]</code></td>
<td><code>getOwnPropertyDescriptor</code></td>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor">Object.getOwnPropertyDescriptor</a>, <code>for..in</code>, <code>Object.keys/values/entries</code></td>
</tr>
<tr>
<td><code>[[OwnPropertyKeys]]</code></td>
<td><code>ownKeys</code></td>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames">Object.getOwnPropertyNames</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols">Object.getOwnPropertySymbols</a>, <code>for..in</code>, <code>Object/keys/values/entries</code></td>
</tr>
</tbody></table>
<pre><code class="language-warn">JavaScript 强制执行某些不变量 — 内部方法和捕捉器必须满足的条件。

其中大多数用于返回值：
- `[[Set]]` 如果值已成功写入，则必须返回 `true`，否则返回 `false`。
- `[[Delete]]` 如果已成功删除该值，则必须返回 `true`，否则返回 `false`。
- ……依此类推，我们将在下面的示例中看到更多内容。

还有其他一些不变量，例如：
- 应用于代理（proxy）对象的 `[[GetPrototypeOf]]`，必须返回与应用于被代理对象的 `[[GetPrototypeOf]]` 相同的值。换句话说，读取代理对象的原型必须始终返回被代理对象的原型。

捕捉器可以拦截这些操作，但是必须遵循下面这些规则。

不变量确保语言功能的正确和一致的行为。完整的不变量列表在 [规范](https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots) 中。如果你不做奇怪的事情，你可能就不会违反它们。</code></pre>
<p>让我们来看看它们是如何在实际示例中工作的。</p>
<h2 id="带有-get-捕捉器的默认值">带有 &quot;get&quot; 捕捉器的默认值</h2>
<p>最常见的捕捉器是用于读取/写入的属性。</p>
<p>要拦截读取操作，<code>handler</code> 应该有 <code>get(target, property, receiver)</code> 方法。</p>
<p>读取属性时触发该方法，参数如下：</p>
<ul>
<li><code>target</code> —— 是目标对象，该对象被作为第一个参数传递给 <code>new Proxy</code>，</li>
<li><code>property</code> —— 目标属性名，</li>
<li><code>receiver</code> —— 如果目标属性是一个 getter 访问器属性，则 <code>receiver</code> 就是本次读取属性所在的 <code>this</code> 对象。通常，这就是 <code>proxy</code> 对象本身（或者，如果我们从 proxy 继承，则是从该 proxy 继承的对象）。现在我们不需要此参数，因此稍后我们将对其进行详细介绍。</li>
</ul>
<p>让我们用 <code>get</code> 来实现一个对象的默认值。</p>
<p>我们将创建一个对不存在的数组项返回 <code>0</code> 的数组。</p>
<p>通常，当人们尝试获取不存在的数组项时，他们会得到 <code>undefined</code>，但是我们在这将常规数组包装到代理（proxy）中，以捕获读取操作，并在没有要读取的属性的时返回 <code>0</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> numbers = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];

numbers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(numbers, {
  get(target, prop) {
    <span class="hljs-keyword">if</span> (prop <span class="hljs-keyword">in</span> target) {
      <span class="hljs-keyword">return</span> target[prop];
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 默认值</span>
    }
  }
});

*!*
alert( numbers[<span class="hljs-number">1</span>] ); <span class="hljs-comment">// 1</span>
alert( numbers[<span class="hljs-number">123</span>] ); <span class="hljs-comment">// 0（没有这个数组项）</span>
*/!*</code></pre>
<p>正如我们所看到的，使用 <code>get</code> 捕捉器很容易实现。</p>
<p>我们可以用 <code>Proxy</code> 来实现“默认”值的任何逻辑。</p>
<p>想象一下，我们有一本词典，上面有短语及其翻译：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> dictionary = {
  <span class="hljs-string">&#x27;Hello&#x27;</span>: <span class="hljs-string">&#x27;Hola&#x27;</span>,
  <span class="hljs-string">&#x27;Bye&#x27;</span>: <span class="hljs-string">&#x27;Adiós&#x27;</span>
};

alert( dictionary[<span class="hljs-string">&#x27;Hello&#x27;</span>] ); <span class="hljs-comment">// Hola</span>
alert( dictionary[<span class="hljs-string">&#x27;Welcome&#x27;</span>] ); <span class="hljs-comment">// undefined</span></code></pre>
<p>现在，如果没有我们要读取的短语，那么从 <code>dictionary</code> 读取它将返回 <code>undefined</code>。但实际上，返回一个未翻译的短语通常比 <code>undefined</code> 要好。因此，让我们在这种情况下返回一个未翻译的短语来替代 <code>undefined</code>。</p>
<p>为此，我们将把 <code>dictionary</code> 包装进一个拦截读取操作的代理：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> dictionary = {
  <span class="hljs-string">&#x27;Hello&#x27;</span>: <span class="hljs-string">&#x27;Hola&#x27;</span>,
  <span class="hljs-string">&#x27;Bye&#x27;</span>: <span class="hljs-string">&#x27;Adiós&#x27;</span>
};

dictionary = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(dictionary, {
*!*
  get(target, phrase) { <span class="hljs-comment">// 拦截读取属性操作</span>
*/!*
    <span class="hljs-keyword">if</span> (phrase <span class="hljs-keyword">in</span> target) { <span class="hljs-comment">//如果词典中有该短语</span>
      <span class="hljs-keyword">return</span> target[phrase]; <span class="hljs-comment">// 返回其翻译</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 否则返回未翻译的短语</span>
      <span class="hljs-keyword">return</span> phrase;
    }
  }
});

<span class="hljs-comment">// 在词典中查找任意短语！</span>
<span class="hljs-comment">// 最坏的情况也只是它们没有被翻译。</span>
alert( dictionary[<span class="hljs-string">&#x27;Hello&#x27;</span>] ); <span class="hljs-comment">// Hola</span>
*!*
alert( dictionary[<span class="hljs-string">&#x27;Welcome to Proxy&#x27;</span>]); <span class="hljs-comment">// Welcome to Proxy（没有被翻译）</span>
*/!*</code></pre>
<pre><code class="language-smart">请注意代理如何覆盖变量：

```js
dictionary = new Proxy(dictionary, ...);
```

代理应该在所有地方都完全替代目标对象。目标对象被代理后，任何人都不应该再引用目标对象。否则很容易搞砸。</code></pre>
<h2 id="使用-set-捕捉器进行验证">使用 &quot;set&quot; 捕捉器进行验证</h2>
<p>假设我们想要一个专门用于数字的数组。如果添加了其他类型的值，则应该抛出一个错误。</p>
<p>当写入属性时 <code>set</code> 捕捉器被触发。</p>
<p><code>set(target, property, value, receiver)</code>：</p>
<ul>
<li><code>target</code> —— 是目标对象，该对象被作为第一个参数传递给 <code>new Proxy</code>，</li>
<li><code>property</code> —— 目标属性名称，</li>
<li><code>value</code> —— 目标属性的值，</li>
<li><code>receiver</code> —— 与 <code>get</code> 捕捉器类似，仅与 setter 访问器属性相关。</li>
</ul>
<p>如果写入操作（setting）成功，<code>set</code> 捕捉器应该返回 <code>true</code>，否则返回 <code>false</code>（触发 <code>TypeError</code>）。</p>
<p>让我们用它来验证新值：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> numbers = [];

numbers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(numbers, { <span class="hljs-comment">// (*)</span>
*!*
  set(target, prop, val) { <span class="hljs-comment">// 拦截写入属性操作</span>
*/!*
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> val == <span class="hljs-string">&#x27;number&#x27;</span>) {
      target[prop] = val;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
  }
});

numbers.push(<span class="hljs-number">1</span>); <span class="hljs-comment">// 添加成功</span>
numbers.push(<span class="hljs-number">2</span>); <span class="hljs-comment">// 添加成功</span>
alert(<span class="hljs-string">&quot;Length is: &quot;</span> + numbers.length); <span class="hljs-comment">// 2</span>

*!*
numbers.push(<span class="hljs-string">&quot;test&quot;</span>); <span class="hljs-comment">// TypeError（proxy 的 &#x27;set&#x27; 返回 false）</span>
*/!*

alert(<span class="hljs-string">&quot;This line is never reached (error in the line above)&quot;</span>);</code></pre>
<p>请注意：数组的内建方法依然有效！值被使用 <code>push</code> 方法添加到数组。当值被添加到数组后，数组的 <code>length</code> 属性会自动增加。我们的代理对象 proxy 不会破坏任何东西。</p>
<p>我们不必重写诸如 <code>push</code> 和 <code>unshift</code> 等添加元素的数组方法，就可以在其中添加检查，因为在内部它们使用代理所拦截的 <code>[[Set]]</code> 操作。</p>
<p>因此，代码简洁明了。</p>
<p>```warn header=&quot;别忘了返回 <code>true</code>&quot;
如上所述，要保持不变量。</p>
<p>对于 <code>set</code> 操作，它必须在成功写入时返回 <code>true</code>。</p>
<p>如果我们忘记这样做，或返回任何假（falsy）值，则该操作将触发 <code>TypeError</code>。</p>
<pre><code>
## 使用 &quot;ownKeys&quot; 和 &quot;getOwnPropertyDescriptor&quot; 进行迭代

`Object.keys`，`for..in` 循环和大多数其他遍历对象属性的方法都使用内部方法 `[[OwnPropertyKeys]]`（由 `ownKeys` 捕捉器拦截) 来获取属性列表。

这些方法在细节上有所不同：
- `Object.getOwnPropertyNames(obj)` 返回非 Symbol 键。
- `Object.getOwnPropertySymbols(obj)` 返回 Symbol 键。
- `Object.keys/values()` 返回带有 `enumerable` 标志的非 Symbol 键/值（属性标志在 &lt;info:property-descriptors&gt; 一章有详细讲解)。
- `for..in` 循环遍历所有带有 `enumerable` 标志的非 Symbol 键，以及原型对象的键。

……但是所有这些都从该列表开始。

在下面这个示例中，我们使用 `ownKeys` 捕捉器拦截 `for..in` 对 `user` 的遍历，并使用 `Object.keys` 和 `Object.values` 来跳过以下划线 `_` 开头的属性：

```js run
let user = {
  name: &quot;John&quot;,
  age: 30,
  _password: &quot;***&quot;
};

user = new Proxy(user, {
*!*
  ownKeys(target) {
*/!*
    return Object.keys(target).filter(key =&gt; !key.startsWith(&#x27;_&#x27;));
  }
});

// &quot;ownKeys&quot; 过滤掉了 _password
for(let key in user) alert(key); // name，然后是 age

// 对这些方法的效果相同：
alert( Object.keys(user) ); // name,age
alert( Object.values(user) ); // John,30</code></pre>
<p>到目前为止，它仍然有效。</p>
<p>尽管如此，但如果我们返回对象中不存在的键，<code>Object.keys</code> 并不会列出这些键：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = { };

user = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(user, {
*!*
  ownKeys(target) {
*/!*
    <span class="hljs-keyword">return</span> [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];
  }
});

alert( <span class="hljs-built_in">Object</span>.keys(user) ); <span class="hljs-comment">// &lt;empty&gt;</span></code></pre>
<p>为什么？原因很简单：<code>Object.keys</code> 仅返回带有 <code>enumerable</code> 标志的属性。为了检查它，该方法会对每个属性调用内部方法 <code>[[GetOwnProperty]]</code> 来获取 <a href="info:property-descriptors">它的描述符（descriptor）</a>。在这里，由于没有属性，其描述符为空，没有 <code>enumerable</code> 标志，因此它被略过。</p>
<p>为了让 <code>Object.keys</code> 返回一个属性，我们要么需要它要么存在于带有 <code>enumerable</code> 标志的对象，要么我们可以拦截对 <code>[[GetOwnProperty]]</code> 的调用（捕捉器 <code>getOwnPropertyDescriptor</code> 可以做到这一点)，并返回带有 <code>enumerable: true</code> 的描述符。</p>
<p>这是关于此的一个例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = { };

user = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(user, {
  ownKeys(target) { <span class="hljs-comment">// 一旦要获取属性列表就会被调用</span>
    <span class="hljs-keyword">return</span> [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];
  },

  getOwnPropertyDescriptor(target, prop) { <span class="hljs-comment">// 被每个属性调用</span>
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>
      <span class="hljs-comment">/* ...其他标志，可能是 &quot;value:...&quot; */</span>
    };
  }

});

alert( <span class="hljs-built_in">Object</span>.keys(user) ); <span class="hljs-comment">// a, b, c</span></code></pre>
<p>让我们再次注意：如果该属性在对象中不存在，那么我们只需要拦截 <code>[[GetOwnProperty]]</code>。</p>
<h2 id="具有-deleteproperty-和其他捕捉器的受保护属性">具有 &quot;deleteProperty&quot; 和其他捕捉器的受保护属性</h2>
<p>有一个普遍的约定，即以下划线 <code>_</code> 开头的属性和方法是内部的。不应从对象外部访问它们。</p>
<p>从技术上讲，我们也是能访问到这样的属性的：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">_password</span>: <span class="hljs-string">&quot;secret&quot;</span>
};

alert(user._password); <span class="hljs-comment">// secret</span></code></pre>
<p>让我们使用代理来防止对以 <code>_</code> 开头的属性的任何访问。</p>
<p>我们将需要以下捕捉器：</p>
<ul>
<li><code>get</code> 读取此类属性时抛出错误，</li>
<li><code>set</code> 写入属性时抛出错误，</li>
<li><code>deleteProperty</code> 删除属性时抛出错误，</li>
<li><code>ownKeys</code> 在使用 <code>for..in</code> 和像 <code>Object.keys</code> 这样的的方法时排除以 <code>_</code> 开头的属性。</li>
</ul>
<p>代码如下：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">_password</span>: <span class="hljs-string">&quot;***&quot;</span>
};

user = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(user, {
*!*
  get(target, prop) {
*/!*
    <span class="hljs-keyword">if</span> (prop.startsWith(<span class="hljs-string">&#x27;_&#x27;</span>)) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Access denied&quot;</span>);
    }
    <span class="hljs-keyword">let</span> value = target[prop];
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;function&#x27;</span>) ? value.bind(target) : value; <span class="hljs-comment">// (*)</span>
  },
*!*
  set(target, prop, val) { <span class="hljs-comment">// 拦截属性写入</span>
*/!*
    <span class="hljs-keyword">if</span> (prop.startsWith(<span class="hljs-string">&#x27;_&#x27;</span>)) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Access denied&quot;</span>);
    } <span class="hljs-keyword">else</span> {
      target[prop] = val;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
  },
*!*
  deleteProperty(target, prop) { <span class="hljs-comment">// 拦截属性删除</span>
*/!*
    <span class="hljs-keyword">if</span> (prop.startsWith(<span class="hljs-string">&#x27;_&#x27;</span>)) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;Access denied&quot;</span>);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">delete</span> target[prop];
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
  },
*!*
  ownKeys(target) { <span class="hljs-comment">// 拦截读取属性列表</span>
*/!*
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(target).filter(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> !key.startsWith(<span class="hljs-string">&#x27;_&#x27;</span>));
  }
});

<span class="hljs-comment">// &quot;get&quot; 不允许读取 _password</span>
<span class="hljs-keyword">try</span> {
  alert(user._password); <span class="hljs-comment">// Error: Access denied</span>
} <span class="hljs-keyword">catch</span>(e) { alert(e.message); }

<span class="hljs-comment">// &quot;set&quot; 不允许写入 _password</span>
<span class="hljs-keyword">try</span> {
  user._password = <span class="hljs-string">&quot;test&quot;</span>; <span class="hljs-comment">// Error: Access denied</span>
} <span class="hljs-keyword">catch</span>(e) { alert(e.message); }

<span class="hljs-comment">// &quot;deleteProperty&quot; 不允许删除 _password</span>
<span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">delete</span> user._password; <span class="hljs-comment">// Error: Access denied</span>
} <span class="hljs-keyword">catch</span>(e) { alert(e.message); }

<span class="hljs-comment">// &quot;ownKeys&quot; 将 _password 过滤出去</span>
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> user) alert(key); <span class="hljs-comment">// name</span></code></pre>
<p>请注意在 <code>(*)</code> 行中 <code>get</code> 捕捉器的重要细节：</p>
<pre><code class="language-js">get(target, prop) {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">let</span> value = target[prop];
*!*
  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;function&#x27;</span>) ? value.bind(target) : value; <span class="hljs-comment">// (*)</span>
*/!*
}</code></pre>
<p>为什么我们需要一个函数去调用 <code>value.bind(target)</code>？</p>
<p>原因是对象方法（例如 <code>user.checkPassword()</code>）必须能够访问 <code>_password</code>：</p>
<pre><code class="language-js">user = {
  <span class="hljs-comment">// ...</span>
  checkPassword(value) {
    <span class="hljs-comment">//对象方法必须能读取 _password</span>
    <span class="hljs-keyword">return</span> value === <span class="hljs-built_in">this</span>._password;
  }
}</code></pre>
<p>对 <code>user.checkPassword()</code> 的调用会调用被代理的对象 <code>user</code> 作为 <code>this</code>（点符号之前的对象会成为 <code>this</code>），因此，当它尝试访问 <code>this._password</code> 时，<code>get</code> 捕捉器将激活（在任何属性读取时，它都会被触发）并抛出错误。</p>
<p>因此，我们在 <code>(*)</code> 行中将对象方法的上下文绑定到原始对象 <code>target</code>。然后，它们将来的调用将使用 <code>target</code> 作为 <code>this</code>，不会触发任何捕捉器。</p>
<p>该解决方案通常可行，但并不理想，因为一个方法可能会将未被代理的对象传递到其他地方，然后我们就会陷入困境：原始对象在哪里，被代理的对象在哪里？</p>
<p>此外，一个对象可能会被代理多次（多个代理可能会对该对象添加不同的“调整”），并且如果我们将未包装的对象传递给方法，则可能会产生意想不到的后果。</p>
<p>因此，在任何地方都不应使用这种代理。</p>
<pre><code class="language-smart">现代 JavaScript 引擎原生支持 class 中的私有属性，这些私有属性以 `#` 为前缀。它们在 &lt;info:private-protected-properties-methods&gt; 一章中有详细描述。无需代理（proxy）。

但是，此类属性有其自身的问题。特别是，它们是不可继承的。</code></pre>
<h2 id="带有-has-捕捉器-的-in-range">带有 &quot;has&quot; 捕捉器 的 &quot;in range&quot;</h2>
<p>让我们来看更多示例。</p>
<p>我们有一个 range 对象：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> range = {
  <span class="hljs-attr">start</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">end</span>: <span class="hljs-number">10</span>
};</code></pre>
<p>我们想使用 <code>in</code> 操作符来检查一个数字是否在 <code>range</code> 范围内。</p>
<p><code>has</code> 捕捉器会拦截 <code>in</code> 调用。</p>
<p><code>has(target, property)</code></p>
<ul>
<li><code>target</code> —— 是目标对象，被作为第一个参数传递给 <code>new Proxy</code>，</li>
<li><code>property</code> —— 属性名称。</li>
</ul>
<p>示例如下</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> range = {
  <span class="hljs-attr">start</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">end</span>: <span class="hljs-number">10</span>
};

range = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(range, {
*!*
  has(target, prop) {
*/!*
    <span class="hljs-keyword">return</span> prop &gt;= target.start &amp;&amp; prop &lt;= target.end;
  }
});

*!*
alert(<span class="hljs-number">5</span> <span class="hljs-keyword">in</span> range); <span class="hljs-comment">// true</span>
alert(<span class="hljs-number">50</span> <span class="hljs-keyword">in</span> range); <span class="hljs-comment">// false</span>
*/!*</code></pre>
<p>漂亮的语法糖，不是吗？而且实现起来非常简单。</p>
<h2 id="包装函数：apply-proxy-apply">包装函数：&quot;apply&quot; [#proxy-apply]</h2>
<p>我们也可以将代理（proxy）包装在函数周围。</p>
<p><code>apply(target, thisArg, args)</code> 捕捉器能使代理以函数的方式被调用：</p>
<ul>
<li><code>target</code> 是目标对象（在 JavaScript 中，函数就是一个对象），</li>
<li><code>thisArg</code> 是 <code>this</code> 的值。</li>
<li><code>args</code> 是参数列表。</li>
</ul>
<p>例如，让我们回忆一下我们在 <a href="info:call-apply-decorators">info:call-apply-decorators</a> 一章中所讲的 <code>delay(f, ms)</code> 装饰器。</p>
<p>在该章中，我们没有用 proxy 来实现它。调用 <code>delay(f, ms)</code> 会返回一个函数，该函数会在 <code>ms</code> 毫秒后把所有调用转发给 <code>f</code>。</p>
<p>这是以前的基于函数的实现：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delay</span>(<span class="hljs-params">f, ms</span>) </span>{
  <span class="hljs-comment">// 返回一个包装器（wrapper），该包装器将在时间到了的时候将调用转发给函数 f</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// (*)</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> f.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>), ms);
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params">user</span>) </span>{
  alert(<span class="hljs-string">`Hello, <span class="hljs-subst">${user}</span>!`</span>);
}

<span class="hljs-comment">// 在进行这个包装后，sayHi 函数会被延迟 3 秒后被调用</span>
sayHi = delay(sayHi, <span class="hljs-number">3000</span>);

sayHi(<span class="hljs-string">&quot;John&quot;</span>); <span class="hljs-comment">// Hello, John! (after 3 seconds)</span></code></pre>
<p>正如我们所看到的那样，大多数情况下它都是可行的。包装函数 <code>(*)</code> 在到达延迟的时间后后执行调用。</p>
<p>但是包装函数不会转发属性读取/写入操作或者任何其他操作。进行包装后，就失去了对原始函数属性的访问，例如 <code>name</code>，<code>length</code> 和其他属性：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delay</span>(<span class="hljs-params">f, ms</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> f.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>), ms);
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params">user</span>) </span>{
  alert(<span class="hljs-string">`Hello, <span class="hljs-subst">${user}</span>!`</span>);
}

*!*
alert(sayHi.length); <span class="hljs-comment">// 1（函数的 length 是函数声明中的参数个数）</span>
*/!*

sayHi = delay(sayHi, <span class="hljs-number">3000</span>);

*!*
alert(sayHi.length); <span class="hljs-comment">// 0（在包装器声明中，参数个数为 0)</span>
*/!*</code></pre>
<p><code>Proxy</code> 的功能要强大得多，因为它可以将所有东西转发到目标对象。</p>
<p>让我们使用 <code>Proxy</code> 来替换掉包装函数：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delay</span>(<span class="hljs-params">f, ms</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(f, {
    apply(target, thisArg, args) {
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> target.apply(thisArg, args), ms);
    }
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params">user</span>) </span>{
  alert(<span class="hljs-string">`Hello, <span class="hljs-subst">${user}</span>!`</span>);
}

sayHi = delay(sayHi, <span class="hljs-number">3000</span>);

*!*
alert(sayHi.length); <span class="hljs-comment">// 1 (*) proxy 将“获取 length”的操作转发给目标对象</span>
*/!*

sayHi(<span class="hljs-string">&quot;John&quot;</span>); <span class="hljs-comment">// Hello, John!（3 秒后）</span></code></pre>
<p>结果是相同的，但现在不仅仅调用，而且代理上的所有操作都能被转发到原始函数。所以在 <code>(*)</code> 行包装后的 <code>sayHi.length</code> 会返回正确的结果。</p>
<p>我们得到了一个“更丰富”的包装器。</p>
<p>还存在其他捕捉器：完整列表在本文的开头。它们的使用模式与上述类似。</p>
<h2 id="reflect">Reflect</h2>
<p><code>Reflect</code> 是一个内建对象，可简化 <code>Proxy</code> 的创建。</p>
<p>前面所讲过的内部方法，例如 <code>[[Get]]</code> 和 <code>[[Set]]</code> 等，都只是规范性的，不能直接调用。</p>
<p><code>Reflect</code> 对象使调用这些内部方法成为了可能。它的方法是内部方法的最小包装。</p>
<p>以下是执行相同操作和 <code>Reflect</code> 调用的示例：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th><code>Reflect</code> 调用</th>
<th>内部方法</th>
</tr>
</thead>
<tbody><tr>
<td><code>obj[prop]</code></td>
<td><code>Reflect.get(obj, prop)</code></td>
<td><code>[[Get]]</code></td>
</tr>
<tr>
<td><code>obj[prop] = value</code></td>
<td><code>Reflect.set(obj, prop, value)</code></td>
<td><code>[[Set]]</code></td>
</tr>
<tr>
<td><code>delete obj[prop]</code></td>
<td><code>Reflect.deleteProperty(obj, prop)</code></td>
<td><code>[[Delete]]</code></td>
</tr>
<tr>
<td><code>new F(value)</code></td>
<td><code>Reflect.construct(F, value)</code></td>
<td><code>[[Construct]]</code></td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
</tbody></table>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {};

<span class="hljs-built_in">Reflect</span>.set(user, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;John&#x27;</span>);

alert(user.name); <span class="hljs-comment">// John</span></code></pre>
<p>尤其是，<code>Reflect</code> 允许我们将操作符（<code>new</code>，<code>delete</code>，……）作为函数（<code>Reflect.construct</code>，<code>Reflect.deleteProperty</code>，……）执行调用。这是一个有趣的功能，但是这里还有一点很重要。</p>
<p><strong>对于每个可被 <code>Proxy</code> 捕获的内部方法，在 <code>Reflect</code> 中都有一个对应的方法，其名称和参数与 <code>Proxy</code> 捕捉器相同。</strong></p>
<p>所以，我们可以使用 <code>Reflect</code> 来将操作转发给原始对象。</p>
<p>在下面这个示例中，捕捉器 <code>get</code> 和 <code>set</code> 均透明地（好像它们都不存在一样）将读取/写入操作转发到对象，并显示一条消息：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,
};

user = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(user, {
  get(target, prop, receiver) {
    alert(<span class="hljs-string">`GET <span class="hljs-subst">${prop}</span>`</span>);
*!*
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, prop, receiver); <span class="hljs-comment">// (1)</span>
*/!*
  },
  set(target, prop, val, receiver) {
    alert(<span class="hljs-string">`SET <span class="hljs-subst">${prop}</span>=<span class="hljs-subst">${val}</span>`</span>);
*!*
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.set(target, prop, val, receiver); <span class="hljs-comment">// (2)</span>
*/!*
  }
});

<span class="hljs-keyword">let</span> name = user.name; <span class="hljs-comment">// 显示 &quot;GET name&quot;</span>
user.name = <span class="hljs-string">&quot;Pete&quot;</span>; <span class="hljs-comment">// 显示 &quot;SET name=Pete&quot;</span></code></pre>
<p>这里：</p>
<ul>
<li><code>Reflect.get</code> 读取一个对象属性。</li>
<li><code>Reflect.set</code> 写入一个对象属性，如果写入成功则返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ul>
<p>这样，一切都很简单：如果一个捕捉器想要将调用转发给对象，则只需使用相同的参数调用 <code>Reflect.&lt;method&gt;</code> 就足够了。</p>
<p>在大多数情况下，我们可以不使用 <code>Reflect</code> 完成相同的事情，例如，用于读取属性的 <code>Reflect.get(target, prop, receiver)</code> 可以被替换为 <code>target[prop]</code>。尽管有一些细微的差别。</p>
<h3 id="代理一个-getter">代理一个 getter</h3>
<p>让我们看一个示例，来说明为什么 <code>Reflect.get</code> 更好。此外，我们还将看到为什么 <code>get/set</code> 有第三个参数 <code>receiver</code>，而且我们之前从来没有使用过它。</p>
<p>我们有一个带有 <code>_name</code> 属性和 getter 的对象 <code>user</code>。</p>
<p>这是对 <code>user</code> 对象对一个代理（proxy）：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">_name</span>: <span class="hljs-string">&quot;Guest&quot;</span>,
  <span class="hljs-keyword">get</span> <span class="hljs-title">name</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._name;
  }
};

*!*
<span class="hljs-keyword">let</span> userProxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(user, {
  get(target, prop, receiver) {
    <span class="hljs-keyword">return</span> target[prop];
  }
});
*/!*

alert(userProxy.name); <span class="hljs-comment">// Guest</span></code></pre>
<p>其 <code>get</code> 捕捉器在这里是“透明的”，它返回原来的属性，不会做任何其他的事。这对于我们的示例而言就足够了。</p>
<p>一切似乎都很好。但是让我们将示例变得稍微复杂一点。</p>
<p>另一个对象 <code>admin</code> 从 <code>user</code> 继承后，我们可以观察到错误的行为：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">_name</span>: <span class="hljs-string">&quot;Guest&quot;</span>,
  <span class="hljs-keyword">get</span> <span class="hljs-title">name</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._name;
  }
};

<span class="hljs-keyword">let</span> userProxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(user, {
  get(target, prop, receiver) {
    <span class="hljs-keyword">return</span> target[prop]; <span class="hljs-comment">// (*) target = user</span>
  }
});

*!*
<span class="hljs-keyword">let</span> admin = {
  <span class="hljs-attr">__proto__</span>: userProxy,
  <span class="hljs-attr">_name</span>: <span class="hljs-string">&quot;Admin&quot;</span>
};

<span class="hljs-comment">// 期望输出：Admin</span>
alert(admin.name); <span class="hljs-comment">// 输出：Guest (?!?)</span>
*/!*</code></pre>
<p>读取 <code>admin.name</code> 应该返回 <code>&quot;Admin&quot;</code>，而不是 <code>&quot;Guest&quot;</code>！</p>
<p>发生了什么？或许我们在继承方面做错了什么？</p>
<p>但是，如果我们移除代理，那么一切都会按预期进行。</p>
<p>问题实际上出在代理中，在 <code>(*)</code> 行。</p>
<ol>
<li><p>当我们读取 <code>admin.name</code> 时，由于 <code>admin</code> 对象自身没有对应的的属性，搜索将转到其原型。</p>
</li>
<li><p>原型是 <code>userProxy</code>。</p>
</li>
<li><p>从代理读取 <code>name</code> 属性时，<code>get</code> 捕捉器会被触发，并从原始对象返回 <code>target[prop]</code> 属性，在 <code>(*)</code> 行。</p>
<p> 当调用 <code>target[prop]</code> 时，若 <code>prop</code> 是一个 getter，它将在 <code>this=target</code> 上下文中运行其代码。因此，结果是来自原始对象 <code>target</code> 的 <code>this._name</code>，即来自 <code>user</code>。</p>
</li>
</ol>
<p>为了解决这种情况，我们需要 <code>get</code> 捕捉器的第三个参数 <code>receiver</code>。它保证将正确的 <code>this</code> 传递给 getter。在我们的例子中是 <code>admin</code>。</p>
<p>如何把上下文传递给 getter？对于一个常规函数，我们可以使用 <code>call/apply</code>，但这是一个 getter，它不能“被调用”，只能被访问。</p>
<p><code>Reflect.get</code> 可以做到。如果我们使用它，一切都会正常运行。</p>
<p>这是更正后的变体：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> user = {
  <span class="hljs-attr">_name</span>: <span class="hljs-string">&quot;Guest&quot;</span>,
  <span class="hljs-keyword">get</span> <span class="hljs-title">name</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._name;
  }
};

<span class="hljs-keyword">let</span> userProxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(user, {
  get(target, prop, receiver) { <span class="hljs-comment">// receiver = admin</span>
*!*
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, prop, receiver); <span class="hljs-comment">// (*)</span>
*/!*
  }
});


<span class="hljs-keyword">let</span> admin = {
  <span class="hljs-attr">__proto__</span>: userProxy,
  <span class="hljs-attr">_name</span>: <span class="hljs-string">&quot;Admin&quot;</span>
};

*!*
alert(admin.name); <span class="hljs-comment">// Admin</span>
*/!*</code></pre>
<p>现在 <code>receiver</code> 保留了对正确 <code>this</code> 的引用（即 <code>admin</code>），该引用是在 <code>(*)</code> 行中被通过 <code>Reflect.get</code> 传递给 getter 的。</p>
<p>我们可以把捕捉器重写得更短：</p>
<pre><code class="language-js">get(target, prop, receiver) {
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(*!*...arguments*/!*);
}</code></pre>
<p><code>Reflect</code> 调用的命名与捕捉器的命名完全相同，并且接受相同的参数。它们是以这种方式专门设计的。</p>
<p>因此，<code>return Reflect...</code> 提供了一个安全的方式，可以轻松地转发操作，并确保我们不会忘记与此相关的任何内容。</p>
<h2 id="proxy-的局限性">Proxy 的局限性</h2>
<p>代理提供了一种独特的方法，可以在最底层更改或调整现有对象的行为。但是，它并不完美。有局限性。</p>
<h3 id="内建对象：内部插槽（internal-slot）">内建对象：内部插槽（Internal slot）</h3>
<p>许多内建对象，例如 <code>Map</code>，<code>Set</code>，<code>Date</code>，<code>Promise</code> 等，都使用了所谓的“内部插槽”。</p>
<p>它们类似于属性，但仅限于内部使用，仅用于规范目的。例如，<code>Map</code> 将项目（item）存储在 <code>[[MapData]]</code> 中。内建方法可以直接访问它们，而不通过 <code>[[Get]]/[[Set]]</code> 内部方法。所以 <code>Proxy</code> 无法拦截它们。</p>
<p>为什么要在意这些呢？毕竟它们是内部的！</p>
<p>好吧，问题在这儿。在类似这样的内建对象被代理后，代理对象没有这些内部插槽，因此内建方法将会失败。</p>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

<span class="hljs-keyword">let</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(map, {});

*!*
proxy.set(<span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// Error</span>
*/!*</code></pre>
<p>在内部，一个 <code>Map</code> 将所有数据存储在其 <code>[[MapData]]</code> 内部插槽中。代理对象没有这样的插槽。<a href="https://tc39.es/ecma262/#sec-map.prototype.set">内建方法 <code>Map.prototype.set</code></a> 方法试图访问内部属性 <code>this.[[MapData]]</code>，但由于 <code>this=proxy</code>，在 <code>proxy</code> 中无法找到它，只能失败。</p>
<p>幸运的是，这儿有一种解决方法：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

<span class="hljs-keyword">let</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(map, {
  get(target, prop, receiver) {
    <span class="hljs-keyword">let</span> value = <span class="hljs-built_in">Reflect</span>.get(...arguments);
*!*
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value == <span class="hljs-string">&#x27;function&#x27;</span> ? value.bind(target) : value;
*/!*
  }
});

proxy.set(<span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-number">1</span>);
alert(proxy.get(<span class="hljs-string">&#x27;test&#x27;</span>)); <span class="hljs-comment">// 1（工作了！）</span></code></pre>
<p>现在它正常工作了，因为 <code>get</code> 捕捉器将函数属性（例如 <code>map.set</code>）绑定到了目标对象（<code>map</code>）本身。</p>
<p>与前面的示例不同，<code>proxy.set(...)</code> 内部 <code>this</code> 的值并不是 <code>proxy</code>，而是原始的 <code>map</code>。因此，当<code>set</code> 捕捉器的内部实现尝试访问 <code>this.[[MapData]]</code> 内部插槽时，它会成功。</p>
<p>```smart header=&quot;<code>Array</code> 没有内部插槽&quot;
一个值得注意的例外：内建 <code>Array</code> 没有使用内部插槽。那是出于历史原因，因为它出现于很久以前。</p>
<p>所以，代理数组时没有这种问题。</p>
<pre><code>
### 私有字段

类的私有字段也会发生类似的情况。

例如，`getName()` 方法访问私有的 `#name` 属性，并在代理后中断（break）：

```js run
class User {
  #name = &quot;Guest&quot;;

  getName() {
    return this.#name;
  }
}

let user = new User();

user = new Proxy(user, {});

*!*
alert(user.getName()); // Error
*/!*</code></pre>
<p>原因是私有字段是通过内部插槽实现的。JavaScript 在访问它们时不使用 <code>[[Get]]/[[Set]]</code>。</p>
<p>在调用 <code>getName()</code> 时，<code>this</code> 的值是代理后的 <code>user</code>，它没有带有私有字段的插槽。</p>
<p>再次，带有 <code>bind</code> 方法的解决方案使它恢复正常：</p>
<pre><code class="language-js">class User {
  #name = &quot;Guest&quot;;

  getName() {
    return this.#name;
  }
}

let user = new User();

user = new Proxy(user, {
  get(target, prop, receiver) {
    let value = Reflect.get(...arguments);
    return typeof value == &#x27;function&#x27; ? value.bind(target) : value;
  }
});

alert(user.getName()); // Guest</code></pre>
<p>如前所述，该解决方案也有缺点：它将原始对象暴露给该方法，可能使其进一步传递并破坏其他代理功能。</p>
<h3 id="proxy--target">Proxy != target</h3>
<p>代理和原始对象是不同的对象。这很自然，对吧？</p>
<p>所以，如果我们使用原始对象作为键，然后对其进行代理，之后却无法找到代理了：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> allUsers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
  <span class="hljs-keyword">constructor</span>(name) {
    <span class="hljs-built_in">this</span>.name = name;
    allUsers.add(<span class="hljs-built_in">this</span>);
  }
}

<span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;John&quot;</span>);

alert(allUsers.has(user)); <span class="hljs-comment">// true</span>

user = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(user, {});

*!*
alert(allUsers.has(user)); <span class="hljs-comment">// false</span>
*/!*</code></pre>
<p>如我们所见，进行代理后，我们在 <code>allUsers</code> 中找不到 <code>user</code>，因为代理是一个不同的对象。</p>
<p>```warn header=&quot;Proxy 无法拦截严格相等性检查 <code>===</code>&quot;
Proxy 可以拦截许多操作符，例如 <code>new</code>（使用 <code>construct</code>），<code>in</code>（使用 <code>has</code>），<code>delete</code>（使用 <code>deleteProperty</code>）等。</p>
<p>但是没有办法拦截对于对象的严格相等性检查。一个对象只严格等于其自身，没有其他值。</p>
<p>因此，比较对象是否相等的所有操作和内建类都会区分对象和代理。这里没有透明的替代品。</p>
<pre><code>
## 可撤销 Proxy

一个 **可撤销** 的代理是可以被禁用的代理。

假设我们有一个资源，并且想随时关闭对该资源的访问。

我们可以做的是将它包装成可一个撤销的代理，没有任何捕捉器。这样的代理会将操作转发给对象，并且我们可以随时将其禁用。

语法为：

```js
let {proxy, revoke} = Proxy.revocable(target, handler)</code></pre>
<p>该调用返回一个带有 <code>proxy</code> 和 <code>revoke</code> 函数的对象以将其禁用。</p>
<p>这是一个例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> object = {
  <span class="hljs-attr">data</span>: <span class="hljs-string">&quot;Valuable data&quot;</span>
};

<span class="hljs-keyword">let</span> {proxy, revoke} = <span class="hljs-built_in">Proxy</span>.revocable(object, {});

<span class="hljs-comment">// 将 proxy 传递到其他某处，而不是对象...</span>
alert(proxy.data); <span class="hljs-comment">// Valuable data</span>

<span class="hljs-comment">// 稍后，在我们的代码中</span>
revoke();

<span class="hljs-comment">// proxy 不再工作（revoked）</span>
alert(proxy.data); <span class="hljs-comment">// Error</span></code></pre>
<p>调用 <code>revoke()</code> 会从代理中删除对目标对象的所有内部引用，因此它们之间再无连接。之后可以对目标对象进行垃圾回收。</p>
<p>我们还可以将 <code>revoke</code> 存储在 <code>WeakMap</code> 中，以更便于通过代理对象轻松找到它：</p>
<pre><code class="language-js">*!*
<span class="hljs-keyword">let</span> revokes = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();
*/!*

<span class="hljs-keyword">let</span> object = {
  <span class="hljs-attr">data</span>: <span class="hljs-string">&quot;Valuable data&quot;</span>
};

<span class="hljs-keyword">let</span> {proxy, revoke} = <span class="hljs-built_in">Proxy</span>.revocable(object, {});

revokes.set(proxy, revoke);

<span class="hljs-comment">// ...稍后，在我们的代码中...</span>
revoke = revokes.get(proxy);
revoke();

alert(proxy.data); <span class="hljs-comment">// Error（revoked）</span></code></pre>
<p>这种方法的好处是，我们不必再随身携带 <code>revoke</code>。我们可以在有需要时通过 <code>proxy</code> 从 map 上获取它。</p>
<p>此处我们使用 <code>WeakMap</code> 而不是 <code>Map</code>，因为它不会阻止垃圾回收。如果一个代理对象变得“不可访问”（例如，没有变量再引用它），则 <code>WeakMap</code> 允许将其与它的 <code>revoke</code> 一起从内存中清除，因为我们不再需要它了。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>规范：<a href="https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots">Proxy</a>。</li>
<li>MDN：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a>。</li>
</ul>
<h2 id="总结">总结</h2>
<p><code>Proxy</code> 是对象的包装器，将代理上的操作转发到对象，并可以选择捕获其中一些操作。</p>
<p>它可以包装任何类型的对象，包括类和函数。</p>
<p>语法为：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, {
  <span class="hljs-comment">/* trap */</span>
});</code></pre>
<p>……然后，我们应该在所有地方使用 <code>proxy</code> 而不是 <code>target</code>。代理没有自己的属性或方法。如果提供了捕捉器（trap），它将捕获操作，否则会将其转发给 <code>target</code> 对象。</p>
<p>我们可以捕获：</p>
<ul>
<li>读取（<code>get</code>），写入（<code>set</code>），删除（<code>deleteProperty</code>）属性（甚至是不存在的属性）。</li>
<li>函数调用（<code>apply</code> 捕捉器）。</li>
<li><code>new</code> 操作（<code>construct</code> 捕捉器）。</li>
<li>许多其他操作（完整列表请见本文开头部分和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">docs</a>）。</li>
</ul>
<p>这使我们能够创建“虚拟”属性和方法，实现默认值，可观察对象，函数装饰器等。</p>
<p>我们还可以将对象多次包装在不同的代理中，并用多个各个方面的功能对其进行装饰。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect">Reflect</a> API 旨在补充 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a>。对于任意 <code>Proxy</code> 捕捉器，都有一个带有相同参数的 <code>Reflect</code> 调用。我们应该使用它们将调用转发给目标对象。</p>
<p>Proxy 有一些局限性：</p>
<ul>
<li>内建对象具有“内部插槽”，对这些对象的访问无法被代理。请参阅上文中的解决方法。</li>
<li>私有类字段也是如此，因为它们也是在内部使用插槽实现的。因此，代理方法的调用必须具有目标对象作为 <code>this</code> 才能访问它们。</li>
<li>对象的严格相等性检查 <code>===</code> 无法被拦截。</li>
<li>性能：基准测试（benchmark）取决于引擎，但通常使用最简单的代理访问属性所需的时间也要长几倍。实际上，这仅对某些“瓶颈”对象来说才重要。</li>
</ul>
