<h1 id="长轮询（long-polling）">长轮询（Long polling）</h1>
<p>长轮询是与服务器保持持久连接的最简单的方式，它不使用任何特定的协议，例如 WebSocket 或者 Server Sent Event。</p>
<p>它很容易实现，在很多场景下也很好用。</p>
<h2 id="常规轮询">常规轮询</h2>
<p>从服务器获取新信息的最简单的方式是定期轮询。也就是说，定期向服务器发出请求：“你好，我在这儿，你有关于我的任何信息吗？”例如，每 10 秒一次。</p>
<p>作为响应，服务器首先通知自己，客户端处于在线状态，然后 —— 发送目前为止的消息包。</p>
<p>这可行，但是也有些缺点：</p>
<ol>
<li>消息传递的延迟最多为 10 秒（两个请求之间）。</li>
<li>即使没有消息，服务器也会每隔 10 秒被请求轰炸一次，即使用户切换到其他地方或者处于休眠状态，也是如此。就性能而言，这是一个很大的负担。</li>
</ol>
<p>因此，如果我们讨论的是一个非常小的服务，那么这种方式可能可行，但总的来说，它需要改进。</p>
<h2 id="长轮询">长轮询</h2>
<p>所谓“长轮询”是轮询服务器的一种更好的方式。</p>
<p>它也很容易实现，并且可以无延迟地传递消息。</p>
<p>其流程为：</p>
<ol>
<li>请求发送到服务器。</li>
<li>服务器在有消息之前不会关闭连接。</li>
<li>当消息出现时 —— 服务器将对其请求作出响应。</li>
<li>浏览器立即发出一个新的请求。</li>
</ol>
<p>对于此方法，浏览器发出一个请求并与服务器之间建立起一个挂起的（pending）连接的情况是标准的。仅在有消息被传递时，才会重新建立连接。</p>
<p><img src="long-polling.svg" alt=""></p>
<p>如果连接丢失，可能是因为网络错误，浏览器会立即发送一个新请求。</p>
<p>实现长轮询的客户端 <code>subscribe</code> 函数的示例代码：</p>
<pre><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">subscribe</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&quot;/subscribe&quot;</span>);

  <span class="hljs-keyword">if</span> (response.status == <span class="hljs-number">502</span>) {
    <span class="hljs-comment">// 状态 502 是连接超时错误，</span>
    <span class="hljs-comment">// 连接挂起时间过长时可能会发生，</span>
    <span class="hljs-comment">// 远程服务器或代理会关闭它</span>
    <span class="hljs-comment">// 让我们重新连接</span>
    <span class="hljs-keyword">await</span> subscribe();
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (response.status != <span class="hljs-number">200</span>) {
    <span class="hljs-comment">// 一个 error —— 让我们显示它</span>
    showMessage(response.statusText);
    <span class="hljs-comment">// 一秒后重新连接</span>
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>));
    <span class="hljs-keyword">await</span> subscribe();
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 获取并显示消息</span>
    <span class="hljs-keyword">let</span> message = <span class="hljs-keyword">await</span> response.text();
    showMessage(message);
    <span class="hljs-comment">// 再次调用 subscribe() 以获取下一条消息</span>
    <span class="hljs-keyword">await</span> subscribe();
  }
}

subscribe();</code></pre>
<p>正如你所看到的，<code>subscribe</code> 函数发起了一个 <code>fetch</code>，然后等待响应，处理它，并再次调用自身。</p>
<pre><code class="language-warn">服务器架构必须能够处理许多挂起的连接。

某些服务器架构是每个连接对应一个进程。对于许多连接的情况，将会有很多进程，并且每个进程占用大量内存。因此，过多的连接会消耗掉全部内存。

使用 PHP，Ruby 语言编写的后端程序会经常遇到这个问题，但是从技术上讲，它不是语言问题，而是实现问题。大多数现代编程语言都允许实现适当的后端，但是其中一些语言比其他语言更容易实现。

使用 Node.js 写的后端通常不会出现这样的问题。</code></pre>
<h2 id="示例：聊天">示例：聊天</h2>
<p>这是一个聊天演示，你可以下载它并在本地运行（如果你熟悉 Node.js 并且可以安装模块）：</p>
<p>[codetabs src=&quot;longpoll&quot; height=500]</p>
<p>浏览器代码在 <code>browser.js</code> 中。</p>
<h2 id="使用场景">使用场景</h2>
<p>在消息很少的情况下，长轮询很有效。</p>
<p>如果消息比较频繁，那么上面描绘的请求-接收（requesting-receiving）消息的图表就会变成锯状状（saw-like）。</p>
<p>每个消息都是一个单独的请求，并带有 header，身份验证开销（authentication overhead）等。</p>
<p>因此，在这种情况下，首选另一种方法，例如：<a href="info:websocket">Websocket</a> 或 <a href="info:server-sent-events">Server Sent Events</a>。</p>
