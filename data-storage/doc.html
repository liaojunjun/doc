<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>create for ggdoc , @author sunyi</title>
    <style>
        .octicon{display:inline-block;fill:currentColor;vertical-align:text-bottom}
        .anchor{float:left;line-height:1;margin-left:-20px;padding-right:4px}
        .anchor:focus{outline:0}
        h1 .octicon-link,h2 .octicon-link,h3 .octicon-link,h4 .octicon-link,h5 .octicon-link,h6 .octicon-link{color:#1b1f23;vertical-align:middle;visibility:hidden}
        h1:hover .anchor,h2:hover .anchor,h3:hover .anchor,h4:hover .anchor,h5:hover .anchor,h6:hover .anchor{text-decoration:none}
        h1:hover .anchor .octicon-link,h2:hover .anchor .octicon-link,h3:hover .anchor .octicon-link,h4:hover .anchor .octicon-link,h5:hover .anchor .octicon-link,h6:hover .anchor .octicon-link{visibility:visible}
        h1:hover .anchor .octicon-link:before,h2:hover .anchor .octicon-link:before,h3:hover .anchor .octicon-link:before,h4:hover .anchor .octicon-link:before,h5:hover .anchor .octicon-link:before,h6:hover .anchor .octicon-link:before{width:16px;height:16px;content:" ";display:inline-block;background-image:url("data:image/svg+xml,%3Csvgxmlns='http://www.w3.org/2000/svg'viewBox='001616'version='1.1'width='16'height='16'aria-hidden='true'%3E%3Cpathfill-rule='evenodd'd='M49h1v1H4c-1.50-3-1.69-3-3.5S2.55343h4c1.45031.6933.501.41-.912.72-23.25V8.59c.58-.451-1.271-2.09C105.228.98484H4c-.980-21.22-22.5S3949zm9-3h-1v1h1c1021.2222.5S13.98121312H9c-.980-2-1.22-2-2.50-.83.42-1.641-2.09V6.25c-1.09.53-21.84-23.25C611.317.5513913h4c1.4503-1.693-3.5S14.56136z'%3E%3C/path%3E%3C/svg%3E")}
        body{-webkit-text-size-adjust:100%;line-height:1.5;color:#24292e;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji;font-size:16px;line-height:1.5;word-wrap:break-word;background-color:#e3e3ef;height:100%;width:100%;margin:0;padding:20px}
        details{display:block}
        summary{display:list-item}
        a{background-color:initial}
        a:active,a:hover{outline-width:0}
        strong{font-weight:inherit;font-weight:bolder}
        h1{font-size:2em;margin:.67em 0}
        img{border-style:none}
        code,kbd,pre{font-family:monospace,monospace;font-size:1em}
        hr{box-sizing:initial;height:0;overflow:visible}
        input{font:inherit;margin:0}
        input{overflow:visible}
        [type="checkbox"]{box-sizing:border-box;padding:0}
        *{box-sizing:border-box}
        input{font-family:inherit;font-size:inherit;line-height:inherit}
        a{color:#0366d6;text-decoration:none}
        a:hover{text-decoration:underline}
        strong{font-weight:600}
        hr{height:0;margin:15px 0;overflow:hidden;background:transparent;border:0;border-bottom:1px solid #dfe2e5}
        hr:after,hr:before{display:table;content:""}
        hr:after{clear:both}
        table{border-spacing:0;border-collapse:collapse}
        td,th{padding:0}
        details summary{cursor:pointer}
        kbd{display:inline-block;padding:3px 5px;font:11px SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;line-height:10px;color:#444d56;vertical-align:middle;background-color:#fafbfc;border:1px solid #d1d5da;border-radius:3px;box-shadow:inset 0 -1px 0 #d1d5da}
        h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:0}
        h1{font-size:32px}
        h1,h2{font-weight:600}
        h2{font-size:24px}
        h3{font-size:20px}
        h3,h4{font-weight:600}
        h4{font-size:16px}
        h5{font-size:14px}
        h5,h6{font-weight:600}
        h6{font-size:12px}
        p{margin-top:0;margin-bottom:10px}
        blockquote{margin:0}
        ol,ul{padding-left:0;margin-top:0;margin-bottom:0}
        ol ol,ul ol{list-style-type:lower-roman}
        ol ol ol,ol ul ol,ul ol ol,ul ul ol{list-style-type:lower-alpha}
        dd{margin-left:0}
        code,pre{font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:12px}
        pre{margin-top:0;margin-bottom:0}
        input::-webkit-inner-spin-button,input::-webkit-outer-spin-button{margin:0;-webkit-appearance:none;appearance:none}
        :checked+.radio-label{position:relative;z-index:1;border-color:#0366d6}
        .border{border:1px solid #e1e4e8!important}
        .border-0{border:0!important}
        .border-bottom{border-bottom:1px solid #e1e4e8!important}
        .rounded-1{border-radius:3px!important}
        .bg-white{background-color:#fff!important}
        .bg-gray-light{background-color:#fafbfc!important}
        .text-gray-light{color:#6a737d!important}
        .mb-0{margin-bottom:0!important}
        .my-2{margin-top:8px!important;margin-bottom:8px!important}
        .pl-0{padding-left:0!important}
        .py-0{padding-top:0!important;padding-bottom:0!important}
        .pl-1{padding-left:4px!important}
        .pl-2{padding-left:8px!important}
        .py-2{padding-top:8px!important;padding-bottom:8px!important}
        .pl-3,.px-3{padding-left:16px!important}
        .px-3{padding-right:16px!important}
        .pl-4{padding-left:24px!important}
        .pl-5{padding-left:32px!important}
        .pl-6{padding-left:40px!important}
        .f6{font-size:12px!important}
        .lh-condensed{line-height:1.25!important}
        .text-bold{font-weight:600!important}
        .pl-c{color:#6a737d}
        .pl-c1,.pl-s .pl-v{color:#005cc5}
        .pl-e,.pl-en{color:#6f42c1}
        .pl-s .pl-s1,.pl-smi{color:#24292e}
        .pl-ent{color:#22863a}
        .pl-k{color:#d73a49}
        .pl-pds,.pl-s,.pl-s .pl-pse .pl-s1,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre{color:#032f62}
        .pl-smw,.pl-v{color:#e36209}
        .pl-bu{color:#b31d28}
        .pl-ii{color:#fafbfc;background-color:#b31d28}
        .pl-c2{color:#fafbfc;background-color:#d73a49}
        .pl-c2:before{content:"^M"}
        .pl-sr .pl-cce{font-weight:700;color:#22863a}
        .pl-ml{color:#735c0f}
        .pl-mh,.pl-mh .pl-en,.pl-ms{font-weight:700;color:#005cc5}
        .pl-mi{font-style:italic;color:#24292e}
        .pl-mb{font-weight:700;color:#24292e}
        .pl-md{color:#b31d28;background-color:#ffeef0}
        .pl-mi1{color:#22863a;background-color:#f0fff4}
        .pl-mc{color:#e36209;background-color:#ffebda}
        .pl-mi2{color:#f6f8fa;background-color:#005cc5}
        .pl-mdr{font-weight:700;color:#6f42c1}
        .pl-ba{color:#586069}
        .pl-sg{color:#959da5}
        .pl-corl{text-decoration:underline;color:#032f62}
        .mb-0{margin-bottom:0!important}
        .my-2{margin-bottom:8px!important}
        .my-2{margin-top:8px!important}
        .pl-0{padding-left:0!important}
        .py-0{padding-top:0!important;padding-bottom:0!important}
        .pl-1{padding-left:4px!important}
        .pl-2{padding-left:8px!important}
        .py-2{padding-top:8px!important;padding-bottom:8px!important}
        .pl-3{padding-left:16px!important}
        .pl-4{padding-left:24px!important}
        .pl-5{padding-left:32px!important}
        .pl-6{padding-left:40px!important}
        .pl-7{padding-left:48px!important}
        .pl-8{padding-left:64px!important}
        .pl-9{padding-left:80px!important}
        .pl-10{padding-left:96px!important}
        .pl-11{padding-left:112px!important}
        .pl-12{padding-left:128px!important}
        hr{border-bottom-color:#eee}
        kbd{display:inline-block;padding:3px 5px;font:11px SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;line-height:10px;color:#444d56;vertical-align:middle;background-color:#fafbfc;border:1px solid #d1d5da;border-radius:3px;box-shadow:inset 0 -1px 0 #d1d5da}
        .markdown-body:after,.markdown-body:before{display:table;content:""}
        .markdown-body:after{clear:both}
        .markdown-body>:first-child{margin-top:0!important}
        .markdown-body>:last-child{margin-bottom:0!important}
        a:not([href]){color:inherit;text-decoration:none}
        blockquote,details,dl,ol,p,pre,table,ul{margin-top:0;margin-bottom:16px}
        hr{height:.25em;padding:0;margin:24px 0;background-color:#e1e4e8;border:0}
        blockquote{padding:0 1em;color:#6a737d;border-left:.25em solid #dfe2e5}
        blockquote>:first-child{margin-top:0}
        blockquote>:last-child{margin-bottom:0}
        h1,h2,h3,h4,h5,h6{margin-top:24px;margin-bottom:16px;font-weight:600;line-height:1.25}
        h1{font-size:2em}
        h1,h2{padding-bottom:.3em;border-bottom:1px solid #eaecef}
        h2{font-size:1.5em}
        h3{font-size:1.25em}
        h4{font-size:1em}
        h5{font-size:.875em}
        h6{font-size:.85em;color:#6a737d}
        ol,ul{padding-left:2em}
        ol ol,ol ul,ul ol,ul ul{margin-top:0;margin-bottom:0}
        li{word-wrap:break-all}
        li>p{margin-top:16px}
        li+li{margin-top:.25em}
        dl{padding:0}
        dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:600}
        dl dd{padding:0 16px;margin-bottom:16px}
        table{display:block;width:100%;overflow:auto}
        table th{font-weight:600}
        table td,table th{padding:6px 13px;border:1px solid #dfe2e5}
        table tr{background-color:#fff;border-top:1px solid #c6cbd1}
        table tr:nth-child(2n){background-color:#f6f8fa}
        img{max-width:100%;box-sizing:initial;background-color:#fff}
        img[align="right"]{padding-left:20px}
        img[align="left"]{padding-right:20px}
        code{padding:.2em .4em;margin:0;font-size:85%;background-color:rgba(27,31,35,0.05);border-radius:3px}
        pre{word-wrap:normal}
        pre>code{padding:0;margin:0;font-size:100%;word-break:normal;white-space:pre;background:transparent;border:0}
        .highlight{margin-bottom:16px}
        .highlight pre{margin-bottom:0;word-break:normal}
        .highlight pre,pre{padding:16px;overflow:auto;font-size:85%;line-height:1.45;background-color:#f6f8fa;border-radius:3px}
        pre code{display:inline;max-width:auto;padding:0;margin:0;overflow:visible;line-height:inherit;word-wrap:normal;background-color:initial;border:0}
        .commit-tease-sha{display:inline-block;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:90%;color:#444d56}
        .full-commit .btn-outline:not(:disabled):hover{color:#005cc5;border-color:#005cc5}
        .blob-wrapper{overflow-x:auto;overflow-y:hidden}
        .blob-wrapper-embedded{max-height:240px;overflow-y:auto}
        .blob-num{width:1%;min-width:50px;padding-right:10px;padding-left:10px;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:12px;line-height:20px;color:rgba(27,31,35,0.3);text-align:right;white-space:nowrap;vertical-align:top;cursor:pointer;user-select:none}
        .blob-num:hover{color:rgba(27,31,35,0.6)}
        .blob-num:before{content:attr(data-line-number)}
        .blob-code{position:relative;padding-right:10px;padding-left:10px;line-height:20px;vertical-align:top}
        .blob-code-inner{overflow:visible;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:12px;color:#24292e;word-wrap:normal;white-space:pre}
        .pl-token.active,.pl-token:hover{cursor:pointer;background:#ffea7f}
        .tab-size[data-tab-size="1"]{-moz-tab-size:1;tab-size:1}
        .tab-size[data-tab-size="2"]{-moz-tab-size:2;tab-size:2}
        .tab-size[data-tab-size="3"]{-moz-tab-size:3;tab-size:3}
        .tab-size[data-tab-size="4"]{-moz-tab-size:4;tab-size:4}
        .tab-size[data-tab-size="5"]{-moz-tab-size:5;tab-size:5}
        .tab-size[data-tab-size="6"]{-moz-tab-size:6;tab-size:6}
        .tab-size[data-tab-size="7"]{-moz-tab-size:7;tab-size:7}
        .tab-size[data-tab-size="8"]{-moz-tab-size:8;tab-size:8}
        .tab-size[data-tab-size="9"]{-moz-tab-size:9;tab-size:9}
        .tab-size[data-tab-size="10"]{-moz-tab-size:10;tab-size:10}
        .tab-size[data-tab-size="11"]{-moz-tab-size:11;tab-size:11}
        .tab-size[data-tab-size="12"]{-moz-tab-size:12;tab-size:12}
        .task-list-item{list-style-type:none}
        .task-list-item+.task-list-item{margin-top:3px}
        .task-list-item input{margin:0 .2em .25em -1.6em;vertical-align:middle}
        #page{width:calc(100% - 500px);margin-left:500px;overflow: hidden;}
        fieldset{display:none;background-color:#fff;border:0;overflow:hidden;box-shadow:2px 2px 10px rgba(128,128,128,0.2);margin-bottom:20px;padding:20px}
        fieldset legend{font-weight:bold;color:green;height:3.5em;margin-left:-20px;padding:0}
        #nav{background:rgb(255 255 255 / .7);padding:20px 10px 100px 20px;position:fixed;top:0;left:0;bottom:0;width:500px;overflow-y:auto;overflow-x: hidden;white-space:nowrap}
        ::-webkit-scrollbar{width:5px}
        ::-webkit-scrollbar-thumb{background-color:#79a5e8}
        @media print,(max-width:900px){
          #nav{display:none!important}
          #page{width:100%!important;margin-left:0!important}
          fieldset{padding-top: 0 !important;padding-bottom: 0 !important;display:block!important;box-shadow:none!important}
          .toggle-hash-btn {display: none !important;}
        }
        .hljs{display:block;overflow-x:auto;padding:.5em;color:#333;background:#f8f8f8}
        .hljs-comment,.hljs-quote{color:#998;font-style:italic}
        .hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:bold}
        .hljs-number,.hljs-literal,.hljs-variable,.hljs-template-variable,.hljs-tag .hljs-attr{color:#008080}
        .hljs-string,.hljs-doctag{color:#d14}
        .hljs-title,.hljs-section,.hljs-selector-id{color:#900;font-weight:bold}
        .hljs-subst{font-weight:normal}
        .hljs-type,.hljs-class .hljs-title{color:#458;font-weight:bold}
        .hljs-tag,.hljs-name,.hljs-attribute{color:#000080;font-weight:normal}
        .hljs-regexp,.hljs-link{color:#009926}
        .hljs-symbol,.hljs-bullet{color:#990073}
        .hljs-built_in,.hljs-builtin-name{color:#0086b3}
        .hljs-meta{color:#999;font-weight:bold}
        .hljs-deletion{background:#fdd}
        .hljs-addition{background:#dfd}
        .hljs-emphasis{font-style:italic}
        .hljs-strong{font-weight:bold}
        .toggle-hash-btn {position: fixed;bottom: 10px;left:10px;z-index: 1000; display: flex; justify-content: space-between;  width: 270px;}
        iframe {border: 5px solid #999;margin:10px;width: 90%;min-height: 50px;}
    </style>
    <script>
          const $ = selector => document.querySelector(selector);
          const $$ = selector => document.querySelectorAll(selector);
          const decode = s => decodeURIComponent(s);
          const domInfo = dom => ({
            offsetParent: dom.offsetParent.className,
            offsetLeft: dom.offsetLeft,
            offsetTop: dom.offsetTop,
            clientWidth: dom.clientWidth,
            offsetWidth: dom.offsetWidth,
            BoundingClientRect: dom.getBoundingClientRect(),
          });
          let openHash = false;
          function viewFieldset() {
            const hash = decode(location.hash);
            if(openHash && hash &&$(`fieldset${hash}`)) {
              Array.from($$('fieldset')).forEach(dom  =>dom.style.display = 'none');
              $(`fieldset${hash}`).style.display = 'block';
            }else {
              Array.from($$('fieldset')).forEach(dom  =>dom.style.display = 'block');
            }
          }
          window.onhashchange = viewFieldset;
          window.onload  = ()=>{
            viewFieldset();
            setATarget();
            loadIframe();
          };
          
          function toggleHash() {
            openHash = !openHash;
            viewFieldset();
            $('.toggle-hash-btn button').innerText = openHash ? '关闭专注模式' : '开启专注模式';
          }
          function setATarget() {
            $$('#page a').forEach(a=>a.target = '_blank');
          }
          function elementInViewport(el) {
            if (el instanceof Element) {
              const { top, left, width, height } = el.getBoundingClientRect();
              const { innerHeight, innerWidth } = window;
              return (
                top + height >= 0 &&
                left + width >= 0 &&
                top <= innerHeight &&
                left <= innerWidth
              );
            }
            return false;
          }
          function loadIframe() {
            const query = "data-src";
            const frames = Array.from($$(`iframe[${query}]`));

            const load = (item) => {
              frames.splice(
                frames.findIndex((v) => v === item),
                1
              );
              item.src = item.getAttribute(query);
              item.removeAttribute(query);
            };
            const processScroll = () => {
              frames.forEach((item) => {
                if (elementInViewport(item)) {
                  load(item);
                }
              });
            };
            processScroll();
            window.addEventListener("scroll", processScroll, false);
            window.removeEventListener("beforeunload", processScroll, false);
          }
    </script>
</head>

<body>
  <div class="toggle-hash-btn">
    <button  onclick="toggleHash()">开启专注模式</button>
  </div><div id="page">
      <fieldset id='_WpRe9A'>
      <legend>cookie</legend>
      <p>Cookie 是直接存储在浏览器中的一小串数据。它们是 HTTP 协议的一部分，由 <a href="https://tools.ietf.org/html/rfc6265">RFC 6265</a> 规范定义。</p>
<p>Cookie 通常是由 Web 服务器使用响应 <code>Set-Cookie</code> HTTP-header 设置的。然后浏览器使用 <code>Cookie</code> HTTP-header 将它们自动添加到（几乎）每个对相同域的请求中。</p>
<p>最常见的用处之一就是身份验证：</p>
<ol>
<li>登录后，服务器在响应中使用 <code>Set-Cookie</code> HTTP-header 来设置具有唯一“会话标识符（session identifier）”的 cookie。</li>
<li>下次如果请求是由相同域发起的，浏览器会使用 <code>Cookie</code> HTTP-header 通过网络发送 cookie。</li>
<li>所以服务器知道是谁发起了请求。</li>
</ol>
<p>我们还可以使用 <code>document.cookie</code> 属性从浏览器访问 cookie。</p>
<h2 id="从-documentcookie-中读取">从 document.cookie 中读取</h2>
<pre><code class="language-js">alert(<span class="hljs-built_in">document</span>.cookie); <span class="hljs-comment">// cookie1=value1; cookie2=value2;...</span></code></pre>
<p><code>document.cookie</code> 的值由 <code>name=value</code> 对组成，以 <code>; </code> 分隔。每一个都是独立的 cookie。</p>
<p>为了找到一个特定的 cookie，我们可以以 <code>; </code> 作为分隔，将 <code>document.cookie</code> 分开，然后找到对应的名字。我们可以使用正则表达式或者数组函数来实现。</p>
<h2 id="写入-documentcookie">写入 document.cookie</h2>
<p>我们可以写入 <code>document.cookie</code>。但这不是一个数据属性，它是一个访问器（getter/setter）。对其的赋值操作会被特殊处理。</p>
<p><strong>对 <code>document.cookie</code> 的写入操作只会更新其中提到的 cookie，而不会涉及其他 cookie。</strong></p>
<p>例如，此调用设置了一个名称为 <code>user</code> 且值为 <code>John</code> 的 cookie：</p>
<pre><code class="language-js"><span class="hljs-built_in">document</span>.cookie = <span class="hljs-string">&quot;user=John&quot;</span>; <span class="hljs-comment">// 只会更新名称为 user 的 cookie</span>
alert(<span class="hljs-built_in">document</span>.cookie); <span class="hljs-comment">// 展示所有 cookie</span></code></pre>
<p>如果你运行了上面这段代码，你会看到多个 cookie。这是因为 <code>document.cookie=</code> 操作不是重写整所有 cookie。它只设置代码中提到的 cookie <code>user</code>。</p>
<p>从技术上讲，cookie 的名称和值可以是任何字符，为了保持有效的格式，它们应该使用内建的 <code>encodeURIComponent</code> 函数对其进行转义：</p>
<pre><code class="language-js"><span class="hljs-comment">// 特殊字符（空格），需要编码</span>
<span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;my name&quot;</span>;
<span class="hljs-keyword">let</span> value = <span class="hljs-string">&quot;John Smith&quot;</span>;

<span class="hljs-comment">// 将 cookie 编码为 my%20name=John%20Smith</span>
<span class="hljs-built_in">document</span>.cookie = <span class="hljs-built_in">encodeURIComponent</span>(name) + <span class="hljs-string">&quot;=&quot;</span> + <span class="hljs-built_in">encodeURIComponent</span>(value);

alert(<span class="hljs-built_in">document</span>.cookie); <span class="hljs-comment">// ...; my%20name=John%20Smith</span></code></pre>
<p>存在一些限制：</p>
<ul>
<li><code>encodeURIComponent</code> 编码后的 <code>name=value</code> 对，大小不能超过 4kb。因此，我们不能在一个 cookie 中保存大的东西。</li>
<li>每个域的 cookie 总数不得超过 20+ 左右，具体限制取决于浏览器。</li>
</ul>
<p>Cookie 有几个选项，其中很多都很重要，应该设置它。</p>
<p>选项被列在 <code>key=value</code> 之后，以 <code>;</code> 分隔，像这样：</p>
<pre><code class="language-js"><span class="hljs-built_in">document</span>.cookie = <span class="hljs-string">&quot;user=John; path=/; expires=Tue, 19 Jan 2038 03:14:07 GMT&quot;</span>;</code></pre>
<h2 id="path">path</h2>
<ul>
<li><strong><code>path=/mypath</code></strong></li>
</ul>
<p>url 路径前缀，该路径下的页面可以访问该 cookie。必须是绝对路径。默认为当前路径。</p>
<p>如果一个 cookie 带有 <code>path=/admin</code> 设置，那么该 cookie 在 <code>/admin</code> 和 <code>/admin/something</code> 下都是可见的，但是在 <code>/home</code> 或 <code>/adminpage</code> 下不可见。</p>
<p>通常，我们应该将 <code>path</code> 设置为根目录：<code>path=/</code>，以使 cookie 对此网站的所有页面可见。</p>
<h2 id="domain">domain</h2>
<ul>
<li><strong><code>domain=site.com</code></strong></li>
</ul>
<p>可访问 cookie 的域。但是在实际中，有一些限制。我们无法设置任何域。</p>
<p>默认情况下，cookie 只有在设置的域下才能被访问到。所以，如果 cookie 设置在 <code>site.com</code> 下，我们在 <code>other.com</code> 下就无法获取它。</p>
<p>……但是棘手的是，我们在子域 <code>forum.site.com</code> 下也无法获取它！</p>
<pre><code class="language-js"><span class="hljs-comment">// 在 site.com</span>
<span class="hljs-built_in">document</span>.cookie = <span class="hljs-string">&quot;user=John&quot;</span>;

<span class="hljs-comment">// 在 forum.site.com</span>
alert(<span class="hljs-built_in">document</span>.cookie); <span class="hljs-comment">// 没有 user</span></code></pre>
<p><strong>无法使 cookie 可以被从另一个二级域访问，因此，<code>other.com</code> 将永远不会收到设置在 <code>site.com</code> 的 cookie。</strong></p>
<p>这是一项安全限制，为了允许我们可以将敏感信息保存在 cookie 中。</p>
<p>……但是，如果我们想要批准像 <code>forum.site.com</code> 这样的子域访问 cookie，这是可以做到的。当我们设置一个在 <code>site.com</code> 的 cookie 时，我们应该将 <code>domain</code> 选项显式地设置为根域：<code>domain=site.com</code>：</p>
<pre><code class="language-js"><span class="hljs-comment">// 在 site.com</span>
<span class="hljs-comment">// 使 cookie 可以被在任何子域 *.site.com 访问：</span>
<span class="hljs-built_in">document</span>.cookie = <span class="hljs-string">&quot;user=John; domain=site.com&quot;</span>;

<span class="hljs-comment">// 之后</span>

<span class="hljs-comment">// 在 forum.site.com</span>
alert(<span class="hljs-built_in">document</span>.cookie); <span class="hljs-comment">// 有 cookie user=John</span></code></pre>
<p>出于历史原因，<code>domain=.site.com</code>（<code>site.com</code> 前面有一个点符号）也以相同的方式工作，允许从子域访问 cookie。这是一个旧的表示法，如果我们需要支持非常旧的浏览器，则应该使用它。</p>
<p>所以，<code>domain</code> 选项允许设置一个可以在子域访问的 cookie。</p>
<h2 id="expires，max-age">expires，max-age</h2>
<p>默认情况下，如果一个 cookie 没有设置这两个参数中的任何一个，那么在关闭浏览器之后，它就会消失。此类 cookie 被称为 &quot;session cookie”。</p>
<p>为了让 cookie 在浏览器关闭后仍然存在，我们可以设置 <code>expires</code> 或 <code>max-age</code> 选项中的一个。</p>
<ul>
<li><strong><code>expires=Tue, 19 Jan 2038 03:14:07 GMT</code></strong></li>
</ul>
<p>cookie 的到期日期，那时浏览器会自动删除它。</p>
<p>日期必须完全采用 GMT 时区的这种格式。我们可以使用 <code>date.toUTCString</code> 来获取它。例如，我们可以将 cookie 设置为 1 天后过期。</p>
<pre><code class="language-js"><span class="hljs-comment">// 当前时间 +1 天</span>
<span class="hljs-keyword">let</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-built_in">Date</span>.now() + <span class="hljs-number">86400e3</span>);
date = date.toUTCString();
<span class="hljs-built_in">document</span>.cookie = <span class="hljs-string">&quot;user=John; expires=&quot;</span> + date;</code></pre>
<p>如果我们将 <code>expires</code> 设置为过去的时间，则 cookie 会被删除。</p>
<ul>
<li><strong><code>max-age=3600</code></strong></li>
</ul>
<p><code>expires</code> 的替代选项，具指明 cookie 的过期时间距离当前时间的秒数。</p>
<p>如果为 0 或负数，则 cookie 会被删除：</p>
<pre><code class="language-js"><span class="hljs-comment">// cookie 会在一小时后失效</span>
<span class="hljs-built_in">document</span>.cookie = <span class="hljs-string">&quot;user=John; max-age=3600&quot;</span>;

<span class="hljs-comment">// 删除 cookie（让它立即过期）</span>
<span class="hljs-built_in">document</span>.cookie = <span class="hljs-string">&quot;user=John; max-age=0&quot;</span>;</code></pre>
<h2 id="secure">secure</h2>
<ul>
<li><strong><code>secure</code></strong></li>
</ul>
<p>Cookie 应只能被通过 HTTPS 传输。</p>
<p><strong>默认情况下，如果我们在 <code>http://site.com</code> 上设置了 cookie，那么该 cookie 也会出现在 <code>https://site.com</code> 上，反之亦然。</strong></p>
<p>也就是说，cookie 是基于域的，它们不区分协议。</p>
<p>使用此选项，如果一个 cookie 是通过 <code>https://site.com</code> 设置的，那么它不会在相同域的 HTTP 环境下出现，例如 <code>http://site.com</code>。所以，如果一个 cookie 包含绝不应该通过未加密的 HTTP 协议发送的敏感内容，那么就应该设置这个选项。</p>
<pre><code class="language-js"><span class="hljs-comment">// 假设我们现在在 HTTPS 环境下</span>
<span class="hljs-comment">// 设置 cookie secure（只在 HTTPS 环境下可访问）</span>
<span class="hljs-built_in">document</span>.cookie = <span class="hljs-string">&quot;user=John; secure&quot;</span>;</code></pre>
<h2 id="samesite">samesite</h2>
<p>这是另外一个关于安全的特性。它旨在防止 XSRF（跨网站请求伪造）攻击。</p>
<p>为了了解它是如何工作的，以及何时有用，让我们看一下 XSRF 攻击。</p>
<h3 id="xsrf-攻击">XSRF 攻击</h3>
<p>想象一下，你登录了 <code>bank.com</code> 网站。此时：你有了来自该网站的身份验证 cookie。你的浏览器会在每次请求时将其发送到 <code>bank.com</code>，以便识别你，并执行所有敏感的财务上的操作。</p>
<p>现在，在另外一个窗口中浏览网页时，你不小心访问了另一个网站 <code>evil.com</code>。该网站具有向 <code>bank.com</code> 网站提交一个具有启动与黑客账户交易的字段的表单 <code>&lt;form action=&quot;https://bank.com/pay&quot;&gt;</code> 的 JavaScript 代码。</p>
<p>你每次访问 <code>bank.com</code> 时，浏览器都会发送 cookie，即使该表单是从 <code>evil.com</code> 提交过来的。因此，银行会识别你的身份，并执行真实的付款。</p>
<p>这就是“跨网站请求伪造（Cross-Site Request Forgery，简称 XSRF）”攻击。</p>
<p>当然，实际的银行会防止出现这种情况。所有由 <code>bank.com</code> 生成的表单都具有一个特殊的字段，即所谓的 “XSRF 保护 token”，恶意页面既不能生成，也不能从远程页面提取它（它可以在那里提交表单，但是无法获取数据）。并且，网站 <code>bank.com</code> 会对收到的每个表单都进行这种 token 的检查。</p>
<p>但是，实现这种防护需要花费时间：我们需要确保每个表单都具有 token 字段，并且还必须检查所有请求。</p>
<h3 id="输入-cookie-samesite-选项">输入 cookie samesite 选项</h3>
<p>Cookie 的 <code>samesite</code> 选项提供了另一种防止此类攻击的方式，（理论上）不需要要求 “XSRF 保护 token”。</p>
<p>它有两个可能的值：</p>
<ul>
<li><strong><code>samesite=strict</code>（和没有值的 <code>samesite</code> 一样)</strong></li>
</ul>
<p>如果用户来自同一网站之外，那么设置了 <code>samesite=strict</code> 的 cookie 永远不会被发送。</p>
<p>换句话说，无论用户是通过邮件链接还是从 <code>evil.com</code> 提交表单，或者进行了任何来自其他域下的操作，cookie 都不会被发送。</p>
<p>如果身份验证 cookie 具有 <code>samesite</code> 选项，那么 XSRF 攻击是没有机会成功的，因为来自 <code>evil.com</code> 的提交没有 cookie。因此，<code>bank.com</code> 将无法识别用户，也就不会继续进行付款。</p>
<p>这种保护是相当可靠的。只有来自 <code>bank.com</code> 的操作才会发送 <code>samesite</code> cookie，例如来自 <code>bank.com</code> 的另一页面的表单提交。</p>
<p>虽然，这样有一些不方便。</p>
<p>当用户通过合法的链接访问 <code>bank.com</code> 时，例如从他们自己的笔记，他们会感到惊讶，<code>bank.com</code> 无法识别他们的身份。实际上，在这种情况下不会发送 <code>samesite=strict</code> cookie。</p>
<p>我们可以通过使用两个 cookie 来解决这个问题：一个 cookie 用于“一般识别”，仅用于说 &quot;Hello, John&quot;，另一个带有 <code>samesite=strict</code> 的 cookie 用于进行数据更改的操作。这样，从网站外部来的用户会看到欢迎信息，但是支付操作必须是从银行网站启动的，这样第二个 cookie 才能被发送。</p>
<ul>
<li><strong><code>samesite=lax</code></strong></li>
</ul>
<p>一种更轻松的方法，该方法还可以防止 XSRF 攻击，并且不会破坏用户体验。</p>
<p>宽松（lax）模式，和 <code>strict</code> 模式类似，当从外部来到网站，则禁止浏览器发送 cookie，但是增加了一个例外。</p>
<p>如果以下两个条件均成立，则会发送 <code>samesite=lax</code> cookie：</p>
<ol>
<li><p>HTTP 方法是“安全的”（例如 GET 方法，而不是 POST）。</p>
<p>所有安全的 HTTP 方法详见 <a href="https://tools.ietf.org/html/rfc7231">RFC7231 规范</a>。基本上，这些都是用于读取而不是写入数据的方法。它们不得执行任何更改数据的操作。跟随链接始终是 GET，是安全的方法。</p>
</li>
<li><p>该操作执行顶级导航（更改浏览器地址栏中的 URL）。</p>
<p>这通常是成立的，但是如果导航是在一个 <code>&lt;iframe&gt;</code> 中执行的，那么它就不是顶级的。此外，用于网络请求的 JavaScript 方法不会执行任何导航，因此它们不适合。</p>
</li>
</ol>
<p>所以，<code>samesite=lax</code> 所做的是基本上允许最常见的“去往 URL”操作具有 cookie。例如，从笔记本中打开网站链接就满足这些条件。</p>
<p>但是，任何更复杂的事儿，例如来自另一个网站的网络请求或表单提交都会丢失 cookie。</p>
<p>如果这种情况适合你，那么添加 <code>samesite=lax</code> 将不会破坏用户体验并且可以增加保护。</p>
<p>总体而言，<code>samesite</code> 是一个很好的选项，但是它有一个重要的缺点：</p>
<ul>
<li><code>samesite</code> 会被到 2017 年左右的旧版本浏览器忽略（不兼容）。</li>
</ul>
<p><strong>因此，如果我们仅依靠 <code>samesite</code> 提供保护，那么在旧版本的浏览器上将很容易受到攻击。</strong></p>
<p>但是，我们肯定可以将 <code>samesite</code> 与其他保护措施（例如 XSRF token）一起使用，例如 xsrf token，这样可以多增加一层保护，将来，当旧版本的浏览器淘汰时，我们可能就可以删除 xsrf token 这种方式了。</p>
<h2 id="httponly">httpOnly</h2>
<p>这个选项和 JavaScript 没有关系，但是我们必须为了完整性也提一下它。</p>
<p>Web 服务器使用 <code>Set-Cookie</code> header 来设置 cookie。并且，它可以设置 <code>httpOnly</code> 选项。</p>
<p>这个选项禁止任何 JavaScript 访问 cookie。我们使用 <code>document.cookie</code> 看不到此类 cookie，也无法对此类 cookie 进行操作。</p>
<p>这是一种预防措施，当黑客将自己的 JavaScript 代码注入网页，并等待用户访问该页面时发起攻击，而这个选项可以防止此时的这种攻击。这应该是不可能发生的，黑客应该无法将他们的代码注入我们的网站，但是网站有可能存在 bug，使得黑客能够实现这样的操作。</p>
<p>通常来说，如果发生了这种情况，并且用户访问了带有黑客 JavaScript 代码的页面，黑客代码将执行并通过 <code>document.cookie</code> 获取到包含用户身份验证信息的 cookie。这就很糟糕了。</p>
<p>但是，如果 cookie 设置了 <code>httpOnly</code>，那么 <code>document.cookie</code> 则看不到 cookie，所以它受到了保护。</p>
<h3 id="getcookiename">getCookie(name)</h3>
<p>获取 cookie 最简短的方式是使用 <a href="info:regular-expressions">正则表达式</a>。</p>
<p><code>getCookie(name)</code> 函数返回具有给定 <code>name</code> 的 cookie：</p>
<pre><code class="language-js"><span class="hljs-comment">// 返回具有给定 name 的 cookie，</span>
<span class="hljs-comment">// 如果没找到，则返回 undefined</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCookie</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">let</span> matches = <span class="hljs-built_in">document</span>.cookie.match(
    <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(
      <span class="hljs-string">&quot;(?:^|; )&quot;</span> +
        name.replace(<span class="hljs-regexp">/([\.$?*|{}\(\)\[\]\\\/\+^])/g</span>, <span class="hljs-string">&quot;\\$1&quot;</span>) +
        <span class="hljs-string">&quot;=([^;]*)&quot;</span>
    )
  );
  <span class="hljs-keyword">return</span> matches ? <span class="hljs-built_in">decodeURIComponent</span>(matches[<span class="hljs-number">1</span>]) : <span class="hljs-literal">undefined</span>;
}</code></pre>
<p>这里的 <code>new RegExp</code> 是动态生成的，以匹配 <code>; name=&lt;value&gt;</code>。</p>
<p>请注意 cookie 的值是经过编码的，所以 <code>getCookie</code> 使用了内建方法 <code>decodeURIComponent</code> 函数对其进行解码。</p>
<h3 id="setcookiename-value-options">setCookie(name, value, options)</h3>
<p>将 cookie <code>name</code> 设置为具有默认值 <code>path=/</code>（可以修改以添加其他默认值）和给定值 <code>value</code>：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setCookie</span>(<span class="hljs-params">name, value, options = {}</span>) </span>{
  options = {
    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/&quot;</span>,
    <span class="hljs-comment">// 如果需要，可以在这里添加其他默认值</span>
    ...options,
  };

  <span class="hljs-keyword">if</span> (options.expires <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span>) {
    options.expires = options.expires.toUTCString();
  }

  <span class="hljs-keyword">let</span> updatedCookie =
    <span class="hljs-built_in">encodeURIComponent</span>(name) + <span class="hljs-string">&quot;=&quot;</span> + <span class="hljs-built_in">encodeURIComponent</span>(value);

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> optionKey <span class="hljs-keyword">in</span> options) {
    updatedCookie += <span class="hljs-string">&quot;; &quot;</span> + optionKey;
    <span class="hljs-keyword">let</span> optionValue = options[optionKey];
    <span class="hljs-keyword">if</span> (optionValue !== <span class="hljs-literal">true</span>) {
      updatedCookie += <span class="hljs-string">&quot;=&quot;</span> + optionValue;
    }
  }

  <span class="hljs-built_in">document</span>.cookie = updatedCookie;
}

<span class="hljs-comment">// 使用范例：</span>
setCookie(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;John&quot;</span>, { <span class="hljs-attr">secure</span>: <span class="hljs-literal">true</span>, <span class="hljs-string">&quot;max-age&quot;</span>: <span class="hljs-number">3600</span> });</code></pre>
<h3 id="deletecookiename">deleteCookie(name)</h3>
<p>要删除一个 cookie，我们可以给它设置一个负的过期时间来调用它：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deleteCookie</span>(<span class="hljs-params">name</span>) </span>{
  setCookie(name, <span class="hljs-string">&quot;&quot;</span>, {
    <span class="hljs-string">&quot;max-age&quot;</span>: -<span class="hljs-number">1</span>,
  });
}</code></pre>
<p>&quot;更新或删除必须使用相同的路径和域&quot;
请注意：当我们更新或删除一个 cookie 时，我们应该使用和设置 cookie 时相同的路径和域选项。</p>

      </fieldset>
      
      <fieldset id='_uaUcId'>
      <legend>storage</legend>
      <p>Web 存储对象 <code>localStorage</code> 和 <code>sessionStorage</code> 允许我们在浏览器上保存键/值对。</p>
<p>我们已经有了 cookie。为什么还要其他存储对象呢？</p>
<ul>
<li>与 cookie 不同，Web 存储对象不会随每个请求被发送到服务器。因此，我们可以保存更多数据。大多数浏览器都允许保存至少 2MB 的数据（或更多），并且具有用于配置数据的设置。</li>
<li>还有一点和 cookie 不同，服务器无法通过 HTTP header 操纵存储对象。一切都是在 JavaScript 中完成的。</li>
<li>存储绑定到源（域/协议/端口三者）。也就是说，不同协议或子域对应不同的存储对象，它们之间无法访问彼此数据。</li>
</ul>
<p>两个存储对象都提供相同的方法和属性：</p>
<ul>
<li><code>setItem(key, value)</code> —— 存储键/值对。</li>
<li><code>getItem(key)</code> —— 按照键获取值。</li>
<li><code>removeItem(key)</code> —— 删除键及其对应的值。</li>
<li><code>clear()</code> —— 删除所有数据。</li>
<li><code>key(index)</code> —— 获取该索引下的键名。</li>
<li><code>length</code> —— 存储的内容的长度。</li>
</ul>
<p>正如你所看到的，它就像一个 <code>Map</code> 集合（<code>setItem/getItem/removeItem</code>），但也允许通过 <code>key(index)</code> 来按索引访问。</p>
<p>让我们看看它是如何工作的吧。</p>
<h2 id="localstorage-示例">localStorage 示例</h2>
<p><code>localStorage</code> 最主要的特点是：</p>
<ul>
<li>在同源的所有标签页和窗口之间共享数据。</li>
<li>数据不会过期。它在浏览器重启甚至系统重启后仍然存在。</li>
</ul>
<p>例如，如果你运行此代码……</p>
<pre><code class="language-js"><span class="hljs-built_in">localStorage</span>.setItem(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-number">1</span>);</code></pre>
<p>……然后关闭/重新打开浏览器，或者只是在不同的窗口打开同一页面，然后你可以这样获取它：</p>
<pre><code class="language-js">alert(<span class="hljs-built_in">localStorage</span>.getItem(<span class="hljs-string">&quot;test&quot;</span>)); <span class="hljs-comment">// 1</span></code></pre>
<p>我们只需要在同一个源（域/端口/协议），URL 路径可以不同。</p>
<p>在所有同源的窗口之间，<code>localStorage</code> 数据可以共享。因此，如果我们在一个窗口中设置了数据，则在另一个窗口中也可以看到数据变化。</p>
<h2 id="类对象形式访问">类对象形式访问</h2>
<p>我们还可以像使用一个普通对象那样，读取/设置键，像这样：</p>
<pre><code class="language-js"><span class="hljs-comment">// 设置 key</span>
<span class="hljs-built_in">localStorage</span>.test = <span class="hljs-number">2</span>;

<span class="hljs-comment">// 获取 key</span>
alert(<span class="hljs-built_in">localStorage</span>.test); <span class="hljs-comment">// 2</span>

<span class="hljs-comment">// 删除 key</span>
<span class="hljs-keyword">delete</span> <span class="hljs-built_in">localStorage</span>.test;</code></pre>
<p>这是历史原因造成的，并且大多数情况下都可行，但通常不建议这样做，因为：</p>
<ol>
<li><p>如果键是由用户生成的，那么它可以是任何内容，例如 <code>length</code> 或 <code>toString</code>，也可以是 <code>localStorage</code> 的另一种内建方法。在这种情况下，<code>getItem/setItem</code> 可以正常工作，而类对象访问的方式则会失败：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> key = <span class="hljs-string">&quot;length&quot;</span>;
<span class="hljs-built_in">localStorage</span>[key] = <span class="hljs-number">5</span>; <span class="hljs-comment">// Error，无法对 length 进行赋值</span></code></pre>
</li>
<li><p>有一个 <code>storage</code> 事件，在我们更改数据时会触发。但以类对象方式访问时，不会触发该事件。我们将在本章的后面看到。</p>
</li>
</ol>
<h2 id="遍历键">遍历键</h2>
<p>正如我们所看到的，这些方法提供了“按照键获取/设置/删除”的功能。但我们如何获取所有保存的值或键呢？</p>
<p>不幸的是，存储对象是不可迭代的。</p>
<p>一种方法是像遍历数组那样遍历它们：</p>
<pre><code class="language-js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">localStorage</span>.length; i++) {
  <span class="hljs-keyword">let</span> key = <span class="hljs-built_in">localStorage</span>.key(i);
  alert(<span class="hljs-string">`<span class="hljs-subst">${key}</span>: <span class="hljs-subst">${<span class="hljs-built_in">localStorage</span>.getItem(key)}</span>`</span>);
}</code></pre>
<p>另一个方式是使用 <code>for key in localStorage</code> 循环，就像处理常规对象一样。</p>
<p>它会遍历所有的键，但也会输出一些我们不需要的内建字段。</p>
<pre><code class="language-js"><span class="hljs-comment">// 不好的尝试</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> <span class="hljs-built_in">localStorage</span>) {
  alert(key); <span class="hljs-comment">// 显示 getItem，setItem 和其他内建的东西</span>
}</code></pre>
<p>……因此，我们需要使用 <code>hasOwnProperty</code> 检查来过滤掉原型中的字段：</p>
<pre><code class="language-js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> <span class="hljs-built_in">localStorage</span>) {
  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">localStorage</span>.hasOwnProperty(key)) {
    <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 跳过像 &quot;setItem&quot;，&quot;getItem&quot; 等这样的键</span>
  }
  alert(<span class="hljs-string">`<span class="hljs-subst">${key}</span>: <span class="hljs-subst">${<span class="hljs-built_in">localStorage</span>.getItem(key)}</span>`</span>);
}</code></pre>
<p>……或者，使用 <code>Object.keys</code> 获取只属于“自己”的键，然后如果需要，可以遍历它们：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> keys = <span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">localStorage</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> keys) {
  alert(<span class="hljs-string">`<span class="hljs-subst">${key}</span>: <span class="hljs-subst">${<span class="hljs-built_in">localStorage</span>.getItem(key)}</span>`</span>);
}</code></pre>
<p>后者有效，因为 <code>Object.keys</code> 只返回属于对象的键，会忽略原型上的。</p>
<h2 id="仅字符串">仅字符串</h2>
<p>请注意，键和值都必须是字符串。</p>
<p>如果是任何其他类型，例数字或对象，它会被自动转换为字符串。</p>
<pre><code class="language-js">sessionStorage.user = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> };
alert(sessionStorage.user); <span class="hljs-comment">// [object Object]</span></code></pre>
<p>我们可以使用 <code>JSON</code> 来存储对象：</p>
<pre><code class="language-js">sessionStorage.user = <span class="hljs-built_in">JSON</span>.stringify({ <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> });

<span class="hljs-comment">// sometime later</span>
<span class="hljs-keyword">let</span> user = <span class="hljs-built_in">JSON</span>.parse(sessionStorage.user);
alert(user.name); <span class="hljs-comment">// John</span></code></pre>
<p>也可以对整个存储对象进行字符串化处理，例如出于调试目的：</p>
<pre><code class="language-js"><span class="hljs-comment">// 为 JSON.stringify 增加了格式设置选项，以使对象看起来更美观</span>
alert(<span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-built_in">localStorage</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>));</code></pre>
<h2 id="sessionstorage">sessionStorage</h2>
<p><code>sessionStorage</code> 对象的使用频率比 <code>localStorage</code> 对象低得多。</p>
<p>属性和方法是相同的，但是它有更多的限制：</p>
<ul>
<li><code>sessionStorage</code> 的数据只存在于当前浏览器标签页。<ul>
<li>具有相同页面的另一个标签页中将会有不同的存储。</li>
<li>但是，它在同一标签页下的 iframe 之间是共享的（假如它们来自相同的源）。</li>
</ul>
</li>
<li>数据在页面刷新后仍然保留，但在关闭/重新打开浏览器标签页后不会被保留。</li>
</ul>
<p>让我们看看它的运行效果。</p>
<p>运行此代码……</p>
<pre><code class="language-js">sessionStorage.setItem(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-number">1</span>);</code></pre>
<p>……然后刷新页面。这时你仍然可以获取到数据：</p>
<pre><code class="language-js">alert(sessionStorage.getItem(<span class="hljs-string">&quot;test&quot;</span>)); <span class="hljs-comment">// after refresh: 1</span></code></pre>
<p>……但是，如果你在另一个新的标签页中打开此页面，然后在新页面中再次运行上面这行代码，则会得到 <code>null</code>，表示“未找到数据”。</p>
<p>这是因为 <code>sessionStorage</code> 不仅绑定到源，还绑定在同一浏览器标签页。因此，<code>sessionStorage</code> 很少被使用。</p>
<h2 id="storage-事件">Storage 事件</h2>
<p>当 <code>localStorage</code> 或 <code>sessionStorage</code> 中的数据更新后，<a href="https://www.w3.org/TR/webstorage/#the-storage-event">storage</a> 事件就会触发，它具有以下属性：</p>
<ul>
<li><code>key</code> —— 发生更改的数据的 <code>key</code>（如果调用的是 <code>.clear()</code> 方法，则为 <code>null</code>）。</li>
<li><code>oldValue</code> —— 旧值（如果是新增数据，则为 <code>null</code>）。</li>
<li><code>newValue</code> —— 新值（如果是删除数据，则为 <code>null</code>）。</li>
<li><code>url</code> —— 发生数据更新的文档的 url。</li>
<li><code>storageArea</code> —— 发生数据更新的 <code>localStorage</code> 或 <code>sessionStorage</code> 对象。</li>
</ul>
<p>重要的是：该事件会在所有可访问到存储对象的 <code>window</code> 对象上触发，导致当前数据改变的 <code>window</code> 对象除外。</p>
<p>我们来详细解释一下。</p>
<p>想象一下，你有两个窗口，它们具有相同的页面。所以 <code>localStorage</code> 在它们之间是共享的。</p>
<pre><code class="language-online">你可以想在浏览器的两个窗口中打开此页面来测试下面的代码。</code></pre>
<p>如果两个窗口都在监听 <code>window.onstorage</code> 事件，那么每个窗口都会对另一个窗口中发生的更新作出反应。</p>
<pre><code class="language-js"><span class="hljs-comment">// 在其他文档对同一存储进行更新时触发</span>
<span class="hljs-built_in">window</span>.onstorage = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
  <span class="hljs-comment">// 等同于 window.addEventListener(&#x27;storage&#x27;, () =&gt; {</span>
  <span class="hljs-keyword">if</span> (event.key != <span class="hljs-string">&quot;now&quot;</span>) <span class="hljs-keyword">return</span>;
  alert(event.key + <span class="hljs-string">&quot;:&quot;</span> + event.newValue + <span class="hljs-string">&quot; at &quot;</span> + event.url);
};

<span class="hljs-built_in">localStorage</span>.setItem(<span class="hljs-string">&quot;now&quot;</span>, <span class="hljs-built_in">Date</span>.now());</code></pre>
<p>请注意，该事件还包含：<code>event.url</code> —— 发生数据更新的文档的 url。</p>
<p>并且，<code>event.storageArea</code> 包含存储对象 —— <code>sessionStorage</code> 和 <code>localStorage</code> 具有相同的事件，所以 <code>event.storageArea</code> 引用了被修改的对象。我们可能会想设置一些东西，以“响应”更改。</p>
<p><strong>这允许同源的不同窗口交换消息。</strong></p>
<p>现代浏览器还支持 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API">Broadcast channel API</a>，这是用于同源窗口之间通信的特殊 API，它的功能更全，但被支持的情况不好。有一些库基于 <code>localStorage</code> 来 polyfill 该 API，使其可以用在任何地方。</p>

      </fieldset>
      </div><div id="nav"><div style="margin-left:0em"><a href="#_WpRe9A">cookie</a><br/></div><div style="margin-left:0em"><a href="#_uaUcId">storage</a><br/></div></div>
</body></html>