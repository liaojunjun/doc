<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>create for ggdoc , @author sunyi</title>
    <style>
        .octicon{display:inline-block;fill:currentColor;vertical-align:text-bottom}
        .anchor{float:left;line-height:1;margin-left:-20px;padding-right:4px}
        .anchor:focus{outline:0}
        h1 .octicon-link,h2 .octicon-link,h3 .octicon-link,h4 .octicon-link,h5 .octicon-link,h6 .octicon-link{color:#1b1f23;vertical-align:middle;visibility:hidden}
        h1:hover .anchor,h2:hover .anchor,h3:hover .anchor,h4:hover .anchor,h5:hover .anchor,h6:hover .anchor{text-decoration:none}
        h1:hover .anchor .octicon-link,h2:hover .anchor .octicon-link,h3:hover .anchor .octicon-link,h4:hover .anchor .octicon-link,h5:hover .anchor .octicon-link,h6:hover .anchor .octicon-link{visibility:visible}
        h1:hover .anchor .octicon-link:before,h2:hover .anchor .octicon-link:before,h3:hover .anchor .octicon-link:before,h4:hover .anchor .octicon-link:before,h5:hover .anchor .octicon-link:before,h6:hover .anchor .octicon-link:before{width:16px;height:16px;content:" ";display:inline-block;background-image:url("data:image/svg+xml,%3Csvgxmlns='http://www.w3.org/2000/svg'viewBox='001616'version='1.1'width='16'height='16'aria-hidden='true'%3E%3Cpathfill-rule='evenodd'd='M49h1v1H4c-1.50-3-1.69-3-3.5S2.55343h4c1.45031.6933.501.41-.912.72-23.25V8.59c.58-.451-1.271-2.09C105.228.98484H4c-.980-21.22-22.5S3949zm9-3h-1v1h1c1021.2222.5S13.98121312H9c-.980-2-1.22-2-2.50-.83.42-1.641-2.09V6.25c-1.09.53-21.84-23.25C611.317.5513913h4c1.4503-1.693-3.5S14.56136z'%3E%3C/path%3E%3C/svg%3E")}
        body{-webkit-text-size-adjust:100%;line-height:1.5;color:#24292e;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji;font-size:16px;line-height:1.5;word-wrap:break-word;background-color:#e3e3ef;height:100%;width:100%;margin:0;padding:20px}
        details{display:block}
        summary{display:list-item}
        a{background-color:initial}
        a:active,a:hover{outline-width:0}
        strong{font-weight:inherit;font-weight:bolder}
        h1{font-size:2em;margin:.67em 0}
        img{border-style:none}
        code,kbd,pre{font-family:monospace,monospace;font-size:1em}
        hr{box-sizing:initial;height:0;overflow:visible}
        input{font:inherit;margin:0}
        input{overflow:visible}
        [type="checkbox"]{box-sizing:border-box;padding:0}
        *{box-sizing:border-box}
        input{font-family:inherit;font-size:inherit;line-height:inherit}
        a{color:#0366d6;text-decoration:none}
        a:hover{text-decoration:underline}
        strong{font-weight:600}
        hr{height:0;margin:15px 0;overflow:hidden;background:transparent;border:0;border-bottom:1px solid #dfe2e5}
        hr:after,hr:before{display:table;content:""}
        hr:after{clear:both}
        table{border-spacing:0;border-collapse:collapse}
        td,th{padding:0}
        details summary{cursor:pointer}
        kbd{display:inline-block;padding:3px 5px;font:11px SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;line-height:10px;color:#444d56;vertical-align:middle;background-color:#fafbfc;border:1px solid #d1d5da;border-radius:3px;box-shadow:inset 0 -1px 0 #d1d5da}
        h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:0}
        h1{font-size:32px}
        h1,h2{font-weight:600}
        h2{font-size:24px}
        h3{font-size:20px}
        h3,h4{font-weight:600}
        h4{font-size:16px}
        h5{font-size:14px}
        h5,h6{font-weight:600}
        h6{font-size:12px}
        p{margin-top:0;margin-bottom:10px}
        blockquote{margin:0}
        ol,ul{padding-left:0;margin-top:0;margin-bottom:0}
        ol ol,ul ol{list-style-type:lower-roman}
        ol ol ol,ol ul ol,ul ol ol,ul ul ol{list-style-type:lower-alpha}
        dd{margin-left:0}
        code,pre{font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:12px}
        pre{margin-top:0;margin-bottom:0}
        input::-webkit-inner-spin-button,input::-webkit-outer-spin-button{margin:0;-webkit-appearance:none;appearance:none}
        :checked+.radio-label{position:relative;z-index:1;border-color:#0366d6}
        .border{border:1px solid #e1e4e8!important}
        .border-0{border:0!important}
        .border-bottom{border-bottom:1px solid #e1e4e8!important}
        .rounded-1{border-radius:3px!important}
        .bg-white{background-color:#fff!important}
        .bg-gray-light{background-color:#fafbfc!important}
        .text-gray-light{color:#6a737d!important}
        .mb-0{margin-bottom:0!important}
        .my-2{margin-top:8px!important;margin-bottom:8px!important}
        .pl-0{padding-left:0!important}
        .py-0{padding-top:0!important;padding-bottom:0!important}
        .pl-1{padding-left:4px!important}
        .pl-2{padding-left:8px!important}
        .py-2{padding-top:8px!important;padding-bottom:8px!important}
        .pl-3,.px-3{padding-left:16px!important}
        .px-3{padding-right:16px!important}
        .pl-4{padding-left:24px!important}
        .pl-5{padding-left:32px!important}
        .pl-6{padding-left:40px!important}
        .f6{font-size:12px!important}
        .lh-condensed{line-height:1.25!important}
        .text-bold{font-weight:600!important}
        .pl-c{color:#6a737d}
        .pl-c1,.pl-s .pl-v{color:#005cc5}
        .pl-e,.pl-en{color:#6f42c1}
        .pl-s .pl-s1,.pl-smi{color:#24292e}
        .pl-ent{color:#22863a}
        .pl-k{color:#d73a49}
        .pl-pds,.pl-s,.pl-s .pl-pse .pl-s1,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre{color:#032f62}
        .pl-smw,.pl-v{color:#e36209}
        .pl-bu{color:#b31d28}
        .pl-ii{color:#fafbfc;background-color:#b31d28}
        .pl-c2{color:#fafbfc;background-color:#d73a49}
        .pl-c2:before{content:"^M"}
        .pl-sr .pl-cce{font-weight:700;color:#22863a}
        .pl-ml{color:#735c0f}
        .pl-mh,.pl-mh .pl-en,.pl-ms{font-weight:700;color:#005cc5}
        .pl-mi{font-style:italic;color:#24292e}
        .pl-mb{font-weight:700;color:#24292e}
        .pl-md{color:#b31d28;background-color:#ffeef0}
        .pl-mi1{color:#22863a;background-color:#f0fff4}
        .pl-mc{color:#e36209;background-color:#ffebda}
        .pl-mi2{color:#f6f8fa;background-color:#005cc5}
        .pl-mdr{font-weight:700;color:#6f42c1}
        .pl-ba{color:#586069}
        .pl-sg{color:#959da5}
        .pl-corl{text-decoration:underline;color:#032f62}
        .mb-0{margin-bottom:0!important}
        .my-2{margin-bottom:8px!important}
        .my-2{margin-top:8px!important}
        .pl-0{padding-left:0!important}
        .py-0{padding-top:0!important;padding-bottom:0!important}
        .pl-1{padding-left:4px!important}
        .pl-2{padding-left:8px!important}
        .py-2{padding-top:8px!important;padding-bottom:8px!important}
        .pl-3{padding-left:16px!important}
        .pl-4{padding-left:24px!important}
        .pl-5{padding-left:32px!important}
        .pl-6{padding-left:40px!important}
        .pl-7{padding-left:48px!important}
        .pl-8{padding-left:64px!important}
        .pl-9{padding-left:80px!important}
        .pl-10{padding-left:96px!important}
        .pl-11{padding-left:112px!important}
        .pl-12{padding-left:128px!important}
        hr{border-bottom-color:#eee}
        kbd{display:inline-block;padding:3px 5px;font:11px SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;line-height:10px;color:#444d56;vertical-align:middle;background-color:#fafbfc;border:1px solid #d1d5da;border-radius:3px;box-shadow:inset 0 -1px 0 #d1d5da}
        .markdown-body:after,.markdown-body:before{display:table;content:""}
        .markdown-body:after{clear:both}
        .markdown-body>:first-child{margin-top:0!important}
        .markdown-body>:last-child{margin-bottom:0!important}
        a:not([href]){color:inherit;text-decoration:none}
        blockquote,details,dl,ol,p,pre,table,ul{margin-top:0;margin-bottom:16px}
        hr{height:.25em;padding:0;margin:24px 0;background-color:#e1e4e8;border:0}
        blockquote{padding:0 1em;color:#6a737d;border-left:.25em solid #dfe2e5}
        blockquote>:first-child{margin-top:0}
        blockquote>:last-child{margin-bottom:0}
        h1,h2,h3,h4,h5,h6{margin-top:24px;margin-bottom:16px;font-weight:600;line-height:1.25}
        h1{font-size:2em}
        h1,h2{padding-bottom:.3em;border-bottom:1px solid #eaecef}
        h2{font-size:1.5em}
        h3{font-size:1.25em}
        h4{font-size:1em}
        h5{font-size:.875em}
        h6{font-size:.85em;color:#6a737d}
        ol,ul{padding-left:2em}
        ol ol,ol ul,ul ol,ul ul{margin-top:0;margin-bottom:0}
        li{word-wrap:break-all}
        li>p{margin-top:16px}
        li+li{margin-top:.25em}
        dl{padding:0}
        dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:600}
        dl dd{padding:0 16px;margin-bottom:16px}
        table{display:block;width:100%;overflow:auto}
        table th{font-weight:600}
        table td,table th{padding:6px 13px;border:1px solid #dfe2e5}
        table tr{background-color:#fff;border-top:1px solid #c6cbd1}
        table tr:nth-child(2n){background-color:#f6f8fa}
        img{max-width:100%;box-sizing:initial;background-color:#fff}
        img[align="right"]{padding-left:20px}
        img[align="left"]{padding-right:20px}
        code{padding:.2em .4em;margin:0;font-size:85%;background-color:rgba(27,31,35,0.05);border-radius:3px}
        pre{word-wrap:normal}
        pre>code{padding:0;margin:0;font-size:100%;word-break:normal;white-space:pre;background:transparent;border:0}
        .highlight{margin-bottom:16px}
        .highlight pre{margin-bottom:0;word-break:normal}
        .highlight pre,pre{padding:16px;overflow:auto;font-size:85%;line-height:1.45;background-color:#f6f8fa;border-radius:3px}
        pre code{display:inline;max-width:auto;padding:0;margin:0;overflow:visible;line-height:inherit;word-wrap:normal;background-color:initial;border:0}
        .commit-tease-sha{display:inline-block;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:90%;color:#444d56}
        .full-commit .btn-outline:not(:disabled):hover{color:#005cc5;border-color:#005cc5}
        .blob-wrapper{overflow-x:auto;overflow-y:hidden}
        .blob-wrapper-embedded{max-height:240px;overflow-y:auto}
        .blob-num{width:1%;min-width:50px;padding-right:10px;padding-left:10px;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:12px;line-height:20px;color:rgba(27,31,35,0.3);text-align:right;white-space:nowrap;vertical-align:top;cursor:pointer;user-select:none}
        .blob-num:hover{color:rgba(27,31,35,0.6)}
        .blob-num:before{content:attr(data-line-number)}
        .blob-code{position:relative;padding-right:10px;padding-left:10px;line-height:20px;vertical-align:top}
        .blob-code-inner{overflow:visible;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:12px;color:#24292e;word-wrap:normal;white-space:pre}
        .pl-token.active,.pl-token:hover{cursor:pointer;background:#ffea7f}
        .tab-size[data-tab-size="1"]{-moz-tab-size:1;tab-size:1}
        .tab-size[data-tab-size="2"]{-moz-tab-size:2;tab-size:2}
        .tab-size[data-tab-size="3"]{-moz-tab-size:3;tab-size:3}
        .tab-size[data-tab-size="4"]{-moz-tab-size:4;tab-size:4}
        .tab-size[data-tab-size="5"]{-moz-tab-size:5;tab-size:5}
        .tab-size[data-tab-size="6"]{-moz-tab-size:6;tab-size:6}
        .tab-size[data-tab-size="7"]{-moz-tab-size:7;tab-size:7}
        .tab-size[data-tab-size="8"]{-moz-tab-size:8;tab-size:8}
        .tab-size[data-tab-size="9"]{-moz-tab-size:9;tab-size:9}
        .tab-size[data-tab-size="10"]{-moz-tab-size:10;tab-size:10}
        .tab-size[data-tab-size="11"]{-moz-tab-size:11;tab-size:11}
        .tab-size[data-tab-size="12"]{-moz-tab-size:12;tab-size:12}
        .task-list-item{list-style-type:none}
        .task-list-item+.task-list-item{margin-top:3px}
        .task-list-item input{margin:0 .2em .25em -1.6em;vertical-align:middle}
        #page{width:calc(100% - 500px);margin-left:500px;overflow: hidden;}
        fieldset{display:none;background-color:#fff;border:0;overflow:hidden;box-shadow:2px 2px 10px rgba(128,128,128,0.2);margin-bottom:20px;padding:20px}
        fieldset legend{font-weight:bold;color:green;height:3.5em;margin-left:-20px;padding:0}
        #nav{background:rgb(255 255 255 / .7);padding:20px 10px 100px 20px;position:fixed;top:0;left:0;bottom:0;width:500px;overflow-y:auto;overflow-x: hidden;white-space:nowrap}
        ::-webkit-scrollbar{width:5px}
        ::-webkit-scrollbar-thumb{background-color:#79a5e8}
        @media print,(max-width:900px){
          #nav{display:none!important}
          #page{width:100%!important;margin-left:0!important}
          fieldset{padding-top: 0 !important;padding-bottom: 0 !important;display:block!important;box-shadow:none!important}
          .toggle-hash-btn {display: none !important;}
        }
        .hljs{display:block;overflow-x:auto;padding:.5em;color:#333;background:#f8f8f8}
        .hljs-comment,.hljs-quote{color:#998;font-style:italic}
        .hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:bold}
        .hljs-number,.hljs-literal,.hljs-variable,.hljs-template-variable,.hljs-tag .hljs-attr{color:#008080}
        .hljs-string,.hljs-doctag{color:#d14}
        .hljs-title,.hljs-section,.hljs-selector-id{color:#900;font-weight:bold}
        .hljs-subst{font-weight:normal}
        .hljs-type,.hljs-class .hljs-title{color:#458;font-weight:bold}
        .hljs-tag,.hljs-name,.hljs-attribute{color:#000080;font-weight:normal}
        .hljs-regexp,.hljs-link{color:#009926}
        .hljs-symbol,.hljs-bullet{color:#990073}
        .hljs-built_in,.hljs-builtin-name{color:#0086b3}
        .hljs-meta{color:#999;font-weight:bold}
        .hljs-deletion{background:#fdd}
        .hljs-addition{background:#dfd}
        .hljs-emphasis{font-style:italic}
        .hljs-strong{font-weight:bold}
        .toggle-hash-btn {position: fixed;bottom: 10px;left:10px;z-index: 1000; display: flex; justify-content: space-between;  width: 270px;}
        iframe {border: 5px solid #999;margin:10px;width: 90%;min-height: 50px;}
    </style>
    <script>
          const $ = selector => document.querySelector(selector);
          const $$ = selector => document.querySelectorAll(selector);
          const decode = s => decodeURIComponent(s);
          const domInfo = dom => ({
            offsetParent: dom.offsetParent.className,
            offsetLeft: dom.offsetLeft,
            offsetTop: dom.offsetTop,
            clientWidth: dom.clientWidth,
            offsetWidth: dom.offsetWidth,
            BoundingClientRect: dom.getBoundingClientRect(),
          });
          let openHash = false;
          function viewFieldset() {
            const hash = decode(location.hash);
            if(openHash && hash &&$(`fieldset${hash}`)) {
              Array.from($$('fieldset')).forEach(dom  =>dom.style.display = 'none');
              $(`fieldset${hash}`).style.display = 'block';
            }else {
              Array.from($$('fieldset')).forEach(dom  =>dom.style.display = 'block');
            }
          }
          window.onhashchange = viewFieldset;
          window.onload  = ()=>{
            viewFieldset();
            setATarget();
            loadIframe();
          };
          
          function toggleHash() {
            openHash = !openHash;
            viewFieldset();
            $('.toggle-hash-btn button').innerText = openHash ? '关闭专注模式' : '开启专注模式';
          }
          function setATarget() {
            $$('#page a').forEach(a=>a.target = '_blank');
          }
          function elementInViewport(el) {
            if (el instanceof Element) {
              const { top, left, width, height } = el.getBoundingClientRect();
              const { innerHeight, innerWidth } = window;
              return (
                top + height >= 0 &&
                left + width >= 0 &&
                top <= innerHeight &&
                left <= innerWidth
              );
            }
            return false;
          }
          function loadIframe() {
            const query = "data-src";
            const frames = Array.from($$(`iframe[${query}]`));

            const load = (item) => {
              frames.splice(
                frames.findIndex((v) => v === item),
                1
              );
              item.src = item.getAttribute(query);
              item.removeAttribute(query);
            };
            const processScroll = () => {
              frames.forEach((item) => {
                if (elementInViewport(item)) {
                  load(item);
                }
              });
            };
            processScroll();
            window.addEventListener("scroll", processScroll, false);
            window.removeEventListener("beforeunload", processScroll, false);
          }
    </script>
</head>

<body>
  <div class="toggle-hash-btn">
    <button  onclick="toggleHash()">开启专注模式</button>
  </div><div id="page">
      <fieldset id='_VzlfgQ'>
      <legend>solution</legend>
      
      </fieldset>
      
      <fieldset id='_0DmaEP'>
      <legend>task</legend>
      <h1 id="拼接类型化数组">拼接类型化数组</h1>
<p>给定一个 <code>Uint8Array</code> 数组，请写一个函数 <code>concat(arrays)</code>，将数组拼接成一个单一数组并返回。</p>

      </fieldset>
      
      <fieldset id='_5O6DBP'>
      <legend>article</legend>
      <h1 id="arraybuffer，二进制数组">ArrayBuffer，二进制数组</h1>
<p>在 Web 开发中，当我们处理文件时（创建，上传，下载），经常会遇到二进制数据。另一个典型的应用场景是图像处理。</p>
<p>这些都可以通过 JavaScript 进行处理，而且二进制操作性能更高。</p>
<p>不过，在 JavaScript 中有很多种二进制数据格式，会有点容易混淆。仅举几个例子：</p>
<ul>
<li><code>ArrayBuffer</code>，<code>Uint8Array</code>，<code>DataView</code>，<code>Blob</code>，<code>File</code> 及其他。</li>
</ul>
<p>与其他语言相比，JavaScript 中的二进制数据是以非标准方式实现的。但是，当我们理清楚以后，一切就会变得相当简单了。</p>
<p><strong>基本的二进制对象是 <code>ArrayBuffer</code> —— 对固定长度的连续内存空间的引用。</strong></p>
<p>我们这样创建它：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(<span class="hljs-number">16</span>); <span class="hljs-comment">// 创建一个长度为 16 的 buffer</span>
alert(buffer.byteLength); <span class="hljs-comment">// 16</span></code></pre>
<p>它会分配一个 16 字节的连续内存空间，并用 0 进行预填充。</p>
<p>&quot;<code>ArrayBuffer</code> 不是某种东西的数组&quot;
让我们先澄清一个可能的误区。<code>ArrayBuffer</code> 与 <code>Array</code> 没有任何共同之处：</p>
<ul>
<li>它的长度是固定的，我们无法增加或减少它的长度。</li>
<li>它正好占用了内存中的那么多空间。</li>
<li>要访问单个字节，需要另一个“视图”对象，而不是 <code>buffer[index]</code>。<pre><code></code></pre>
</li>
</ul>
<p><code>ArrayBuffer</code> 是一个内存区域。它里面存储了什么？无从判断。只是一个原始的字节序列。</p>
<p><strong>如要操作 <code>ArrayBuffer</code>，我们需要使用“视图”对象。</strong></p>
<p>视图对象本身并不存储任何东西。它是一副“眼镜”，透过它来解释存储在 <code>ArrayBuffer</code> 中的字节。</p>
<p>例如：</p>
<ul>
<li><strong><code>Uint8Array</code></strong> —— 将 <code>ArrayBuffer</code> 中的每个字节视为 0 到 255 之间的单个数字（每个字节是 8 位，因此只能容纳那么多）。这称为 “8 位无符号整数”。</li>
<li><strong><code>Uint16Array</code></strong> —— 将每 2 个字节视为一个 0 到 65535 之间的整数。这称为 “16 位无符号整数”。</li>
<li><strong><code>Uint32Array</code></strong> —— 将每 4 个字节视为一个 0 到 4294967295 之间的整数。这称为 “32 位无符号整数”。</li>
<li><strong><code>Float64Array</code></strong> —— 将每 8 个字节视为一个 <code>5.0x10<sup>-324</sup></code> 到 <code>1.8x10<sup>308</sup></code> 之间的浮点数。</li>
</ul>
<p>因此，一个 16 字节 <code>ArrayBuffer</code> 中的二进制数据可以解释为 16 个“小数字”，或 8 个更大的数字（每个数字 2 个字节），或 4 个更大的数字（每个数字 4 个字节），或 2 个高精度的浮点数（每个数字 8 个字节）。</p>
<p><img src="arraybuffer-views.svg" alt=""></p>
<p><code>ArrayBuffer</code> 是核心对象，是所有的基础，是原始的二进制数据。</p>
<p>但是，如果我们要写入值或遍历它，基本上几乎所有操作 —— 我们必须使用视图（view），例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(<span class="hljs-number">16</span>); <span class="hljs-comment">// 创建一个长度为 16 的 buffer</span>


<span class="hljs-keyword">let</span> view = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint32Array</span>(buffer); <span class="hljs-comment">// 将 buffer 视为一个 32 位整数的序列</span>

alert(<span class="hljs-built_in">Uint32Array</span>.BYTES_PER_ELEMENT); <span class="hljs-comment">// 每个整数 4 个字节</span>


alert(view.length); <span class="hljs-comment">// 4，它存储了 4 个整数</span>
alert(view.byteLength); <span class="hljs-comment">// 16，字节中的大小</span>

<span class="hljs-comment">// 让我们写入一个值</span>
view[<span class="hljs-number">0</span>] = <span class="hljs-number">123456</span>;

<span class="hljs-comment">// 遍历值</span>
<span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> view</span>)</span> {
  alert(num); <span class="hljs-comment">// 123456，然后 0，0，0（一共 4 个值）</span>
}
</code></pre>
<h2 id="typedarray">TypedArray</h2>
<p>所有这些视图（<code>Uint8Array</code>，<code>Uint32Array</code> 等）的通用术语是 <a href="https://tc39.github.io/ecma262/#sec-typedarray-objects">TypedArray</a>。它们都享有同一组方法和属性。</p>
<p>请注意，没有名为 <code>TypedArray</code> 的构造器，它只是表示 <code>ArrayBuffer</code> 上的视图之一的通用总称术语：<code>Int8Array</code>，<code>Uint8Array</code> 及其他，很快就会有完整列表。</p>
<p>当你看到 <code>new TypedArray</code> 之类的内容时，它表示 <code>new Int8Array</code>、<code>new Uint8Array</code> 及其他中之一。</p>
<p>类型化数组的行为类似于常规数组：具有索引，并且是可迭代的。</p>
<p>一个类型化数组的构造器（无论是 <code>Int8Array</code> 或 <code>Float64Array</code>，都无关紧要），其行为各不相同，并且取决于参数类型。</p>
<p>参数有 5 种变体：</p>
<pre><code class="language-js"><span class="hljs-keyword">new</span> TypedArray(buffer, [byteOffset], [length]);
<span class="hljs-keyword">new</span> TypedArray(object);
<span class="hljs-keyword">new</span> TypedArray(typedArray);
<span class="hljs-keyword">new</span> TypedArray(length);
<span class="hljs-keyword">new</span> TypedArray();</code></pre>
<ol>
<li><p>如果给定的是 <code>ArrayBuffer</code> 参数，则会在其上创建视图。我们已经用过该语法了。</p>
<p> 可选，我们可以给定起始位置 <code>byteOffset</code>（默认为 0）以及 <code>length</code>（默认至 buffer 的末尾），这样视图将仅涵盖 <code>buffer</code> 的一部分。</p>
</li>
<li><p>如果给定的是 <code>Array</code>，或任何类数组对象，则会创建一个相同长度的类型化数组，并复制其内容。</p>
<p> 我们可以使用它来预填充数组的数据：</p>
<pre><code class="language-js">
<span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);

alert( arr.length ); <span class="hljs-comment">// 4，创建了相同长度的二进制数组</span>
alert( arr[<span class="hljs-number">1</span>] ); <span class="hljs-comment">// 1，用给定值填充了 4 个字节（无符号 8 位整数）</span></code></pre>
</li>
<li><p>如果给定的是另一个 <code>TypedArray</code>，也是如此：创建一个相同长度的类型化数组，并复制其内容。如果需要的话，数据在此过程中会被转换为新的类型。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr16 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint16Array</span>([<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>]);

<span class="hljs-keyword">let</span> arr8 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(arr16);

alert( arr8[<span class="hljs-number">0</span>] ); <span class="hljs-comment">// 1</span>
alert( arr8[<span class="hljs-number">1</span>] ); <span class="hljs-comment">// 232，试图复制 1000，但无法将 1000 放进 8 位字节中（详述见下文）。</span></code></pre>
</li>
<li><p>对于数字参数 <code>length</code> —— 创建类型化数组以包含这么多元素。它的字节长度将是 <code>length</code> 乘以单个 <code>TypedArray.BYTES_PER_ELEMENT</code> 中的字节数：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint16Array</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// 为 4 个整数创建类型化数组</span>
alert( <span class="hljs-built_in">Uint16Array</span>.BYTES_PER_ELEMENT ); <span class="hljs-comment">// 每个整数 2 个字节</span>
alert( arr.byteLength ); <span class="hljs-comment">// 8（字节中的大小）</span></code></pre>
</li>
<li><p>不带参数的情况下，创建长度为零的类型化数组。</p>
</li>
</ol>
<p>我们可以直接创建一个 <code>TypedArray</code>，而无需提及 <code>ArrayBuffer</code>。但是，视图离不开底层的 <code>ArrayBuffer</code>，因此，除第一种情况（已提供 <code>ArrayBuffer</code>）外，其他所有情况都会自动创建 <code>ArrayBuffer</code>。</p>
<p>如要访问 <code>ArrayBuffer</code>，可以用以下属性：</p>
<ul>
<li><code>arr.buffer</code> —— 引用 <code>ArrayBuffer</code>。</li>
<li><code>arr.byteLength</code> —— <code>ArrayBuffer</code> 的长度。</li>
</ul>
<p>因此，我们总是可以从一个视图转到另一个视图：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr8 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);

<span class="hljs-comment">// 同一数据的另一个视图</span>
<span class="hljs-keyword">let</span> arr16 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint16Array</span>(arr8.buffer);</code></pre>
<p>下面是类型化数组的列表：</p>
<ul>
<li><code>Uint8Array</code>，<code>Uint16Array</code>，<code>Uint32Array</code> —— 用于 8、16 和 32 位的整数。<ul>
<li><code>Uint8ClampedArray</code> —— 用于 8 位整数，在赋值时便“固定“其值（见下文）。</li>
</ul>
</li>
<li><code>Int8Array</code>，<code>Int16Array</code>，<code>Int32Array</code> —— 用于有符号整数（可以为负数）。</li>
<li><code>Float32Array</code>，<code>Float64Array</code> —— 用于 32 位和 64 位的有符号浮点数。</li>
</ul>
<p>&quot;没有 <code>int8</code> 或类似的单值类型&quot;
请注意，尽管有类似 <code>Int8Array</code> 这样的名称，但 JavaScript 中并没有像 <code>int</code>，或 <code>int8</code> 这样的单值类型。</p>
<p>这是合乎逻辑的，因为 <code>Int8Array</code> 不是这些单值的数组，而是 <code>ArrayBuffer</code> 上的视图。</p>
<pre><code>
### 越界行为

如果我们尝试将越界值写入类型化数组会出现什么情况？不会报错。但是多余的位被切除。

例如，我们尝试将 256 放入 `Uint8Array`。256 的二进制格式是 `100000000`（9 位），但 `Uint8Array` 每个值只有 8 位，因此可用范围为 0 到 255。

对于更大的数字，仅存储最右边的（低位有效）8 位，其余部分被切除： 

![](8bit-integer-256.svg)

因此结果是 0。

257 的二进制格式是 `100000001`（9 位），最右边的 8 位会被存储，因此数组中会有 `1`：

![](8bit-integer-257.svg)

换句话说，该数字对 2&lt;sup&gt;8&lt;/sup&gt; 取模的结果被保存了下来。

示例如下：

```js
let uint8array = new Uint8Array(16);

let num = 256;
alert(num.toString(2)); // 100000000（二进制表示）

uint8array[0] = 256;
uint8array[1] = 257;

alert(uint8array[0]); // 0
alert(uint8array[1]); // 1</code></pre>
<p><code>Uint8ClampedArray</code> 在这方面比较特殊，它的表现不太一样。对于大于 255 的任何数字，它将保存为 255，对于任何负数，它将保存为 0。此行为对于图像处理很有用。</p>
<h2 id="typedarray-方法">TypedArray 方法</h2>
<p><code>TypedArray</code> 具有常规的 <code>Array</code> 方法，但有个明显的例外。</p>
<p>我们可以遍历（iterate），<code>map</code>，<code>slice</code>，<code>find</code> 和 <code>reduce</code> 等。</p>
<p>但有几件事我们做不了：</p>
<ul>
<li>没有 <code>splice</code> —— 我们无法“删除”一个值，因为类型化数组是缓冲区（buffer）上的视图，并且缓冲区（buffer）是固定的、连续的内存区域。我们所能做的就是分配一个零值。</li>
<li>无 <code>concat</code> 方法。</li>
</ul>
<p>还有两种其他方法：</p>
<ul>
<li><code>arr.set(fromArr, [offset])</code> 将 <code>fromArr</code> 中从 <code>offset</code>（默认为 0）开始的所有元素复制到 <code>arr</code>。</li>
<li><code>arr.subarray([begin, end])</code> 创建一个从 <code>begin</code> 到 <code>end</code>（不包括）相同类型的新视图。这类似于 <code>slice</code> 方法（同样也支持），但不复制任何内容 —— 只是创建一个新视图，以对给定片段的数据进行操作。</li>
</ul>
<p>有了这些方法，我们可以复制、混合类型化数组，从现有数组创建新数组，等。</p>
<h2 id="dataview">DataView</h2>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/DataView">DataView</a> 是在 <code>ArrayBuffer</code> 上的一种特殊的超灵活“未类型化”视图。它允许以任何格式访问任何偏移量（offset）的数据。</p>
<ul>
<li>对于类型化的数组，构造器决定了其格式。整个数组应该是统一的。第 i 个数字是 <code>arr[i]</code>。</li>
<li>通过 <code>DataView</code>，我们可以使用 <code>.getUint8(i)</code> 或 <code>.getUint16(i)</code> 之类的方法访问数据。我们在调用方法时选择格式，而不是在构造的时候。</li>
</ul>
<p>语法：</p>
<pre><code class="language-js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">DataView</span>(buffer, [byteOffset], [byteLength])</code></pre>
<ul>
<li><strong><code>buffer</code></strong> —— 底层的 <code>ArrayBuffer</code>。与类型化数组不同，<code>DataView</code> 不会自行创建缓冲区（buffer）。我们需要事先准备好。</li>
<li><strong><code>byteOffset</code></strong> —— 视图的起始字节位置（默认为 0）。</li>
<li><strong><code>byteLength</code></strong> —— 视图的字节长度（默认至 <code>buffer</code> 的末尾）。</li>
</ul>
<p>例如，这里我们从同一个 buffer 中提取不同格式的数字：</p>
<pre><code class="language-js"><span class="hljs-comment">// 4 个字节的二进制数组，每个都是最大值 255</span>
<span class="hljs-keyword">let</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>([<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>]).buffer;

<span class="hljs-keyword">let</span> dataView = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DataView</span>(buffer);

<span class="hljs-comment">// 在偏移量为 0 处获取 8 位数字</span>
alert( dataView.getUint8(<span class="hljs-number">0</span>) ); <span class="hljs-comment">// 255</span>

<span class="hljs-comment">// 现在在偏移量为 0 处获取 16 位数字，它由 2 个字节组成，一起解析为 65535</span>
alert( dataView.getUint16(<span class="hljs-number">0</span>) ); <span class="hljs-comment">// 65535（最大的 16 位无符号整数）</span>

<span class="hljs-comment">// 在偏移量为 0 处获取 32 位数字</span>
alert( dataView.getUint32(<span class="hljs-number">0</span>) ); <span class="hljs-comment">// 4294967295（最大的 32 位无符号整数）</span>

dataView.setUint32(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 将 4 个字节的数字设为 0，即将所有字节都设为 0</span></code></pre>
<p>当我们将混合格式的数据存储在同一缓冲区（buffer）中时，<code>DataView</code> 非常有用。例如，我们存储一个成对序列（16 位整数，32 位浮点数）。用 <code>DataView</code> 可以轻松访问它们。</p>
<h2 id="总结">总结</h2>
<p><code>ArrayBuffer</code> 是核心对象，是对固定长度的连续内存区域的引用。</p>
<p>几乎任何对 <code>ArrayBuffer</code> 的操作，都需要一个视图。</p>
<ul>
<li>它可以是 <code>TypedArray</code>：<ul>
<li><code>Uint8Array</code>，<code>Uint16Array</code>，<code>Uint32Array</code> —— 用于 8 位、16 位和 32 位无符号整数。</li>
<li><code>Uint8ClampedArray</code> —— 用于 8 位整数，在赋值时便“固定”其值。</li>
<li><code>Int8Array</code>，<code>Int16Array</code>，<code>Int32Array</code> —— 用于有符号整数（可以为负数）。</li>
<li><code>Float32Array</code>，<code>Float64Array</code> —— 用于 32 位和 64 位的有符号浮点数。</li>
</ul>
</li>
<li>或 <code>DataView</code> —— 使用方法来指定格式的视图，例如，<code>getUint8(offset)</code>。</li>
</ul>
<p>在大多数情况下，我们直接对类型化数组进行创建和操作，而将 <code>ArrayBuffer</code> 作为“通用标识符（common discriminator）”隐藏起来。我们可以通过 <code>.buffer</code> 来访问它，并在需要时创建另一个视图。</p>
<p>还有另外两个术语，用于对二进制数据进行操作的方法的描述：</p>
<ul>
<li><code>ArrayBufferView</code> 是所有这些视图的总称。</li>
<li><code>BufferSource</code> 是 <code>ArrayBuffer</code> 或 <code>ArrayBufferView</code> 的总称。</li>
</ul>
<p>我们将在下一章中学习这些术语。<code>BufferSource</code> 是最常用的术语之一，因为它的意思是“任何类型的二进制数据” —— <code>ArrayBuffer</code> 或其上的视图。</p>
<p>这是一份备忘单：</p>
<p><img src="arraybuffer-view-buffersource.svg" alt=""></p>

      </fieldset>
      
      <fieldset id='_vJH4hB'>
      <legend>article</legend>
      <h1 id="textdecoder-和-textencoder">TextDecoder 和 TextEncoder</h1>
<p>如果二进制数据实际上是一个字符串怎么办？例如，我们收到了一个包含文本数据的文件。</p>
<p>内建的 <a href="https://encoding.spec.whatwg.org/#interface-textdecoder">TextDecoder</a> 对象在给定缓冲区（buffer）和编码格式（encoding）的情况下，能够将值读取到实际的 JavaScript 字符串中。</p>
<p>首先我们需要创建：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> decoder = <span class="hljs-keyword">new</span> TextDecoder([label], [options]);</code></pre>
<ul>
<li><strong><code>label</code></strong> —— 编码格式，默认为 <code>utf-8</code>，但同时也支持 <code>big5</code>，<code>windows-1251</code> 等许多其他编码格式。</li>
<li><strong><code>options</code></strong> —— 可选对象：<ul>
<li><strong><code>fatal</code></strong> —— 布尔值，如果为 <code>true</code> 则为无效（不可解码）字符抛出异常，否则（默认）用字符 <code>\uFFFD</code> 替换无效字符。</li>
<li><strong><code>ignoreBOM</code></strong> —— 布尔值，如果为 <code>true</code> 则 BOM（可选的字节顺序 unicode 标记），很少需要使用。</li>
</ul>
</li>
</ul>
<p>……然后解码：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> str = decoder.decode([input], [options]);</code></pre>
<ul>
<li><strong><code>input</code></strong> —— 要被解码的 <code>BufferSource</code>。</li>
<li><strong><code>options</code></strong> —— 可选对象：<ul>
<li><strong><code>stream</code></strong> —— 对于解码流，为 true，则将传入的数据块（chunk）作为参数重复调用 <code>decoder</code>。在这种情况下，多字节的字符可能偶尔会在块与块之间被分割。这个选项告诉 <code>TextDecoder</code> 记住“未完成”的字符，并在下一个数据块来的时候进行解码。</li>
</ul>
</li>
</ul>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> uint8Array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>([<span class="hljs-number">72</span>, <span class="hljs-number">101</span>, <span class="hljs-number">108</span>, <span class="hljs-number">108</span>, <span class="hljs-number">111</span>]);

alert( <span class="hljs-keyword">new</span> TextDecoder().decode(uint8Array) ); <span class="hljs-comment">// Hello</span></code></pre>
<pre><code class="language-js"><span class="hljs-keyword">let</span> uint8Array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>([<span class="hljs-number">228</span>, <span class="hljs-number">189</span>, <span class="hljs-number">160</span>, <span class="hljs-number">229</span>, <span class="hljs-number">165</span>, <span class="hljs-number">189</span>]);

alert( <span class="hljs-keyword">new</span> TextDecoder().decode(uint8Array) ); <span class="hljs-comment">// 你好</span></code></pre>
<p>我们可以通过为其创建子数组视图来解码部分缓冲区：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> uint8Array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>([<span class="hljs-number">0</span>, <span class="hljs-number">72</span>, <span class="hljs-number">101</span>, <span class="hljs-number">108</span>, <span class="hljs-number">108</span>, <span class="hljs-number">111</span>, <span class="hljs-number">0</span>]);

<span class="hljs-comment">// 该字符串位于中间</span>
<span class="hljs-comment">// 在不复制任何内容的前提下，创建一个新的视图</span>
<span class="hljs-keyword">let</span> binaryString = uint8Array.subarray(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>);

alert( <span class="hljs-keyword">new</span> TextDecoder().decode(binaryString) ); <span class="hljs-comment">// Hello</span></code></pre>
<h2 id="textencoder">TextEncoder</h2>
<p><a href="https://encoding.spec.whatwg.org/#interface-textencoder">TextEncoder</a> 做相反的事情 —— 将字符串转换为字节。</p>
<p>语法为：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> encoder = <span class="hljs-keyword">new</span> TextEncoder();</code></pre>
<p>只支持 <code>utf-8</code> 编码。</p>
<p>它有两种方法：</p>
<ul>
<li><strong><code>encode(str)</code></strong> —— 从字符串返回 <code>Uint8Array</code>。</li>
<li><strong><code>encodeInto(str, destination)</code></strong> —— 将 <code>str</code> 编码到 <code>destination</code> 中，该目标必须为 <code>Uint8Array</code>。</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">let</span> encoder = <span class="hljs-keyword">new</span> TextEncoder();

<span class="hljs-keyword">let</span> uint8Array = encoder.encode(<span class="hljs-string">&quot;Hello&quot;</span>);
alert(uint8Array); <span class="hljs-comment">// 72,101,108,108,111</span></code></pre>

      </fieldset>
      
      <fieldset id='_9mVnZI'>
      <legend>article</legend>
      <h1 id="blob">Blob</h1>
<p><code>ArrayBuffer</code> 和视图（view）都是 ECMA 标准的一部分，是 JavaScript 的一部分。</p>
<p>在浏览器中，还有其他更高级的对象，特别是 <code>Blob</code>，在 <a href="https://www.w3.org/TR/FileAPI/">File API</a> 中有相关描述。</p>
<p><code>Blob</code> 由一个可选的字符串 <code>type</code>（通常是 MIME 类型）和 <code>blobParts</code> 组成 —— 一系列其他 <code>Blob</code> 对象，字符串和 <code>BufferSource</code>。</p>
<p><img src="blob.svg" alt=""></p>
<p>构造函数的语法为：</p>
<pre><code class="language-js"><span class="hljs-keyword">new</span> Blob(blobParts, options);</code></pre>
<ul>
<li><strong><code>blobParts</code></strong> 是 <code>Blob</code>/<code>BufferSource</code>/<code>String</code> 类型的值的数组。</li>
<li><strong><code>options</code></strong> 可选对象：<ul>
<li><strong><code>type</code></strong> —— <code>Blob</code> 类型，通常是 MIME 类型，例如 <code>image/png</code>，</li>
<li><strong><code>endings</code></strong> —— 是否转换换行符，使 <code>Blob</code> 对应于当前操作系统的换行符（<code>\r\n</code> 或 <code>\n</code>）。默认为 <code>&quot;transparent&quot;</code>（啥也不做），不过也可以是 <code>&quot;native&quot;</code>（转换）。</li>
</ul>
</li>
</ul>
<p>例如：</p>
<pre><code class="language-js"><span class="hljs-comment">// 从字符串创建 Blob</span>
<span class="hljs-keyword">let</span> blob = <span class="hljs-keyword">new</span> Blob([<span class="hljs-string">&quot;&lt;html&gt;…&lt;/html&gt;&quot;</span>], {<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;text/html&#x27;</span>});
<span class="hljs-comment">// 请注意：第一个参数必须是一个数组 [...]</span></code></pre>
<pre><code class="language-js"><span class="hljs-comment">// 从类型化数组（typed array）和字符串创建 Blob</span>
<span class="hljs-keyword">let</span> hello = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>([<span class="hljs-number">72</span>, <span class="hljs-number">101</span>, <span class="hljs-number">108</span>, <span class="hljs-number">108</span>, <span class="hljs-number">111</span>]); <span class="hljs-comment">// 二进制格式的 &quot;hello&quot; </span>

<span class="hljs-keyword">let</span> blob = <span class="hljs-keyword">new</span> Blob([hello, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>], {<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;text/plain&#x27;</span>});</code></pre>
<p>我们可以用 <code>slice</code> 方法来提取 <code>Blob</code> 片段：</p>
<pre><code class="language-js">blob.slice([byteStart], [byteEnd], [contentType]);</code></pre>
<ul>
<li><strong><code>byteStart</code></strong> —— 起始字节，默认为 0。</li>
<li><strong><code>byteEnd</code></strong> —— 最后一个字节（专有，默认为最后）。</li>
<li><strong><code>contentType</code></strong> —— 新 blob 的 <code>type</code>，默认与源 blob 相同。</li>
</ul>
<p>参数值类似于 <code>array.slice</code>，也允许是负数。</p>
<p>```smart header=&quot;<code>Blob</code> 对象是不可改变的&quot;
我们无法直接在 <code>Blob</code> 中更改数据，但我们可以通过 <code>slice</code> 获得 <code>Blob</code> 的多个部分，从这些部分创建新的 <code>Blob</code> 对象，将它们组成新的 <code>Blob</code>，等。</p>
<p>这种行为类似于 JavaScript 字符串：我们无法更改字符串中的字符，但可以生成一个新的改动过的字符串。</p>
<pre><code>
## Blob 用作 URL

Blob 可以很容易用作 `&lt;a&gt;`、`&lt;img&gt;` 或其他标签的 URL，来显示它们的内容。

多亏了 `type`，让我们也可以下载/上传 `Blob` 对象，而在网络请求中，`type` 自然地变成了 `Content-Type`。

让我们从一个简单的例子开始。通过点击链接，你可以下载一个具有动态生成的内容为 `hello world` 的 `Blob` 的文件：

```html
&lt;!-- download 特性（attribute）强制浏览器下载而不是导航 --&gt;
&lt;a download=&quot;hello.txt&quot; href=&#x27;#&#x27; id=&quot;link&quot;&gt;Download&lt;/a&gt;

&lt;script&gt;
let blob = new Blob([&quot;Hello, world!&quot;], {type: &#x27;text/plain&#x27;});

link.href = URL.createObjectURL(blob);
&lt;/script&gt;</code></pre>
<p>我们也可以在 Javascript 中动态创建一个链接，通过 <code>link.click()</code> 模拟一个点击，然后便自动下载了。</p>
<p>下面是类似的代码，此代码可以让用户无需任何 HTML 即可下载动态生成的 <code>Blob</code>（译注：也就是通过代码模拟用户点击，从而自动下载）：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> link = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;a&#x27;</span>);
link.download = <span class="hljs-string">&#x27;hello.txt&#x27;</span>;

<span class="hljs-keyword">let</span> blob = <span class="hljs-keyword">new</span> Blob([<span class="hljs-string">&#x27;Hello, world!&#x27;</span>], {<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;text/plain&#x27;</span>});

link.href = URL.createObjectURL(blob);

link.click();

URL.revokeObjectURL(link.href);</code></pre>
<p><code>URL.createObjectURL</code> 取一个 <code>Blob</code>，并为其创建一个唯一的 URL，形式为 <code>blob:&lt;origin&gt;/&lt;uuid&gt;</code>。</p>
<p>也就是 <code>link.href</code> 的值的样子：</p>
<pre><code>blob:https://javascript.info/1e67e00e-860d-40a5-89ae-6ab0cbee6273</code></pre>
<p>浏览器内部为每个通过 <code>URL.createObjectURL</code> 生成的 URL 存储了一个 URL -&gt; <code>Blob</code> 映射。因此，此类 URL 很短，但可以访问 <code>Blob</code>。</p>
<p>生成的 URL（即其链接）仅在当前文档打开的状态下才有效。它允许引用 <code>&lt;img&gt;</code>、<code>&lt;a&gt;</code> 中的 <code>Blob</code>，以及基本上任何其他期望 URL 的对象。</p>
<p>不过它有个副作用。虽然这里有 <code>Blob</code> 的映射，但 <code>Blob</code> 本身只保存在内存中的。浏览器无法释放它。</p>
<p>在文档退出时（unload），该映射会被自动清除，因此 <code>Blob</code> 也相应被释放了。但是，如果应用程序寿命很长，那这个释放就不会很快发生。</p>
<p><strong>因此，如果我们创建一个 URL，那么即使我们不再需要该 <code>Blob</code> 了，它也会被挂在内存中。</strong></p>
<p><code>URL.revokeObjectURL(url)</code> 从内部映射中移除引用，因此允许 <code>Blob</code> 被删除（如果没有其他引用的话），并释放内存。</p>
<p>在上面最后一个示例中，我们打算仅使用一次 <code>Blob</code>，来进行即时下载，因此我们立即调用 <code>URL.revokeObjectURL(link.href)</code>。</p>
<p>而在前一个带有可点击的 HTML 链接的示例中，我们不调用 <code>URL.revokeObjectURL(link.href)</code>，因为那样会使 <code>Blob</code> URL 无效。在调用该方法后，由于映射被删除了，因此该 URL 也就不再起作用了。</p>
<h2 id="blob-转换为-base64">Blob 转换为 base64</h2>
<p><code>URL.createObjectURL</code> 的一个替代方法是，将 <code>Blob</code> 转换为 base64-编码的字符串。</p>
<p>这种编码将二进制数据表示为一个由 0 到 64 的 ASCII 码组成的字符串，非常安全且“可读“。更重要的是 —— 我们可以在 &quot;data-url&quot; 中使用此编码。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs">&quot;data-url&quot;</a> 的形式为 <code>data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</code>。我们可以在任何地方使用这种 url，和使用“常规” url 一样。</p>
<p>例如，这是一个笑脸：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;data:image/png;base64,R0lGODlhDAAMAKIFAF5LAP/zxAAAANyuAP/gaP///wAAAAAAACH5BAEAAAUALAAAAAAMAAwAAAMlWLPcGjDKFYi9lxKBOaGcF35DhWHamZUW0K4mAbiwWtuf0uxFAgA7&quot;</span>&gt;</span></code></pre>
<p>浏览器将解码该字符串，并显示图像：<img src="data:image/png;base64,R0lGODlhDAAMAKIFAF5LAP/zxAAAANyuAP/gaP///wAAAAAAACH5BAEAAAUALAAAAAAMAAwAAAMlWLPcGjDKFYi9lxKBOaGcF35DhWHamZUW0K4mAbiwWtuf0uxFAgA7"></p>
<p>我们使用内建的 <code>FileReader</code> 对象来将 <code>Blob</code> 转换为 base64。它可以将 <code>Blob</code> 中的数据读取为多种格式。在<a href="info:file">下一章</a> 我们将更深入地介绍它。</p>
<p>下面是下载 <code>Blob</code> 的示例，这次是通过 base-64：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> link = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;a&#x27;</span>);
link.download = <span class="hljs-string">&#x27;hello.txt&#x27;</span>;

<span class="hljs-keyword">let</span> blob = <span class="hljs-keyword">new</span> Blob([<span class="hljs-string">&#x27;Hello, world!&#x27;</span>], {<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;text/plain&#x27;</span>});


<span class="hljs-keyword">let</span> reader = <span class="hljs-keyword">new</span> FileReader();
reader.readAsDataURL(blob); <span class="hljs-comment">// 将 Blob 转换为 base64 并调用 onload</span>


reader.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  link.href = reader.result; <span class="hljs-comment">// data url</span>
  link.click();
};</code></pre>
<p>这两种从 <code>Blob</code> 创建 URL 的方法都可以用。但通常 <code>URL.createObjectURL(blob)</code> 更简单快捷。</p>
<pre><code class="language-compare">+ 如果介意内存，我们需要撤销（revoke）它们
+ 直接访问 `Blob`，无需“编码/解码”
- 无需撤销（revoke）任何操作。
- 对大的 `Blob` 进行编码时，性能和内存会有损耗。</code></pre>
<h2 id="image-转换为-blob">Image 转换为 blob</h2>
<p>我们可以创建一个图像（image）的、图像的一部分、或者甚至创建一个页面截图的 <code>Blob</code>。这样方便将其上传至其他地方。</p>
<p>图像操作是通过 <code>&lt;canvas&gt;</code> 元素来实现的：</p>
<ol>
<li>使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage">canvas.drawImage</a> 在 canvas 上绘制图像（或图像的一部分）。</li>
<li>调用 canvas 方法 <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob">.toBlob(callback, format, quality)</a> 创建一个 <code>Blob</code>，并在创建完成后使用其运行 <code>callback</code>。</li>
</ol>
<p>在下面这个示例中，图像只是被复制了，不过我们可以在创建 blob 之前，从中裁剪图像，或者在 canvas 上对其进行转换：</p>
<pre><code class="language-js"><span class="hljs-comment">// 获取任何图像</span>
<span class="hljs-keyword">let</span> img = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;img&#x27;</span>);

<span class="hljs-comment">// 生成同尺寸的 &lt;canvas&gt;</span>
<span class="hljs-keyword">let</span> canvas = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;canvas&#x27;</span>);
canvas.width = img.clientWidth;
canvas.height = img.clientHeight;

<span class="hljs-keyword">let</span> context = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);

<span class="hljs-comment">// 向其中复制图像（此方法允许剪裁图像）</span>
context.drawImage(img, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-comment">// 我们 context.rotate()，并在 canvas 上做很多其他事情</span>

<span class="hljs-comment">// toBlob 是异步操作，结束后会调用 callback</span>
canvas.toBlob(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">blob</span>) </span>{
  <span class="hljs-comment">// blob 创建完成，下载它</span>
  <span class="hljs-keyword">let</span> link = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;a&#x27;</span>);
  link.download = <span class="hljs-string">&#x27;example.png&#x27;</span>;

  link.href = URL.createObjectURL(blob);
  link.click();

  <span class="hljs-comment">// 删除内部 blob 引用，这样浏览器可以从内存中将其清除</span>
  URL.revokeObjectURL(link.href);
}, <span class="hljs-string">&#x27;image/png&#x27;</span>);</code></pre>
<p>如果我们更喜欢 <code>async/await</code> 而不是 callback：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> blob = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> canvasElem.toBlob(resolve, <span class="hljs-string">&#x27;image/png&#x27;</span>));</code></pre>
<p>对于页面截屏，我们可以使用诸如 <a href="https://github.com/niklasvh/html2canvas">https://github.com/niklasvh/html2canvas</a> 之类的库。它所做的只是扫一遍浏览器页面，并将其绘制在 <code>&lt;canvas&gt;</code> 上。然后，我们就可以像上面一样获取一个它的 <code>Blob</code>。</p>
<h2 id="blob-转换为-arraybuffer">Blob 转换为 ArrayBuffer</h2>
<p><code>Blob</code> 构造器允许从几乎所有东西创建 blob，包括任何 <code>BufferSource</code>。</p>
<p>但是，如果我们需要执行低级别的操作的话，则可以使用 <code>FileReader</code> 从 blob 中获取最低级别的 <code>ArrayBuffer</code>：</p>
<pre><code class="language-js"><span class="hljs-comment">// 从 blob 获取 arrayBuffer</span>
<span class="hljs-keyword">let</span> fileReader = <span class="hljs-keyword">new</span> FileReader();


fileReader.readAsArrayBuffer(blob);


fileReader.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
  <span class="hljs-keyword">let</span> arrayBuffer = fileReader.result;
};</code></pre>
<h2 id="总结">总结</h2>
<p><code>ArrayBuffer</code>，<code>Uint8Array</code> 及其他 <code>BufferSource</code> 是“二进制数据”，而 <a href="https://www.w3.org/TR/FileAPI/#dfn-Blob">Blob</a> 则表示“具有类型的二进制数据”。</p>
<p>这样可以方便 <code>Blob</code> 用于在浏览器中非常常见的上传/下载操作。</p>
<p><a href="info:xmlhttprequest">XMLHttpRequest</a>，<a href="info:fetch">fetch</a> 等进行 Web 请求的方法可以自然地使用 <code>Blob</code>，也可以使用其他类型的二进制数据。</p>
<p>我们可以轻松地在 <code>Blob</code> 和低级别的二进制数据类型之间进行转换：</p>
<ul>
<li>我们可以使用 <code>new Blob(...)</code> 构造函数从一个类型化数组（typed array）创建 <code>Blob</code>。</li>
<li>我们可以使用 <code>FileReader</code> 从 <code>Blob</code> 中取回 <code>ArrayBuffer</code>，然后在其上创建一个视图（view），用于低级别的二进制处理。</li>
</ul>

      </fieldset>
      
      <fieldset id='_SKRLnC'>
      <legend>article</legend>
      <h1 id="file-和-filereader">File 和 FileReader</h1>
<p><a href="https://www.w3.org/TR/FileAPI/#dfn-file">File</a> 对象继承自 <code>Blob</code>，并扩展了与文件系统相关的功能。 </p>
<p>有两种方式可以获取它。</p>
<p>第一种，与 <code>Blob</code> 类似，有一个构造器：</p>
<pre><code class="language-js"><span class="hljs-keyword">new</span> File(fileParts, fileName, [options])</code></pre>
<ul>
<li><strong><code>fileParts</code></strong> —— Blob/BufferSource/String 类型值的数组。</li>
<li><strong><code>fileName</code></strong> —— 文件名字符串。</li>
<li><strong><code>options</code></strong> —— 可选对象：<ul>
<li><strong><code>lastModified</code></strong> —— 最后一次修改的时间戳（整数日期）。</li>
</ul>
</li>
</ul>
<p>第二种，更常见的是，我们从 <code>&lt;input type=&quot;file&quot;&gt;</code> 或拖放或其他浏览器接口来获取文件。在这种情况下，file 将从操作系统（OS）获得 this 信息。</p>
<p>由于 <code>File</code> 是继承自 <code>Blob</code> 的，所以 <code>File</code> 对象具有相同的属性，附加：</p>
<ul>
<li><code>name</code> —— 文件名，</li>
<li><code>lastModified</code> —— 最后一次修改的时间戳。</li>
</ul>
<p>这就是我们从 <code>&lt;input type=&quot;file&quot;&gt;</code> 中获取 <code>File</code> 对象的方式：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">onchange</span>=<span class="hljs-string">&quot;showFile(this)&quot;</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showFile</span>(<span class="hljs-params">input</span>) </span>{
  <span class="hljs-keyword">let</span> file = input.files[<span class="hljs-number">0</span>];

  alert(<span class="hljs-string">`File name: <span class="hljs-subst">${file.name}</span>`</span>); <span class="hljs-comment">// 例如 my.png</span>
  alert(<span class="hljs-string">`Last modified: <span class="hljs-subst">${file.lastModified}</span>`</span>); <span class="hljs-comment">// 例如 1552830408824</span>
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<pre><code class="language-smart">输入（input）可以选择多个文件，因此 `input.files` 是一个类数组对象。这里我们只有一个文件，所以我们只取 `input.files[0]`。</code></pre>
<h2 id="filereader">FileReader</h2>
<p><a href="https://www.w3.org/TR/FileAPI/#dfn-filereader">FileReader</a> 是一个对象，其唯一目的是从 <code>Blob</code>（因此也从 <code>File</code>）对象中读取数据。</p>
<p>它使用事件来传递数据，因为从磁盘读取数据可能比较费时间。</p>
<p>构造函数：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> reader = <span class="hljs-keyword">new</span> FileReader(); <span class="hljs-comment">// 没有参数</span></code></pre>
<p>主要方法:</p>
<ul>
<li><strong><code>readAsArrayBuffer(blob)</code></strong> —— 将数据读取为二进制格式的 <code>ArrayBuffer</code>。</li>
<li><strong><code>readAsText(blob, [encoding])</code></strong> —— 将数据读取为给定编码（默认为 <code>utf-8</code> 编码）的文本字符串。</li>
<li><strong><code>readAsDataURL(blob)</code></strong> —— 读取二进制数据，并将其编码为 base64 的 data url。</li>
<li><strong><code>abort()</code></strong> —— 取消操作。</li>
</ul>
<p><code>read*</code> 方法的选择，取决于我们喜欢哪种格式，以及如何使用数据。</p>
<ul>
<li><code>readAsArrayBuffer</code> —— 用于二进制文件，执行低级别的二进制操作。对于诸如切片（slicing）之类的高级别的操作，<code>File</code> 是继承自 <code>Blob</code> 的，所以我们可以直接调用它们，而无需读取。</li>
<li><code>readAsText</code> —— 用于文本文件，当我们想要获取字符串时。</li>
<li><code>readAsDataURL</code> —— 当我们想在 <code>src</code> 中使用此数据，并将其用于 <code>img</code> 或其他标签时。正如我们在  <a href="info:blob">info:blob</a> 一章中所讲的，还有一种用于此的读取文件的替代方案：<code>URL.createObjectURL(file)</code>。</li>
</ul>
<p>读取过程中，有以下事件：</p>
<ul>
<li><code>loadstart</code> —— 开始加载。</li>
<li><code>progress</code> —— 在读取过程中出现。</li>
<li><code>load</code> —— 读取完成，没有 error。</li>
<li><code>abort</code> —— 调用了 <code>abort()</code>。</li>
<li><code>error</code> —— 出现 error。</li>
<li><code>loadend</code> —— 读取完成，无论成功还是失败。</li>
</ul>
<p>读取完成后，我们可以通过以下方式访问读取结果：</p>
<ul>
<li><code>reader.result</code> 是结果（如果成功）</li>
<li><code>reader.error</code> 是 error（如果失败）。</li>
</ul>
<p>使用最广泛的事件无疑是 <code>load</code> 和 <code>error</code>。</p>
<p>这是一个读取文件的示例：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">onchange</span>=<span class="hljs-string">&quot;readFile(this)&quot;</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readFile</span>(<span class="hljs-params">input</span>) </span>{
  <span class="hljs-keyword">let</span> file = input.files[<span class="hljs-number">0</span>];

  <span class="hljs-keyword">let</span> reader = <span class="hljs-keyword">new</span> FileReader();

  reader.readAsText(file);

  reader.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(reader.result);
  };

  reader.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(reader.error);
  };

}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>```smart header=&quot;<code>FileReader</code> 用于 blob&quot;
正如我们在 <a href="info:blob">info:blob</a> 一章中所提到的，<code>FileReader</code> 不仅可读取文件，还可读取任何 blob。</p>
<p>我们可以使用它将 blob 转换为其他格式：</p>
<ul>
<li><code>readAsArrayBuffer(blob)</code> —— 转换为 <code>ArrayBuffer</code>，</li>
<li><code>readAsText(blob, [encoding])</code> —— 转换为字符串（<code>TextDecoder</code> 的一个替代方案），</li>
<li><code>readAsDataURL(blob)</code> —— 转换为 base64 的 data url。<pre><code>
</code></pre>
</li>
</ul>
<p>```smart header=&quot;在 Web Workers 中可以使用 <code>FileReaderSync</code>&quot;
对于 Web Worker，还有一种同步的 <code>FileReader</code> 变体，称为 <a href="https://www.w3.org/TR/FileAPI/#FileReaderSync">FileReaderSync</a>。</p>
<p>它的读取方法 <code>read*</code> 不会生成事件，但是会像常规函数那样返回一个结果。</p>
<p>不过，这仅在 Web Worker 中可用，因为在读取文件的时候，同步调用会有延迟，而在 Web Worker 中，这种延迟并不是很重要。它不会影响页面。</p>
<pre><code>
## 总结

`File` 对象继承自 `Blob`。

除了 `Blob` 方法和属性外，`File` 对象还有 `name` 和 `lastModified` 属性，以及从文件系统读取的内部功能。我们通常从用户输入如 `&lt;input&gt;` 或拖放事件来获取 `File` 对象。

`FileReader` 对象可以从文件或 blob 中读取数据，可以读取为以下三种格式：
- 字符串（`readAsText`）。
- `ArrayBuffer`（`readAsArrayBuffer`）。
- data url，base-64 编码（`readAsDataURL`）。

但是，在很多情况下，我们不必读取文件内容。就像我们处理 blob 一样，我们可以使用 `URL.createObjectURL(file)` 创建一个短的 url，并将其赋给 `&lt;a&gt;` 或 `&lt;img&gt;`。这样，文件便可以下载文件或者将其呈现为图像，作为 canvas 等的一部分。

而且，如果我们要通过网络发送一个 `File`，那也很容易：像 `XMLHttpRequest` 或 `fetch` 等网络 API 本身就接受 `File` 对象。</code></pre>

      </fieldset>
      </div><div id="nav"><div style="margin-left:0em"><strong>arraybuffer-binary-arrays</strong><br/></div><div style="margin-left:1em"><strong>concat</strong><br/></div><div style="margin-left:2em"><a href="#_VzlfgQ">solution</a><br/></div><div style="margin-left:2em"><a href="#_0DmaEP">task</a><br/></div><div style="margin-left:1em"><a href="#_5O6DBP">article</a><br/></div><div style="margin-left:0em"><strong>text-decoder</strong><br/></div><div style="margin-left:1em"><a href="#_vJH4hB">article</a><br/></div><div style="margin-left:0em"><strong>blob</strong><br/></div><div style="margin-left:1em"><a href="#_9mVnZI">article</a><br/></div><div style="margin-left:0em"><strong>file</strong><br/></div><div style="margin-left:1em"><a href="#_SKRLnC">article</a><br/></div></div>
</body></html>