<p>使用循环的解法：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sumTo</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {
    sum += i;
  }
  <span class="hljs-keyword">return</span> sum;
}

alert( sumTo(<span class="hljs-number">100</span>) );</code></pre>
<p>使用递归的解法：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sumTo</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  <span class="hljs-keyword">return</span> n + sumTo(n - <span class="hljs-number">1</span>);
}

alert( sumTo(<span class="hljs-number">100</span>) );</code></pre>
<p>使用公式 <code>sumTo(n) = n*(n+1)/2</code> 的解法：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sumTo</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">return</span> n * (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
}

alert( sumTo(<span class="hljs-number">100</span>) );</code></pre>
<p>P.S. 当然是公式解法最快。对任何数字 <code>n</code>，只需要进行 3 次运算。数学大法好！</p>
<p>循环的速度次之。在循环和递归方法里，我们对相同的数字求和。但是递归涉及嵌套调用和执行堆栈管理。这也会占用资源，因此递归的速度更慢一些。</p>
<p>P.P.S. 一些引擎支持“尾调用（tail call）”优化：如果递归调用是函数中的最后一个调用（例如上面的 <code>sumTo</code>），那么外部的函数就不再需要恢复执行，因此引擎也就不再需要记住他的执行上下文。这样就减轻了内存负担，因此计算 <code>sumTo(100000)</code> 就变得可能。但是如果你的 JavaScript 引擎不支持尾调用优化，那就会报错：超出最大堆栈深度，因为通常总堆栈的大小是有限制的。</p>
