<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>create for ggdoc , @author sunyi</title>
    <style>
        .octicon{display:inline-block;fill:currentColor;vertical-align:text-bottom}
        .anchor{float:left;line-height:1;margin-left:-20px;padding-right:4px}
        .anchor:focus{outline:0}
        h1 .octicon-link,h2 .octicon-link,h3 .octicon-link,h4 .octicon-link,h5 .octicon-link,h6 .octicon-link{color:#1b1f23;vertical-align:middle;visibility:hidden}
        h1:hover .anchor,h2:hover .anchor,h3:hover .anchor,h4:hover .anchor,h5:hover .anchor,h6:hover .anchor{text-decoration:none}
        h1:hover .anchor .octicon-link,h2:hover .anchor .octicon-link,h3:hover .anchor .octicon-link,h4:hover .anchor .octicon-link,h5:hover .anchor .octicon-link,h6:hover .anchor .octicon-link{visibility:visible}
        h1:hover .anchor .octicon-link:before,h2:hover .anchor .octicon-link:before,h3:hover .anchor .octicon-link:before,h4:hover .anchor .octicon-link:before,h5:hover .anchor .octicon-link:before,h6:hover .anchor .octicon-link:before{width:16px;height:16px;content:" ";display:inline-block;background-image:url("data:image/svg+xml,%3Csvgxmlns='http://www.w3.org/2000/svg'viewBox='001616'version='1.1'width='16'height='16'aria-hidden='true'%3E%3Cpathfill-rule='evenodd'd='M49h1v1H4c-1.50-3-1.69-3-3.5S2.55343h4c1.45031.6933.501.41-.912.72-23.25V8.59c.58-.451-1.271-2.09C105.228.98484H4c-.980-21.22-22.5S3949zm9-3h-1v1h1c1021.2222.5S13.98121312H9c-.980-2-1.22-2-2.50-.83.42-1.641-2.09V6.25c-1.09.53-21.84-23.25C611.317.5513913h4c1.4503-1.693-3.5S14.56136z'%3E%3C/path%3E%3C/svg%3E")}
        body{-webkit-text-size-adjust:100%;line-height:1.5;color:#24292e;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji;font-size:16px;line-height:1.5;word-wrap:break-word;background-color:#e3e3ef;height:100%;width:100%;margin:0;padding:20px}
        details{display:block}
        summary{display:list-item}
        a{background-color:initial}
        a:active,a:hover{outline-width:0}
        strong{font-weight:inherit;font-weight:bolder}
        h1{font-size:2em;margin:.67em 0}
        img{border-style:none}
        code,kbd,pre{font-family:monospace,monospace;font-size:1em}
        hr{box-sizing:initial;height:0;overflow:visible}
        input{font:inherit;margin:0}
        input{overflow:visible}
        [type="checkbox"]{box-sizing:border-box;padding:0}
        *{box-sizing:border-box}
        input{font-family:inherit;font-size:inherit;line-height:inherit}
        a{color:#0366d6;text-decoration:none}
        a:hover{text-decoration:underline}
        strong{font-weight:600}
        hr{height:0;margin:15px 0;overflow:hidden;background:transparent;border:0;border-bottom:1px solid #dfe2e5}
        hr:after,hr:before{display:table;content:""}
        hr:after{clear:both}
        table{border-spacing:0;border-collapse:collapse}
        td,th{padding:0}
        details summary{cursor:pointer}
        kbd{display:inline-block;padding:3px 5px;font:11px SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;line-height:10px;color:#444d56;vertical-align:middle;background-color:#fafbfc;border:1px solid #d1d5da;border-radius:3px;box-shadow:inset 0 -1px 0 #d1d5da}
        h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:0}
        h1{font-size:32px}
        h1,h2{font-weight:600}
        h2{font-size:24px}
        h3{font-size:20px}
        h3,h4{font-weight:600}
        h4{font-size:16px}
        h5{font-size:14px}
        h5,h6{font-weight:600}
        h6{font-size:12px}
        p{margin-top:0;margin-bottom:10px}
        blockquote{margin:0}
        ol,ul{padding-left:0;margin-top:0;margin-bottom:0}
        ol ol,ul ol{list-style-type:lower-roman}
        ol ol ol,ol ul ol,ul ol ol,ul ul ol{list-style-type:lower-alpha}
        dd{margin-left:0}
        code,pre{font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:12px}
        pre{margin-top:0;margin-bottom:0}
        input::-webkit-inner-spin-button,input::-webkit-outer-spin-button{margin:0;-webkit-appearance:none;appearance:none}
        :checked+.radio-label{position:relative;z-index:1;border-color:#0366d6}
        .border{border:1px solid #e1e4e8!important}
        .border-0{border:0!important}
        .border-bottom{border-bottom:1px solid #e1e4e8!important}
        .rounded-1{border-radius:3px!important}
        .bg-white{background-color:#fff!important}
        .bg-gray-light{background-color:#fafbfc!important}
        .text-gray-light{color:#6a737d!important}
        .mb-0{margin-bottom:0!important}
        .my-2{margin-top:8px!important;margin-bottom:8px!important}
        .pl-0{padding-left:0!important}
        .py-0{padding-top:0!important;padding-bottom:0!important}
        .pl-1{padding-left:4px!important}
        .pl-2{padding-left:8px!important}
        .py-2{padding-top:8px!important;padding-bottom:8px!important}
        .pl-3,.px-3{padding-left:16px!important}
        .px-3{padding-right:16px!important}
        .pl-4{padding-left:24px!important}
        .pl-5{padding-left:32px!important}
        .pl-6{padding-left:40px!important}
        .f6{font-size:12px!important}
        .lh-condensed{line-height:1.25!important}
        .text-bold{font-weight:600!important}
        .pl-c{color:#6a737d}
        .pl-c1,.pl-s .pl-v{color:#005cc5}
        .pl-e,.pl-en{color:#6f42c1}
        .pl-s .pl-s1,.pl-smi{color:#24292e}
        .pl-ent{color:#22863a}
        .pl-k{color:#d73a49}
        .pl-pds,.pl-s,.pl-s .pl-pse .pl-s1,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre{color:#032f62}
        .pl-smw,.pl-v{color:#e36209}
        .pl-bu{color:#b31d28}
        .pl-ii{color:#fafbfc;background-color:#b31d28}
        .pl-c2{color:#fafbfc;background-color:#d73a49}
        .pl-c2:before{content:"^M"}
        .pl-sr .pl-cce{font-weight:700;color:#22863a}
        .pl-ml{color:#735c0f}
        .pl-mh,.pl-mh .pl-en,.pl-ms{font-weight:700;color:#005cc5}
        .pl-mi{font-style:italic;color:#24292e}
        .pl-mb{font-weight:700;color:#24292e}
        .pl-md{color:#b31d28;background-color:#ffeef0}
        .pl-mi1{color:#22863a;background-color:#f0fff4}
        .pl-mc{color:#e36209;background-color:#ffebda}
        .pl-mi2{color:#f6f8fa;background-color:#005cc5}
        .pl-mdr{font-weight:700;color:#6f42c1}
        .pl-ba{color:#586069}
        .pl-sg{color:#959da5}
        .pl-corl{text-decoration:underline;color:#032f62}
        .mb-0{margin-bottom:0!important}
        .my-2{margin-bottom:8px!important}
        .my-2{margin-top:8px!important}
        .pl-0{padding-left:0!important}
        .py-0{padding-top:0!important;padding-bottom:0!important}
        .pl-1{padding-left:4px!important}
        .pl-2{padding-left:8px!important}
        .py-2{padding-top:8px!important;padding-bottom:8px!important}
        .pl-3{padding-left:16px!important}
        .pl-4{padding-left:24px!important}
        .pl-5{padding-left:32px!important}
        .pl-6{padding-left:40px!important}
        .pl-7{padding-left:48px!important}
        .pl-8{padding-left:64px!important}
        .pl-9{padding-left:80px!important}
        .pl-10{padding-left:96px!important}
        .pl-11{padding-left:112px!important}
        .pl-12{padding-left:128px!important}
        hr{border-bottom-color:#eee}
        kbd{display:inline-block;padding:3px 5px;font:11px SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;line-height:10px;color:#444d56;vertical-align:middle;background-color:#fafbfc;border:1px solid #d1d5da;border-radius:3px;box-shadow:inset 0 -1px 0 #d1d5da}
        .markdown-body:after,.markdown-body:before{display:table;content:""}
        .markdown-body:after{clear:both}
        .markdown-body>:first-child{margin-top:0!important}
        .markdown-body>:last-child{margin-bottom:0!important}
        a:not([href]){color:inherit;text-decoration:none}
        blockquote,details,dl,ol,p,pre,table,ul{margin-top:0;margin-bottom:16px}
        hr{height:.25em;padding:0;margin:24px 0;background-color:#e1e4e8;border:0}
        blockquote{padding:0 1em;color:#6a737d;border-left:.25em solid #dfe2e5}
        blockquote>:first-child{margin-top:0}
        blockquote>:last-child{margin-bottom:0}
        h1,h2,h3,h4,h5,h6{margin-top:24px;margin-bottom:16px;font-weight:600;line-height:1.25}
        h1{font-size:2em}
        h1,h2{padding-bottom:.3em;border-bottom:1px solid #eaecef}
        h2{font-size:1.5em}
        h3{font-size:1.25em}
        h4{font-size:1em}
        h5{font-size:.875em}
        h6{font-size:.85em;color:#6a737d}
        ol,ul{padding-left:2em}
        ol ol,ol ul,ul ol,ul ul{margin-top:0;margin-bottom:0}
        li{word-wrap:break-all}
        li>p{margin-top:16px}
        li+li{margin-top:.25em}
        dl{padding:0}
        dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:600}
        dl dd{padding:0 16px;margin-bottom:16px}
        table{display:block;width:100%;overflow:auto}
        table th{font-weight:600}
        table td,table th{padding:6px 13px;border:1px solid #dfe2e5}
        table tr{background-color:#fff;border-top:1px solid #c6cbd1}
        table tr:nth-child(2n){background-color:#f6f8fa}
        img{max-width:100%;box-sizing:initial;background-color:#fff}
        img[align="right"]{padding-left:20px}
        img[align="left"]{padding-right:20px}
        code{padding:.2em .4em;margin:0;font-size:85%;background-color:rgba(27,31,35,0.05);border-radius:3px}
        pre{word-wrap:normal}
        pre>code{padding:0;margin:0;font-size:100%;word-break:normal;white-space:pre;background:transparent;border:0}
        .highlight{margin-bottom:16px}
        .highlight pre{margin-bottom:0;word-break:normal}
        .highlight pre,pre{padding:16px;overflow:auto;font-size:85%;line-height:1.45;background-color:#f6f8fa;border-radius:3px}
        pre code{display:inline;max-width:auto;padding:0;margin:0;overflow:visible;line-height:inherit;word-wrap:normal;background-color:initial;border:0}
        .commit-tease-sha{display:inline-block;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:90%;color:#444d56}
        .full-commit .btn-outline:not(:disabled):hover{color:#005cc5;border-color:#005cc5}
        .blob-wrapper{overflow-x:auto;overflow-y:hidden}
        .blob-wrapper-embedded{max-height:240px;overflow-y:auto}
        .blob-num{width:1%;min-width:50px;padding-right:10px;padding-left:10px;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:12px;line-height:20px;color:rgba(27,31,35,0.3);text-align:right;white-space:nowrap;vertical-align:top;cursor:pointer;user-select:none}
        .blob-num:hover{color:rgba(27,31,35,0.6)}
        .blob-num:before{content:attr(data-line-number)}
        .blob-code{position:relative;padding-right:10px;padding-left:10px;line-height:20px;vertical-align:top}
        .blob-code-inner{overflow:visible;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:12px;color:#24292e;word-wrap:normal;white-space:pre}
        .pl-token.active,.pl-token:hover{cursor:pointer;background:#ffea7f}
        .tab-size[data-tab-size="1"]{-moz-tab-size:1;tab-size:1}
        .tab-size[data-tab-size="2"]{-moz-tab-size:2;tab-size:2}
        .tab-size[data-tab-size="3"]{-moz-tab-size:3;tab-size:3}
        .tab-size[data-tab-size="4"]{-moz-tab-size:4;tab-size:4}
        .tab-size[data-tab-size="5"]{-moz-tab-size:5;tab-size:5}
        .tab-size[data-tab-size="6"]{-moz-tab-size:6;tab-size:6}
        .tab-size[data-tab-size="7"]{-moz-tab-size:7;tab-size:7}
        .tab-size[data-tab-size="8"]{-moz-tab-size:8;tab-size:8}
        .tab-size[data-tab-size="9"]{-moz-tab-size:9;tab-size:9}
        .tab-size[data-tab-size="10"]{-moz-tab-size:10;tab-size:10}
        .tab-size[data-tab-size="11"]{-moz-tab-size:11;tab-size:11}
        .tab-size[data-tab-size="12"]{-moz-tab-size:12;tab-size:12}
        .task-list-item{list-style-type:none}
        .task-list-item+.task-list-item{margin-top:3px}
        .task-list-item input{margin:0 .2em .25em -1.6em;vertical-align:middle}
        #page{width:calc(100% - 300px);margin-left:300px}
        fieldset{display:none;background-color:#fff;border:0;overflow:hidden;box-shadow:2px 2px 10px rgba(128,128,128,0.2);margin-bottom:20px;padding:20px}
        fieldset legend{font-weight:bold;color:green;height:3.5em;margin-left:-20px;padding:0}
        #nav{background:rgb(255 255 255 / .6);padding:40px;position:fixed;top:0;left:0;bottom:0;width:300px;overflow-y:auto}
        ::-webkit-scrollbar{width:5px}
        ::-webkit-scrollbar-thumb{background-color:#79a5e8}
        @media print,(max-width:900px){
          #nav{display:none!important}
          #page{width:100%!important;margin-left:0!important}
          fieldset{display:block!important;box-shadow:none!important}
          .toggle-hash-btn {display: none !important;}
        }
        .hljs{display:block;overflow-x:auto;padding:.5em;color:#333;background:#f8f8f8}
        .hljs-comment,.hljs-quote{color:#998;font-style:italic}
        .hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:bold}
        .hljs-number,.hljs-literal,.hljs-variable,.hljs-template-variable,.hljs-tag .hljs-attr{color:#008080}
        .hljs-string,.hljs-doctag{color:#d14}
        .hljs-title,.hljs-section,.hljs-selector-id{color:#900;font-weight:bold}
        .hljs-subst{font-weight:normal}
        .hljs-type,.hljs-class .hljs-title{color:#458;font-weight:bold}
        .hljs-tag,.hljs-name,.hljs-attribute{color:#000080;font-weight:normal}
        .hljs-regexp,.hljs-link{color:#009926}
        .hljs-symbol,.hljs-bullet{color:#990073}
        .hljs-built_in,.hljs-builtin-name{color:#0086b3}
        .hljs-meta{color:#999;font-weight:bold}
        .hljs-deletion{background:#fdd}
        .hljs-addition{background:#dfd}
        .hljs-emphasis{font-style:italic}
        .hljs-strong{font-weight:bold}
        .toggle-hash-btn {position: fixed;bottom: 10px;left:10px;z-index: 1000; display: flex; justify-content: space-between;  width: 270px;}
    </style>
    <script>
          const $ = selector => document.querySelector(selector);
          const $$ = selector => document.querySelectorAll(selector);
          const decode = s => decodeURIComponent(s);
          const domInfo = dom => ({
            offsetParent: dom.offsetParent.className,
            offsetLeft: dom.offsetLeft,
            offsetTop: dom.offsetTop,
            clientWidth: dom.clientWidth,
            offsetWidth: dom.offsetWidth,
            BoundingClientRect: dom.getBoundingClientRect(),
          });
          let openHash = false;
          function viewFieldset() {
            const hash = decode(location.hash);
            if(openHash && hash &&$(`fieldset${hash}`)) {
              Array.from($$('fieldset')).forEach(dom  =>dom.style.display = 'none');
              $(`fieldset${hash}`).style.display = 'block';
            }else {
              Array.from($$('fieldset')).forEach(dom  =>dom.style.display = 'block');
            }
          }
          window.onhashchange = viewFieldset;
          window.onload  = ()=>{
            viewFieldset();
            setATarget();
          };
          
          function toggleHash() {
            openHash = !openHash;
            viewFieldset();
            $('.toggle-hash-btn button').innerText = openHash ? '关闭专注模式' : '开启专注模式';
          }
          function setATarget() {
            $$('#page a').forEach(a=>a.target = '_blank');
          }
    </script>
</head>

<body>
  <div class="toggle-hash-btn">
    <button  onclick="toggleHash()">开启专注模式</button>
     <a target='_blank' href="https://github.com/liaojunjun/ggdoc"><svg class="octicon octicon-mark-github v-align-middle" height="25" viewBox="0 0 16 16" version="1.1" width="32" aria-hidden="true"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path></svg></a>
  </div><div id="page">
      <fieldset id='_11l8CW'>
      <legend>article</legend>
      <h1 id="贝塞尔曲线">贝塞尔曲线</h1>
<p>贝塞尔曲线用于计算机图形绘制形状，CSS 动画和许多其他地方。</p>
<p>它们其实非常简单，值得学习一次并且在矢量图形和高级动画的世界里非常受用。</p>
<h2 id="控制点">控制点</h2>
<p><a href="https://en.wikipedia.org/wiki/B%C3%A9zier_curve">贝塞尔曲线</a>由控制点定义。</p>
<p>这些点可能有 2、3、4 或更多。</p>
<p>例如，两点曲线：</p>
<p><img src="bezier2.svg" alt=""></p>
<p>三点曲线：</p>
<p><img src="bezier3.svg" alt=""></p>
<p>四点曲线：</p>
<p><img src="bezier4.svg" alt=""></p>
<p>如果仔细观察这些曲线，你会立即注意到：</p>
<ol>
<li><p><strong>控制点不总是在曲线上</strong>这是非常正常的，稍后我们将看到曲线是如何构建的。</p>
</li>
<li><p><strong>曲线的阶次等于控制点的数量减一</strong>。
对于两个点我们能得到一条线性曲线（直线），三个点 — 一条二阶曲线，四个点 — 一条三阶曲线。</p>
</li>
<li><p><strong>曲线总是在控制点的<a href="https://en.wikipedia.org/wiki/Convex_hull">凸包</a>内部：</strong></p>
<p> <img src="bezier4-e.svg" alt=""> <img src="bezier3-e.svg" alt=""></p>
</li>
</ol>
<p>由于最后一个属性，在计算机图形学中，可以优化相交测试。如果凸包不相交，则曲线也不相交。因此，首先检查凸包的交叉点可以非常快地给出“无交叉”结果。检查交叉区域或凸包更容易，因为它们是矩形，三角形等（见上图），比曲线简单的多。</p>
<p>贝塞尔曲线绘制的主要重点 —— 通过移动曲线，曲线<strong>以直观明显的</strong>方式变化。</p>
<p>尝试在下面的示例中使用鼠标移动控制点：</p>
<p>[iframe src=&quot;demo.svg?nocpath=1&amp;p=0,0,0.5,0,0.5,1,1,1&quot; height=370]</p>
<p><strong>可以注意到，曲线沿切线 1 -&gt; 2 和 3 -&gt; 4 延伸。</strong></p>
<p>经过一些练习后，很明显我们知道怎样通过放置控制点来获得所需要的曲线。通过连接几条曲线，我们几乎可以得到任何东西。</p>
<p>这里有一些例子：</p>
<p><img src="bezier-car.svg" alt=""> <img src="bezier-letter.svg" alt=""> <img src="bezier-vase.svg" alt=""></p>
<h2 id="数学">数学</h2>
<p>贝塞尔曲线可以使用数学方程式来描述。</p>
<p>很快我们就能看到 —— 没必要知道它。但是为了完整性 —— 请看这里。</p>
<p>给定控制点 <code>P<sub>i</sub></code> 的坐标：第一个控制点的坐标为 <code>P<sub>1</sub> = (x<sub>1</sub>, y<sub>1</sub>)</code>，第二个控制点的坐标为 <code>P<sub>2</sub> = (x<sub>2</sub>, y<sub>2</sub>)</code>，以此类推，曲线坐标由方程式描述，这个方程式依赖属于区间 <code>[0,1]</code> 的参数 <code>t</code>。</p>
<ul>
<li><p>有两个控制点的曲线方程：</p>
<p>  <code>P = (1-t)P<sub>1</sub> + tP<sub>2</sub></code></p>
</li>
<li><p>有三个控制点的曲线方程：</p>
<p>  <code>P = (1−t)<sup>2</sup>P<sub>1</sub> + 2(1−t)tP<sub>2</sub> + t<sup>2</sup>P<sub>3</sub></code></p>
</li>
<li><p>有四个控制点的曲线方程：</p>
<p>  <code>P = (1−t)<sup>3</sup>P<sub>1</sub> + 3(1−t)<sup>2</sup>tP<sub>2</sub>  +3(1−t)t<sup>2</sup>P<sub>3</sub> + t<sup>3</sup>P<sub>4</sub></code></p>
</li>
</ul>
<p>这些是矢量方程。</p>
<p>我们可以逐坐标重写它们，例如 3 点曲线：</p>
<ul>
<li><code>x = (1−t)<sup>2</sup>x<sub>1</sub> + 2(1−t)tx<sub>2</sub> + t<sup>2</sup>x<sub>3</sub></code></li>
<li><code>y = (1−t)<sup>2</sup>y<sub>1</sub> + 2(1−t)ty<sub>2</sub> + t<sup>2</sup>y<sub>3</sub></code></li>
</ul>
<p>我们应该放置 3 个控制点的坐标，而不是 <code>x<sub>1</sub>、y<sub>1</sub>、x<sub>2</sub>、y<sub>2</sub>、x<sub>3</sub> 和 y<sub>3</sub></code>。</p>
<p>例如，如果控制点是 <code>(0,0)</code>、<code>(0.5, 1)</code> 和 <code>(1, 0)</code>，则方程式为：</p>
<ul>
<li><code>x = (1−t)<sup>2</sup> * 0 + 2(1−t)t * 0.5 + t<sup>2</sup> * 1 = (1-t)t + t<sup>2</sup> = t</code></li>
<li><code>y = (1−t)<sup>2</sup> * 0 + 2(1−t)t * 1 + t<sup>2</sup> * 0 = 2(1-t)t = –t<sup>2</sup> + 2t</code></li>
</ul>
<p>现在随着 <code>t</code> 从 <code>0</code> 到 <code>1</code> 变化，每个 <code>t</code> 对应的 <code>(x,y)</code> 集合可以构成曲线。</p>
<p>这可能太学术化了，对于曲线为什么看起来像这样以及它们如何依赖于控制点的描述并不是很明显。</p>
<p>所以绘制算法可能更容易理解。</p>
<h2 id="德卡斯特里奥算法">德卡斯特里奥算法</h2>
<p><a href="https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm">德卡斯特里奥算法</a>与曲线的数学定义相同，但直观地显示了曲线是如何被建立的。</p>
<p>让我们看看 3 个控制点的例子。</p>
<p>这里是一个演示，随后会有解释。</p>
<p>控制点可以用鼠标移动，点击 “play” 运行演示。</p>
<p>[iframe src=&quot;demo.svg?p=0,0,0.5,1,1,0&amp;animate=1&quot; height=370]</p>
<p><strong>德卡斯特里奥算法构造三点贝塞尔曲线：</strong></p>
<ol>
<li><p>绘制控制点。在上面的演示中，它们标有：<code>1</code>、<code>2</code> 和 <code>3</code>。</p>
</li>
<li><p>创建控制点 1 -&gt; 2 -&gt; 3 间的线段. 在上面的演示中它们是<span style="color:#825E28">棕色</span>的。</p>
</li>
<li><p>参数 <code>t</code> 从 <code>0</code> to <code>1</code> 变化。 在上面的演示中取值 <code>0.05</code>：循环遍历 <code>0, 0.05, 0.1, 0.15, ... 0.95, 1</code>。</p>
<p> 对于每一个 <code>t</code> 的取值：</p>
<ul>
<li><p>在每一个<span style="color:#825E28">棕色</span>线段上我们取一个点，这个点距起点的距离按比例 <code>t</code> 取值。由于有两条线段，我们能得到两个点。</p>
<p>  例如，当 <code>t=0</code> — 所有点都在线段起点处，当 <code>t=0.25</code> — 点到起点的距离为线段长度的 25%，当 <code>t=0.5</code> — 50%（中间），当 <code>t=1</code> — 线段终点。</p>
</li>
<li><p>连接这些点，下面这张图中连好的线被绘制成<span style="color:#167490">蓝色</span>。</p>
</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>当 <code>t=0.25</code></th>
<th>当 <code>t=0.5</code></th>
</tr>
</thead>
<tbody><tr>
<td><img src="bezier3-draw1.svg" alt=""></td>
<td><img src="bezier3-draw2.svg" alt=""></td>
</tr>
</tbody></table>
<ol start="4">
<li><p>现在在<span style="color:#167490">蓝色</span>线段上取一个点，距离比例取相同数值的 <code>t</code>。也就是说，当 <code>t=0.25</code>（左图）时，我们取到的点位于线段的左 1/4 终点处，当 <code>t=0.5</code>（右图）时 — 线段中间。在上图中这一点是<span style="color:red">红色</span>的。</p>
</li>
<li><p>随着 <code>t</code> 从 <code>0</code> to <code>1</code> 变化，每一个 <code>t</code> 的值都会添加一个点到曲线上。这些点的集合就形成的贝塞尔曲线。它在上面的图中是红色的，并且是抛物线状的。</p>
</li>
</ol>
<p>这是三控制点的处理过程，但是对于 4 个点同样适用。</p>
<p>4 个控制点的演示（点可以被鼠标移动）：</p>
<p>[iframe src=&quot;demo.svg?p=0,0,0.5,0,0.5,1,1,1&amp;animate=1&quot; height=370]</p>
<p>算法：</p>
<ul>
<li>控制点通过线段连接：1 -&gt; 2、2 -&gt; 3 和 3 -&gt; 4。 我们能得到 3 条<span style="color:#825E28">棕色</span>的线段。</li>
<li>对于 <code>0</code> to <code>1</code> 之间的每一个 <code>t</code>：<ul>
<li>我们在这些线段上距起点距离比例为 <code>t</code> 的位置取点。把这些点连接起来，然后得到两条<span style="color:#0A0">绿色线段</span>。</li>
<li>在这些线段上同样按比例 <code>t</code> 取点，得到一条<span style="color:#167490">蓝色线段</span>。</li>
<li>在蓝色线段按比例 <code>t</code> 取点。在上面的例子中是<span style="color:red">红色</span>的。</li>
</ul>
</li>
<li>这些点在一起组成了曲线。</li>
</ul>
<p>该算法是递归的，并且可以适应于任意数量的控制点。</p>
<p>给定 N 个控制点，我们将它们连接起来以获得初始的 N-1 个线段。</p>
<p>然后对从 <code>0</code> 到 <code>1</code> 的每一个 <code>t</code>：</p>
<ul>
<li>在每条线段上按 <code>t</code> 比例距离取一个点并且连接 —— 会得到 N-2 个线段。</li>
<li>在上面得到的每条线段上按 <code>t</code> 比例距离取一个点并且连接 —— 会得到 N-3 个线段，以此类推……</li>
<li>直到我们得到一个点。得到的这些点就形成了曲线。</li>
</ul>
<p>曲线的移动演示:</p>
<p>[iframe src=&quot;demo.svg?p=0,0,0,0.75,0.25,1,1,1&amp;animate=1&quot; height=370]</p>
<p>和其它的点：</p>
<p>[iframe src=&quot;demo.svg?p=0,0,1,0.5,0,0.5,1,1&amp;animate=1&quot; height=370]</p>
<p>环形：</p>
<p>[iframe src=&quot;demo.svg?p=0,0,1,0.5,0,1,0.5,0&amp;animate=1&quot; height=370]</p>
<p>非平滑贝塞尔曲线：</p>
<p>[iframe src=&quot;demo.svg?p=0,0,1,1,0,1,1,0&amp;animate=1&quot; height=370]</p>
<p>由于算法是递归的，我们可以构建任何顺序的贝塞尔曲线：使用 5 个、6 个或更多个控制点。但在实践中它们没那么有用。通常我们取 2-3 个点，对于复杂的线条，将几条曲线拼接在一起。这更容易开发和计算。</p>
<pre><code class="language-smart">我们使用控制点制作贝塞尔曲线。正如我们所见，它们并不在曲线上。或者更准确地说，第一个和最后一个在曲线上，但其它的不在。

有时我们有另一种任务：绘制一条曲线**通过几个点**，让它们都在一条平滑曲线上。这种任务叫[插值](https://en.wikipedia.org/wiki/Interpolation)，这里我们不覆盖讲解它。

这些曲线有数学方程式，例如[拉格朗日多项式](https://en.wikipedia.org/wiki/Lagrange_polynomial)。

在计算机图形中[样条插值](https://en.wikipedia.org/wiki/Spline_interpolation)通常用于构建连接多个点的平滑曲线。</code></pre>
<h2 id="总结">总结</h2>
<p>贝塞尔曲线由其控制点定义。</p>
<p>贝塞尔曲线的两种定义方法：</p>
<ol>
<li>使用数学方程式。</li>
<li>使用绘图过程：德卡斯特里奥算法</li>
</ol>
<p>贝塞尔曲线的优点：</p>
<ul>
<li>我们可以通过控制点移动来用鼠标绘制平滑线条。</li>
<li>复杂的形状可以由多条贝塞尔曲线组成。</li>
</ul>
<p>用途：</p>
<ul>
<li>在计算机图形学，建模，矢量图形编辑器中。字体由贝塞尔曲线描述。</li>
<li>在 Web 开发中 — 用于 Canvas 上的图形和 SVG 格式。顺便说一下，上面的“实时”示例是用 SVG 编写的。它们实际上是一个 SVG 文档，被赋予不同的控制点做参数。你可以在单独的窗口中打开它并查源码：<a href="demo.svg?p=0,0,1,0.5,0,0.5,1,1&amp;animate=1">demo.svg</a>。</li>
<li>在 CSS 动画中描述动画的路径和速度。</li>
</ul>

      </fieldset>
      
      <fieldset id='_UhtcYE'>
      <legend>solution</legend>
      <p>使用 CSS 为 <code>width</code> 和 <code>height</code> 属性生成动效：</p>
<pre><code class="language-css"><span class="hljs-comment">/* 原始类 */</span>

<span class="hljs-selector-id">#flyjet</span> {
  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">3s</span>;
}

<span class="hljs-comment">/* JS 添加的 .growing */</span>
<span class="hljs-selector-id">#flyjet</span><span class="hljs-selector-class">.growing</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">240px</span>;
}</code></pre>
<p>请注意，<code>transitionend</code> 会被触发两次 —— 每个属性触发一次。因此，如果我们不进行额外检查的话，这条信息会显示两次。</p>

      </fieldset>
      
      <fieldset id='_SR8kti'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="让飞机动起来（css）">让飞机动起来（CSS）</h1>
<p>生成如下图的动画（点击显示）：</p>
<p>[iframe src=&quot;solution&quot; height=300]</p>
<ul>
<li>点击后，图片会从 <code>40x24px</code> 变为 <code>400x240px</code> （变大十倍）。</li>
<li>动画持续三秒。</li>
<li>在动画结束后，输出：&quot;Done!&quot;。</li>
<li>动画过程中，如果飞机被点击，这些操作不应该打断动画。</li>
</ul>

      </fieldset>
      
      <fieldset id='_OeJFe1'>
      <legend>solution</legend>
      <p>我们需要为此选择合适的贝塞尔曲线。它应该在某个地方拥有 <code>y &gt; 1</code>，来使得飞机『跳出来』。 </p>
<p>举例来说，我们可以使两个控制点的 <code>y</code> 都大于 <code>1</code>：<code>cubic-bezier(0.25, 1.5, 0.75, 1.5)</code>。</p>
<p>如图：</p>
<p><img src="bezier-up.svg" alt=""></p>

      </fieldset>
      
      <fieldset id='_zPKJeW'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="为飞机生成动画（css）">为飞机生成动画（CSS）</h1>
<p>修改前一个的任务 <a href="info:task/animate-logo-css">info:task/animate-logo-css</a> 的解决方案，让飞机超过原有的大小 <code>400x240px</code>（跳脱出来），然后再回到之前的大小。</p>
<p>这里是效果演示（点击飞机）：</p>
<p>[iframe src=&quot;solution&quot; height=350]</p>
<p>在前一个解决方案的基础上做修改。</p>

      </fieldset>
      
      <fieldset id='_gegy3K'>
      <legend>solution</legend>
      
      </fieldset>
      
      <fieldset id='_TMeTGG'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="圆圈动画">圆圈动画</h1>
<p>创建一个函数：<code>showCircle(cx, cy, radius)</code>，来显示一个不断变大的圆。</p>
<ul>
<li><code>cx,cy</code> 为圆心相对于窗口的位置。</li>
<li><code>radius</code> 为圆的半径。</li>
</ul>
<p>点击下方的按钮以演示效果：</p>
<p>[iframe src=&quot;solution&quot; height=260]</p>
<p>源文件中提供了一个具有合适样式的圆样例，因此你需要做的就是创建合适的动画。</p>

      </fieldset>
      
      <fieldset id='_Vgpuim'>
      <legend>article</legend>
      <h1 id="css-动画">CSS 动画</h1>
<p>CSS 动画可以在不借助 Javascript 的情况下做出一些简单的动画效果。</p>
<p>你也可以通过 Javascript 控制 CSS 动画，使用少量的代码，就能让动画表现更加出色。</p>
<h2 id="css-过渡（transition）css-transition">CSS 过渡（transition）[#css-transition]</h2>
<p>CSS 过渡的理念非常简单，我们只需要定义某一个属性以及如何动态地表现其变化。当属性变化时，浏览器将会绘制出相应的过渡动画。</p>
<p>也就是说：我们只需要改变某个属性，然后所有流畅的动画都由浏览器生成。</p>
<p>举个例子，以下 CSS 会为 <code>backgroud-color</code> 的变化生成一个 3 秒的过渡动画：</p>
<pre><code class="language-css"><span class="hljs-selector-class">.animated</span> {
  <span class="hljs-attribute">transition-property</span>: background-color;
  <span class="hljs-attribute">transition-duration</span>: <span class="hljs-number">3s</span>;
}</code></pre>
<p>现在，只要一个元素拥有名为 <code>.animated</code> 的类，那么任何背景颜色的变化都会被渲染为 3 秒钟的动画。</p>
<p>单击以下按钮以演示动画：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;color&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
  <span class="hljs-selector-id">#color</span> {
    <span class="hljs-attribute">transition-property</span>: background-color;
    <span class="hljs-attribute">transition-duration</span>: <span class="hljs-number">3s</span>;
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  color.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">this</span>.style.backgroundColor = <span class="hljs-string">&#x27;red&#x27;</span>;
  };
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>CSS 提供了四个属性来描述一个过渡：</p>
<ul>
<li><code>transition-property</code></li>
<li><code>transition-duration</code></li>
<li><code>transition-timing-function</code></li>
<li><code>transition-delay</code></li>
</ul>
<p>之后我们会详细介绍它们，目前我们需要知道，我们可以在 <code>transition</code> 中以 <code>property duration timing-function delay</code> 的顺序一次性定义它们，并且可以同时为多个属性设置过渡动画。</p>
<p>请看以下例子，点击按钮生成 <code>color</code> 和 <code>font-size</code> 的过渡动画：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;growing&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>
#growing {
*!*
  transition: font-size 3s, color 2s;
*/!*
}
<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
growing.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">this</span>.style.fontSize = <span class="hljs-string">&#x27;36px&#x27;</span>;
  <span class="hljs-built_in">this</span>.style.color = <span class="hljs-string">&#x27;red&#x27;</span>;
};
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>现在让我们一个一个展开看这些属性。</p>
<h2 id="transition-property">transition-property</h2>
<p>在 <code>transition-property</code> 中我们可以列举要设置动画的所有属性，如：<code>left、margin-left、height 和 color</code>。</p>
<p>不是所有的 CSS 属性都可以使用过渡动画，但是它们中的<a href="http://www.w3.org/TR/css3-transitions/#animatable-properties-">大多数</a>都是可以的。<code>all</code> 表示应用在所有属性上。</p>
<h2 id="transition-duration">transition-duration</h2>
<p><code>transition-duration</code> 允许我们指定动画持续的时间。时间的格式参照 <a href="http://www.w3.org/TR/css3-values/#time">CSS 时间格式</a>：单位为秒 <code>s</code> 或者毫秒 <code>ms</code>。</p>
<h2 id="transition-delay">transition-delay</h2>
<p><code>transition-delay</code> 允许我们设定动画<strong>开始前</strong>的延迟时间。例如，对于 <code>transition-delay: 1s</code>，动画将会在属性变化发生 1 秒后开始渲染。</p>
<p>你也可以提供一个负值。那么动画将会从整个过渡的中间时刻开始渲染。例如，对于 <code>transition-duration: 2s</code>，同时把 <code>delay</code> 设置为 <code>-1s</code>，那么这个动画将会持续 1 秒钟，并且从正中间开始渲染。</p>
<p>这里演示了数字从 <code>0</code> 到 <code>9</code> 的动画，使用了 CSS <code>translate</code> 方法：</p>
<p>[codetabs src=&quot;digits&quot;]</p>
<p>如下在 <code>tranform</code> 属性上应用动画：</p>
<pre><code class="language-css"><span class="hljs-selector-id">#stripe</span><span class="hljs-selector-class">.animate</span> {
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">90%</span>);
  <span class="hljs-attribute">transition-property</span>: transform;
  <span class="hljs-attribute">transition-duration</span>: <span class="hljs-number">9s</span>;
}</code></pre>
<p>在以上的例子中，JavaScript 把 <code>.animate</code> 类添加到了元素上，由此触发了动画：</p>
<pre><code class="language-js">stripe.classList.add(<span class="hljs-string">&#x27;animate&#x27;</span>);</code></pre>
<p>我们也可以『从中间』开始，也就是说从某个特定数字开始，比方说，从当前的时间的秒数开始。这就要用到负的 <code>transition-delay</code>。</p>
<p>此处，如果你单击这个数字，那么它会从当前的秒数开始渲染：</p>
<p>[codetabs src=&quot;digits-negative-delay&quot;]</p>
<p>只需添加一行 JavaScript 代码：</p>
<pre><code class="language-js">stripe.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> sec = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getSeconds() % <span class="hljs-number">10</span>;
*!*
  <span class="hljs-comment">// for instance, -3s here starts the animation from the 3rd second</span>
  stripe.style.transitionDelay = <span class="hljs-string">&#x27;-&#x27;</span> + sec + <span class="hljs-string">&#x27;s&#x27;</span>;
*/!*
  stripe.classList.add(<span class="hljs-string">&#x27;animate&#x27;</span>);
};</code></pre>
<h2 id="transition-timing-function">transition-timing-function</h2>
<p>时间函数描述了动画进程在时间上的分布。它是先慢后快还是先快后慢？</p>
<p>乍一看，这可能是最复杂的属性了，但是稍微花点时间，你就会发现其实也很简单。</p>
<p>这个属性接受两种值：一个贝塞尔曲线（Bezier curve）或者阶跃函数（steps）。我们先从贝塞尔曲线开始，这也是较为常用的。</p>
<h3 id="贝塞尔曲线（bezier-curve）">贝塞尔曲线（Bezier curve）</h3>
<p>时间函数可以用<a href="/bezier-curve">贝塞尔曲线</a>描述，通过设置四个满足以下条件的控制点：</p>
<ol>
<li>第一个应为：<code>(0,0)</code>。</li>
<li>最后一个应为：<code>(1,1)</code>。</li>
<li>对于中间值，<code>x</code> 必须位于 <code>0..1</code> 之间，<code>y</code> 可以为任意值。</li>
</ol>
<p>CSS 中设置一贝塞尔曲线的语法为：<code>cubic-bezier(x2, y2, x3, y3)</code>。这里我们只需要设置第二个和第三个值，因为第一个点固定为 <code>(0,0)</code>，第四个点固定为 <code>(1,1)</code>。</p>
<p>时间函数描述了动画进行的快慢。</p>
<ul>
<li><code>x</code> 轴表示时间：<code>0</code> —— 开始时刻，<code>1</code> —— <code>transition-duration</code>的结束时刻。</li>
<li><code>y</code> 轴表示过程的完成度：<code>0</code> —— 属性的起始值，<code>1</code> —— 属性的最终值。</li>
</ul>
<p>最简单的一种情况就是动画匀速进行，可以通过设置曲线为 <code>cubic-bezier(0, 0, 1, 1)</code> 来实现。</p>
<p>看上去就像这样：</p>
<p><img src="bezier-linear.svg" alt=""></p>
<p>...正如我们所见，这就是条直线。随着时间 <code>x</code> 推移，完成度 <code>y</code> 稳步从 <code>0</code> 增长到 <code>1</code>。</p>
<p>例子中的列车匀速地从左侧移动到右侧：</p>
<p>[codetabs src=&quot;train-linear&quot;]</p>
<p>这个里面的 CSS 就是基于刚才那条曲线的：</p>
<pre><code class="language-css"><span class="hljs-selector-class">.train</span> {
  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">transition</span>: left <span class="hljs-number">5s</span> <span class="hljs-built_in">cubic-bezier</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
  <span class="hljs-comment">/* JavaScript sets left to 450px */</span>
}</code></pre>
<p>...那么，我们如果表现出减速行驶的列车呢？</p>
<p>我们可以使用另一条贝塞尔曲线：<code>cubic-bezier(0.0, 0.5, 0.5 ,1.0)</code>。</p>
<p>图像如下：</p>
<p><img src="train-curve.svg" alt=""></p>
<p>正如我们所见，这个过程起初很快：曲线开始迅速升高，然后越来越慢。</p>
<p>这是实际的效果演示：</p>
<p>[codetabs src=&quot;train&quot;]</p>
<p>CSS：</p>
<pre><code class="language-css"><span class="hljs-selector-class">.train</span> {
  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">transition</span>: left <span class="hljs-number">5s</span> <span class="hljs-built_in">cubic-bezier</span>(<span class="hljs-number">0</span>, .<span class="hljs-number">5</span>, .<span class="hljs-number">5</span>, <span class="hljs-number">1</span>);
  <span class="hljs-comment">/* JavaScript sets left to 450px */</span>
}</code></pre>
<p>CSS 提供几条内置的曲线：<code>linear</code>、<code>ease</code>、<code>ease-in</code>、<code>ease-out</code> 和 <code>ease-in-out</code>。</p>
<p><code>linear</code> 其实就是 <code>cubic-bezier(0, 0, 1, 1)</code> 的简写 —— 一条直线，刚刚我们已经看过了。 </p>
<p>其它的名称是以下贝塞尔曲线的简写：</p>
<table>
<thead>
<tr>
<th><code>ease</code><sup>*</sup></th>
<th><code>ease-in</code></th>
<th><code>ease-out</code></th>
<th><code>ease-in-out</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>(0.25, 0.1, 0.25, 1.0)</code></td>
<td><code>(0.42, 0, 1.0, 1.0)</code></td>
<td><code>(0, 0, 0.58, 1.0)</code></td>
<td><code>(0.42, 0, 0.58, 1.0)</code></td>
</tr>
<tr>
<td><img src="ease.svg" alt="ease, figure"></td>
<td><img src="ease-in.svg" alt="ease-in, figure"></td>
<td><img src="ease-out.svg" alt="ease-out, figure"></td>
<td><img src="ease-in-out.svg" alt="ease-in-out, figure"></td>
</tr>
</tbody></table>
<p><code>*</code> —— 默认值，如果没有指定时间函数，那么将使用 <code>ease</code> 作为默认值。</p>
<p>所以，我们可以使用 <code>ease-out</code> 来表现减速行驶的列车：</p>
<pre><code class="language-css"><span class="hljs-selector-class">.train</span> {
  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">transition</span>: left <span class="hljs-number">5s</span> ease-out;
  <span class="hljs-comment">/* transition: left 5s cubic-bezier(0, .5, .5, 1); */</span>
}</code></pre>
<p>但是这看起来有点怪怪的。</p>
<p><strong>贝塞尔曲线可以使动画『超出』其原本的范围。</strong></p>
<p>曲线上的控制点的 <code>y</code> 值可以使任意的：不管是负值还是一个很大的值。如此，贝塞尔曲线就会变得很低或者很高，让动画超出其正常的范围。</p>
<p>在一下的例子中使用的代码：</p>
<pre><code class="language-css"><span class="hljs-selector-class">.train</span> {
  <span class="hljs-attribute">left</span>: <span class="hljs-number">100px</span>;
  <span class="hljs-attribute">transition</span>: left <span class="hljs-number">5s</span> <span class="hljs-built_in">cubic-bezier</span>(.<span class="hljs-number">5</span>, -<span class="hljs-number">1</span>, .<span class="hljs-number">5</span>, <span class="hljs-number">2</span>);
  <span class="hljs-comment">/* JavaScript sets left to 400px */</span>
}</code></pre>
<p><code>left</code> 本该在 <code>100px</code> 到 <code>400px</code> 之间变化。</p>
<p>但是如果你点击列车，你会发现：</p>
<ul>
<li>起初，列车会<strong>反向</strong>运动：<code>left</code> 会变得小于 <code>100px</code>。</li>
<li>然后，它会变回往前运动，并且超过 <code>400px</code>。</li>
<li>最后再返回 —— 回到 <code>400px</code>。</li>
</ul>
<p>[codetabs src=&quot;train-over&quot;]</p>
<p>为什么会这样？看一眼给定的贝塞尔曲线的图像你就会明白了。</p>
<p><img src="bezier-train-over.svg" alt=""></p>
<p>我们把第二个点的 <code>y</code> 坐标移动到了小于 <code>0</code> 的位置，同时把第三个点的 <code>y</code> 坐标移动到了大于 <code>1</code> 的位置，因此曲线已经不再像一个四分之一圆了。<code>y</code> 坐标超出了常规的 <code>0..1</code> 的范围。</p>
<p>正如我们所知，<code>y</code> 表示『动画进程的完成度』。<code>y = 0</code> 表示属性的初始值，<code>y = 1</code> 则表示属性的最终值。因此，<code>y &lt; 0</code> 意味着属性值要比初始值小，而 <code>y &gt; 1</code> 则表明属性值要比最终值大。</p>
<p>当然了，<code>-1</code> 和 <code>2</code> 还是比较缓和的值。如果我们把 <code>y</code> 设为 <code>-99</code> 和 <code>99</code>，那么列车将会偏离地更远。</p>
<p>但是，如何针对特定的任务寻找到合适的贝塞尔曲线呢？事实上，有很多工具可以帮到你。比方说，我们可以利用这个网站：<a href="http://cubic-bezier.com/">http://cubic-bezier.com/</a>。</p>
<h3 id="阶跃函数（steps）">阶跃函数（Steps）</h3>
<p>时间函数 <code>steps(number of steps[, start/end])</code> 允许你让动画分段进行，<code>number of steps</code> 表示需要拆分为多少段。</p>
<p>让我们通过一个数字的例子来演示一下。我们将会让数字以离散的方式变化，而不是以连续的方式。</p>
<p>为了达到效果，我们把动画拆分为 9 段：</p>
<pre><code class="language-css"><span class="hljs-selector-id">#stripe</span><span class="hljs-selector-class">.animate</span>  {
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">90%</span>);
  <span class="hljs-attribute">transition</span>: transform <span class="hljs-number">9s</span> *!*<span class="hljs-built_in">steps</span>(<span class="hljs-number">9</span>, start)*/!*;
}</code></pre>
<p><code>step(9, start)</code> 生效时：</p>
<p>[codetabs src=&quot;step&quot;]</p>
<p><code>steps</code> 的第一个参数表示段数。这个过渡动画将会被拆分为 9 个部分（每个占 10%）。时间间隔也会以同样的方式被拆分：9 秒会被分割为多个时长 1 秒的间隔。</p>
<p>第二个参数可以取 <code>start</code> 或 <code>end</code> 两者其一。</p>
<p><code>start</code> 表示在动画开始时，我们需要立即开始第一段的动画。</p>
<p>可以观察到，在动画过程中：当我们单击数字之后，它会立马变为 <code>1</code>（即第一段），然后在下一秒开始的时候继续变化。</p>
<p>具体的流程如下：</p>
<ul>
<li><code>0s</code> —— <code>-10%</code>（在第一秒开始的时候立即变化）</li>
<li><code>1s</code> —— <code>-20%</code></li>
<li>...</li>
<li><code>8s</code> -- <code>-80%</code></li>
<li>（最后一秒，显示最终值）</li>
</ul>
<p>另一个值 <code>end</code> 表示：改变不应该在最开始的时候发生，而是发生在每一段的最后时刻。</p>
<p>其流程如下：</p>
<ul>
<li><code>0s</code> —— <code>0</code></li>
<li><code>1s</code> —— <code>-10%</code>（在第一秒结束时第一次变化）</li>
<li><code>2s</code> —— <code>-20%</code></li>
<li>...</li>
<li><code>9s</code> —— <code>-90%</code></li>
</ul>
<p><code>step(9, end)</code> 生效时：</p>
<p>[codetabs src=&quot;step-end&quot;]</p>
<p>另外还有一些简写值：</p>
<ul>
<li><code>step-start</code> —— 等同于 <code>steps(1, start)</code>。即：动画立刻开始，并且只有一段。也就是说，会立刻开始，紧接着就结束了，宛如没有动画一样。</li>
<li><code>step-end</code> —— 等同于 <code>steps(1, end)</code>。即：在 <code>transition-duration</code> 结束时生成一段动画。</li>
</ul>
<p>这些值很少会被用到，因为它们并不算是真正的动画，而是单步的变化。</p>
<h2 id="transitionend-事件">transitionend 事件</h2>
<p>CSS 动画完成后，会触发 <code>transitionend</code> 事件。</p>
<p>这被广泛用于在动画结束后执行某种操作。我们也可以用它来串联动画。</p>
<p>举例来说，下面的小船会在点击后向右浮动，然后再回来。而且，每一次都会向右移动地更远一点：</p>
<p>[iframe src=&quot;boat&quot; height=300 edit link]</p>
<p>这个动画通过 <code>go</code> 函数初始化，并且在每次动画完成后都会重复执行，并转变方向：</p>
<pre><code class="language-js">boat.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">//...</span>
  <span class="hljs-keyword">let</span> times = <span class="hljs-number">1</span>;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">go</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (times % <span class="hljs-number">2</span>) {
      <span class="hljs-comment">// 向右移动</span>
      boat.classList.remove(<span class="hljs-string">&#x27;back&#x27;</span>);
      boat.style.marginLeft = <span class="hljs-number">100</span> * times + <span class="hljs-number">200</span> + <span class="hljs-string">&#x27;px&#x27;</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 向左移动</span>
      boat.classList.add(<span class="hljs-string">&#x27;back&#x27;</span>);
      boat.style.marginLeft = <span class="hljs-number">100</span> * times - <span class="hljs-number">200</span> + <span class="hljs-string">&#x27;px&#x27;</span>;
    }

  }

  go();

  boat.addEventListener(<span class="hljs-string">&#x27;transitionend&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    times++;
    go();
  });
};</code></pre>
<p><code>transitionend</code> 的事件对象有几个特定的属性：</p>
<p><code>event.propertyName</code>
：当前完成动画的属性，这在我们同时为多个属性加上动画时会很有用。</p>
<p><code>event.elapsedTime</code>
：动画完成的时间（按秒计算），不包括 <code>transition-delay</code>。</p>
<h2 id="关键帧动画（keyframes）">关键帧动画（Keyframes）</h2>
<p>我们可以通过 CSS 提供的 <code>@keyframes</code> 规则整合多个简单的动画。</p>
<p>它会指定某个动画的名称以及相应的规则：哪个属性，何时以及何地渲染动画。然后使用 <code>animation</code> 属性把动画绑定到相应的元素上，并为其添加额外的参数。</p>
<p>这里有个详细的例子：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;progress&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>
*!*
  @keyframes go-left-right {        /* 指定一个名字：&quot;go-left-right&quot; */
    from { left: 0px; }             /* 从 left: 0px 开始 */
    to { left: calc(100% - 50px); } /* 移动至 left: 100%-50px */
  }
*/!*

  .progress {
*!*
    animation: go-left-right 3s infinite alternate;
    /* 把动画 &quot;go-left-right&quot; 应用到元素上
       持续 3 秒
       持续次数：infinite
       每次都改变方向
    */
*/!*

    position: relative;
    border: 2px solid green;
    width: 50px;
    height: 20px;
    background: lime;
  }
<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre>
<p>有许多关于 <code>@keyframes</code> 的文章以及一个<a href="https://drafts.csswg.org/css-animations/">详细的规范说明</a>。</p>
<p>很可能你并不需要经常用到 <code>@keyframes</code>，除非你的网站上有一直在运动的元素。</p>
<h2 id="总结">总结</h2>
<p>CSS 动画允许你为一个或者多个属性的变化创建丝滑流畅（也可能不是）的过渡动画。</p>
<p>它们适用于大多数的动画需求。我们也可以使用 JavaScript 创建动画，下一章将会详细讲解相关内容。</p>
<p>相对于 JavaScript 动画，CSS 动画存在的特点如下：</p>
<pre><code class="language-compare">+ 简单的事，简单地做。
+ 快速，而且对 CPU 造成的压力很小。
- JavaScript 动画更加灵活。它们可以实现任何动画逻辑，比如某个元素的爆炸效果。
- 不仅仅只是属性的变化。我们还可以在 JavaScript 中生成新元素用于动画。</code></pre>
<p>本节已经介绍了可以使用 CSS 实现的主要动画类型，而且 <code>transitionend</code> 还允许在动画结束后执行 JavaScript 代码，因此它可以方便得与代码结合起来。</p>
<p>但是在下一节，我们将会学习一些 JavaScript 动画来实现更加复杂的效果。</p>

      </fieldset>
      
      <fieldset id='_T0njnD'>
      <legend>solution</legend>
      <p>为了达到反弹效果，我们可以在带有 <code>position:relative</code> 属性的区域内，给小球使用 <code>top</code> 和 <code>position:absolute</code> CSS 属性。</p>
<p>field 区域的底部坐标是 <code>field.clientHeight</code>。<code>top</code> 属性给出了球顶部的坐标，在最底部时达到 <code>field.clientHeight - ball.clientHeight</code>。</p>
<p>因此，我们将 <code>top</code> 从 <code>0</code> 变化到 <code>field.clientHeight - ball.clientHeight</code> 来设置动画。</p>
<p>现在为了获得“弹跳”效果，我们可以在 <code>easeOut</code> 模式下使用时序函数 <code>bounce</code>。</p>
<p>这是动画的最终代码：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> to = field.clientHeight - ball.clientHeight;

animate({
  <span class="hljs-attr">duration</span>: <span class="hljs-number">2000</span>,
  <span class="hljs-attr">timing</span>: makeEaseOut(bounce),
  draw(progress) {
    ball.style.top = to * progress + <span class="hljs-string">&#x27;px&#x27;</span>
  }
});</code></pre>

      </fieldset>
      
      <fieldset id='_NtJmoi'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="为弹跳的球设置动画">为弹跳的球设置动画</h1>
<p>做一个弹跳的球。点击查看应有的效果：</p>
<p>[iframe height=250 src=&quot;solution&quot;]</p>

      </fieldset>
      
      <fieldset id='_VavPHX'>
      <legend>solution</legend>
      <p>在任务 <a href="info:task/animate-ball">info:task/animate-ball</a> 中，我们只有一个需要添加动画的属性。现在多了一个 <code>elem.style.left</code>。</p>
<p>水平坐标由另一个定律改变：它不会“反弹”，而是逐渐增加使球逐渐向右移动。</p>
<p>我们可以为它多写一个 <code>animate</code>。</p>
<p>至于时序函数，我们可以使用 <code>linear</code>，但像 <code>makeEaseOut(quad)</code> 这样的函数看起来要好得多。</p>
<p>代码：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> height = field.clientHeight - ball.clientHeight;
<span class="hljs-keyword">let</span> width = <span class="hljs-number">100</span>;

<span class="hljs-comment">// 设置 top 动画（弹跳）</span>
animate({
  <span class="hljs-attr">duration</span>: <span class="hljs-number">2000</span>,
  <span class="hljs-attr">timing</span>: makeEaseOut(bounce),
  <span class="hljs-attr">draw</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">progress</span>) </span>{
    ball.style.top = height * progress + <span class="hljs-string">&#x27;px&#x27;</span>
  }
});

<span class="hljs-comment">// 设置 left 动画（向右移动）</span>
animate({
  <span class="hljs-attr">duration</span>: <span class="hljs-number">2000</span>,
  <span class="hljs-attr">timing</span>: makeEaseOut(quad),
  <span class="hljs-attr">draw</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">progress</span>) </span>{
    ball.style.left = width * progress + <span class="hljs-string">&quot;px&quot;</span>
  }
});</code></pre>

      </fieldset>
      
      <fieldset id='_WTVmme'>
      <legend>task</legend>
      <p>importance: 5</p>
<hr>
<h1 id="设置动画使球向右移动">设置动画使球向右移动</h1>
<p>让球向右移动。像这样：</p>
<p>[iframe height=250 src=&quot;solution&quot;]</p>
<p>编写动画代码。终止时球到左侧的距离是 <code>100px</code>。</p>
<p>从前一个任务 <a href="info:task/animate-ball">info:task/animate-ball</a> 的答案开始。</p>

      </fieldset>
      
      <fieldset id='_kHaDVW'>
      <legend>article</legend>
      <h1 id="javascript-动画">JavaScript 动画</h1>
<p>JavaScript 动画可以处理 CSS 无法处理的事情。</p>
<p>例如，沿着具有与 Bezier 曲线不同的时序函数的复杂路径移动，或者实现画布上的动画。</p>
<h2 id="使用-setinterval">使用 setInterval</h2>
<p>从 HTML/CSS 的角度来看，动画是 style 属性的逐渐变化。例如，将 <code>style.left</code> 从 <code>0px</code> 变化到 <code>100px</code> 可以移动元素。</p>
<p>如果我们用 <code>setInterval</code> 每秒做 50 次小变化，看起来会更流畅。电影也是这样的原理：每秒 24 帧或更多帧足以使其看起来流畅。</p>
<p>伪代码如下：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> delay = <span class="hljs-number">1000</span> / <span class="hljs-number">50</span>; <span class="hljs-comment">// 每秒 50 帧</span>
<span class="hljs-keyword">let</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (animation complete) <span class="hljs-built_in">clearInterval</span>(timer);
  <span class="hljs-keyword">else</span> increase style.left
}, delay)</code></pre>
<p>更完整的动画示例：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> start = <span class="hljs-built_in">Date</span>.now(); <span class="hljs-comment">// 保存开始时间</span>

<span class="hljs-keyword">let</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// 距开始过了多长时间</span>
  <span class="hljs-keyword">let</span> timePassed = <span class="hljs-built_in">Date</span>.now() - start;

  <span class="hljs-keyword">if</span> (timePassed &gt;= <span class="hljs-number">2000</span>) {
    <span class="hljs-built_in">clearInterval</span>(timer); <span class="hljs-comment">// 2 秒后结束动画</span>
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-comment">// 在 timePassed 时刻绘制动画</span>
  draw(timePassed);

}, <span class="hljs-number">20</span>);

<span class="hljs-comment">// 随着 timePassed 从 0 增加到 2000</span>
<span class="hljs-comment">// 将 left 的值从 0px 增加到 400px</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">draw</span>(<span class="hljs-params">timePassed</span>) </span>{
  train.style.left = timePassed / <span class="hljs-number">5</span> + <span class="hljs-string">&#x27;px&#x27;</span>;
}</code></pre>
<p>点击演示：</p>
<p>[codetabs height=200 src=&quot;move&quot;]</p>
<h2 id="使用-requestanimationframe">使用 requestAnimationFrame</h2>
<p>假设我们有几个同时运行的动画。</p>
<p>如果我们单独运行它们，每个都有自己的 <code>setInterval(..., 20)</code>，那么浏览器必须以比 <code>20ms</code> 更频繁的速度重绘。</p>
<p>每个 <code>setInterval</code> 每 <code>20ms</code> 触发一次，但它们相互独立，因此 <code>20ms</code> 内将有多个独立运行的重绘。</p>
<p>这几个独立的重绘应该组合在一起，以使浏览器更加容易处理。</p>
<p>换句话说，像下面这样：</p>
<pre><code class="language-js"><span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  animate1();
  animate2();
  animate3();
}, <span class="hljs-number">20</span>)</code></pre>
<p>……比这样更好：</p>
<pre><code class="language-js"><span class="hljs-built_in">setInterval</span>(animate1, <span class="hljs-number">20</span>);
<span class="hljs-built_in">setInterval</span>(animate2, <span class="hljs-number">20</span>);
<span class="hljs-built_in">setInterval</span>(animate3, <span class="hljs-number">20</span>);</code></pre>
<p>还有一件事需要记住。有时当 CPU 过载时，或者有其他原因需要降低重绘频率。例如，如果浏览器选项卡被隐藏，那么绘图完全没有意义。</p>
<p>有一个标准<a href="http://www.w3.org/TR/animation-timing/">动画时序</a>提供了 <code>requestAnimationFrame</code> 函数。</p>
<p>它解决了所有这些问题，甚至更多其它的问题。</p>
<p>语法：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> requestId = requestAnimationFrame(callback);</code></pre>
<p>这会让 <code>callback</code> 函数在浏览器每次重绘的最近时间运行。</p>
<p>如果我们对 <code>callback</code> 中的元素进行变化，这些变化将与其他 <code>requestAnimationFrame</code> 回调和 CSS 动画组合在一起。因此，只会有一次几何重新计算和重绘，而不是多次。</p>
<p>返回值 <code>requestId</code> 可用来取消回调：</p>
<pre><code class="language-js"><span class="hljs-comment">// 取消回调的周期执行</span>
cancelAnimationFrame(requestId);</code></pre>
<p><code>callback</code> 得到一个参数 —— 从页面加载开始经过的毫秒数。这个时间也可通过调用 <a href="mdn:api/Performance/now">performance.now()</a> 得到。</p>
<p>通常 <code>callback</code> 很快就会运行，除非 CPU 过载或笔记本电量消耗殆尽，或者其他原因。</p>
<p>下面的代码显示了 <code>requestAnimationFrame</code> 的前 10 次运行之间的时间间隔。通常是 10-20ms：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">let</span> prev = performance.now();
  <span class="hljs-keyword">let</span> times = <span class="hljs-number">0</span>;

  requestAnimationFrame(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">measure</span>(<span class="hljs-params">time</span>) </span>{
    <span class="hljs-built_in">document</span>.body.insertAdjacentHTML(<span class="hljs-string">&quot;beforeEnd&quot;</span>, <span class="hljs-built_in">Math</span>.floor(time - prev) + <span class="hljs-string">&quot; &quot;</span>);
    prev = time;

    <span class="hljs-keyword">if</span> (times++ &lt; <span class="hljs-number">10</span>) requestAnimationFrame(measure);
  });
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h2 id="结构化动画">结构化动画</h2>
<p>现在我们可以在 <code>requestAnimationFrame</code> 基础上创建一个更通用的动画函数：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">animate</span>(<span class="hljs-params">{timing, draw, duration}</span>) </span>{

  <span class="hljs-keyword">let</span> start = performance.now();

  requestAnimationFrame(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">animate</span>(<span class="hljs-params">time</span>) </span>{
    <span class="hljs-comment">// timeFraction 从 0 增加到 1</span>
    <span class="hljs-keyword">let</span> timeFraction = (time - start) / duration;
    <span class="hljs-keyword">if</span> (timeFraction &gt; <span class="hljs-number">1</span>) timeFraction = <span class="hljs-number">1</span>;

    <span class="hljs-comment">// 计算当前动画状态</span>
    <span class="hljs-keyword">let</span> progress = timing(timeFraction);

    draw(progress); <span class="hljs-comment">// 绘制</span>

    <span class="hljs-keyword">if</span> (timeFraction &lt; <span class="hljs-number">1</span>) {
      requestAnimationFrame(animate);
    }

  });
}</code></pre>
<p><code>animate</code> 函数接受 3 个描述动画的基本参数：</p>
<p><code>duration</code>
: 动画总时间，比如 <code>1000</code>。</p>
<p><code>timing(timeFraction)</code>
: 时序函数，类似 CSS 属性 <code>transition-timing-function</code>，传入一个已过去的时间与总时间之比的小数（<code>0</code> 代表开始，<code>1</code> 代表结束），返回动画完成度（类似 Bezier 曲线中的 <code>y</code>）。</p>
<pre><code>例如，线性函数意味着动画以相同的速度均匀地进行：

```js
function linear(timeFraction) {
  return timeFraction;
}
```

图像如下：

![](linear.svg)

它类似于 `transition-timing-function: linear`。后文有更多有趣的变体。</code></pre>
<p><code>draw(progress)</code>
: 获取动画完成状态并绘制的函数。值 <code>progress = 0</code> 表示开始动画状态，<code>progress = 1</code> 表示结束状态。</p>
<pre><code>这是实际绘制动画的函数。

它可以移动元素：
```js
function draw(progress) {
  train.style.left = progress + &#x27;px&#x27;;
}
```

……或者做任何其他事情，我们可以以任何方式为任何事物制作动画。</code></pre>
<p>让我们使用我们的函数将元素的 <code>width</code> 从 <code>0</code> 变化为 <code>100%</code>。</p>
<p>点击演示元素：</p>
<p>[codetabs height=60 src=&quot;width&quot;]</p>
<p>它的代码如下：</p>
<pre><code class="language-js">animate({
  <span class="hljs-attr">duration</span>: <span class="hljs-number">1000</span>,
  timing(timeFraction) {
    <span class="hljs-keyword">return</span> timeFraction;
  },
  draw(progress) {
    elem.style.width = progress * <span class="hljs-number">100</span> + <span class="hljs-string">&#x27;%&#x27;</span>;
  }
});</code></pre>
<p>与 CSS 动画不同，我们可以在这里设计任何时序函数和任何绘图函数。时序函数不受 Bezier 曲线的限制。并且 <code>draw</code> 不局限于操作 CSS 属性，还可以为类似烟花动画或其他动画创建新元素。</p>
<h2 id="时序函数">时序函数</h2>
<p>上文我们看到了最简单的线性时序函数。</p>
<p>让我们看看更多。我们将尝试使用不同时序函数的移动动画来查看它们的工作原理。</p>
<h3 id="n-次幂">n 次幂</h3>
<p>如果我们想加速动画，我们可以让 <code>progress</code> 为 <code>n</code> 次幂。</p>
<p>例如，抛物线：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quad</span>(<span class="hljs-params">timeFraction</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.pow(timeFraction, <span class="hljs-number">2</span>)
}</code></pre>
<p>图像如下：</p>
<p><img src="quad.svg" alt=""></p>
<p>看看实际效果（点击激活）：</p>
<p>[iframe height=40 src=&quot;quad&quot; link]</p>
<p>……或者三次曲线甚至使用更大的 <code>n</code>。增大幂会让动画加速得更快。</p>
<p>下面是 <code>progress</code> 为 <code>5</code> 次幂的图像:</p>
<p><img src="quint.svg" alt=""></p>
<p>实际效果：</p>
<p>[iframe height=40 src=&quot;quint&quot; link]</p>
<h3 id="圆弧">圆弧</h3>
<p>函数：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">circ</span>(<span class="hljs-params">timeFraction</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> - <span class="hljs-built_in">Math</span>.sin(<span class="hljs-built_in">Math</span>.acos(timeFraction));
}</code></pre>
<p>图像：</p>
<p><img src="circ.svg" alt=""></p>
<p>[iframe height=40 src=&quot;circ&quot; link]</p>
<h3 id="反弹：弓箭射击">反弹：弓箭射击</h3>
<p>此函数执行“弓箭射击”。首先，我们“拉弓弦”，然后“射击”。</p>
<p>与以前的函数不同，它取决于附加参数 <code>x</code>，即“弹性系数”。“拉弓弦”的距离由它定义。</p>
<p>代码如下：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">back</span>(<span class="hljs-params">x, timeFraction</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.pow(timeFraction, <span class="hljs-number">2</span>) * ((x + <span class="hljs-number">1</span>) * timeFraction - x);
}</code></pre>
<p><strong><code>x = 1.5</code> 时的图像：</strong></p>
<p><img src="back.svg" alt=""></p>
<p>在动画中我们使用特定的 <code>x</code> 值。下面是 <code>x = 1.5</code> 时的例子：</p>
<p>[iframe height=40 src=&quot;back&quot; link]</p>
<h3 id="弹跳">弹跳</h3>
<p>想象一下，我们正在抛球。球落下之后，弹跳几次然后停下来。</p>
<p><code>bounce</code> 函数也是如此，但顺序相反：“bouncing”立即启动。它使用了几个特殊的系数：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bounce</span>(<span class="hljs-params">timeFraction</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>, result; <span class="hljs-number">1</span>; a += b, b /= <span class="hljs-number">2</span>) {
    <span class="hljs-keyword">if</span> (timeFraction &gt;= (<span class="hljs-number">7</span> - <span class="hljs-number">4</span> * a) / <span class="hljs-number">11</span>) {
      <span class="hljs-keyword">return</span> -<span class="hljs-built_in">Math</span>.pow((<span class="hljs-number">11</span> - <span class="hljs-number">6</span> * a - <span class="hljs-number">11</span> * timeFraction) / <span class="hljs-number">4</span>, <span class="hljs-number">2</span>) + <span class="hljs-built_in">Math</span>.pow(b, <span class="hljs-number">2</span>)
    }
  }
}</code></pre>
<p>演示：</p>
<p>[iframe height=40 src=&quot;bounce&quot; link]</p>
<h3 id="伸缩动画">伸缩动画</h3>
<p>另一个“伸缩”函数接受附加参数 <code>x</code> 作为“初始范围”。</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">elastic</span>(<span class="hljs-params">x, timeFraction</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">10</span> * (timeFraction - <span class="hljs-number">1</span>)) * <span class="hljs-built_in">Math</span>.cos(<span class="hljs-number">20</span> * <span class="hljs-built_in">Math</span>.PI * x / <span class="hljs-number">3</span> * timeFraction)
}</code></pre>
<p><strong><code>x=1.5</code> 时的图像：</strong>
<img src="elastic.svg" alt=""></p>
<p><code>x=1.5</code> 时的演示</p>
<p>[iframe height=40 src=&quot;elastic&quot; link]</p>
<h2 id="逆转：ease">逆转：ease*</h2>
<p>我们有一组时序函数。它们的直接应用称为“easeIn”。</p>
<p>有时我们需要以相反的顺序显示动画。这是通过“easeOut”变换完成的。</p>
<h3 id="easeout">easeOut</h3>
<p>在“easeOut”模式中，我们将 <code>timing</code> 函数封装到 <code>timingEaseOut</code>中：</p>
<pre><code class="language-js">timingEaseOut(timeFraction) = <span class="hljs-number">1</span> - timing(<span class="hljs-number">1</span> - timeFraction);</code></pre>
<p>换句话说，我们有一个“变换”函数 <code>makeEaseOut</code>，它接受一个“常规”时序函数 <code>timing</code> 并返回一个封装器，里面封装了 <code>timing</code> 函数：</p>
<pre><code class="language-js"><span class="hljs-comment">// 接受时序函数，返回变换后的变体</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeEaseOut</span>(<span class="hljs-params">timing</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">timeFraction</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> - timing(<span class="hljs-number">1</span> - timeFraction);
  }
}</code></pre>
<p>例如，我们可以使用上面描述的 <code>bounce</code> 函数：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> bounceEaseOut = makeEaseOut(bounce);</code></pre>
<p>这样，弹跳不会在动画开始时执行，而是在动画结束时。这样看起来更好：</p>
<p>[codetabs src=&quot;bounce-easeout&quot;]</p>
<p>在这里，我们可以看到变换如何改变函数的行为：</p>
<p><img src="bounce-inout.svg" alt=""></p>
<p>如果在开始时有动画效果，比如弹跳 —— 那么它将在最后显示。</p>
<p>上图中<span style="color:#EE6B47">常规弹跳</span>为红色，<span style="color:#62C0DC">easeOut 弹跳</span>为蓝色。</p>
<ul>
<li>常规弹跳 —— 物体在底部弹跳，然后突然跳到顶部。</li>
<li><code>easeOut</code> 变换之后 —— 物体跳到顶部之后，在那里弹跳。</li>
</ul>
<h3 id="easeinout">easeInOut</h3>
<p>我们还可以在动画的开头和结尾都显示效果。该变换称为“easeInOut”。</p>
<p>给定时序函数，我们按下面的方式计算动画状态：</p>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (timeFraction &lt;= <span class="hljs-number">0.5</span>) { <span class="hljs-comment">// 动画前半部分</span>
  <span class="hljs-keyword">return</span> timing(<span class="hljs-number">2</span> * timeFraction) / <span class="hljs-number">2</span>;
} <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 动画后半部分</span>
  <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> - timing(<span class="hljs-number">2</span> * (<span class="hljs-number">1</span> - timeFraction))) / <span class="hljs-number">2</span>;
}</code></pre>
<p>封装器代码：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeEaseInOut</span>(<span class="hljs-params">timing</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">timeFraction</span>) </span>{
    <span class="hljs-keyword">if</span> (timeFraction &lt; <span class="hljs-number">.5</span>)
      <span class="hljs-keyword">return</span> timing(<span class="hljs-number">2</span> * timeFraction) / <span class="hljs-number">2</span>;
    <span class="hljs-keyword">else</span>
      <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> - timing(<span class="hljs-number">2</span> * (<span class="hljs-number">1</span> - timeFraction))) / <span class="hljs-number">2</span>;
  }
}

bounceEaseInOut = makeEaseInOut(bounce);</code></pre>
<p><code>bounceEaseInOut</code> 演示如下:</p>
<p>[codetabs src=&quot;bounce-easeinout&quot;]</p>
<p>“easeInOut” 变换将两个图像连接成一个：动画的前半部分为“easeIn”（常规），后半部分为“easeOut”（反向）。</p>
<p>如果我们比较 <code>circ</code> 时序函数的 <code>easeIn</code>、<code>easeOut</code> 和 <code>easeInOut</code> 的图像，就可以清楚地看到效果：</p>
<p><img src="circ-ease.svg" alt=""></p>
<ul>
<li><span style="color:#EE6B47">红色</span>是 <code>circ</code>（<code>easeIn</code>）的常规变体。</li>
<li><span style="color:#8DB173">绿色</span> —— <code>easeOut</code>。</li>
<li><span style="color:#62C0DC">蓝色</span> —— <code>easeInOut</code>。</li>
</ul>
<p>正如我们所看到的，动画前半部分的图形是缩小的“easeIn”，后半部分是缩小的“easeOut”。结果是动画以相同的效果开始和结束。</p>
<h2 id="更有趣的-draw">更有趣的 &quot;draw&quot;</h2>
<p>除了移动元素，我们还可以做其他事情。我们所需要的只是写出合适的 <code>draw</code>。</p>
<p>这是动画形式的“弹跳”文字输入：</p>
<p>[codetabs src=&quot;text&quot;]</p>
<h2 id="总结">总结</h2>
<p>JavaScript 动画应该通过 <code>requestAnimationFrame</code> 实现。该内置方法允许设置回调函数，以便在浏览器准备重绘时运行。那通常很快，但确切的时间取决于浏览器。</p>
<p>当页面在后台时，根本没有重绘，因此回调将不会运行：动画将被暂停并且不会消耗资源。那很棒。</p>
<p>这是设置大多数动画的 helper 函数 <code>animate</code>：</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">animate</span>(<span class="hljs-params">{timing, draw, duration}</span>) </span>{

  <span class="hljs-keyword">let</span> start = performance.now();

  requestAnimationFrame(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">animate</span>(<span class="hljs-params">time</span>) </span>{
    <span class="hljs-comment">// timeFraction 从 0 增加到 1</span>
    <span class="hljs-keyword">let</span> timeFraction = (time - start) / duration;
    <span class="hljs-keyword">if</span> (timeFraction &gt; <span class="hljs-number">1</span>) timeFraction = <span class="hljs-number">1</span>;

    <span class="hljs-comment">// 计算当前动画状态</span>
    <span class="hljs-keyword">let</span> progress = timing(timeFraction);

    draw(progress); <span class="hljs-comment">// 绘制</span>

    <span class="hljs-keyword">if</span> (timeFraction &lt; <span class="hljs-number">1</span>) {
      requestAnimationFrame(animate);
    }

  });
}</code></pre>
<p>参数：</p>
<ul>
<li><code>duration</code> —— 动画运行的总毫秒数。</li>
<li><code>timing</code> —— 计算动画进度的函数。获取从 0 到 1 的小数时间，返回动画进度，通常也是从 0 到 1。</li>
<li><code>draw</code> —— 绘制动画的函数。</li>
</ul>
<p>当然我们可以改进它，增加更多花里胡哨的东西，但 JavaScript 动画不是经常用到。它们用于做一些有趣和不标准的事情。因此，您大可在必要时再添加所需的功能。</p>
<p>JavaScript 动画可以使用任何时序函数。我们介绍了很多例子和变换，使它们更加通用。与 CSS 不同，我们不仅限于 Bezier 曲线。</p>
<p><code>draw</code> 也是如此：我们可以将任何东西动画化，而不仅仅是 CSS 属性。</p>

      </fieldset>
      </div><div id="nav"><div style="margin-left:0em"><strong>bezier-curve</strong><br/></div><div style="margin-left:1em"><a href="#_11l8CW">article</a><br/></div><div style="margin-left:0em"><strong>css-animations</strong><br/></div><div style="margin-left:1em"><strong>animate-logo-css</strong><br/></div><div style="margin-left:2em"><a href="#_UhtcYE">solution</a><br/></div><div style="margin-left:2em"><a href="#_SR8kti">task</a><br/></div><div style="margin-left:1em"><strong>animate-logo-bezier-css</strong><br/></div><div style="margin-left:2em"><a href="#_OeJFe1">solution</a><br/></div><div style="margin-left:2em"><a href="#_zPKJeW">task</a><br/></div><div style="margin-left:1em"><strong>animate-circle</strong><br/></div><div style="margin-left:2em"><a href="#_gegy3K">solution</a><br/></div><div style="margin-left:2em"><a href="#_TMeTGG">task</a><br/></div><div style="margin-left:1em"><a href="#_Vgpuim">article</a><br/></div><div style="margin-left:0em"><strong>js-animation</strong><br/></div><div style="margin-left:1em"><strong>animate-ball</strong><br/></div><div style="margin-left:2em"><a href="#_T0njnD">solution</a><br/></div><div style="margin-left:2em"><a href="#_NtJmoi">task</a><br/></div><div style="margin-left:1em"><strong>animate-ball-hops</strong><br/></div><div style="margin-left:2em"><a href="#_VavPHX">solution</a><br/></div><div style="margin-left:2em"><a href="#_WTVmme">task</a><br/></div><div style="margin-left:1em"><a href="#_kHaDVW">article</a><br/></div></div>
</body></html>